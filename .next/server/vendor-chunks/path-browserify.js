"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/path-browserify";
exports.ids = ["vendor-chunks/path-browserify"];
exports.modules = {

/***/ "(rsc)/./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/***/ ((module) => {

eval("// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction assertPath(path) {\n    if (typeof path !== \"string\") {\n        throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(path));\n    }\n}\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n    var res = \"\";\n    var lastSegmentLength = 0;\n    var lastSlash = -1;\n    var dots = 0;\n    var code;\n    for(var i = 0; i <= path.length; ++i){\n        if (i < path.length) code = path.charCodeAt(i);\n        else if (code === 47 /*/*/ ) break;\n        else code = 47 /*/*/ ;\n        if (code === 47 /*/*/ ) {\n            if (lastSlash === i - 1 || dots === 1) {\n            // NOOP\n            } else if (lastSlash !== i - 1 && dots === 2) {\n                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/  || res.charCodeAt(res.length - 2) !== 46 /*.*/ ) {\n                    if (res.length > 2) {\n                        var lastSlashIndex = res.lastIndexOf(\"/\");\n                        if (lastSlashIndex !== res.length - 1) {\n                            if (lastSlashIndex === -1) {\n                                res = \"\";\n                                lastSegmentLength = 0;\n                            } else {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    } else if (res.length === 2 || res.length === 1) {\n                        res = \"\";\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    if (res.length > 0) res += \"/..\";\n                    else res = \"..\";\n                    lastSegmentLength = 2;\n                }\n            } else {\n                if (res.length > 0) res += \"/\" + path.slice(lastSlash + 1, i);\n                else res = path.slice(lastSlash + 1, i);\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        } else if (code === 46 /*.*/  && dots !== -1) {\n            ++dots;\n        } else {\n            dots = -1;\n        }\n    }\n    return res;\n}\nfunction _format(sep, pathObject) {\n    var dir = pathObject.dir || pathObject.root;\n    var base = pathObject.base || (pathObject.name || \"\") + (pathObject.ext || \"\");\n    if (!dir) {\n        return base;\n    }\n    if (dir === pathObject.root) {\n        return dir + base;\n    }\n    return dir + sep + base;\n}\nvar posix = {\n    // path.resolve([from ...], to)\n    resolve: function resolve() {\n        var resolvedPath = \"\";\n        var resolvedAbsolute = false;\n        var cwd;\n        for(var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--){\n            var path;\n            if (i >= 0) path = arguments[i];\n            else {\n                if (cwd === undefined) cwd = process.cwd();\n                path = cwd;\n            }\n            assertPath(path);\n            // Skip empty entries\n            if (path.length === 0) {\n                continue;\n            }\n            resolvedPath = path + \"/\" + resolvedPath;\n            resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/ ;\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        // Normalize the path\n        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n        if (resolvedAbsolute) {\n            if (resolvedPath.length > 0) return \"/\" + resolvedPath;\n            else return \"/\";\n        } else if (resolvedPath.length > 0) {\n            return resolvedPath;\n        } else {\n            return \".\";\n        }\n    },\n    normalize: function normalize(path) {\n        assertPath(path);\n        if (path.length === 0) return \".\";\n        var isAbsolute = path.charCodeAt(0) === 47 /*/*/ ;\n        var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/ ;\n        // Normalize the path\n        path = normalizeStringPosix(path, !isAbsolute);\n        if (path.length === 0 && !isAbsolute) path = \".\";\n        if (path.length > 0 && trailingSeparator) path += \"/\";\n        if (isAbsolute) return \"/\" + path;\n        return path;\n    },\n    isAbsolute: function isAbsolute(path) {\n        assertPath(path);\n        return path.length > 0 && path.charCodeAt(0) === 47 /*/*/ ;\n    },\n    join: function join() {\n        if (arguments.length === 0) return \".\";\n        var joined;\n        for(var i = 0; i < arguments.length; ++i){\n            var arg = arguments[i];\n            assertPath(arg);\n            if (arg.length > 0) {\n                if (joined === undefined) joined = arg;\n                else joined += \"/\" + arg;\n            }\n        }\n        if (joined === undefined) return \".\";\n        return posix.normalize(joined);\n    },\n    relative: function relative(from, to) {\n        assertPath(from);\n        assertPath(to);\n        if (from === to) return \"\";\n        from = posix.resolve(from);\n        to = posix.resolve(to);\n        if (from === to) return \"\";\n        // Trim any leading backslashes\n        var fromStart = 1;\n        for(; fromStart < from.length; ++fromStart){\n            if (from.charCodeAt(fromStart) !== 47 /*/*/ ) break;\n        }\n        var fromEnd = from.length;\n        var fromLen = fromEnd - fromStart;\n        // Trim any leading backslashes\n        var toStart = 1;\n        for(; toStart < to.length; ++toStart){\n            if (to.charCodeAt(toStart) !== 47 /*/*/ ) break;\n        }\n        var toEnd = to.length;\n        var toLen = toEnd - toStart;\n        // Compare paths to find the longest common path from root\n        var length = fromLen < toLen ? fromLen : toLen;\n        var lastCommonSep = -1;\n        var i = 0;\n        for(; i <= length; ++i){\n            if (i === length) {\n                if (toLen > length) {\n                    if (to.charCodeAt(toStart + i) === 47 /*/*/ ) {\n                        // We get here if `from` is the exact base path for `to`.\n                        // For example: from='/foo/bar'; to='/foo/bar/baz'\n                        return to.slice(toStart + i + 1);\n                    } else if (i === 0) {\n                        // We get here if `from` is the root\n                        // For example: from='/'; to='/foo'\n                        return to.slice(toStart + i);\n                    }\n                } else if (fromLen > length) {\n                    if (from.charCodeAt(fromStart + i) === 47 /*/*/ ) {\n                        // We get here if `to` is the exact base path for `from`.\n                        // For example: from='/foo/bar/baz'; to='/foo/bar'\n                        lastCommonSep = i;\n                    } else if (i === 0) {\n                        // We get here if `to` is the root.\n                        // For example: from='/foo'; to='/'\n                        lastCommonSep = 0;\n                    }\n                }\n                break;\n            }\n            var fromCode = from.charCodeAt(fromStart + i);\n            var toCode = to.charCodeAt(toStart + i);\n            if (fromCode !== toCode) break;\n            else if (fromCode === 47 /*/*/ ) lastCommonSep = i;\n        }\n        var out = \"\";\n        // Generate the relative path based on the path difference between `to`\n        // and `from`\n        for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){\n            if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/ ) {\n                if (out.length === 0) out += \"..\";\n                else out += \"/..\";\n            }\n        }\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts\n        if (out.length > 0) return out + to.slice(toStart + lastCommonSep);\n        else {\n            toStart += lastCommonSep;\n            if (to.charCodeAt(toStart) === 47 /*/*/ ) ++toStart;\n            return to.slice(toStart);\n        }\n    },\n    _makeLong: function _makeLong(path) {\n        return path;\n    },\n    dirname: function dirname(path) {\n        assertPath(path);\n        if (path.length === 0) return \".\";\n        var code = path.charCodeAt(0);\n        var hasRoot = code === 47 /*/*/ ;\n        var end = -1;\n        var matchedSlash = true;\n        for(var i = path.length - 1; i >= 1; --i){\n            code = path.charCodeAt(i);\n            if (code === 47 /*/*/ ) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            } else {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n        if (end === -1) return hasRoot ? \"/\" : \".\";\n        if (hasRoot && end === 1) return \"//\";\n        return path.slice(0, end);\n    },\n    basename: function basename(path, ext) {\n        if (ext !== undefined && typeof ext !== \"string\") throw new TypeError('\"ext\" argument must be a string');\n        assertPath(path);\n        var start = 0;\n        var end = -1;\n        var matchedSlash = true;\n        var i;\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext.length === path.length && ext === path) return \"\";\n            var extIdx = ext.length - 1;\n            var firstNonSlashEnd = -1;\n            for(i = path.length - 1; i >= 0; --i){\n                var code = path.charCodeAt(i);\n                if (code === 47 /*/*/ ) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                } else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        } else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) end = firstNonSlashEnd;\n            else if (end === -1) end = path.length;\n            return path.slice(start, end);\n        } else {\n            for(i = path.length - 1; i >= 0; --i){\n                if (path.charCodeAt(i) === 47 /*/*/ ) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                } else if (end === -1) {\n                    // We saw the first non-path separator, mark this as the end of our\n                    // path component\n                    matchedSlash = false;\n                    end = i + 1;\n                }\n            }\n            if (end === -1) return \"\";\n            return path.slice(start, end);\n        }\n    },\n    extname: function extname(path) {\n        assertPath(path);\n        var startDot = -1;\n        var startPart = 0;\n        var end = -1;\n        var matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        var preDotState = 0;\n        for(var i = path.length - 1; i >= 0; --i){\n            var code = path.charCodeAt(i);\n            if (code === 47 /*/*/ ) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46 /*.*/ ) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            } else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n            return \"\";\n        }\n        return path.slice(startDot, end);\n    },\n    format: function format(pathObject) {\n        if (pathObject === null || typeof pathObject !== \"object\") {\n            throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n        }\n        return _format(\"/\", pathObject);\n    },\n    parse: function parse(path) {\n        assertPath(path);\n        var ret = {\n            root: \"\",\n            dir: \"\",\n            base: \"\",\n            ext: \"\",\n            name: \"\"\n        };\n        if (path.length === 0) return ret;\n        var code = path.charCodeAt(0);\n        var isAbsolute = code === 47 /*/*/ ;\n        var start;\n        if (isAbsolute) {\n            ret.root = \"/\";\n            start = 1;\n        } else {\n            start = 0;\n        }\n        var startDot = -1;\n        var startPart = 0;\n        var end = -1;\n        var matchedSlash = true;\n        var i = path.length - 1;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        var preDotState = 0;\n        // Get non-dir info\n        for(; i >= start; --i){\n            code = path.charCodeAt(i);\n            if (code === 47 /*/*/ ) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46 /*.*/ ) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            } else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n            if (end !== -1) {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);\n                else ret.base = ret.name = path.slice(startPart, end);\n            }\n        } else {\n            if (startPart === 0 && isAbsolute) {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            } else {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);\n        else if (isAbsolute) ret.dir = \"/\";\n        return ret;\n    },\n    sep: \"/\",\n    delimiter: \":\",\n    win32: null,\n    posix: null\n};\nposix.posix = posix;\nmodule.exports = posix;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHFFQUFxRTtBQUNyRSx5QkFBeUI7QUFFekIsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5QztBQUV6QztBQUVBLFNBQVNBLFdBQVdDLElBQUk7SUFDdEIsSUFBSSxPQUFPQSxTQUFTLFVBQVU7UUFDNUIsTUFBTSxJQUFJQyxVQUFVLHFDQUFxQ0MsS0FBS0MsU0FBUyxDQUFDSDtJQUMxRTtBQUNGO0FBRUEsNERBQTREO0FBQzVELFNBQVNJLHFCQUFxQkosSUFBSSxFQUFFSyxjQUFjO0lBQ2hELElBQUlDLE1BQU07SUFDVixJQUFJQyxvQkFBb0I7SUFDeEIsSUFBSUMsWUFBWSxDQUFDO0lBQ2pCLElBQUlDLE9BQU87SUFDWCxJQUFJQztJQUNKLElBQUssSUFBSUMsSUFBSSxHQUFHQSxLQUFLWCxLQUFLWSxNQUFNLEVBQUUsRUFBRUQsRUFBRztRQUNyQyxJQUFJQSxJQUFJWCxLQUFLWSxNQUFNLEVBQ2pCRixPQUFPVixLQUFLYSxVQUFVLENBQUNGO2FBQ3BCLElBQUlELFNBQVMsR0FBRyxHQUFHLEtBQ3RCO2FBRUFBLE9BQU8sR0FBRyxHQUFHO1FBQ2YsSUFBSUEsU0FBUyxHQUFHLEdBQUcsS0FBSTtZQUNyQixJQUFJRixjQUFjRyxJQUFJLEtBQUtGLFNBQVMsR0FBRztZQUNyQyxPQUFPO1lBQ1QsT0FBTyxJQUFJRCxjQUFjRyxJQUFJLEtBQUtGLFNBQVMsR0FBRztn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QixZQUFZO2dCQUNqQ2lDLElBQUk1QyxJQUFJLEdBQUd2QixLQUFLZ0IsS0FBSyxDQUFDLEdBQUc4QztnQkFDekJLLElBQUk3QyxJQUFJLEdBQUd0QixLQUFLZ0IsS0FBSyxDQUFDLEdBQUd1QztZQUMzQixPQUFPO2dCQUNMWSxJQUFJNUMsSUFBSSxHQUFHdkIsS0FBS2dCLEtBQUssQ0FBQytDLFdBQVdEO2dCQUNqQ0ssSUFBSTdDLElBQUksR0FBR3RCLEtBQUtnQixLQUFLLENBQUMrQyxXQUFXUjtZQUNuQztZQUNBWSxJQUFJM0MsR0FBRyxHQUFHeEIsS0FBS2dCLEtBQUssQ0FBQzhDLFVBQVVQO1FBQ2pDO1FBRUEsSUFBSVEsWUFBWSxHQUFHSSxJQUFJL0MsR0FBRyxHQUFHcEIsS0FBS2dCLEtBQUssQ0FBQyxHQUFHK0MsWUFBWTthQUFRLElBQUk3QixZQUFZaUMsSUFBSS9DLEdBQUcsR0FBRztRQUV6RixPQUFPK0M7SUFDVDtJQUVBakQsS0FBSztJQUNMa0QsV0FBVztJQUNYQyxPQUFPO0lBQ1A1QyxPQUFPO0FBQ1Q7QUFFQUEsTUFBTUEsS0FBSyxHQUFHQTtBQUVkNkMsT0FBT0MsT0FBTyxHQUFHOUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ydW1ibGUtcmFmZmxlLWZyYW1lLy4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcz9lZDZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vICdwYXRoJyBtb2R1bGUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xIChvbmx5IHRoZSBwb3NpeCBwYXJ0KVxuLy8gdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbFxuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NlcnRQYXRoKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJyArIEpTT04uc3RyaW5naWZ5KHBhdGgpKTtcbiAgfVxufVxuXG4vLyBSZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggd2l0aCBkaXJlY3RvcnkgbmFtZXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgsIGFsbG93QWJvdmVSb290KSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgdmFyIGxhc3RTbGFzaCA9IC0xO1xuICB2YXIgZG90cyA9IDA7XG4gIHZhciBjb2RlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGkgPCBwYXRoLmxlbmd0aClcbiAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgZWxzZSBpZiAoY29kZSA9PT0gNDcgLyovKi8pXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBjb2RlID0gNDcgLyovKi87XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICBpZiAobGFzdFNsYXNoID09PSBpIC0gMSB8fCBkb3RzID09PSAxKSB7XG4gICAgICAgIC8vIE5PT1BcbiAgICAgIH0gZWxzZSBpZiAobGFzdFNsYXNoICE9PSBpIC0gMSAmJiBkb3RzID09PSAyKSB7XG4gICAgICAgIGlmIChyZXMubGVuZ3RoIDwgMiB8fCBsYXN0U2VnbWVudExlbmd0aCAhPT0gMiB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMSkgIT09IDQ2IC8qLiovIHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAyKSAhPT0gNDYgLyouKi8pIHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciBsYXN0U2xhc2hJbmRleCA9IHJlcy5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ICE9PSByZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gJyc7XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zbGljZSgwLCBsYXN0U2xhc2hJbmRleCk7XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSByZXMubGVuZ3RoIC0gMSAtIHJlcy5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlcy5sZW5ndGggPT09IDIgfHwgcmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzID0gJyc7XG4gICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmVzICs9ICcvLi4nO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlcyA9ICcuLic7XG4gICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgcmVzICs9ICcvJyArIHBhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXMgPSBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IGkgLSBsYXN0U2xhc2ggLSAxO1xuICAgICAgfVxuICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgIGRvdHMgPSAwO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNDYgLyouKi8gJiYgZG90cyAhPT0gLTEpIHtcbiAgICAgICsrZG90cztcbiAgICB9IGVsc2Uge1xuICAgICAgZG90cyA9IC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBfZm9ybWF0KHNlcCwgcGF0aE9iamVjdCkge1xuICB2YXIgZGlyID0gcGF0aE9iamVjdC5kaXIgfHwgcGF0aE9iamVjdC5yb290O1xuICB2YXIgYmFzZSA9IHBhdGhPYmplY3QuYmFzZSB8fCAocGF0aE9iamVjdC5uYW1lIHx8ICcnKSArIChwYXRoT2JqZWN0LmV4dCB8fCAnJyk7XG4gIGlmICghZGlyKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgaWYgKGRpciA9PT0gcGF0aE9iamVjdC5yb290KSB7XG4gICAgcmV0dXJuIGRpciArIGJhc2U7XG4gIH1cbiAgcmV0dXJuIGRpciArIHNlcCArIGJhc2U7XG59XG5cbnZhciBwb3NpeCA9IHtcbiAgLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIHZhciByZXNvbHZlZFBhdGggPSAnJztcbiAgICB2YXIgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuICAgIHZhciBjd2Q7XG5cbiAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgICAgdmFyIHBhdGg7XG4gICAgICBpZiAoaSA+PSAwKVxuICAgICAgICBwYXRoID0gYXJndW1lbnRzW2ldO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChjd2QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBjd2QgPSBwcm9jZXNzLmN3ZCgpO1xuICAgICAgICBwYXRoID0gY3dkO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgICAvLyBTa2lwIGVtcHR5IGVudHJpZXNcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qLyovO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICAgIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHJlc29sdmVkUGF0aCwgIXJlc29sdmVkQWJzb2x1dGUpO1xuXG4gICAgaWYgKHJlc29sdmVkQWJzb2x1dGUpIHtcbiAgICAgIGlmIChyZXNvbHZlZFBhdGgubGVuZ3RoID4gMClcbiAgICAgICAgcmV0dXJuICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB9IGVsc2UgaWYgKHJlc29sdmVkUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJy4nO1xuICAgIH1cbiAgfSxcblxuICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcblxuICAgIHZhciBpc0Fic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgICB2YXIgdHJhaWxpbmdTZXBhcmF0b3IgPSBwYXRoLmNoYXJDb2RlQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gNDcgLyovKi87XG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgICBwYXRoID0gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aCwgIWlzQWJzb2x1dGUpO1xuXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwICYmICFpc0Fic29sdXRlKSBwYXRoID0gJy4nO1xuICAgIGlmIChwYXRoLmxlbmd0aCA+IDAgJiYgdHJhaWxpbmdTZXBhcmF0b3IpIHBhdGggKz0gJy8nO1xuXG4gICAgaWYgKGlzQWJzb2x1dGUpIHJldHVybiAnLycgKyBwYXRoO1xuICAgIHJldHVybiBwYXRoO1xuICB9LFxuXG4gIGlzQWJzb2x1dGU6IGZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMCAmJiBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qLyovO1xuICB9LFxuXG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gJy4nO1xuICAgIHZhciBqb2luZWQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICBhc3NlcnRQYXRoKGFyZyk7XG4gICAgICBpZiAoYXJnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGpvaW5lZCA9IGFyZztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGpvaW5lZCArPSAnLycgKyBhcmc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAnLic7XG4gICAgcmV0dXJuIHBvc2l4Lm5vcm1hbGl6ZShqb2luZWQpO1xuICB9LFxuXG4gIHJlbGF0aXZlOiBmdW5jdGlvbiByZWxhdGl2ZShmcm9tLCB0bykge1xuICAgIGFzc2VydFBhdGgoZnJvbSk7XG4gICAgYXNzZXJ0UGF0aCh0byk7XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHJldHVybiAnJztcblxuICAgIGZyb20gPSBwb3NpeC5yZXNvbHZlKGZyb20pO1xuICAgIHRvID0gcG9zaXgucmVzb2x2ZSh0byk7XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHJldHVybiAnJztcblxuICAgIC8vIFRyaW0gYW55IGxlYWRpbmcgYmFja3NsYXNoZXNcbiAgICB2YXIgZnJvbVN0YXJ0ID0gMTtcbiAgICBmb3IgKDsgZnJvbVN0YXJ0IDwgZnJvbS5sZW5ndGg7ICsrZnJvbVN0YXJ0KSB7XG4gICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCkgIT09IDQ3IC8qLyovKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGZyb21FbmQgPSBmcm9tLmxlbmd0aDtcbiAgICB2YXIgZnJvbUxlbiA9IGZyb21FbmQgLSBmcm9tU3RhcnQ7XG5cbiAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXG4gICAgdmFyIHRvU3RhcnQgPSAxO1xuICAgIGZvciAoOyB0b1N0YXJ0IDwgdG8ubGVuZ3RoOyArK3RvU3RhcnQpIHtcbiAgICAgIGlmICh0by5jaGFyQ29kZUF0KHRvU3RhcnQpICE9PSA0NyAvKi8qLylcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciB0b0VuZCA9IHRvLmxlbmd0aDtcbiAgICB2YXIgdG9MZW4gPSB0b0VuZCAtIHRvU3RhcnQ7XG5cbiAgICAvLyBDb21wYXJlIHBhdGhzIHRvIGZpbmQgdGhlIGxvbmdlc3QgY29tbW9uIHBhdGggZnJvbSByb290XG4gICAgdmFyIGxlbmd0aCA9IGZyb21MZW4gPCB0b0xlbiA/IGZyb21MZW4gOiB0b0xlbjtcbiAgICB2YXIgbGFzdENvbW1vblNlcCA9IC0xO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8PSBsZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGkgPT09IGxlbmd0aCkge1xuICAgICAgICBpZiAodG9MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYHRvYC5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhcic7IHRvPScvZm9vL2Jhci9iYXonXG4gICAgICAgICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCArIGkgKyAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgcm9vdFxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy8nOyB0bz0nL2ZvbydcbiAgICAgICAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0ICsgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZyb21MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgZnJvbWAuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXIvYmF6JzsgdG89Jy9mb28vYmFyJ1xuICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSByb290LlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28nOyB0bz0nLydcbiAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhciBmcm9tQ29kZSA9IGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKTtcbiAgICAgIHZhciB0b0NvZGUgPSB0by5jaGFyQ29kZUF0KHRvU3RhcnQgKyBpKTtcbiAgICAgIGlmIChmcm9tQ29kZSAhPT0gdG9Db2RlKVxuICAgICAgICBicmVhaztcbiAgICAgIGVsc2UgaWYgKGZyb21Db2RlID09PSA0NyAvKi8qLylcbiAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XG4gICAgfVxuXG4gICAgdmFyIG91dCA9ICcnO1xuICAgIC8vIEdlbmVyYXRlIHRoZSByZWxhdGl2ZSBwYXRoIGJhc2VkIG9uIHRoZSBwYXRoIGRpZmZlcmVuY2UgYmV0d2VlbiBgdG9gXG4gICAgLy8gYW5kIGBmcm9tYFxuICAgIGZvciAoaSA9IGZyb21TdGFydCArIGxhc3RDb21tb25TZXAgKyAxOyBpIDw9IGZyb21FbmQ7ICsraSkge1xuICAgICAgaWYgKGkgPT09IGZyb21FbmQgfHwgZnJvbS5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAob3V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICBvdXQgKz0gJy4uJztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG91dCArPSAnLy4uJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMYXN0bHksIGFwcGVuZCB0aGUgcmVzdCBvZiB0aGUgZGVzdGluYXRpb24gKGB0b2ApIHBhdGggdGhhdCBjb21lcyBhZnRlclxuICAgIC8vIHRoZSBjb21tb24gcGF0aCBwYXJ0c1xuICAgIGlmIChvdXQubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiBvdXQgKyB0by5zbGljZSh0b1N0YXJ0ICsgbGFzdENvbW1vblNlcCk7XG4gICAgZWxzZSB7XG4gICAgICB0b1N0YXJ0ICs9IGxhc3RDb21tb25TZXA7XG4gICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0KSA9PT0gNDcgLyovKi8pXG4gICAgICAgICsrdG9TdGFydDtcbiAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0KTtcbiAgICB9XG4gIH0sXG5cbiAgX21ha2VMb25nOiBmdW5jdGlvbiBfbWFrZUxvbmcocGF0aCkge1xuICAgIHJldHVybiBwYXRoO1xuICB9LFxuXG4gIGRpcm5hbWU6IGZ1bmN0aW9uIGRpcm5hbWUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHJldHVybiAnLy8nO1xuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG4gIH0sXG5cbiAgYmFzZW5hbWU6IGZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgsIGV4dCkge1xuICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZXh0ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHRcIiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIHZhciBzdGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkICYmIGV4dC5sZW5ndGggPiAwICYmIGV4dC5sZW5ndGggPD0gcGF0aC5sZW5ndGgpIHtcbiAgICAgIGlmIChleHQubGVuZ3RoID09PSBwYXRoLmxlbmd0aCAmJiBleHQgPT09IHBhdGgpIHJldHVybiAnJztcbiAgICAgIHZhciBleHRJZHggPSBleHQubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBmaXJzdE5vblNsYXNoRW5kID0gLTE7XG4gICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpcnN0Tm9uU2xhc2hFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgcmVtZW1iZXIgdGhpcyBpbmRleCBpbiBjYXNlXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIGl0IGlmIHRoZSBleHRlbnNpb24gZW5kcyB1cCBub3QgbWF0Y2hpbmdcbiAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgZmlyc3ROb25TbGFzaEVuZCA9IGkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0SWR4ID49IDApIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZXhwbGljaXQgZXh0ZW5zaW9uXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gZXh0LmNoYXJDb2RlQXQoZXh0SWR4KSkge1xuICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgZXh0ZW5zaW9uLCBzbyBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXIgcGF0aFxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEV4dGVuc2lvbiBkb2VzIG5vdCBtYXRjaCwgc28gb3VyIHJlc3VsdCBpcyB0aGUgZW50aXJlIHBhdGhcbiAgICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xuICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnQgPT09IGVuZCkgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtlbHNlIGlmIChlbmQgPT09IC0xKSBlbmQgPSBwYXRoLmxlbmd0aDtcbiAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID09PSAtMSkgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9LFxuXG4gIGV4dG5hbWU6IGZ1bmN0aW9uIGV4dG5hbWUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gICAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICB9LFxuXG4gIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KHBhdGhPYmplY3QpIHtcbiAgICBpZiAocGF0aE9iamVjdCA9PT0gbnVsbCB8fCB0eXBlb2YgcGF0aE9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInBhdGhPYmplY3RcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgcGF0aE9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBfZm9ybWF0KCcvJywgcGF0aE9iamVjdCk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgdmFyIHJldCA9IHsgcm9vdDogJycsIGRpcjogJycsIGJhc2U6ICcnLCBleHQ6ICcnLCBuYW1lOiAnJyB9O1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJldDtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgaXNBYnNvbHV0ZSA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICAgIHZhciBzdGFydDtcbiAgICBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgcmV0LnJvb3QgPSAnLyc7XG4gICAgICBzdGFydCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gICAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuXG4gICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAgIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gICAgdmFyIHByZURvdFN0YXRlID0gMDtcblxuICAgIC8vIEdldCBub24tZGlyIGluZm9cbiAgICBmb3IgKDsgaSA+PSBzdGFydDsgLS1pKSB7XG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHN0YXJ0RG90ID0gaTtlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICAgIGlmIChlbmQgIT09IC0xKSB7XG4gICAgICAgIGlmIChzdGFydFBhcnQgPT09IDAgJiYgaXNBYnNvbHV0ZSkgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGguc2xpY2UoMSwgZW5kKTtlbHNlIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlKSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aC5zbGljZSgxLCBzdGFydERvdCk7XG4gICAgICAgIHJldC5iYXNlID0gcGF0aC5zbGljZSgxLCBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgc3RhcnREb3QpO1xuICAgICAgICByZXQuYmFzZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgcmV0LmV4dCA9IHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0UGFydCA+IDApIHJldC5kaXIgPSBwYXRoLnNsaWNlKDAsIHN0YXJ0UGFydCAtIDEpO2Vsc2UgaWYgKGlzQWJzb2x1dGUpIHJldC5kaXIgPSAnLyc7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIHNlcDogJy8nLFxuICBkZWxpbWl0ZXI6ICc6JyxcbiAgd2luMzI6IG51bGwsXG4gIHBvc2l4OiBudWxsXG59O1xuXG5wb3NpeC5wb3NpeCA9IHBvc2l4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvc2l4O1xuIl0sIm5hbWVzIjpbImFzc2VydFBhdGgiLCJwYXRoIiwiVHlwZUVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsIm5vcm1hbGl6ZVN0cmluZ1Bvc2l4IiwiYWxsb3dBYm92ZVJvb3QiLCJyZXMiLCJsYXN0U2VnbWVudExlbmd0aCIsImxhc3RTbGFzaCIsImRvdHMiLCJjb2RlIiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJsYXN0U2xhc2hJbmRleCIsImxhc3RJbmRleE9mIiwic2xpY2UiLCJfZm9ybWF0Iiwic2VwIiwicGF0aE9iamVjdCIsImRpciIsInJvb3QiLCJiYXNlIiwibmFtZSIsImV4dCIsInBvc2l4IiwicmVzb2x2ZSIsInJlc29sdmVkUGF0aCIsInJlc29sdmVkQWJzb2x1dGUiLCJjd2QiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJwcm9jZXNzIiwibm9ybWFsaXplIiwiaXNBYnNvbHV0ZSIsInRyYWlsaW5nU2VwYXJhdG9yIiwiam9pbiIsImpvaW5lZCIsImFyZyIsInJlbGF0aXZlIiwiZnJvbSIsInRvIiwiZnJvbVN0YXJ0IiwiZnJvbUVuZCIsImZyb21MZW4iLCJ0b1N0YXJ0IiwidG9FbmQiLCJ0b0xlbiIsImxhc3RDb21tb25TZXAiLCJmcm9tQ29kZSIsInRvQ29kZSIsIm91dCIsIl9tYWtlTG9uZyIsImRpcm5hbWUiLCJoYXNSb290IiwiZW5kIiwibWF0Y2hlZFNsYXNoIiwiYmFzZW5hbWUiLCJzdGFydCIsImV4dElkeCIsImZpcnN0Tm9uU2xhc2hFbmQiLCJleHRuYW1lIiwic3RhcnREb3QiLCJzdGFydFBhcnQiLCJwcmVEb3RTdGF0ZSIsImZvcm1hdCIsInBhcnNlIiwicmV0IiwiZGVsaW1pdGVyIiwid2luMzIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/path-browserify/index.js\n");

/***/ })

};
;