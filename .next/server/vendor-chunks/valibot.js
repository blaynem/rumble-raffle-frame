"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/valibot";
exports.ids = ["vendor-chunks/valibot"];
exports.modules = {

/***/ "(rsc)/./node_modules/valibot/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/valibot/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ValiError: () => (/* binding */ ValiError),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   anyAsync: () => (/* binding */ anyAsync),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   arrayAsync: () => (/* binding */ arrayAsync),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   bigintAsync: () => (/* binding */ bigintAsync),\n/* harmony export */   blob: () => (/* binding */ blob),\n/* harmony export */   blobAsync: () => (/* binding */ blobAsync),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   booleanAsync: () => (/* binding */ booleanAsync),\n/* harmony export */   brand: () => (/* binding */ brand),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   coerceAsync: () => (/* binding */ coerceAsync),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   customAsync: () => (/* binding */ customAsync),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   dateAsync: () => (/* binding */ dateAsync),\n/* harmony export */   email: () => (/* binding */ email),\n/* harmony export */   emoji: () => (/* binding */ emoji),\n/* harmony export */   endsWith: () => (/* binding */ endsWith),\n/* harmony export */   enumType: () => (/* binding */ enumType),\n/* harmony export */   enumTypeAsync: () => (/* binding */ enumTypeAsync),\n/* harmony export */   equal: () => (/* binding */ equal),\n/* harmony export */   excludes: () => (/* binding */ excludes),\n/* harmony export */   executePipe: () => (/* binding */ executePipe),\n/* harmony export */   executePipeAsync: () => (/* binding */ executePipeAsync),\n/* harmony export */   fallback: () => (/* binding */ fallback),\n/* harmony export */   fallbackAsync: () => (/* binding */ fallbackAsync),\n/* harmony export */   finite: () => (/* binding */ finite),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   getDefaultArgs: () => (/* binding */ getDefaultArgs),\n/* harmony export */   getIssues: () => (/* binding */ getIssues),\n/* harmony export */   imei: () => (/* binding */ imei),\n/* harmony export */   includes: () => (/* binding */ includes),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   instanceAsync: () => (/* binding */ instanceAsync),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   ip: () => (/* binding */ ip),\n/* harmony export */   ipv4: () => (/* binding */ ipv4),\n/* harmony export */   ipv6: () => (/* binding */ ipv6),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   isLuhnAlgo: () => (/* binding */ isLuhnAlgo),\n/* harmony export */   isoDate: () => (/* binding */ isoDate),\n/* harmony export */   isoDateTime: () => (/* binding */ isoDateTime),\n/* harmony export */   isoTime: () => (/* binding */ isoTime),\n/* harmony export */   isoTimeSecond: () => (/* binding */ isoTimeSecond),\n/* harmony export */   isoTimestamp: () => (/* binding */ isoTimestamp),\n/* harmony export */   isoWeek: () => (/* binding */ isoWeek),\n/* harmony export */   keyof: () => (/* binding */ keyof),\n/* harmony export */   length: () => (/* binding */ length),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   literalAsync: () => (/* binding */ literalAsync),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapAsync: () => (/* binding */ mapAsync),\n/* harmony export */   maxBytes: () => (/* binding */ maxBytes),\n/* harmony export */   maxLength: () => (/* binding */ maxLength),\n/* harmony export */   maxRange: () => (/* binding */ maxRange),\n/* harmony export */   maxSize: () => (/* binding */ maxSize),\n/* harmony export */   maxValue: () => (/* binding */ maxValue),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   mergeAsync: () => (/* binding */ mergeAsync),\n/* harmony export */   mimeType: () => (/* binding */ mimeType),\n/* harmony export */   minBytes: () => (/* binding */ minBytes),\n/* harmony export */   minLength: () => (/* binding */ minLength),\n/* harmony export */   minRange: () => (/* binding */ minRange),\n/* harmony export */   minSize: () => (/* binding */ minSize),\n/* harmony export */   minValue: () => (/* binding */ minValue),\n/* harmony export */   multipleOf: () => (/* binding */ multipleOf),\n/* harmony export */   nan: () => (/* binding */ nan),\n/* harmony export */   nanAsync: () => (/* binding */ nanAsync),\n/* harmony export */   nativeEnum: () => (/* binding */ nativeEnum),\n/* harmony export */   nativeEnumAsync: () => (/* binding */ nativeEnumAsync),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   neverAsync: () => (/* binding */ neverAsync),\n/* harmony export */   nonNullable: () => (/* binding */ nonNullable),\n/* harmony export */   nonNullableAsync: () => (/* binding */ nonNullableAsync),\n/* harmony export */   nonNullish: () => (/* binding */ nonNullish),\n/* harmony export */   nonNullishAsync: () => (/* binding */ nonNullishAsync),\n/* harmony export */   nonOptional: () => (/* binding */ nonOptional),\n/* harmony export */   nonOptionalAsync: () => (/* binding */ nonOptionalAsync),\n/* harmony export */   nullType: () => (/* binding */ nullType),\n/* harmony export */   nullTypeAsync: () => (/* binding */ nullTypeAsync),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   nullableAsync: () => (/* binding */ nullableAsync),\n/* harmony export */   nullish: () => (/* binding */ nullish),\n/* harmony export */   nullishAsync: () => (/* binding */ nullishAsync),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   numberAsync: () => (/* binding */ numberAsync),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   objectAsync: () => (/* binding */ objectAsync),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   omitAsync: () => (/* binding */ omitAsync),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   optionalAsync: () => (/* binding */ optionalAsync),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseAsync: () => (/* binding */ parseAsync),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   partialAsync: () => (/* binding */ partialAsync),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   pickAsync: () => (/* binding */ pickAsync),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   recordAsync: () => (/* binding */ recordAsync),\n/* harmony export */   recursive: () => (/* binding */ recursive),\n/* harmony export */   recursiveAsync: () => (/* binding */ recursiveAsync),\n/* harmony export */   regex: () => (/* binding */ regex),\n/* harmony export */   required: () => (/* binding */ required),\n/* harmony export */   requiredAsync: () => (/* binding */ requiredAsync),\n/* harmony export */   safeInteger: () => (/* binding */ safeInteger),\n/* harmony export */   safeParse: () => (/* binding */ safeParse),\n/* harmony export */   safeParseAsync: () => (/* binding */ safeParseAsync),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setAsync: () => (/* binding */ setAsync),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   special: () => (/* binding */ special),\n/* harmony export */   specialAsync: () => (/* binding */ specialAsync),\n/* harmony export */   startsWith: () => (/* binding */ startsWith),\n/* harmony export */   strict: () => (/* binding */ strict),\n/* harmony export */   strictAsync: () => (/* binding */ strictAsync),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   stringAsync: () => (/* binding */ stringAsync),\n/* harmony export */   symbol: () => (/* binding */ symbol2),\n/* harmony export */   symbolAsync: () => (/* binding */ symbolAsync),\n/* harmony export */   toCustom: () => (/* binding */ toCustom),\n/* harmony export */   toCustomAsync: () => (/* binding */ toCustomAsync),\n/* harmony export */   toLowerCase: () => (/* binding */ toLowerCase),\n/* harmony export */   toMaxValue: () => (/* binding */ toMaxValue),\n/* harmony export */   toMinValue: () => (/* binding */ toMinValue),\n/* harmony export */   toTrimmed: () => (/* binding */ toTrimmed),\n/* harmony export */   toTrimmedEnd: () => (/* binding */ toTrimmedEnd),\n/* harmony export */   toTrimmedStart: () => (/* binding */ toTrimmedStart),\n/* harmony export */   toUpperCase: () => (/* binding */ toUpperCase),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   transformAsync: () => (/* binding */ transformAsync),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   tupleAsync: () => (/* binding */ tupleAsync),\n/* harmony export */   undefinedType: () => (/* binding */ undefinedType),\n/* harmony export */   undefinedTypeAsync: () => (/* binding */ undefinedTypeAsync),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unionAsync: () => (/* binding */ unionAsync),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   unknownAsync: () => (/* binding */ unknownAsync),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   useDefault: () => (/* binding */ useDefault),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   value: () => (/* binding */ value),\n/* harmony export */   voidType: () => (/* binding */ voidType),\n/* harmony export */   voidTypeAsync: () => (/* binding */ voidTypeAsync),\n/* harmony export */   withDefault: () => (/* binding */ withDefault)\n/* harmony export */ });\n// src/error/flatten/flatten.ts\nfunction flatten(arg1) {\n    return (Array.isArray(arg1) ? arg1 : arg1.issues).reduce((flatErrors, issue)=>{\n        if (issue.path) {\n            const path = issue.path.map(({ key })=>key).join(\".\");\n            flatErrors.nested[path] = [\n                ...flatErrors.nested[path] || [],\n                issue.message\n            ];\n        } else {\n            flatErrors.root = [\n                ...flatErrors.root || [],\n                issue.message\n            ];\n        }\n        return flatErrors;\n    }, {\n        nested: {}\n    });\n}\n// src/error/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n    /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */ constructor(issues){\n        super(issues[0].message);\n        this.name = \"ValiError\";\n        this.issues = issues;\n    }\n};\n// src/methods/brand/brand.ts\nvar symbol = Symbol(\"brand\");\nfunction brand(schema, name) {\n    return schema;\n}\n// src/methods/coerce/coerce.ts\nfunction coerce(schema, action) {\n    return {\n        ...schema,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            return schema._parse(action(input), info);\n        }\n    };\n}\n// src/methods/coerce/coerceAsync.ts\nfunction coerceAsync(schema, action) {\n    return {\n        ...schema,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            return schema._parse(await action(input), info);\n        }\n    };\n}\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, value2) {\n    return {\n        ...schema,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            const result = schema._parse(input, info);\n            return {\n                output: result.issues ? typeof value2 === \"function\" ? value2({\n                    input,\n                    issues: result.issues\n                }) : value2 : result.output\n            };\n        }\n    };\n}\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, value2) {\n    return {\n        ...schema,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            const result = await schema._parse(input, info);\n            return {\n                output: result.issues ? typeof value2 === \"function\" ? value2({\n                    input,\n                    issues: result.issues\n                }) : value2 : result.output\n            };\n        }\n    };\n}\n// src/methods/is/is.ts\nfunction is(schema, input) {\n    return !schema._parse(input, {\n        abortEarly: true\n    }).issues;\n}\n// src/utils/executePipe/utils/getIssue/getIssue.ts\nfunction getIssue(info, issue) {\n    return {\n        reason: info?.reason,\n        validation: issue.validation,\n        origin: info?.origin || \"value\",\n        message: issue.message,\n        input: issue.input,\n        abortEarly: info?.abortEarly,\n        abortPipeEarly: info?.abortPipeEarly\n    };\n}\n// src/utils/executePipe/utils/getPipeInfo/getPipeInfo.ts\nfunction getPipeInfo(info, reason) {\n    return {\n        reason,\n        origin: info?.origin,\n        abortEarly: info?.abortEarly,\n        abortPipeEarly: info?.abortPipeEarly\n    };\n}\n// src/utils/executePipe/executePipe.ts\nfunction executePipe(input, pipe, parseInfo, reason) {\n    if (!pipe || !pipe.length) {\n        return {\n            output: input\n        };\n    }\n    let pipeInfo;\n    let issues;\n    let output = input;\n    for (const action of pipe){\n        const result = action(output);\n        if (result.issue) {\n            pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);\n            const issue = getIssue(pipeInfo, result.issue);\n            issues ? issues.push(issue) : issues = [\n                issue\n            ];\n            if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {\n                break;\n            }\n        } else {\n            output = result.output;\n        }\n    }\n    return issues ? {\n        issues\n    } : {\n        output\n    };\n}\n// src/utils/executePipe/executePipeAsync.ts\nasync function executePipeAsync(input, pipe, parseInfo, reason) {\n    if (!pipe || !pipe.length) {\n        return {\n            output: input\n        };\n    }\n    let pipeInfo;\n    let issues;\n    let output = input;\n    for (const action of pipe){\n        const result = await action(output);\n        if (result.issue) {\n            pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);\n            const issue = getIssue(pipeInfo, result.issue);\n            issues ? issues.push(issue) : issues = [\n                issue\n            ];\n            if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {\n                break;\n            }\n        } else {\n            output = result.output;\n        }\n    }\n    return issues ? {\n        issues\n    } : {\n        output\n    };\n}\n// src/utils/getDefaultArgs/getDefaultArgs.ts\nfunction getDefaultArgs(arg1, arg2) {\n    return !arg1 || typeof arg1 === \"string\" ? [\n        arg1,\n        arg2\n    ] : [\n        void 0,\n        arg1\n    ];\n}\n// src/utils/getIssues/getIssues.ts\nfunction getIssues(info, reason, validation, message, input, issues) {\n    return {\n        issues: [\n            {\n                reason,\n                validation,\n                origin: info?.origin || \"value\",\n                message,\n                input,\n                issues,\n                abortEarly: info?.abortEarly,\n                abortPipeEarly: info?.abortPipeEarly\n            }\n        ]\n    };\n}\n// src/utils/isLuhnAlgo/isLuhnAlgo.ts\nfunction isLuhnAlgo(input) {\n    const number2 = input.replace(/\\D/g, \"\");\n    let length2 = number2.length;\n    let bit = 1;\n    let sum = 0;\n    while(length2){\n        const value2 = +number2[--length2];\n        bit ^= 1;\n        sum += bit ? [\n            0,\n            2,\n            4,\n            6,\n            8,\n            1,\n            3,\n            5,\n            7,\n            9\n        ][value2] : value2;\n    }\n    return sum % 10 === 0;\n}\n// src/schemas/any/any.ts\nfunction any(pipe = []) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"any\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            return executePipe(input, pipe, info, \"any\");\n        }\n    };\n}\n// src/schemas/any/anyAsync.ts\nfunction anyAsync(pipe = []) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"any\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            return executePipeAsync(input, pipe, info, \"any\");\n        }\n    };\n}\n// src/schemas/array/array.ts\nfunction array(item, arg2, arg3) {\n    const [error, pipe] = getDefaultArgs(arg2, arg3);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"array\",\n        /**\n     * The array item schema.\n     */ array: {\n            item\n        },\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (!Array.isArray(input)) {\n                return getIssues(info, \"type\", \"array\", error || \"Invalid type\", input);\n            }\n            let issues;\n            const output = [];\n            for(let key = 0; key < input.length; key++){\n                const value2 = input[key];\n                const result = item._parse(value2, info);\n                if (result.issues) {\n                    const pathItem = {\n                        schema: \"array\",\n                        input,\n                        key,\n                        value: value2\n                    };\n                    for (const issue of result.issues){\n                        if (issue.path) {\n                            issue.path.unshift(pathItem);\n                        } else {\n                            issue.path = [\n                                pathItem\n                            ];\n                        }\n                        issues?.push(issue);\n                    }\n                    if (!issues) {\n                        issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                        break;\n                    }\n                } else {\n                    output.push(result.output);\n                }\n            }\n            return issues ? {\n                issues\n            } : executePipe(output, pipe, info, \"array\");\n        }\n    };\n}\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, arg2, arg3) {\n    const [error, pipe] = getDefaultArgs(arg2, arg3);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"array\",\n        /**\n     * The array item schema.\n     */ array: {\n            item\n        },\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (!Array.isArray(input)) {\n                return getIssues(info, \"type\", \"array\", error || \"Invalid type\", input);\n            }\n            let issues;\n            const output = [];\n            await Promise.all(input.map(async (value2, key)=>{\n                if (!(info?.abortEarly && issues)) {\n                    const result = await item._parse(value2, info);\n                    if (!(info?.abortEarly && issues)) {\n                        if (result.issues) {\n                            const pathItem = {\n                                schema: \"array\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of result.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                issues?.push(issue);\n                            }\n                            if (!issues) {\n                                issues = result.issues;\n                            }\n                            if (info?.abortEarly) {\n                                throw null;\n                            }\n                        } else {\n                            output[key] = result.output;\n                        }\n                    }\n                }\n            })).catch(()=>null);\n            return issues ? {\n                issues\n            } : executePipeAsync(output, pipe, info, \"array\");\n        }\n    };\n}\n// src/schemas/bigint/bigint.ts\nfunction bigint(arg1, arg2) {\n    const [error, pipe] = getDefaultArgs(arg1, arg2);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"bigint\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (typeof input !== \"bigint\") {\n                return getIssues(info, \"type\", \"bigint\", error || \"Invalid type\", input);\n            }\n            return executePipe(input, pipe, info, \"bigint\");\n        }\n    };\n}\n// src/schemas/bigint/bigintAsync.ts\nfunction bigintAsync(arg1, arg2) {\n    const [error, pipe] = getDefaultArgs(arg1, arg2);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"bigint\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (typeof input !== \"bigint\") {\n                return getIssues(info, \"type\", \"bigint\", error || \"Invalid type\", input);\n            }\n            return executePipeAsync(input, pipe, info, \"bigint\");\n        }\n    };\n}\n// src/schemas/blob/blob.ts\nfunction blob(arg1, arg2) {\n    const [error, pipe] = getDefaultArgs(arg1, arg2);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"blob\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (!(input instanceof Blob)) {\n                return getIssues(info, \"type\", \"blob\", error || \"Invalid type\", input);\n            }\n            return executePipe(input, pipe, info, \"blob\");\n        }\n    };\n}\n// src/schemas/blob/blobAsync.ts\nfunction blobAsync(arg1, arg2) {\n    const [error, pipe] = getDefaultArgs(arg1, arg2);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"blob\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (!(input instanceof Blob)) {\n                return getIssues(info, \"type\", \"blob\", error || \"Invalid type\", input);\n            }\n            return executePipeAsync(input, pipe, info, \"blob\");\n        }\n    };\n}\n// src/schemas/boolean/boolean.ts\nfunction boolean(arg1, arg2) {\n    const [error, pipe] = getDefaultArgs(arg1, arg2);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"boolean\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (typeof input !== \"boolean\") {\n                return getIssues(info, \"type\", \"boolean\", error || \"Invalid type\", input);\n            }\n            return executePipe(input, pipe, info, \"boolean\");\n        }\n    };\n}\n// src/schemas/boolean/booleanAsync.ts\nfunction booleanAsync(arg1, arg2) {\n    const [error, pipe] = getDefaultArgs(arg1, arg2);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"boolean\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (typeof input !== \"boolean\") {\n                return getIssues(info, \"type\", \"boolean\", error || \"Invalid type\", input);\n            }\n            return executePipeAsync(input, pipe, info, \"boolean\");\n        }\n    };\n}\n// src/schemas/date/date.ts\nfunction date(arg1, arg2) {\n    const [error, pipe] = getDefaultArgs(arg1, arg2);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"date\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (!(input instanceof Date)) {\n                return getIssues(info, \"type\", \"date\", error || \"Invalid type\", input);\n            }\n            return executePipe(input, pipe, info, \"date\");\n        }\n    };\n}\n// src/schemas/date/dateAsync.ts\nfunction dateAsync(arg1, arg2) {\n    const [error, pipe] = getDefaultArgs(arg1, arg2);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"date\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (!(input instanceof Date)) {\n                return getIssues(info, \"type\", \"date\", error || \"Invalid type\", input);\n            }\n            return executePipeAsync(input, pipe, info, \"date\");\n        }\n    };\n}\n// src/schemas/enumType/enumType.ts\nfunction enumType(enumValue, error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"enum\",\n        /**\n     * The enum value.\n     */ enum: enumValue,\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (!enumValue.includes(input)) {\n                return getIssues(info, \"type\", \"enum\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/enumType/enumTypeAsync.ts\nfunction enumTypeAsync(enumValue, error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"enum\",\n        /**\n     * The enum value.\n     */ enum: enumValue,\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (!enumValue.includes(input)) {\n                return getIssues(info, \"type\", \"enum\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/instance/instance.ts\nfunction instance(of, arg2, arg3) {\n    const [error, pipe] = getDefaultArgs(arg2, arg3);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"instance\",\n        /**\n     * The class of the instance.\n     */ class: of,\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (!(input instanceof of)) {\n                return getIssues(info, \"type\", \"instance\", error || \"Invalid type\", input);\n            }\n            return executePipe(input, pipe, info, \"instance\");\n        }\n    };\n}\n// src/schemas/instance/instanceAsync.ts\nfunction instanceAsync(of, arg2, arg3) {\n    const [error, pipe] = getDefaultArgs(arg2, arg3);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"instance\",\n        /**\n     * The class of the instance.\n     */ class: of,\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (!(input instanceof of)) {\n                return getIssues(info, \"type\", \"instance\", error || \"Invalid type\", input);\n            }\n            return executePipeAsync(input, pipe, info, \"instance\");\n        }\n    };\n}\n// src/schemas/literal/literal.ts\nfunction literal(literal2, error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"literal\",\n        /**\n     * The literal value.\n     */ literal: literal2,\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (input !== literal2) {\n                return getIssues(info, \"type\", \"literal\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/literal/literalAsync.ts\nfunction literalAsync(literal2, error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"literal\",\n        /**\n     * The literal value.\n     */ literal: literal2,\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (input !== literal2) {\n                return getIssues(info, \"type\", \"literal\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/map/map.ts\nfunction map(key, value2, arg3, arg4) {\n    const [error, pipe] = getDefaultArgs(arg3, arg4);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"map\",\n        /**\n     * The map key and value schema.\n     */ map: {\n            key,\n            value: value2\n        },\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (!(input instanceof Map)) {\n                return getIssues(info, \"type\", \"map\", error || \"Invalid type\", input);\n            }\n            let issues;\n            const output = /* @__PURE__ */ new Map();\n            for (const [inputKey, inputValue] of input.entries()){\n                let pathItem;\n                const keyResult = key._parse(inputKey, {\n                    origin: \"key\",\n                    abortEarly: info?.abortEarly,\n                    abortPipeEarly: info?.abortPipeEarly\n                });\n                if (keyResult.issues) {\n                    pathItem = {\n                        schema: \"map\",\n                        input,\n                        key: inputKey,\n                        value: inputValue\n                    };\n                    for (const issue of keyResult.issues){\n                        if (issue.path) {\n                            issue.path.unshift(pathItem);\n                        } else {\n                            issue.path = [\n                                pathItem\n                            ];\n                        }\n                        issues?.push(issue);\n                    }\n                    if (!issues) {\n                        issues = keyResult.issues;\n                    }\n                    if (info?.abortEarly) {\n                        break;\n                    }\n                }\n                const valueResult = value2._parse(inputValue, info);\n                if (valueResult.issues) {\n                    pathItem = pathItem || {\n                        schema: \"map\",\n                        input,\n                        key: inputKey,\n                        value: inputValue\n                    };\n                    for (const issue of valueResult.issues){\n                        if (issue.path) {\n                            issue.path.unshift(pathItem);\n                        } else {\n                            issue.path = [\n                                pathItem\n                            ];\n                        }\n                        issues?.push(issue);\n                    }\n                    if (!issues) {\n                        issues = valueResult.issues;\n                    }\n                    if (info?.abortEarly) {\n                        break;\n                    }\n                }\n                if (!keyResult.issues && !valueResult.issues) {\n                    output.set(keyResult.output, valueResult.output);\n                }\n            }\n            return issues ? {\n                issues\n            } : executePipe(output, pipe, info, \"map\");\n        }\n    };\n}\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, arg3, arg4) {\n    const [error, pipe] = getDefaultArgs(arg3, arg4);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"map\",\n        /**\n     * The map key and value schema.\n     */ map: {\n            key,\n            value: value2\n        },\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (!(input instanceof Map)) {\n                return getIssues(info, \"type\", \"map\", error || \"Invalid type\", input);\n            }\n            const output = /* @__PURE__ */ new Map();\n            let issues;\n            await Promise.all(Array.from(input.entries()).map(async ([inputKey, inputValue])=>{\n                let pathItem;\n                const [keyResult, valueResult] = await Promise.all([\n                    {\n                        schema: key,\n                        value: inputKey,\n                        origin: \"key\"\n                    },\n                    {\n                        schema: value2,\n                        value: inputValue,\n                        origin: \"value\"\n                    }\n                ].map(async ({ schema, value: value3, origin })=>{\n                    if (!(info?.abortEarly && issues)) {\n                        const result = await schema._parse(value3, {\n                            origin,\n                            abortEarly: info?.abortEarly,\n                            abortPipeEarly: info?.abortPipeEarly\n                        });\n                        if (!(info?.abortEarly && issues)) {\n                            if (result.issues) {\n                                pathItem = pathItem || {\n                                    schema: \"map\",\n                                    input,\n                                    key: inputKey,\n                                    value: inputValue\n                                };\n                                for (const issue of result.issues){\n                                    if (issue.path) {\n                                        issue.path.unshift(pathItem);\n                                    } else {\n                                        issue.path = [\n                                            pathItem\n                                        ];\n                                    }\n                                    issues?.push(issue);\n                                }\n                                if (!issues) {\n                                    issues = result.issues;\n                                }\n                                if (info?.abortEarly) {\n                                    throw null;\n                                }\n                            } else {\n                                return result;\n                            }\n                        }\n                    }\n                })).catch(()=>[]);\n                if (keyResult && valueResult) {\n                    output.set(keyResult.output, valueResult.output);\n                }\n            }));\n            return issues ? {\n                issues\n            } : executePipeAsync(input, pipe, info, \"map\");\n        }\n    };\n}\n// src/schemas/nan/nan.ts\nfunction nan(error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"nan\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (!Number.isNaN(input)) {\n                return getIssues(info, \"type\", \"nan\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/nan/nanAsync.ts\nfunction nanAsync(error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"nan\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (!Number.isNaN(input)) {\n                return getIssues(info, \"type\", \"nan\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/nativeEnum/nativeEnum.ts\nfunction nativeEnum(nativeEnum2, error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"native_enum\",\n        /**\n     * The native enum value.\n     */ nativeEnum: nativeEnum2,\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (!Object.values(nativeEnum2).includes(input)) {\n                return getIssues(info, \"type\", \"native_enum\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/nativeEnum/nativeEnumAsync.ts\nfunction nativeEnumAsync(nativeEnum2, error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"native_enum\",\n        /**\n     * The native enum value.\n     */ nativeEnum: nativeEnum2,\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (!Object.values(nativeEnum2).includes(input)) {\n                return getIssues(info, \"type\", \"native_enum\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/never/never.ts\nfunction never(error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"never\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            return getIssues(info, \"type\", \"never\", error || \"Invalid type\", input);\n        }\n    };\n}\n// src/schemas/never/neverAsync.ts\nfunction neverAsync(error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"never\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            return getIssues(info, \"type\", \"never\", error || \"Invalid type\", input);\n        }\n    };\n}\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"non_nullable\",\n        /**\n     * The wrapped schema.\n     */ wrapped,\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (input === null) {\n                return getIssues(info, \"type\", \"non_nullable\", error || \"Invalid type\", input);\n            }\n            return wrapped._parse(input, info);\n        }\n    };\n}\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"non_nullable\",\n        /**\n     * The wrapped schema.\n     */ wrapped,\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (input === null) {\n                return getIssues(info, \"type\", \"non_nullable\", error || \"Invalid type\", input);\n            }\n            return wrapped._parse(input, info);\n        }\n    };\n}\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"non_nullish\",\n        /**\n     * The wrapped schema.\n     */ wrapped,\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (input === null || input === void 0) {\n                return getIssues(info, \"type\", \"non_nullish\", error || \"Invalid type\", input);\n            }\n            return wrapped._parse(input, info);\n        }\n    };\n}\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"non_nullish\",\n        /**\n     * The wrapped schema.\n     */ wrapped,\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (input === null || input === void 0) {\n                return getIssues(info, \"type\", \"non_nullish\", error || \"Invalid type\", input);\n            }\n            return wrapped._parse(input, info);\n        }\n    };\n}\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"non_optional\",\n        /**\n     * The wrapped schema.\n     */ wrapped,\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (input === void 0) {\n                return getIssues(info, \"type\", \"non_optional\", error || \"Invalid type\", input);\n            }\n            return wrapped._parse(input, info);\n        }\n    };\n}\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"non_optional\",\n        /**\n     * The wrapped schema.\n     */ wrapped,\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (input === void 0) {\n                return getIssues(info, \"type\", \"non_optional\", error || \"Invalid type\", input);\n            }\n            return wrapped._parse(input, info);\n        }\n    };\n}\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"nullable\",\n        /**\n     * The wrapped schema.\n     */ wrapped,\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (input === null) {\n                return {\n                    output: input\n                };\n            }\n            return wrapped._parse(input, info);\n        }\n    };\n}\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"nullable\",\n        /**\n     * The wrapped schema.\n     */ wrapped,\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (input === null) {\n                return {\n                    output: input\n                };\n            }\n            return wrapped._parse(input, info);\n        }\n    };\n}\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"nullish\",\n        /**\n     * The wrapped schema.\n     */ wrapped,\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (input === null || input === void 0) {\n                return {\n                    output: input\n                };\n            }\n            return wrapped._parse(input, info);\n        }\n    };\n}\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"nullish\",\n        /**\n     * The wrapped schema.\n     */ wrapped,\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (input === null || input === void 0) {\n                return {\n                    output: input\n                };\n            }\n            return wrapped._parse(input, info);\n        }\n    };\n}\n// src/schemas/nullType/nullType.ts\nfunction nullType(error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"null\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (input !== null) {\n                return getIssues(info, \"type\", \"null\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/nullType/nullTypeAsync.ts\nfunction nullTypeAsync(error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"null\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (input !== null) {\n                return getIssues(info, \"type\", \"null\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/number/number.ts\nfunction number(arg1, arg2) {\n    const [error, pipe] = getDefaultArgs(arg1, arg2);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"number\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (typeof input !== \"number\") {\n                return getIssues(info, \"type\", \"number\", error || \"Invalid type\", input);\n            }\n            return executePipe(input, pipe, info, \"number\");\n        }\n    };\n}\n// src/schemas/number/numberAsync.ts\nfunction numberAsync(arg1, arg2) {\n    const [error, pipe] = getDefaultArgs(arg1, arg2);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"number\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (typeof input !== \"number\") {\n                return getIssues(info, \"type\", \"number\", error || \"Invalid type\", input);\n            }\n            return executePipeAsync(input, pipe, info, \"number\");\n        }\n    };\n}\n// src/schemas/object/object.ts\nfunction object(object2, arg2, arg3) {\n    const [error, pipe] = getDefaultArgs(arg2, arg3);\n    let cachedEntries;\n    return {\n        /**\n     * The schema type.\n     */ schema: \"object\",\n        /**\n     * The object schema.\n     */ object: object2,\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (!input || typeof input !== \"object\") {\n                return getIssues(info, \"type\", \"object\", error || \"Invalid type\", input);\n            }\n            cachedEntries = cachedEntries || Object.entries(object2);\n            let issues;\n            const output = {};\n            for (const [key, schema] of cachedEntries){\n                const value2 = input[key];\n                const result = schema._parse(value2, info);\n                if (result.issues) {\n                    const pathItem = {\n                        schema: \"object\",\n                        input,\n                        key,\n                        value: value2\n                    };\n                    for (const issue of result.issues){\n                        if (issue.path) {\n                            issue.path.unshift(pathItem);\n                        } else {\n                            issue.path = [\n                                pathItem\n                            ];\n                        }\n                        issues?.push(issue);\n                    }\n                    if (!issues) {\n                        issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                        break;\n                    }\n                } else {\n                    output[key] = result.output;\n                }\n            }\n            return issues ? {\n                issues\n            } : executePipe(output, pipe, info, \"object\");\n        }\n    };\n}\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(object2, arg2, arg3) {\n    const [error, pipe] = getDefaultArgs(arg2, arg3);\n    let cachedEntries;\n    return {\n        /**\n     * The schema type.\n     */ schema: \"object\",\n        /**\n     * The object schema.\n     */ object: object2,\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (!input || typeof input !== \"object\") {\n                return getIssues(info, \"type\", \"object\", error || \"Invalid type\", input);\n            }\n            cachedEntries = cachedEntries || Object.entries(object2);\n            let issues;\n            const output = {};\n            await Promise.all(cachedEntries.map(async ([key, schema])=>{\n                if (!(info?.abortEarly && issues)) {\n                    const value2 = input[key];\n                    const result = await schema._parse(value2, info);\n                    if (!(info?.abortEarly && issues)) {\n                        if (result.issues) {\n                            const pathItem = {\n                                schema: \"object\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of result.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                issues?.push(issue);\n                            }\n                            if (!issues) {\n                                issues = result.issues;\n                            }\n                            if (info?.abortEarly) {\n                                throw null;\n                            }\n                        } else {\n                            output[key] = result.output;\n                        }\n                    }\n                }\n            })).catch(()=>null);\n            return issues ? {\n                issues\n            } : executePipeAsync(output, pipe, info, \"object\");\n        }\n    };\n}\n// src/schemas/optional/optional.ts\nfunction optional(wrapped) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"optional\",\n        /**\n     * The wrapped schema.\n     */ wrapped,\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (input === void 0) {\n                return {\n                    output: input\n                };\n            }\n            return wrapped._parse(input, info);\n        }\n    };\n}\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"optional\",\n        /**\n     * The wrapped schema.\n     */ wrapped,\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (input === void 0) {\n                return {\n                    output: input\n                };\n            }\n            return wrapped._parse(input, info);\n        }\n    };\n}\n// src/schemas/string/string.ts\nfunction string(arg1, arg2) {\n    const [error, pipe] = getDefaultArgs(arg1, arg2);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"string\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (typeof input !== \"string\") {\n                return getIssues(info, \"type\", \"string\", error || \"Invalid type\", input);\n            }\n            return executePipe(input, pipe, info, \"string\");\n        }\n    };\n}\n// src/schemas/string/stringAsync.ts\nfunction stringAsync(arg1, arg2) {\n    const [error, pipe] = getDefaultArgs(arg1, arg2);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"string\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (typeof input !== \"string\") {\n                return getIssues(info, \"type\", \"string\", error || \"Invalid type\", input);\n            }\n            return executePipeAsync(input, pipe, info, \"string\");\n        }\n    };\n}\n// src/schemas/record/utils/getRecordArgs/getRecordArgs.ts\nfunction getRecordArgs(arg1, arg2, arg3, arg4) {\n    if (typeof arg2 === \"object\" && !Array.isArray(arg2)) {\n        const [error2, pipe2] = getDefaultArgs(arg3, arg4);\n        return [\n            arg1,\n            arg2,\n            error2,\n            pipe2\n        ];\n    }\n    const [error, pipe] = getDefaultArgs(arg2, arg3);\n    return [\n        string(),\n        arg1,\n        error,\n        pipe\n    ];\n}\n// src/schemas/record/values.ts\nvar BLOCKED_KEYS = [\n    \"__proto__\",\n    \"prototype\",\n    \"constructor\"\n];\n// src/schemas/record/record.ts\nfunction record(arg1, arg2, arg3, arg4) {\n    const [key, value2, error, pipe] = getRecordArgs(arg1, arg2, arg3, arg4);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"record\",\n        /**\n     * The record key and value schema.\n     */ record: {\n            key,\n            value: value2\n        },\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (!input || typeof input !== \"object\") {\n                return getIssues(info, \"type\", \"record\", error || \"Invalid type\", input);\n            }\n            let issues;\n            const output = {};\n            for (const [inputKey, inputValue] of Object.entries(input)){\n                if (!BLOCKED_KEYS.includes(inputKey)) {\n                    let pathItem;\n                    const keyResult = key._parse(inputKey, {\n                        origin: \"key\",\n                        abortEarly: info?.abortEarly,\n                        abortPipeEarly: info?.abortPipeEarly\n                    });\n                    if (keyResult.issues) {\n                        pathItem = {\n                            schema: \"record\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of keyResult.issues){\n                            issue.path = [\n                                pathItem\n                            ];\n                            issues?.push(issue);\n                        }\n                        if (!issues) {\n                            issues = keyResult.issues;\n                        }\n                        if (info?.abortEarly) {\n                            break;\n                        }\n                    }\n                    const valueResult = value2._parse(inputValue, info);\n                    if (valueResult.issues) {\n                        pathItem = pathItem || {\n                            schema: \"record\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of valueResult.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            issues?.push(issue);\n                        }\n                        if (!issues) {\n                            issues = valueResult.issues;\n                        }\n                        if (info?.abortEarly) {\n                            break;\n                        }\n                    }\n                    if (!keyResult.issues && !valueResult.issues) {\n                        output[keyResult.output] = valueResult.output;\n                    }\n                }\n            }\n            return issues ? {\n                issues\n            } : executePipe(output, pipe, info, \"record\");\n        }\n    };\n}\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(arg1, arg2, arg3, arg4) {\n    const [key, value2, error, pipe] = getRecordArgs(arg1, arg2, arg3, arg4);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"record\",\n        /**\n     * The record key and value schema.\n     */ record: {\n            key,\n            value: value2\n        },\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (!input || typeof input !== \"object\") {\n                return getIssues(info, \"type\", \"record\", error || \"Invalid type\", input);\n            }\n            let issues;\n            const output = {};\n            await Promise.all(// Note: `Object.entries(...)` converts each key to a string\n            Object.entries(input).map(async ([inputKey, inputValue])=>{\n                if (!BLOCKED_KEYS.includes(inputKey)) {\n                    let pathItem;\n                    const [keyResult, valueResult] = await Promise.all([\n                        {\n                            schema: key,\n                            value: inputKey,\n                            origin: \"key\"\n                        },\n                        {\n                            schema: value2,\n                            value: inputValue,\n                            origin: \"value\"\n                        }\n                    ].map(async ({ schema, value: value3, origin })=>{\n                        if (!(info?.abortEarly && issues)) {\n                            const result = await schema._parse(value3, {\n                                origin,\n                                abortEarly: info?.abortEarly,\n                                abortPipeEarly: info?.abortPipeEarly\n                            });\n                            if (!(info?.abortEarly && issues)) {\n                                if (result.issues) {\n                                    pathItem = pathItem || {\n                                        schema: \"record\",\n                                        input,\n                                        key: inputKey,\n                                        value: inputValue\n                                    };\n                                    for (const issue of result.issues){\n                                        if (issue.path) {\n                                            issue.path.unshift(pathItem);\n                                        } else {\n                                            issue.path = [\n                                                pathItem\n                                            ];\n                                        }\n                                        issues?.push(issue);\n                                    }\n                                    if (!issues) {\n                                        issues = result.issues;\n                                    }\n                                    if (info?.abortEarly) {\n                                        throw null;\n                                    }\n                                } else {\n                                    return result;\n                                }\n                            }\n                        }\n                    })).catch(()=>[]);\n                    if (keyResult && valueResult) {\n                        output[keyResult.output] = valueResult.output;\n                    }\n                }\n            }));\n            return issues ? {\n                issues\n            } : executePipeAsync(output, pipe, info, \"record\");\n        }\n    };\n}\n// src/schemas/recursive/recursive.ts\nfunction recursive(getter) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"recursive\",\n        /**\n     * The schema getter.\n     */ getter,\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            return getter()._parse(input, info);\n        }\n    };\n}\n// src/schemas/recursive/recursiveAsync.ts\nfunction recursiveAsync(getter) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"recursive\",\n        /**\n     * The schema getter.\n     */ getter,\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            return getter()._parse(input, info);\n        }\n    };\n}\n// src/schemas/set/set.ts\nfunction set(value2, arg2, arg3) {\n    const [error, pipe] = getDefaultArgs(arg2, arg3);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"set\",\n        /**\n     * The set value schema.\n     */ set: {\n            value: value2\n        },\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (!(input instanceof Set)) {\n                return getIssues(info, \"type\", \"set\", error || \"Invalid type\", input);\n            }\n            let key = 0;\n            let issues;\n            const output = /* @__PURE__ */ new Set();\n            for (const inputValue of input){\n                const result = value2._parse(inputValue, info);\n                if (result.issues) {\n                    const pathItem = {\n                        schema: \"set\",\n                        input,\n                        key,\n                        value: inputValue\n                    };\n                    for (const issue of result.issues){\n                        if (issue.path) {\n                            issue.path.unshift(pathItem);\n                        } else {\n                            issue.path = [\n                                pathItem\n                            ];\n                        }\n                        issues?.push(issue);\n                    }\n                    if (!issues) {\n                        issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                        break;\n                    }\n                } else {\n                    output.add(result.output);\n                }\n                key++;\n            }\n            return issues ? {\n                issues\n            } : executePipe(output, pipe, info, \"set\");\n        }\n    };\n}\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, arg2, arg3) {\n    const [error, pipe] = getDefaultArgs(arg2, arg3);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"set\",\n        /**\n     * The set value schema.\n     */ set: {\n            value: value2\n        },\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (!(input instanceof Set)) {\n                return getIssues(info, \"type\", \"set\", error || \"Invalid type\", input);\n            }\n            let issues;\n            const output = /* @__PURE__ */ new Set();\n            await Promise.all(Array.from(input.values()).map(async (inputValue, key)=>{\n                if (!(info?.abortEarly && issues)) {\n                    const result = await value2._parse(inputValue, info);\n                    if (!(info?.abortEarly && issues)) {\n                        if (result.issues) {\n                            const pathItem = {\n                                schema: \"set\",\n                                input,\n                                key,\n                                value: inputValue\n                            };\n                            for (const issue of result.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                issues?.push(issue);\n                            }\n                            if (!issues) {\n                                issues = result.issues;\n                            }\n                            if (info?.abortEarly) {\n                                throw null;\n                            }\n                        } else {\n                            output.add(result.output);\n                        }\n                    }\n                }\n            })).catch(()=>null);\n            return issues ? {\n                issues\n            } : executePipeAsync(input, pipe, info, \"set\");\n        }\n    };\n}\n// src/schemas/special/special.ts\nfunction special(check, arg2, arg3) {\n    const [error, pipe] = getDefaultArgs(arg2, arg3);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"special\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (!check(input)) {\n                return getIssues(info, \"type\", \"special\", error || \"Invalid type\", input);\n            }\n            return executePipe(input, pipe, info, \"special\");\n        }\n    };\n}\n// src/schemas/special/specialAsync.ts\nfunction specialAsync(check, arg2, arg3) {\n    const [error, pipe] = getDefaultArgs(arg2, arg3);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"special\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (!await check(input)) {\n                return getIssues(info, \"type\", \"special\", error || \"Invalid type\", input);\n            }\n            return executePipeAsync(input, pipe, info, \"special\");\n        }\n    };\n}\n// src/schemas/symbol/symbol.ts\nfunction symbol2(error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"symbol\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (typeof input !== \"symbol\") {\n                return getIssues(info, \"type\", \"symbol\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/symbol/symbolAsync.ts\nfunction symbolAsync(error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"symbol\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (typeof input !== \"symbol\") {\n                return getIssues(info, \"type\", \"symbol\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/tuple/utils/getTupleArgs/getTupleArgs.ts\nfunction getTupleArgs(arg1, arg2, arg3) {\n    if (typeof arg1 === \"object\" && !Array.isArray(arg1)) {\n        const [error2, pipe2] = getDefaultArgs(arg2, arg3);\n        return [\n            arg1,\n            error2,\n            pipe2\n        ];\n    }\n    const [error, pipe] = getDefaultArgs(arg1, arg2);\n    return [\n        void 0,\n        error,\n        pipe\n    ];\n}\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, arg2, arg3, arg4) {\n    const [rest, error, pipe] = getTupleArgs(arg2, arg3, arg4);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"tuple\",\n        /**\n     * The tuple items and rest schema.\n     */ tuple: {\n            items,\n            rest\n        },\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (!Array.isArray(input) || !rest && items.length !== input.length || rest && items.length > input.length) {\n                return getIssues(info, \"type\", \"tuple\", error || \"Invalid type\", input);\n            }\n            let issues;\n            const output = [];\n            for(let key = 0; key < items.length; key++){\n                const value2 = input[key];\n                const result = items[key]._parse(value2, info);\n                if (result.issues) {\n                    const pathItem = {\n                        schema: \"tuple\",\n                        input,\n                        key,\n                        value: value2\n                    };\n                    for (const issue of result.issues){\n                        if (issue.path) {\n                            issue.path.unshift(pathItem);\n                        } else {\n                            issue.path = [\n                                pathItem\n                            ];\n                        }\n                        issues?.push(issue);\n                    }\n                    if (!issues) {\n                        issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                        break;\n                    }\n                } else {\n                    output[key] = result.output;\n                }\n            }\n            if (rest) {\n                for(let key = items.length; key < input.length; key++){\n                    const value2 = input[key];\n                    const result = rest._parse(value2, info);\n                    if (result.issues) {\n                        const pathItem = {\n                            schema: \"tuple\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of result.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            issues?.push(issue);\n                        }\n                        if (!issues) {\n                            issues = result.issues;\n                        }\n                        if (info?.abortEarly) {\n                            break;\n                        }\n                    } else {\n                        output[key] = result.output;\n                    }\n                }\n            }\n            return issues ? {\n                issues\n            } : executePipe(output, pipe, info, \"tuple\");\n        }\n    };\n}\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, arg2, arg3, arg4) {\n    const [rest, error, pipe] = getTupleArgs(arg2, arg3, arg4);\n    return {\n        /**\n     * The schema type.\n     */ schema: \"tuple\",\n        /**\n     * The tuple items and rest schema.\n     */ tuple: {\n            items,\n            rest\n        },\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (!Array.isArray(input) || !rest && items.length !== input.length || rest && items.length > input.length) {\n                return getIssues(info, \"type\", \"tuple\", error || \"Invalid type\", input);\n            }\n            let issues;\n            const output = [];\n            await Promise.all([\n                // Parse schema of each tuple item\n                Promise.all(items.map(async (schema, key)=>{\n                    if (!(info?.abortEarly && issues)) {\n                        const value2 = input[key];\n                        const result = await schema._parse(value2, info);\n                        if (!(info?.abortEarly && issues)) {\n                            if (result.issues) {\n                                const pathItem = {\n                                    schema: \"tuple\",\n                                    input,\n                                    key,\n                                    value: value2\n                                };\n                                for (const issue of result.issues){\n                                    if (issue.path) {\n                                        issue.path.unshift(pathItem);\n                                    } else {\n                                        issue.path = [\n                                            pathItem\n                                        ];\n                                    }\n                                    issues?.push(issue);\n                                }\n                                if (!issues) {\n                                    issues = result.issues;\n                                }\n                                if (info?.abortEarly) {\n                                    throw null;\n                                }\n                            } else {\n                                output[key] = result.output;\n                            }\n                        }\n                    }\n                })),\n                // If necessary parse schema of each rest item\n                rest && Promise.all(input.slice(items.length).map(async (value2, index)=>{\n                    if (!(info?.abortEarly && issues)) {\n                        const key = items.length + index;\n                        const result = await rest._parse(value2, info);\n                        if (!(info?.abortEarly && issues)) {\n                            if (result.issues) {\n                                const pathItem = {\n                                    schema: \"tuple\",\n                                    input,\n                                    key,\n                                    value: value2\n                                };\n                                for (const issue of result.issues){\n                                    if (issue.path) {\n                                        issue.path.unshift(pathItem);\n                                    } else {\n                                        issue.path = [\n                                            pathItem\n                                        ];\n                                    }\n                                    issues?.push(issue);\n                                }\n                                if (!issues) {\n                                    issues = result.issues;\n                                }\n                                if (info?.abortEarly) {\n                                    throw null;\n                                }\n                            } else {\n                                output[key] = result.output;\n                            }\n                        }\n                    }\n                }))\n            ]).catch(()=>null);\n            return issues ? {\n                issues\n            } : executePipeAsync(output, pipe, info, \"tuple\");\n        }\n    };\n}\n// src/schemas/undefinedType/undefinedType.ts\nfunction undefinedType(error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"undefined\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (typeof input !== \"undefined\") {\n                return getIssues(info, \"type\", \"undefined\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/undefinedType/undefinedTypeAsync.ts\nfunction undefinedTypeAsync(error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"undefined\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (typeof input !== \"undefined\") {\n                return getIssues(info, \"type\", \"undefined\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/union/union.ts\nfunction union(union2, error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"union\",\n        /**\n     * The union schema.\n     */ union: union2,\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            let issues;\n            let output;\n            for (const schema of union2){\n                const result = schema._parse(input, info);\n                if (result.issues) {\n                    if (issues) {\n                        for (const issue of result.issues){\n                            issues.push(issue);\n                        }\n                    } else {\n                        issues = result.issues;\n                    }\n                } else {\n                    output = [\n                        result.output\n                    ];\n                    break;\n                }\n            }\n            return output ? {\n                output: output[0]\n            } : getIssues(info, \"type\", \"union\", error || \"Invalid type\", input, issues);\n        }\n    };\n}\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(union2, error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"union\",\n        /**\n     * The union schema.\n     */ union: union2,\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            let issues;\n            let output;\n            for (const schema of union2){\n                const result = await schema._parse(input, info);\n                if (result.issues) {\n                    if (issues) {\n                        for (const issue of result.issues){\n                            issues.push(issue);\n                        }\n                    } else {\n                        issues = result.issues;\n                    }\n                } else {\n                    output = [\n                        result.output\n                    ];\n                    break;\n                }\n            }\n            return output ? {\n                output: output[0]\n            } : getIssues(info, \"type\", \"union\", error || \"Invalid type\", input, issues);\n        }\n    };\n}\n// src/schemas/unknown/unknown.ts\nfunction unknown(pipe = []) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"unknown\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            return executePipe(input, pipe, info, \"unknown\");\n        }\n    };\n}\n// src/schemas/unknown/unknownAsync.ts\nfunction unknownAsync(pipe = []) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"unknown\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            return executePipeAsync(input, pipe, info, \"unknown\");\n        }\n    };\n}\n// src/schemas/voidType/voidType.ts\nfunction voidType(error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"void\",\n        /**\n     * Whether it's async.\n     */ async: false,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            if (typeof input !== \"undefined\") {\n                return getIssues(info, \"type\", \"void\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/schemas/voidType/voidTypeAsync.ts\nfunction voidTypeAsync(error) {\n    return {\n        /**\n     * The schema type.\n     */ schema: \"void\",\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            if (typeof input !== \"undefined\") {\n                return getIssues(info, \"type\", \"void\", error || \"Invalid type\", input);\n            }\n            return {\n                output: input\n            };\n        }\n    };\n}\n// src/methods/keyof/keyof.ts\nfunction keyof(schema) {\n    return enumType(Object.keys(schema.object));\n}\n// src/methods/merge/merge.ts\nfunction merge(schemas, arg2, arg3) {\n    const [error, pipe] = getDefaultArgs(arg2, arg3);\n    return object(schemas.reduce((object2, schemas2)=>({\n            ...object2,\n            ...schemas2.object\n        }), {}), error, pipe);\n}\n// src/methods/merge/mergeAsync.ts\nfunction mergeAsync(schemas, arg2, arg3) {\n    const [error, pipe] = getDefaultArgs(arg2, arg3);\n    return objectAsync(schemas.reduce((object2, schemas2)=>({\n            ...object2,\n            ...schemas2.object\n        }), {}), error, pipe);\n}\n// src/methods/omit/omit.ts\nfunction omit(schema, keys, arg3, arg4) {\n    const [error, pipe] = getDefaultArgs(arg3, arg4);\n    return object(Object.entries(schema.object).reduce((object2, [key, schema2])=>keys.includes(key) ? object2 : {\n            ...object2,\n            [key]: schema2\n        }, {}), error, pipe);\n}\n// src/methods/omit/omitAsync.ts\nfunction omitAsync(schema, keys, arg3, arg4) {\n    const [error, pipe] = getDefaultArgs(arg3, arg4);\n    return objectAsync(Object.entries(schema.object).reduce((object2, [key, schema2])=>keys.includes(key) ? object2 : {\n            ...object2,\n            [key]: schema2\n        }, {}), error, pipe);\n}\n// src/methods/parse/parse.ts\nfunction parse(schema, input, info) {\n    const result = schema._parse(input, info);\n    if (result.issues) {\n        throw new ValiError(result.issues);\n    }\n    return result.output;\n}\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, info) {\n    const result = await schema._parse(input, info);\n    if (result.issues) {\n        throw new ValiError(result.issues);\n    }\n    return result.output;\n}\n// src/methods/partial/partial.ts\nfunction partial(schema, arg3, arg4) {\n    const [error, pipe] = getDefaultArgs(arg3, arg4);\n    return object(Object.entries(schema.object).reduce((object2, [key, schema2])=>({\n            ...object2,\n            [key]: optional(schema2)\n        }), {}), error, // @ts-ignore FIXME: Remove line once bug in TS is fixed\n    pipe);\n}\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, arg3, arg4) {\n    const [error, pipe] = getDefaultArgs(arg3, arg4);\n    return objectAsync(Object.entries(schema.object).reduce((object2, [key, schema2])=>({\n            ...object2,\n            [key]: optionalAsync(schema2)\n        }), {}), error, // @ts-ignore FIXME: Remove line once bug in TS is fixed\n    pipe);\n}\n// src/methods/pick/pick.ts\nfunction pick(schema, keys, arg3, arg4) {\n    const [error, pipe] = getDefaultArgs(arg3, arg4);\n    return object(Object.entries(schema.object).reduce((object2, [key, schema2])=>keys.includes(key) ? {\n            ...object2,\n            [key]: schema2\n        } : object2, {}), error, pipe);\n}\n// src/methods/pick/pickAsync.ts\nfunction pickAsync(schema, keys, arg3, arg4) {\n    const [error, pipe] = getDefaultArgs(arg3, arg4);\n    return objectAsync(Object.entries(schema.object).reduce((object2, [key, schema2])=>keys.includes(key) ? {\n            ...object2,\n            [key]: schema2\n        } : object2, {}), error, pipe);\n}\n// src/methods/required/required.ts\nfunction required(schema, arg3, arg4) {\n    const [error, pipe] = getDefaultArgs(arg3, arg4);\n    return object(Object.entries(schema.object).reduce((object2, [key, schema2])=>({\n            ...object2,\n            [key]: nonOptional(schema2)\n        }), {}), error, // @ts-ignore FIXME: Remove line once bug in TS is fixed\n    pipe);\n}\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg3, arg4) {\n    const [error, pipe] = getDefaultArgs(arg3, arg4);\n    return objectAsync(Object.entries(schema.object).reduce((object2, [key, schema2])=>({\n            ...object2,\n            [key]: nonOptionalAsync(schema2)\n        }), {}), error, // @ts-ignore FIXME: Remove line once bug in TS is fixed\n    pipe);\n}\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, info) {\n    const result = schema._parse(input, info);\n    return result.issues ? {\n        success: false,\n        error: new ValiError(result.issues),\n        issues: result.issues\n    } : {\n        success: true,\n        data: result.output,\n        output: result.output\n    };\n}\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, info) {\n    const result = await schema._parse(input, info);\n    return result.issues ? {\n        success: false,\n        error: new ValiError(result.issues),\n        issues: result.issues\n    } : {\n        success: true,\n        data: result.output,\n        output: result.output\n    };\n}\n// src/methods/strict/strict.ts\nfunction strict(schema, error) {\n    return {\n        ...schema,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            const result = schema._parse(input, info);\n            return !result.issues && // Check length of input and output keys\n            Object.keys(input).length !== Object.keys(result.output).length ? getIssues(info, \"object\", \"strict\", error || \"Invalid keys\", input) : result;\n        }\n    };\n}\n// src/methods/strict/strictAsync.ts\nfunction strictAsync(schema, error) {\n    return {\n        ...schema,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            const result = await schema._parse(input, info);\n            return !result.issues && // Check length of input and output keys\n            Object.keys(input).length !== Object.keys(result.output).length ? getIssues(info, \"object\", \"strict\", error || \"Invalid keys\", input) : result;\n        }\n    };\n}\n// src/methods/transform/transform.ts\nfunction transform(schema, action) {\n    return {\n        ...schema,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            const result = schema._parse(input, info);\n            return result.issues ? result : {\n                output: action(result.output)\n            };\n        }\n    };\n}\n// src/methods/transform/transformAsync.ts\nfunction transformAsync(schema, action) {\n    return {\n        ...schema,\n        /**\n     * Whether it's async.\n     */ async: true,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ async _parse (input, info) {\n            const result = await schema._parse(input, info);\n            return result.issues ? result : {\n                output: await action(result.output)\n            };\n        }\n    };\n}\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n    return schema.wrapped;\n}\n// src/methods/withDefault/withDefault.ts\nfunction withDefault(schema, value2) {\n    return {\n        ...schema,\n        /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */ _parse (input, info) {\n            return schema._parse(input === void 0 ? typeof value2 === \"function\" ? value2() : value2 : input, info);\n        }\n    };\n}\nvar useDefault = withDefault;\n// src/transformations/toCustom/toCustom.ts\nfunction toCustom(action) {\n    return (input)=>({\n            output: action(input)\n        });\n}\n// src/transformations/toCustom/toCustomAsync.ts\nfunction toCustomAsync(action) {\n    return async (input)=>({\n            output: await action(input)\n        });\n}\n// src/transformations/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n    return (input)=>({\n            output: input.toLocaleLowerCase()\n        });\n}\n// src/transformations/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n    return (input)=>({\n            output: input > requirement ? requirement : input\n        });\n}\n// src/transformations/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n    return (input)=>({\n            output: input < requirement ? requirement : input\n        });\n}\n// src/transformations/toTrimmed/toTrimmed.ts\nfunction toTrimmed() {\n    return (input)=>({\n            output: input.trim()\n        });\n}\n// src/transformations/toTrimmedEnd/toTrimmedEnd.ts\nfunction toTrimmedEnd() {\n    return (input)=>({\n            output: input.trimEnd()\n        });\n}\n// src/transformations/toTrimmedStart/toTrimmedStart.ts\nfunction toTrimmedStart() {\n    return (input)=>({\n            output: input.trimStart()\n        });\n}\n// src/transformations/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n    return (input)=>({\n            output: input.toUpperCase()\n        });\n}\n// src/validations/bytes/bytes.ts\nfunction bytes(requirement, error) {\n    return (input)=>{\n        if (new TextEncoder().encode(input).length !== requirement) {\n            return {\n                issue: {\n                    validation: \"bytes\",\n                    message: error || \"Invalid byte length\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/custom/custom.ts\nfunction custom(requirement, error) {\n    return (input)=>{\n        if (!requirement(input)) {\n            return {\n                issue: {\n                    validation: \"custom\",\n                    message: error || \"Invalid input\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/custom/customAsync.ts\nfunction customAsync(requirement, error) {\n    return async (input)=>{\n        if (!await requirement(input)) {\n            return {\n                issue: {\n                    validation: \"custom\",\n                    message: error || \"Invalid input\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/email/email.ts\nfunction email(error) {\n    return (input)=>{\n        if (!/^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@(([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{2,})$/i.test(input)) {\n            return {\n                issue: {\n                    validation: \"email\",\n                    message: error || \"Invalid email\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/emoji/emoji.ts\nfunction emoji(error) {\n    return (input)=>{\n        if (!/^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$/u.test(input)) {\n            return {\n                issue: {\n                    validation: \"emoji\",\n                    message: error || \"Invalid emoji\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/endsWith/endsWith.ts\nfunction endsWith(requirement, error) {\n    return (input)=>{\n        if (!input.endsWith(requirement)) {\n            return {\n                issue: {\n                    validation: \"ends_with\",\n                    message: error || \"Invalid end\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/equal/equal.ts\nfunction equal(requirement, error) {\n    return (input)=>{\n        if (input !== requirement) {\n            return {\n                issue: {\n                    validation: \"equal\",\n                    message: error || \"Invalid input\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/excludes/excludes.ts\nfunction excludes(requirement, error) {\n    return (input)=>{\n        if (input.includes(requirement)) {\n            return {\n                issue: {\n                    validation: \"excludes\",\n                    message: error || \"Invalid content\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/finite/finite.ts\nfunction finite(error) {\n    return (input)=>{\n        if (!Number.isFinite(input)) {\n            return {\n                issue: {\n                    validation: \"finite\",\n                    message: error || \"Invalid finite number\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/imei/imei.ts\nfunction imei(error) {\n    return (input)=>{\n        if (!/^\\d{2}[ |/|-]?\\d{6}[ |/|-]?\\d{6}[ |/|-]?\\d$/.test(input) || !isLuhnAlgo(input)) {\n            return {\n                issue: {\n                    validation: \"imei\",\n                    message: error || \"Invalid IMEI\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/includes/includes.ts\nfunction includes(requirement, error) {\n    return (input)=>{\n        if (!input.includes(requirement)) {\n            return {\n                issue: {\n                    validation: \"includes\",\n                    message: error || \"Invalid content\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/integer/integer.ts\nfunction integer(error) {\n    return (input)=>{\n        if (!Number.isInteger(input)) {\n            return {\n                issue: {\n                    validation: \"integer\",\n                    message: error || \"Invalid integer\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/ip/ip.ts\nfunction ip(error) {\n    return (input)=>{\n        if (!/^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}$/.test(input) && !/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(input)) {\n            return {\n                issue: {\n                    validation: \"ip\",\n                    message: error || \"Invalid IP\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/ipv4/ipv4.ts\nfunction ipv4(error) {\n    return (input)=>{\n        if (!/^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}$/.test(input)) {\n            return {\n                issue: {\n                    validation: \"ipv4\",\n                    message: error || \"Invalid IP v4\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/ipv6/ipv6.ts\nfunction ipv6(error) {\n    return (input)=>{\n        if (!/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(input)) {\n            return {\n                issue: {\n                    validation: \"ipv6\",\n                    message: error || \"Invalid IP v6\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/isoDate/isoDate.ts\nfunction isoDate(error) {\n    return (input)=>{\n        if (!/^\\d{4}-(0[1-9]|1[0-2])-([12]\\d|0[1-9]|3[01])$/.test(input)) {\n            return {\n                issue: {\n                    validation: \"iso_date\",\n                    message: error || \"Invalid date\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/isoDateTime/isoDateTime.ts\nfunction isoDateTime(error) {\n    return (input)=>{\n        if (!/^\\d{4}-(0[1-9]|1[0-2])-([12]\\d|0[1-9]|3[01])T(0[0-9]|1\\d|2[0-3]):[0-5]\\d$/.test(input)) {\n            return {\n                issue: {\n                    validation: \"iso_date_time\",\n                    message: error || \"Invalid datetime\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/isoTime/isoTime.ts\nfunction isoTime(error) {\n    return (input)=>{\n        if (!/^(0[0-9]|1\\d|2[0-3]):[0-5]\\d$/.test(input)) {\n            return {\n                issue: {\n                    validation: \"iso_time\",\n                    message: error || \"Invalid time\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(error) {\n    return (input)=>{\n        if (!/^(0[0-9]|1\\d|2[0-3]):[0-5]\\d:[0-5]\\d$/.test(input)) {\n            return {\n                issue: {\n                    validation: \"iso_time_second\",\n                    message: error || \"Invalid time\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(error) {\n    return (input)=>{\n        if (!/^\\d{4}-(0[1-9]|1[0-2])-([12]\\d|0[1-9]|3[01])T(0[0-9]|1\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{3}Z$/.test(input)) {\n            return {\n                issue: {\n                    validation: \"iso_timestamp\",\n                    message: error || \"Invalid timestamp\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/isoWeek/isoWeek.ts\nfunction isoWeek(error) {\n    return (input)=>{\n        if (!/^\\d{4}-W(0[1-9]|[1-4]\\d|5[0-3])$/.test(input)) {\n            return {\n                issue: {\n                    validation: \"iso_week\",\n                    message: error || \"Invalid week\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/length/length.ts\nfunction length(requirement, error) {\n    return (input)=>{\n        if (input.length !== requirement) {\n            return {\n                issue: {\n                    validation: \"length\",\n                    message: error || \"Invalid length\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, error) {\n    return (input)=>{\n        if (new TextEncoder().encode(input).length > requirement) {\n            return {\n                issue: {\n                    validation: \"max_bytes\",\n                    message: error || \"Invalid byte length\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/maxLength/maxLength.ts\nfunction maxLength(requirement, error) {\n    return (input)=>{\n        if (input.length > requirement) {\n            return {\n                issue: {\n                    validation: \"max_length\",\n                    message: error || \"Invalid length\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/maxSize/maxSize.ts\nfunction maxSize(requirement, error) {\n    return (input)=>{\n        if (input.size > requirement) {\n            return {\n                issue: {\n                    validation: \"max_size\",\n                    message: error || \"Invalid size\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/maxValue/maxValue.ts\nfunction maxValue(requirement, error) {\n    return (input)=>{\n        if (input > requirement) {\n            return {\n                issue: {\n                    validation: \"max_value\",\n                    message: error || \"Invalid value\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\nvar maxRange = maxValue;\n// src/validations/minBytes/minBytes.ts\nfunction minBytes(requirement, error) {\n    return (input)=>{\n        if (new TextEncoder().encode(input).length < requirement) {\n            return {\n                issue: {\n                    validation: \"min_bytes\",\n                    message: error || \"Invalid byte length\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/mimeType/mimeType.ts\nfunction mimeType(requirement, error) {\n    return (input)=>{\n        if (!requirement.includes(input.type)) {\n            return {\n                issue: {\n                    validation: \"mime_type\",\n                    message: error || \"Invalid MIME type\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/minLength/minLength.ts\nfunction minLength(requirement, error) {\n    return (input)=>{\n        if (input.length < requirement) {\n            return {\n                issue: {\n                    validation: \"min_length\",\n                    message: error || \"Invalid length\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/minSize/minSize.ts\nfunction minSize(requirement, error) {\n    return (input)=>{\n        if (input.size < requirement) {\n            return {\n                issue: {\n                    validation: \"min_size\",\n                    message: error || \"Invalid size\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/minValue/minValue.ts\nfunction minValue(requirement, error) {\n    return (input)=>{\n        if (input < requirement) {\n            return {\n                issue: {\n                    validation: \"min_value\",\n                    message: error || \"Invalid value\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\nvar minRange = minValue;\n// src/validations/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, error) {\n    return (input)=>{\n        if (input % requirement !== 0) {\n            return {\n                issue: {\n                    validation: \"multipleOf\",\n                    message: error || \"Invalid multiple\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/regex/regex.ts\nfunction regex(requirement, error) {\n    return (input)=>{\n        if (!requirement.test(input)) {\n            return {\n                issue: {\n                    validation: \"regex\",\n                    message: error || \"Invalid regex\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/safeInteger/safeInteger.ts\nfunction safeInteger(error) {\n    return (input)=>{\n        if (!Number.isSafeInteger(input)) {\n            return {\n                issue: {\n                    validation: \"safe_integer\",\n                    message: error || \"Invalid safe integer\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/size/size.ts\nfunction size(requirement, error) {\n    return (input)=>{\n        if (input.size !== requirement) {\n            return {\n                issue: {\n                    validation: \"size\",\n                    message: error || \"Invalid size\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/startsWith/startsWith.ts\nfunction startsWith(requirement, error) {\n    return (input)=>{\n        if (!input.startsWith(requirement)) {\n            return {\n                issue: {\n                    validation: \"starts_with\",\n                    message: error || \"Invalid start\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/url/url.ts\nfunction url(error) {\n    return (input)=>{\n        try {\n            new URL(input);\n            return {\n                output: input\n            };\n        } catch (_) {\n            return {\n                issue: {\n                    validation: \"url\",\n                    message: error || \"Invalid URL\",\n                    input\n                }\n            };\n        }\n    };\n}\n// src/validations/uuid/uuid.ts\nfunction uuid(error) {\n    return (input)=>{\n        if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(input)) {\n            return {\n                issue: {\n                    validation: \"uuid\",\n                    message: error || \"Invalid UUID\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n// src/validations/value/value.ts\nfunction value(requirement, error) {\n    return (input)=>{\n        if (input !== requirement) {\n            return {\n                issue: {\n                    validation: \"value\",\n                    message: error || \"Invalid value\",\n                    input\n                }\n            };\n        }\n        return {\n            output: input\n        };\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdmFsaWJvdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUFDL0IsU0FBU0EsUUFBUUMsSUFBSTtJQUNuQixPQUFPLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUUEsT0FBT0EsS0FBS0csTUFBTSxFQUFFQyxNQUFNLENBQ3RELENBQUNDLFlBQVlDO1FBQ1gsSUFBSUEsTUFBTUMsSUFBSSxFQUFFO1lBQ2QsTUFBTUEsT0FBT0QsTUFBTUMsSUFBSSxDQUFDQyxHQUFHLENBQUMsQ0FBQyxFQUFFQyxHQUFHLEVBQUUsR0FBS0EsS0FBS0MsSUFBSSxDQUFDO1lBQ25ETCxXQUFXTSxNQUFNLENBQUNKLEtBQUssR0FBRzttQkFDckJGLFdBQVdNLE1BQU0sQ0FBQ0osS0FBSyxJQUFJLEVBQUU7Z0JBQ2hDRCxNQUFNTSxPQUFPO2FBQ2Q7UUFDSCxPQUFPO1lBQ0xQLFdBQVdRLElBQUksR0FBRzttQkFBSVIsV0FBV1EsSUFBSSxJQUFJLEVBQUU7Z0JBQUVQLE1BQU1NLE9BQU87YUFBQztRQUM3RDtRQUNBLE9BQU9QO0lBQ1QsR0FDQTtRQUFFTSxRQUFRLENBQUM7SUFBRTtBQUVqQjtBQUVBLG1DQUFtQztBQUNuQyxJQUFJRyxZQUFZLGNBQWNDO0lBRTVCOzs7O0dBSUMsR0FDREMsWUFBWWIsTUFBTSxDQUFFO1FBQ2xCLEtBQUssQ0FBQ0EsTUFBTSxDQUFDLEVBQUUsQ0FBQ1MsT0FBTztRQUN2QixJQUFJLENBQUNLLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ2QsTUFBTSxHQUFHQTtJQUNoQjtBQUNGO0FBRUEsNkJBQTZCO0FBQzdCLElB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dXJjZXMiOlsid2VicGFjazovL3J1bWJsZS1yYWZmbGUtZnJhbWUvLi9ub2RlX21vZHVsZXMvdmFsaWJvdC9kaXN0L2luZGV4LmpzPzQ4ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Vycm9yL2ZsYXR0ZW4vZmxhdHRlbi50c1xuZnVuY3Rpb24gZmxhdHRlbihhcmcxKSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheShhcmcxKSA/IGFyZzEgOiBhcmcxLmlzc3VlcykucmVkdWNlKFxuICAgIChmbGF0RXJyb3JzLCBpc3N1ZSkgPT4ge1xuICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGlzc3VlLnBhdGgubWFwKCh7IGtleSB9KSA9PiBrZXkpLmpvaW4oXCIuXCIpO1xuICAgICAgICBmbGF0RXJyb3JzLm5lc3RlZFtwYXRoXSA9IFtcbiAgICAgICAgICAuLi5mbGF0RXJyb3JzLm5lc3RlZFtwYXRoXSB8fCBbXSxcbiAgICAgICAgICBpc3N1ZS5tZXNzYWdlXG4gICAgICAgIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGF0RXJyb3JzLnJvb3QgPSBbLi4uZmxhdEVycm9ycy5yb290IHx8IFtdLCBpc3N1ZS5tZXNzYWdlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmbGF0RXJyb3JzO1xuICAgIH0sXG4gICAgeyBuZXN0ZWQ6IHt9IH1cbiAgKTtcbn1cblxuLy8gc3JjL2Vycm9yL1ZhbGlFcnJvci9WYWxpRXJyb3IudHNcbnZhciBWYWxpRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgaXNzdWVzO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFZhbGlib3QgZXJyb3Igd2l0aCB1c2VmdWwgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBpc3N1ZXMgVGhlIGVycm9yIGlzc3Vlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGlzc3Vlcykge1xuICAgIHN1cGVyKGlzc3Vlc1swXS5tZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlZhbGlFcnJvclwiO1xuICAgIHRoaXMuaXNzdWVzID0gaXNzdWVzO1xuICB9XG59O1xuXG4vLyBzcmMvbWV0aG9kcy9icmFuZC9icmFuZC50c1xudmFyIHN5bWJvbCA9IFN5bWJvbChcImJyYW5kXCIpO1xuZnVuY3Rpb24gYnJhbmQoc2NoZW1hLCBuYW1lKSB7XG4gIHJldHVybiBzY2hlbWE7XG59XG5cbi8vIHNyYy9tZXRob2RzL2NvZXJjZS9jb2VyY2UudHNcbmZ1bmN0aW9uIGNvZXJjZShzY2hlbWEsIGFjdGlvbikge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIHJldHVybiBzY2hlbWEuX3BhcnNlKGFjdGlvbihpbnB1dCksIGluZm8pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvY29lcmNlL2NvZXJjZUFzeW5jLnRzXG5mdW5jdGlvbiBjb2VyY2VBc3luYyhzY2hlbWEsIGFjdGlvbikge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIHJldHVybiBzY2hlbWEuX3BhcnNlKGF3YWl0IGFjdGlvbihpbnB1dCksIGluZm8pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZmFsbGJhY2svZmFsbGJhY2sudHNcbmZ1bmN0aW9uIGZhbGxiYWNrKHNjaGVtYSwgdmFsdWUyKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdXRwdXQ6IHJlc3VsdC5pc3N1ZXMgPyB0eXBlb2YgdmFsdWUyID09PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZTIoe1xuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIGlzc3VlczogcmVzdWx0Lmlzc3Vlc1xuICAgICAgICB9KSA6IHZhbHVlMiA6IHJlc3VsdC5vdXRwdXRcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9mYWxsYmFjay9mYWxsYmFja0FzeW5jLnRzXG5mdW5jdGlvbiBmYWxsYmFja0FzeW5jKHNjaGVtYSwgdmFsdWUyKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdXRwdXQ6IHJlc3VsdC5pc3N1ZXMgPyB0eXBlb2YgdmFsdWUyID09PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZTIoe1xuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIGlzc3VlczogcmVzdWx0Lmlzc3Vlc1xuICAgICAgICB9KSA6IHZhbHVlMiA6IHJlc3VsdC5vdXRwdXRcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9pcy9pcy50c1xuZnVuY3Rpb24gaXMoc2NoZW1hLCBpbnB1dCkge1xuICByZXR1cm4gIXNjaGVtYS5fcGFyc2UoaW5wdXQsIHsgYWJvcnRFYXJseTogdHJ1ZSB9KS5pc3N1ZXM7XG59XG5cbi8vIHNyYy91dGlscy9leGVjdXRlUGlwZS91dGlscy9nZXRJc3N1ZS9nZXRJc3N1ZS50c1xuZnVuY3Rpb24gZ2V0SXNzdWUoaW5mbywgaXNzdWUpIHtcbiAgcmV0dXJuIHtcbiAgICByZWFzb246IGluZm8/LnJlYXNvbixcbiAgICB2YWxpZGF0aW9uOiBpc3N1ZS52YWxpZGF0aW9uLFxuICAgIG9yaWdpbjogaW5mbz8ub3JpZ2luIHx8IFwidmFsdWVcIixcbiAgICBtZXNzYWdlOiBpc3N1ZS5tZXNzYWdlLFxuICAgIGlucHV0OiBpc3N1ZS5pbnB1dCxcbiAgICBhYm9ydEVhcmx5OiBpbmZvPy5hYm9ydEVhcmx5LFxuICAgIGFib3J0UGlwZUVhcmx5OiBpbmZvPy5hYm9ydFBpcGVFYXJseVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvZXhlY3V0ZVBpcGUvdXRpbHMvZ2V0UGlwZUluZm8vZ2V0UGlwZUluZm8udHNcbmZ1bmN0aW9uIGdldFBpcGVJbmZvKGluZm8sIHJlYXNvbikge1xuICByZXR1cm4ge1xuICAgIHJlYXNvbixcbiAgICBvcmlnaW46IGluZm8/Lm9yaWdpbixcbiAgICBhYm9ydEVhcmx5OiBpbmZvPy5hYm9ydEVhcmx5LFxuICAgIGFib3J0UGlwZUVhcmx5OiBpbmZvPy5hYm9ydFBpcGVFYXJseVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvZXhlY3V0ZVBpcGUvZXhlY3V0ZVBpcGUudHNcbmZ1bmN0aW9uIGV4ZWN1dGVQaXBlKGlucHV0LCBwaXBlLCBwYXJzZUluZm8sIHJlYXNvbikge1xuICBpZiAoIXBpcGUgfHwgIXBpcGUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9XG4gIGxldCBwaXBlSW5mbztcbiAgbGV0IGlzc3VlcztcbiAgbGV0IG91dHB1dCA9IGlucHV0O1xuICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBwaXBlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYWN0aW9uKG91dHB1dCk7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZSkge1xuICAgICAgcGlwZUluZm8gPSBwaXBlSW5mbyB8fCBnZXRQaXBlSW5mbyhwYXJzZUluZm8sIHJlYXNvbik7XG4gICAgICBjb25zdCBpc3N1ZSA9IGdldElzc3VlKHBpcGVJbmZvLCByZXN1bHQuaXNzdWUpO1xuICAgICAgaXNzdWVzID8gaXNzdWVzLnB1c2goaXNzdWUpIDogaXNzdWVzID0gW2lzc3VlXTtcbiAgICAgIGlmIChwaXBlSW5mby5hYm9ydEVhcmx5IHx8IHBpcGVJbmZvLmFib3J0UGlwZUVhcmx5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSByZXN1bHQub3V0cHV0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNzdWVzID8geyBpc3N1ZXMgfSA6IHsgb3V0cHV0IH07XG59XG5cbi8vIHNyYy91dGlscy9leGVjdXRlUGlwZS9leGVjdXRlUGlwZUFzeW5jLnRzXG5hc3luYyBmdW5jdGlvbiBleGVjdXRlUGlwZUFzeW5jKGlucHV0LCBwaXBlLCBwYXJzZUluZm8sIHJlYXNvbikge1xuICBpZiAoIXBpcGUgfHwgIXBpcGUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9XG4gIGxldCBwaXBlSW5mbztcbiAgbGV0IGlzc3VlcztcbiAgbGV0IG91dHB1dCA9IGlucHV0O1xuICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBwaXBlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWN0aW9uKG91dHB1dCk7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZSkge1xuICAgICAgcGlwZUluZm8gPSBwaXBlSW5mbyB8fCBnZXRQaXBlSW5mbyhwYXJzZUluZm8sIHJlYXNvbik7XG4gICAgICBjb25zdCBpc3N1ZSA9IGdldElzc3VlKHBpcGVJbmZvLCByZXN1bHQuaXNzdWUpO1xuICAgICAgaXNzdWVzID8gaXNzdWVzLnB1c2goaXNzdWUpIDogaXNzdWVzID0gW2lzc3VlXTtcbiAgICAgIGlmIChwaXBlSW5mby5hYm9ydEVhcmx5IHx8IHBpcGVJbmZvLmFib3J0UGlwZUVhcmx5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSByZXN1bHQub3V0cHV0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNzdWVzID8geyBpc3N1ZXMgfSA6IHsgb3V0cHV0IH07XG59XG5cbi8vIHNyYy91dGlscy9nZXREZWZhdWx0QXJncy9nZXREZWZhdWx0QXJncy50c1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEFyZ3MoYXJnMSwgYXJnMikge1xuICByZXR1cm4gIWFyZzEgfHwgdHlwZW9mIGFyZzEgPT09IFwic3RyaW5nXCIgPyBbYXJnMSwgYXJnMl0gOiBbdm9pZCAwLCBhcmcxXTtcbn1cblxuLy8gc3JjL3V0aWxzL2dldElzc3Vlcy9nZXRJc3N1ZXMudHNcbmZ1bmN0aW9uIGdldElzc3VlcyhpbmZvLCByZWFzb24sIHZhbGlkYXRpb24sIG1lc3NhZ2UsIGlucHV0LCBpc3N1ZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBpc3N1ZXM6IFtcbiAgICAgIHtcbiAgICAgICAgcmVhc29uLFxuICAgICAgICB2YWxpZGF0aW9uLFxuICAgICAgICBvcmlnaW46IGluZm8/Lm9yaWdpbiB8fCBcInZhbHVlXCIsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBpc3N1ZXMsXG4gICAgICAgIGFib3J0RWFybHk6IGluZm8/LmFib3J0RWFybHksXG4gICAgICAgIGFib3J0UGlwZUVhcmx5OiBpbmZvPy5hYm9ydFBpcGVFYXJseVxuICAgICAgfVxuICAgIF1cbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2lzTHVobkFsZ28vaXNMdWhuQWxnby50c1xuZnVuY3Rpb24gaXNMdWhuQWxnbyhpbnB1dCkge1xuICBjb25zdCBudW1iZXIyID0gaW5wdXQucmVwbGFjZSgvXFxEL2csIFwiXCIpO1xuICBsZXQgbGVuZ3RoMiA9IG51bWJlcjIubGVuZ3RoO1xuICBsZXQgYml0ID0gMTtcbiAgbGV0IHN1bSA9IDA7XG4gIHdoaWxlIChsZW5ndGgyKSB7XG4gICAgY29uc3QgdmFsdWUyID0gK251bWJlcjJbLS1sZW5ndGgyXTtcbiAgICBiaXQgXj0gMTtcbiAgICBzdW0gKz0gYml0ID8gWzAsIDIsIDQsIDYsIDgsIDEsIDMsIDUsIDcsIDldW3ZhbHVlMl0gOiB2YWx1ZTI7XG4gIH1cbiAgcmV0dXJuIHN1bSAlIDEwID09PSAwO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9hbnkvYW55LnRzXG5mdW5jdGlvbiBhbnkocGlwZSA9IFtdKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJhbnlcIixcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVQaXBlKGlucHV0LCBwaXBlLCBpbmZvLCBcImFueVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2FueS9hbnlBc3luYy50c1xuZnVuY3Rpb24gYW55QXN5bmMocGlwZSA9IFtdKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJhbnlcIixcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZVBpcGVBc3luYyhpbnB1dCwgcGlwZSwgaW5mbywgXCJhbnlcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9hcnJheS9hcnJheS50c1xuZnVuY3Rpb24gYXJyYXkoaXRlbSwgYXJnMiwgYXJnMykge1xuICBjb25zdCBbZXJyb3IsIHBpcGVdID0gZ2V0RGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJhcnJheVwiLFxuICAgIC8qKlxuICAgICAqIFRoZSBhcnJheSBpdGVtIHNjaGVtYS5cbiAgICAgKi9cbiAgICBhcnJheTogeyBpdGVtIH0sXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhpbmZvLCBcInR5cGVcIiwgXCJhcnJheVwiLCBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBsZXQgaXNzdWVzO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICBmb3IgKGxldCBrZXkgPSAwOyBrZXkgPCBpbnB1dC5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZW0uX3BhcnNlKHZhbHVlMiwgaW5mbyk7XG4gICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICBzY2hlbWE6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgIH07XG4gICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZm8/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChyZXN1bHQub3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlzc3VlcyA/IHsgaXNzdWVzIH0gOiBleGVjdXRlUGlwZShvdXRwdXQsIHBpcGUsIGluZm8sIFwiYXJyYXlcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9hcnJheS9hcnJheUFzeW5jLnRzXG5mdW5jdGlvbiBhcnJheUFzeW5jKGl0ZW0sIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwiYXJyYXlcIixcbiAgICAvKipcbiAgICAgKiBUaGUgYXJyYXkgaXRlbSBzY2hlbWEuXG4gICAgICovXG4gICAgYXJyYXk6IHsgaXRlbSB9LFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhpbmZvLCBcInR5cGVcIiwgXCJhcnJheVwiLCBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBsZXQgaXNzdWVzO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgaW5wdXQubWFwKGFzeW5jICh2YWx1ZTIsIGtleSkgPT4ge1xuICAgICAgICAgIGlmICghKGluZm8/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaXRlbS5fcGFyc2UodmFsdWUyLCBpbmZvKTtcbiAgICAgICAgICAgIGlmICghKGluZm8/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgc2NoZW1hOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlcyA9IHJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmZvPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IHJlc3VsdC5vdXRwdXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgcmV0dXJuIGlzc3VlcyA/IHsgaXNzdWVzIH0gOiBleGVjdXRlUGlwZUFzeW5jKG91dHB1dCwgcGlwZSwgaW5mbywgXCJhcnJheVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2JpZ2ludC9iaWdpbnQudHNcbmZ1bmN0aW9uIGJpZ2ludChhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFtlcnJvciwgcGlwZV0gPSBnZXREZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NoZW1hIHR5cGUuXG4gICAgICovXG4gICAgc2NoZW1hOiBcImJpZ2ludFwiLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoXG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgICBcInR5cGVcIixcbiAgICAgICAgICBcImJpZ2ludFwiLFxuICAgICAgICAgIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGVjdXRlUGlwZShpbnB1dCwgcGlwZSwgaW5mbywgXCJiaWdpbnRcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9iaWdpbnQvYmlnaW50QXN5bmMudHNcbmZ1bmN0aW9uIGJpZ2ludEFzeW5jKGFyZzEsIGFyZzIpIHtcbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwiYmlnaW50XCIsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJiaWdpbnRcIikge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgICAgXCJiaWdpbnRcIixcbiAgICAgICAgICBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhlY3V0ZVBpcGVBc3luYyhpbnB1dCwgcGlwZSwgaW5mbywgXCJiaWdpbnRcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ibG9iL2Jsb2IudHNcbmZ1bmN0aW9uIGJsb2IoYXJnMSwgYXJnMikge1xuICBjb25zdCBbZXJyb3IsIHBpcGVdID0gZ2V0RGVmYXVsdEFyZ3MoYXJnMSwgYXJnMik7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJibG9iXCIsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhpbmZvLCBcInR5cGVcIiwgXCJibG9iXCIsIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGVjdXRlUGlwZShpbnB1dCwgcGlwZSwgaW5mbywgXCJibG9iXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYmxvYi9ibG9iQXN5bmMudHNcbmZ1bmN0aW9uIGJsb2JBc3luYyhhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFtlcnJvciwgcGlwZV0gPSBnZXREZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NoZW1hIHR5cGUuXG4gICAgICovXG4gICAgc2NoZW1hOiBcImJsb2JcIixcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoaW5mbywgXCJ0eXBlXCIsIFwiYmxvYlwiLCBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhlY3V0ZVBpcGVBc3luYyhpbnB1dCwgcGlwZSwgaW5mbywgXCJibG9iXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYm9vbGVhbi9ib29sZWFuLnRzXG5mdW5jdGlvbiBib29sZWFuKGFyZzEsIGFyZzIpIHtcbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwiYm9vbGVhblwiLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgICAgXCJib29sZWFuXCIsXG4gICAgICAgICAgZXJyb3IgfHwgXCJJbnZhbGlkIHR5cGVcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4ZWN1dGVQaXBlKGlucHV0LCBwaXBlLCBpbmZvLCBcImJvb2xlYW5cIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ib29sZWFuL2Jvb2xlYW5Bc3luYy50c1xuZnVuY3Rpb24gYm9vbGVhbkFzeW5jKGFyZzEsIGFyZzIpIHtcbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwiYm9vbGVhblwiLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoXG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgICBcInR5cGVcIixcbiAgICAgICAgICBcImJvb2xlYW5cIixcbiAgICAgICAgICBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhlY3V0ZVBpcGVBc3luYyhpbnB1dCwgcGlwZSwgaW5mbywgXCJib29sZWFuXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvZGF0ZS9kYXRlLnRzXG5mdW5jdGlvbiBkYXRlKGFyZzEsIGFyZzIpIHtcbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwiZGF0ZVwiLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoaW5mbywgXCJ0eXBlXCIsIFwiZGF0ZVwiLCBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhlY3V0ZVBpcGUoaW5wdXQsIHBpcGUsIGluZm8sIFwiZGF0ZVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2RhdGUvZGF0ZUFzeW5jLnRzXG5mdW5jdGlvbiBkYXRlQXN5bmMoYXJnMSwgYXJnMikge1xuICBjb25zdCBbZXJyb3IsIHBpcGVdID0gZ2V0RGVmYXVsdEFyZ3MoYXJnMSwgYXJnMik7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJkYXRlXCIsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKGluZm8sIFwidHlwZVwiLCBcImRhdGVcIiwgZXJyb3IgfHwgXCJJbnZhbGlkIHR5cGVcIiwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4ZWN1dGVQaXBlQXN5bmMoaW5wdXQsIHBpcGUsIGluZm8sIFwiZGF0ZVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2VudW1UeXBlL2VudW1UeXBlLnRzXG5mdW5jdGlvbiBlbnVtVHlwZShlbnVtVmFsdWUsIGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJlbnVtXCIsXG4gICAgLyoqXG4gICAgICogVGhlIGVudW0gdmFsdWUuXG4gICAgICovXG4gICAgZW51bTogZW51bVZhbHVlLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIWVudW1WYWx1ZS5pbmNsdWRlcyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhpbmZvLCBcInR5cGVcIiwgXCJlbnVtXCIsIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2VudW1UeXBlL2VudW1UeXBlQXN5bmMudHNcbmZ1bmN0aW9uIGVudW1UeXBlQXN5bmMoZW51bVZhbHVlLCBlcnJvcikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwiZW51bVwiLFxuICAgIC8qKlxuICAgICAqIFRoZSBlbnVtIHZhbHVlLlxuICAgICAqL1xuICAgIGVudW06IGVudW1WYWx1ZSxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIWVudW1WYWx1ZS5pbmNsdWRlcyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhpbmZvLCBcInR5cGVcIiwgXCJlbnVtXCIsIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2luc3RhbmNlL2luc3RhbmNlLnRzXG5mdW5jdGlvbiBpbnN0YW5jZShvZiwgYXJnMiwgYXJnMykge1xuICBjb25zdCBbZXJyb3IsIHBpcGVdID0gZ2V0RGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJpbnN0YW5jZVwiLFxuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyBvZiB0aGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY2xhc3M6IG9mLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIG9mKSkge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgICAgXCJpbnN0YW5jZVwiLFxuICAgICAgICAgIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGVjdXRlUGlwZShpbnB1dCwgcGlwZSwgaW5mbywgXCJpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2luc3RhbmNlL2luc3RhbmNlQXN5bmMudHNcbmZ1bmN0aW9uIGluc3RhbmNlQXN5bmMob2YsIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwiaW5zdGFuY2VcIixcbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3Mgb2YgdGhlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNsYXNzOiBvZixcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIG9mKSkge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgICAgXCJpbnN0YW5jZVwiLFxuICAgICAgICAgIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGVjdXRlUGlwZUFzeW5jKGlucHV0LCBwaXBlLCBpbmZvLCBcImluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbGl0ZXJhbC9saXRlcmFsLnRzXG5mdW5jdGlvbiBsaXRlcmFsKGxpdGVyYWwyLCBlcnJvcikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwibGl0ZXJhbFwiLFxuICAgIC8qKlxuICAgICAqIFRoZSBsaXRlcmFsIHZhbHVlLlxuICAgICAqL1xuICAgIGxpdGVyYWw6IGxpdGVyYWwyLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoaW5wdXQgIT09IGxpdGVyYWwyKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoXG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgICBcInR5cGVcIixcbiAgICAgICAgICBcImxpdGVyYWxcIixcbiAgICAgICAgICBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9saXRlcmFsL2xpdGVyYWxBc3luYy50c1xuZnVuY3Rpb24gbGl0ZXJhbEFzeW5jKGxpdGVyYWwyLCBlcnJvcikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwibGl0ZXJhbFwiLFxuICAgIC8qKlxuICAgICAqIFRoZSBsaXRlcmFsIHZhbHVlLlxuICAgICAqL1xuICAgIGxpdGVyYWw6IGxpdGVyYWwyLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmIChpbnB1dCAhPT0gbGl0ZXJhbDIpIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhcbiAgICAgICAgICBpbmZvLFxuICAgICAgICAgIFwidHlwZVwiLFxuICAgICAgICAgIFwibGl0ZXJhbFwiLFxuICAgICAgICAgIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL21hcC9tYXAudHNcbmZ1bmN0aW9uIG1hcChrZXksIHZhbHVlMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBbZXJyb3IsIHBpcGVdID0gZ2V0RGVmYXVsdEFyZ3MoYXJnMywgYXJnNCk7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJtYXBcIixcbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIGtleSBhbmQgdmFsdWUgc2NoZW1hLlxuICAgICAqL1xuICAgIG1hcDogeyBrZXksIHZhbHVlOiB2YWx1ZTIgfSxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBNYXApKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoaW5mbywgXCJ0eXBlXCIsIFwibWFwXCIsIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIGxldCBpc3N1ZXM7XG4gICAgICBjb25zdCBvdXRwdXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCBbaW5wdXRLZXksIGlucHV0VmFsdWVdIG9mIGlucHV0LmVudHJpZXMoKSkge1xuICAgICAgICBsZXQgcGF0aEl0ZW07XG4gICAgICAgIGNvbnN0IGtleVJlc3VsdCA9IGtleS5fcGFyc2UoaW5wdXRLZXksIHtcbiAgICAgICAgICBvcmlnaW46IFwia2V5XCIsXG4gICAgICAgICAgYWJvcnRFYXJseTogaW5mbz8uYWJvcnRFYXJseSxcbiAgICAgICAgICBhYm9ydFBpcGVFYXJseTogaW5mbz8uYWJvcnRQaXBlRWFybHlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChrZXlSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICBzY2hlbWE6IFwibWFwXCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBrZXlSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgaXNzdWVzID0ga2V5UmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZm8/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZVJlc3VsdCA9IHZhbHVlMi5fcGFyc2UoaW5wdXRWYWx1ZSwgaW5mbyk7XG4gICAgICAgIGlmICh2YWx1ZVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICBwYXRoSXRlbSA9IHBhdGhJdGVtIHx8IHtcbiAgICAgICAgICAgIHNjaGVtYTogXCJtYXBcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlUmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgIGlzc3VlcyA9IHZhbHVlUmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZm8/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtleVJlc3VsdC5pc3N1ZXMgJiYgIXZhbHVlUmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgIG91dHB1dC5zZXQoa2V5UmVzdWx0Lm91dHB1dCwgdmFsdWVSZXN1bHQub3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlzc3VlcyA/IHsgaXNzdWVzIH0gOiBleGVjdXRlUGlwZShvdXRwdXQsIHBpcGUsIGluZm8sIFwibWFwXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbWFwL21hcEFzeW5jLnRzXG5mdW5jdGlvbiBtYXBBc3luYyhrZXksIHZhbHVlMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBbZXJyb3IsIHBpcGVdID0gZ2V0RGVmYXVsdEFyZ3MoYXJnMywgYXJnNCk7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJtYXBcIixcbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIGtleSBhbmQgdmFsdWUgc2NoZW1hLlxuICAgICAqL1xuICAgIG1hcDogeyBrZXksIHZhbHVlOiB2YWx1ZTIgfSxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhpbmZvLCBcInR5cGVcIiwgXCJtYXBcIiwgZXJyb3IgfHwgXCJJbnZhbGlkIHR5cGVcIiwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0cHV0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGxldCBpc3N1ZXM7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgQXJyYXkuZnJvbShpbnB1dC5lbnRyaWVzKCkpLm1hcChhc3luYyAoW2lucHV0S2V5LCBpbnB1dFZhbHVlXSkgPT4ge1xuICAgICAgICAgIGxldCBwYXRoSXRlbTtcbiAgICAgICAgICBjb25zdCBba2V5UmVzdWx0LCB2YWx1ZVJlc3VsdF0gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgeyBzY2hlbWE6IGtleSwgdmFsdWU6IGlucHV0S2V5LCBvcmlnaW46IFwia2V5XCIgfSxcbiAgICAgICAgICAgICAgeyBzY2hlbWE6IHZhbHVlMiwgdmFsdWU6IGlucHV0VmFsdWUsIG9yaWdpbjogXCJ2YWx1ZVwiIH1cbiAgICAgICAgICAgIF0ubWFwKGFzeW5jICh7IHNjaGVtYSwgdmFsdWU6IHZhbHVlMywgb3JpZ2luIH0pID0+IHtcbiAgICAgICAgICAgICAgaWYgKCEoaW5mbz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZSh2YWx1ZTMsIHtcbiAgICAgICAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgICAgICAgIGFib3J0RWFybHk6IGluZm8/LmFib3J0RWFybHksXG4gICAgICAgICAgICAgICAgICBhYm9ydFBpcGVFYXJseTogaW5mbz8uYWJvcnRQaXBlRWFybHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIShpbmZvPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhJdGVtID0gcGF0aEl0ZW0gfHwge1xuICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogXCJtYXBcIixcbiAgICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICBrZXk6IGlucHV0S2V5LFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGlzc3VlcyA9IHJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLmNhdGNoKCgpID0+IFtdKTtcbiAgICAgICAgICBpZiAoa2V5UmVzdWx0ICYmIHZhbHVlUmVzdWx0KSB7XG4gICAgICAgICAgICBvdXRwdXQuc2V0KGtleVJlc3VsdC5vdXRwdXQsIHZhbHVlUmVzdWx0Lm91dHB1dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBpc3N1ZXMgPyB7IGlzc3VlcyB9IDogZXhlY3V0ZVBpcGVBc3luYyhpbnB1dCwgcGlwZSwgaW5mbywgXCJtYXBcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9uYW4vbmFuLnRzXG5mdW5jdGlvbiBuYW4oZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NoZW1hIHR5cGUuXG4gICAgICovXG4gICAgc2NoZW1hOiBcIm5hblwiLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIU51bWJlci5pc05hTihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhpbmZvLCBcInR5cGVcIiwgXCJuYW5cIiwgZXJyb3IgfHwgXCJJbnZhbGlkIHR5cGVcIiwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbmFuL25hbkFzeW5jLnRzXG5mdW5jdGlvbiBuYW5Bc3luYyhlcnJvcikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwibmFuXCIsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoaW5mbywgXCJ0eXBlXCIsIFwibmFuXCIsIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25hdGl2ZUVudW0vbmF0aXZlRW51bS50c1xuZnVuY3Rpb24gbmF0aXZlRW51bShuYXRpdmVFbnVtMiwgZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NoZW1hIHR5cGUuXG4gICAgICovXG4gICAgc2NoZW1hOiBcIm5hdGl2ZV9lbnVtXCIsXG4gICAgLyoqXG4gICAgICogVGhlIG5hdGl2ZSBlbnVtIHZhbHVlLlxuICAgICAqL1xuICAgIG5hdGl2ZUVudW06IG5hdGl2ZUVudW0yLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIU9iamVjdC52YWx1ZXMobmF0aXZlRW51bTIpLmluY2x1ZGVzKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgICAgXCJuYXRpdmVfZW51bVwiLFxuICAgICAgICAgIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25hdGl2ZUVudW0vbmF0aXZlRW51bUFzeW5jLnRzXG5mdW5jdGlvbiBuYXRpdmVFbnVtQXN5bmMobmF0aXZlRW51bTIsIGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJuYXRpdmVfZW51bVwiLFxuICAgIC8qKlxuICAgICAqIFRoZSBuYXRpdmUgZW51bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBuYXRpdmVFbnVtOiBuYXRpdmVFbnVtMixcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIU9iamVjdC52YWx1ZXMobmF0aXZlRW51bTIpLmluY2x1ZGVzKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgICAgXCJuYXRpdmVfZW51bVwiLFxuICAgICAgICAgIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25ldmVyL25ldmVyLnRzXG5mdW5jdGlvbiBuZXZlcihlcnJvcikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwibmV2ZXJcIixcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgcmV0dXJuIGdldElzc3VlcyhpbmZvLCBcInR5cGVcIiwgXCJuZXZlclwiLCBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLCBpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9uZXZlci9uZXZlckFzeW5jLnRzXG5mdW5jdGlvbiBuZXZlckFzeW5jKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJuZXZlclwiLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIHJldHVybiBnZXRJc3N1ZXMoaW5mbywgXCJ0eXBlXCIsIFwibmV2ZXJcIiwgZXJyb3IgfHwgXCJJbnZhbGlkIHR5cGVcIiwgaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uTnVsbGFibGUvbm9uTnVsbGFibGUudHNcbmZ1bmN0aW9uIG5vbk51bGxhYmxlKHdyYXBwZWQsIGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJub25fbnVsbGFibGVcIixcbiAgICAvKipcbiAgICAgKiBUaGUgd3JhcHBlZCBzY2hlbWEuXG4gICAgICovXG4gICAgd3JhcHBlZCxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoXG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgICBcInR5cGVcIixcbiAgICAgICAgICBcIm5vbl9udWxsYWJsZVwiLFxuICAgICAgICAgIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVkLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ub25OdWxsYWJsZS9ub25OdWxsYWJsZUFzeW5jLnRzXG5mdW5jdGlvbiBub25OdWxsYWJsZUFzeW5jKHdyYXBwZWQsIGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJub25fbnVsbGFibGVcIixcbiAgICAvKipcbiAgICAgKiBUaGUgd3JhcHBlZCBzY2hlbWEuXG4gICAgICovXG4gICAgd3JhcHBlZCxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhcbiAgICAgICAgICBpbmZvLFxuICAgICAgICAgIFwidHlwZVwiLFxuICAgICAgICAgIFwibm9uX251bGxhYmxlXCIsXG4gICAgICAgICAgZXJyb3IgfHwgXCJJbnZhbGlkIHR5cGVcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZWQuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxpc2gvbm9uTnVsbGlzaC50c1xuZnVuY3Rpb24gbm9uTnVsbGlzaCh3cmFwcGVkLCBlcnJvcikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwibm9uX251bGxpc2hcIixcbiAgICAvKipcbiAgICAgKiBUaGUgd3JhcHBlZCBzY2hlbWEuXG4gICAgICovXG4gICAgd3JhcHBlZCxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhcbiAgICAgICAgICBpbmZvLFxuICAgICAgICAgIFwidHlwZVwiLFxuICAgICAgICAgIFwibm9uX251bGxpc2hcIixcbiAgICAgICAgICBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlZC5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uTnVsbGlzaC9ub25OdWxsaXNoQXN5bmMudHNcbmZ1bmN0aW9uIG5vbk51bGxpc2hBc3luYyh3cmFwcGVkLCBlcnJvcikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwibm9uX251bGxpc2hcIixcbiAgICAvKipcbiAgICAgKiBUaGUgd3JhcHBlZCBzY2hlbWEuXG4gICAgICovXG4gICAgd3JhcHBlZCxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgICAgXCJub25fbnVsbGlzaFwiLFxuICAgICAgICAgIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVkLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ub25PcHRpb25hbC9ub25PcHRpb25hbC50c1xuZnVuY3Rpb24gbm9uT3B0aW9uYWwod3JhcHBlZCwgZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NoZW1hIHR5cGUuXG4gICAgICovXG4gICAgc2NoZW1hOiBcIm5vbl9vcHRpb25hbFwiLFxuICAgIC8qKlxuICAgICAqIFRoZSB3cmFwcGVkIHNjaGVtYS5cbiAgICAgKi9cbiAgICB3cmFwcGVkLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgICAgXCJub25fb3B0aW9uYWxcIixcbiAgICAgICAgICBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlZC5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uT3B0aW9uYWwvbm9uT3B0aW9uYWxBc3luYy50c1xuZnVuY3Rpb24gbm9uT3B0aW9uYWxBc3luYyh3cmFwcGVkLCBlcnJvcikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwibm9uX29wdGlvbmFsXCIsXG4gICAgLyoqXG4gICAgICogVGhlIHdyYXBwZWQgc2NoZW1hLlxuICAgICAqL1xuICAgIHdyYXBwZWQsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhcbiAgICAgICAgICBpbmZvLFxuICAgICAgICAgIFwidHlwZVwiLFxuICAgICAgICAgIFwibm9uX29wdGlvbmFsXCIsXG4gICAgICAgICAgZXJyb3IgfHwgXCJJbnZhbGlkIHR5cGVcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZWQuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGxhYmxlL251bGxhYmxlLnRzXG5mdW5jdGlvbiBudWxsYWJsZSh3cmFwcGVkKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJudWxsYWJsZVwiLFxuICAgIC8qKlxuICAgICAqIFRoZSB3cmFwcGVkIHNjaGVtYS5cbiAgICAgKi9cbiAgICB3cmFwcGVkLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZWQuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGxhYmxlL251bGxhYmxlQXN5bmMudHNcbmZ1bmN0aW9uIG51bGxhYmxlQXN5bmMod3JhcHBlZCkge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwibnVsbGFibGVcIixcbiAgICAvKipcbiAgICAgKiBUaGUgd3JhcHBlZCBzY2hlbWEuXG4gICAgICovXG4gICAgd3JhcHBlZCxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZWQuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGxpc2gvbnVsbGlzaC50c1xuZnVuY3Rpb24gbnVsbGlzaCh3cmFwcGVkKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJudWxsaXNoXCIsXG4gICAgLyoqXG4gICAgICogVGhlIHdyYXBwZWQgc2NoZW1hLlxuICAgICAqL1xuICAgIHdyYXBwZWQsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVkLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsaXNoL251bGxpc2hBc3luYy50c1xuZnVuY3Rpb24gbnVsbGlzaEFzeW5jKHdyYXBwZWQpIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NoZW1hIHR5cGUuXG4gICAgICovXG4gICAgc2NoZW1hOiBcIm51bGxpc2hcIixcbiAgICAvKipcbiAgICAgKiBUaGUgd3JhcHBlZCBzY2hlbWEuXG4gICAgICovXG4gICAgd3JhcHBlZCxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlZC5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVsbFR5cGUvbnVsbFR5cGUudHNcbmZ1bmN0aW9uIG51bGxUeXBlKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJudWxsXCIsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmIChpbnB1dCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKGluZm8sIFwidHlwZVwiLCBcIm51bGxcIiwgZXJyb3IgfHwgXCJJbnZhbGlkIHR5cGVcIiwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVsbFR5cGUvbnVsbFR5cGVBc3luYy50c1xuZnVuY3Rpb24gbnVsbFR5cGVBc3luYyhlcnJvcikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwibnVsbFwiLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmIChpbnB1dCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKGluZm8sIFwidHlwZVwiLCBcIm51bGxcIiwgZXJyb3IgfHwgXCJJbnZhbGlkIHR5cGVcIiwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVtYmVyL251bWJlci50c1xuZnVuY3Rpb24gbnVtYmVyKGFyZzEsIGFyZzIpIHtcbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwibnVtYmVyXCIsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhcbiAgICAgICAgICBpbmZvLFxuICAgICAgICAgIFwidHlwZVwiLFxuICAgICAgICAgIFwibnVtYmVyXCIsXG4gICAgICAgICAgZXJyb3IgfHwgXCJJbnZhbGlkIHR5cGVcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4ZWN1dGVQaXBlKGlucHV0LCBwaXBlLCBpbmZvLCBcIm51bWJlclwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bWJlci9udW1iZXJBc3luYy50c1xuZnVuY3Rpb24gbnVtYmVyQXN5bmMoYXJnMSwgYXJnMikge1xuICBjb25zdCBbZXJyb3IsIHBpcGVdID0gZ2V0RGVmYXVsdEFyZ3MoYXJnMSwgYXJnMik7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJudW1iZXJcIixcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoXG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgICBcInR5cGVcIixcbiAgICAgICAgICBcIm51bWJlclwiLFxuICAgICAgICAgIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGVjdXRlUGlwZUFzeW5jKGlucHV0LCBwaXBlLCBpbmZvLCBcIm51bWJlclwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL29iamVjdC9vYmplY3QudHNcbmZ1bmN0aW9uIG9iamVjdChvYmplY3QyLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFtlcnJvciwgcGlwZV0gPSBnZXREZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgbGV0IGNhY2hlZEVudHJpZXM7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJvYmplY3RcIixcbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0IHNjaGVtYS5cbiAgICAgKi9cbiAgICBvYmplY3Q6IG9iamVjdDIsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoXG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgICBcInR5cGVcIixcbiAgICAgICAgICBcIm9iamVjdFwiLFxuICAgICAgICAgIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhY2hlZEVudHJpZXMgPSBjYWNoZWRFbnRyaWVzIHx8IE9iamVjdC5lbnRyaWVzKG9iamVjdDIpO1xuICAgICAgbGV0IGlzc3VlcztcbiAgICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBba2V5LCBzY2hlbWFdIG9mIGNhY2hlZEVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9wYXJzZSh2YWx1ZTIsIGluZm8pO1xuICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgc2NoZW1hOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5mbz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlzc3VlcyA/IHsgaXNzdWVzIH0gOiBleGVjdXRlUGlwZShcbiAgICAgICAgb3V0cHV0LFxuICAgICAgICBwaXBlLFxuICAgICAgICBpbmZvLFxuICAgICAgICBcIm9iamVjdFwiXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb2JqZWN0L29iamVjdEFzeW5jLnRzXG5mdW5jdGlvbiBvYmplY3RBc3luYyhvYmplY3QyLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFtlcnJvciwgcGlwZV0gPSBnZXREZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgbGV0IGNhY2hlZEVudHJpZXM7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJvYmplY3RcIixcbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0IHNjaGVtYS5cbiAgICAgKi9cbiAgICBvYmplY3Q6IG9iamVjdDIsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhcbiAgICAgICAgICBpbmZvLFxuICAgICAgICAgIFwidHlwZVwiLFxuICAgICAgICAgIFwib2JqZWN0XCIsXG4gICAgICAgICAgZXJyb3IgfHwgXCJJbnZhbGlkIHR5cGVcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2FjaGVkRW50cmllcyA9IGNhY2hlZEVudHJpZXMgfHwgT2JqZWN0LmVudHJpZXMob2JqZWN0Mik7XG4gICAgICBsZXQgaXNzdWVzO1xuICAgICAgY29uc3Qgb3V0cHV0ID0ge307XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgY2FjaGVkRW50cmllcy5tYXAoYXN5bmMgKFtrZXksIHNjaGVtYV0pID0+IHtcbiAgICAgICAgICBpZiAoIShpbmZvPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY2hlbWEuX3BhcnNlKHZhbHVlMiwgaW5mbyk7XG4gICAgICAgICAgICBpZiAoIShpbmZvPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgIHNjaGVtYTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZm8/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICByZXR1cm4gaXNzdWVzID8geyBpc3N1ZXMgfSA6IGV4ZWN1dGVQaXBlQXN5bmMoXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgcGlwZSxcbiAgICAgICAgaW5mbyxcbiAgICAgICAgXCJvYmplY3RcIlxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL29wdGlvbmFsL29wdGlvbmFsLnRzXG5mdW5jdGlvbiBvcHRpb25hbCh3cmFwcGVkKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJvcHRpb25hbFwiLFxuICAgIC8qKlxuICAgICAqIFRoZSB3cmFwcGVkIHNjaGVtYS5cbiAgICAgKi9cbiAgICB3cmFwcGVkLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlZC5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb3B0aW9uYWwvb3B0aW9uYWxBc3luYy50c1xuZnVuY3Rpb24gb3B0aW9uYWxBc3luYyh3cmFwcGVkKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJvcHRpb25hbFwiLFxuICAgIC8qKlxuICAgICAqIFRoZSB3cmFwcGVkIHNjaGVtYS5cbiAgICAgKi9cbiAgICB3cmFwcGVkLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVkLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zdHJpbmcvc3RyaW5nLnRzXG5mdW5jdGlvbiBzdHJpbmcoYXJnMSwgYXJnMikge1xuICBjb25zdCBbZXJyb3IsIHBpcGVdID0gZ2V0RGVmYXVsdEFyZ3MoYXJnMSwgYXJnMik7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJzdHJpbmdcIixcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgICAgXCJzdHJpbmdcIixcbiAgICAgICAgICBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhlY3V0ZVBpcGUoaW5wdXQsIHBpcGUsIGluZm8sIFwic3RyaW5nXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc3RyaW5nL3N0cmluZ0FzeW5jLnRzXG5mdW5jdGlvbiBzdHJpbmdBc3luYyhhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFtlcnJvciwgcGlwZV0gPSBnZXREZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NoZW1hIHR5cGUuXG4gICAgICovXG4gICAgc2NoZW1hOiBcInN0cmluZ1wiLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhcbiAgICAgICAgICBpbmZvLFxuICAgICAgICAgIFwidHlwZVwiLFxuICAgICAgICAgIFwic3RyaW5nXCIsXG4gICAgICAgICAgZXJyb3IgfHwgXCJJbnZhbGlkIHR5cGVcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4ZWN1dGVQaXBlQXN5bmMoaW5wdXQsIHBpcGUsIGluZm8sIFwic3RyaW5nXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvcmVjb3JkL3V0aWxzL2dldFJlY29yZEFyZ3MvZ2V0UmVjb3JkQXJncy50c1xuZnVuY3Rpb24gZ2V0UmVjb3JkQXJncyhhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGlmICh0eXBlb2YgYXJnMiA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShhcmcyKSkge1xuICAgIGNvbnN0IFtlcnJvcjIsIHBpcGUyXSA9IGdldERlZmF1bHRBcmdzKGFyZzMsIGFyZzQpO1xuICAgIHJldHVybiBbYXJnMSwgYXJnMiwgZXJyb3IyLCBwaXBlMl07XG4gIH1cbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKFxuICAgIGFyZzIsXG4gICAgYXJnM1xuICApO1xuICByZXR1cm4gW3N0cmluZygpLCBhcmcxLCBlcnJvciwgcGlwZV07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3JlY29yZC92YWx1ZXMudHNcbnZhciBCTE9DS0VEX0tFWVMgPSBbXCJfX3Byb3RvX19cIiwgXCJwcm90b3R5cGVcIiwgXCJjb25zdHJ1Y3RvclwiXTtcblxuLy8gc3JjL3NjaGVtYXMvcmVjb3JkL3JlY29yZC50c1xuZnVuY3Rpb24gcmVjb3JkKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW2tleSwgdmFsdWUyLCBlcnJvciwgcGlwZV0gPSBnZXRSZWNvcmRBcmdzKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwicmVjb3JkXCIsXG4gICAgLyoqXG4gICAgICogVGhlIHJlY29yZCBrZXkgYW5kIHZhbHVlIHNjaGVtYS5cbiAgICAgKi9cbiAgICByZWNvcmQ6IHsga2V5LCB2YWx1ZTogdmFsdWUyIH0sXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoXG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgICBcInR5cGVcIixcbiAgICAgICAgICBcInJlY29yZFwiLFxuICAgICAgICAgIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGxldCBpc3N1ZXM7XG4gICAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgW2lucHV0S2V5LCBpbnB1dFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhpbnB1dCkpIHtcbiAgICAgICAgaWYgKCFCTE9DS0VEX0tFWVMuaW5jbHVkZXMoaW5wdXRLZXkpKSB7XG4gICAgICAgICAgbGV0IHBhdGhJdGVtO1xuICAgICAgICAgIGNvbnN0IGtleVJlc3VsdCA9IGtleS5fcGFyc2UoaW5wdXRLZXksIHtcbiAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgIGFib3J0RWFybHk6IGluZm8/LmFib3J0RWFybHksXG4gICAgICAgICAgICBhYm9ydFBpcGVFYXJseTogaW5mbz8uYWJvcnRQaXBlRWFybHlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoa2V5UmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHNjaGVtYTogXCJyZWNvcmRcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBrZXlSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaXNzdWVzID0ga2V5UmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmZvPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2YWx1ZVJlc3VsdCA9IHZhbHVlMi5fcGFyc2UoaW5wdXRWYWx1ZSwgaW5mbyk7XG4gICAgICAgICAgaWYgKHZhbHVlUmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgcGF0aEl0ZW0gPSBwYXRoSXRlbSB8fCB7XG4gICAgICAgICAgICAgIHNjaGVtYTogXCJyZWNvcmRcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICBpc3N1ZXMgPSB2YWx1ZVJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5mbz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFrZXlSZXN1bHQuaXNzdWVzICYmICF2YWx1ZVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIG91dHB1dFtrZXlSZXN1bHQub3V0cHV0XSA9IHZhbHVlUmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpc3N1ZXMgPyB7IGlzc3VlcyB9IDogZXhlY3V0ZVBpcGUoXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgcGlwZSxcbiAgICAgICAgaW5mbyxcbiAgICAgICAgXCJyZWNvcmRcIlxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3JlY29yZC9yZWNvcmRBc3luYy50c1xuZnVuY3Rpb24gcmVjb3JkQXN5bmMoYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBba2V5LCB2YWx1ZTIsIGVycm9yLCBwaXBlXSA9IGdldFJlY29yZEFyZ3MoYXJnMSwgYXJnMiwgYXJnMywgYXJnNCk7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJyZWNvcmRcIixcbiAgICAvKipcbiAgICAgKiBUaGUgcmVjb3JkIGtleSBhbmQgdmFsdWUgc2NoZW1hLlxuICAgICAqL1xuICAgIHJlY29yZDogeyBrZXksIHZhbHVlOiB2YWx1ZTIgfSxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgICAgXCJyZWNvcmRcIixcbiAgICAgICAgICBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBsZXQgaXNzdWVzO1xuICAgICAgY29uc3Qgb3V0cHV0ID0ge307XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgLy8gTm90ZTogYE9iamVjdC5lbnRyaWVzKC4uLilgIGNvbnZlcnRzIGVhY2gga2V5IHRvIGEgc3RyaW5nXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGlucHV0KS5tYXAoYXN5bmMgKFtpbnB1dEtleSwgaW5wdXRWYWx1ZV0pID0+IHtcbiAgICAgICAgICBpZiAoIUJMT0NLRURfS0VZUy5pbmNsdWRlcyhpbnB1dEtleSkpIHtcbiAgICAgICAgICAgIGxldCBwYXRoSXRlbTtcbiAgICAgICAgICAgIGNvbnN0IFtrZXlSZXN1bHQsIHZhbHVlUmVzdWx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgeyBzY2hlbWE6IGtleSwgdmFsdWU6IGlucHV0S2V5LCBvcmlnaW46IFwia2V5XCIgfSxcbiAgICAgICAgICAgICAgICB7IHNjaGVtYTogdmFsdWUyLCB2YWx1ZTogaW5wdXRWYWx1ZSwgb3JpZ2luOiBcInZhbHVlXCIgfVxuICAgICAgICAgICAgICBdLm1hcChhc3luYyAoeyBzY2hlbWEsIHZhbHVlOiB2YWx1ZTMsIG9yaWdpbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoaW5mbz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY2hlbWEuX3BhcnNlKHZhbHVlMywge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIGFib3J0RWFybHk6IGluZm8/LmFib3J0RWFybHksXG4gICAgICAgICAgICAgICAgICAgIGFib3J0UGlwZUVhcmx5OiBpbmZvPy5hYm9ydFBpcGVFYXJseVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShpbmZvPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXRoSXRlbSA9IHBhdGhJdGVtIHx8IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogXCJyZWNvcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICkuY2F0Y2goKCkgPT4gW10pO1xuICAgICAgICAgICAgaWYgKGtleVJlc3VsdCAmJiB2YWx1ZVJlc3VsdCkge1xuICAgICAgICAgICAgICBvdXRwdXRba2V5UmVzdWx0Lm91dHB1dF0gPSB2YWx1ZVJlc3VsdC5vdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBpc3N1ZXMgPyB7IGlzc3VlcyB9IDogZXhlY3V0ZVBpcGVBc3luYyhcbiAgICAgICAgb3V0cHV0LFxuICAgICAgICBwaXBlLFxuICAgICAgICBpbmZvLFxuICAgICAgICBcInJlY29yZFwiXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvcmVjdXJzaXZlL3JlY3Vyc2l2ZS50c1xuZnVuY3Rpb24gcmVjdXJzaXZlKGdldHRlcikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwicmVjdXJzaXZlXCIsXG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSBnZXR0ZXIuXG4gICAgICovXG4gICAgZ2V0dGVyLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICByZXR1cm4gZ2V0dGVyKCkuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3JlY3Vyc2l2ZS9yZWN1cnNpdmVBc3luYy50c1xuZnVuY3Rpb24gcmVjdXJzaXZlQXN5bmMoZ2V0dGVyKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJyZWN1cnNpdmVcIixcbiAgICAvKipcbiAgICAgKiBUaGUgc2NoZW1hIGdldHRlci5cbiAgICAgKi9cbiAgICBnZXR0ZXIsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgcmV0dXJuIGdldHRlcigpLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zZXQvc2V0LnRzXG5mdW5jdGlvbiBzZXQodmFsdWUyLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFtlcnJvciwgcGlwZV0gPSBnZXREZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NoZW1hIHR5cGUuXG4gICAgICovXG4gICAgc2NoZW1hOiBcInNldFwiLFxuICAgIC8qKlxuICAgICAqIFRoZSBzZXQgdmFsdWUgc2NoZW1hLlxuICAgICAqL1xuICAgIHNldDogeyB2YWx1ZTogdmFsdWUyIH0sXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgU2V0KSkge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKGluZm8sIFwidHlwZVwiLCBcInNldFwiLCBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBsZXQga2V5ID0gMDtcbiAgICAgIGxldCBpc3N1ZXM7XG4gICAgICBjb25zdCBvdXRwdXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZm9yIChjb25zdCBpbnB1dFZhbHVlIG9mIGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlMi5fcGFyc2UoaW5wdXRWYWx1ZSwgaW5mbyk7XG4gICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICBzY2hlbWE6IFwic2V0XCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5mbz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5hZGQocmVzdWx0Lm91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAga2V5Kys7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNzdWVzID8geyBpc3N1ZXMgfSA6IGV4ZWN1dGVQaXBlKG91dHB1dCwgcGlwZSwgaW5mbywgXCJzZXRcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zZXQvc2V0QXN5bmMudHNcbmZ1bmN0aW9uIHNldEFzeW5jKHZhbHVlMiwgYXJnMiwgYXJnMykge1xuICBjb25zdCBbZXJyb3IsIHBpcGVdID0gZ2V0RGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJzZXRcIixcbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IHZhbHVlIHNjaGVtYS5cbiAgICAgKi9cbiAgICBzZXQ6IHsgdmFsdWU6IHZhbHVlMiB9LFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgU2V0KSkge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKGluZm8sIFwidHlwZVwiLCBcInNldFwiLCBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBsZXQgaXNzdWVzO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBBcnJheS5mcm9tKGlucHV0LnZhbHVlcygpKS5tYXAoYXN5bmMgKGlucHV0VmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGlmICghKGluZm8/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsdWUyLl9wYXJzZShpbnB1dFZhbHVlLCBpbmZvKTtcbiAgICAgICAgICAgIGlmICghKGluZm8/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgc2NoZW1hOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZm8/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQocmVzdWx0Lm91dHB1dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgcmV0dXJuIGlzc3VlcyA/IHsgaXNzdWVzIH0gOiBleGVjdXRlUGlwZUFzeW5jKGlucHV0LCBwaXBlLCBpbmZvLCBcInNldFwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3NwZWNpYWwvc3BlY2lhbC50c1xuZnVuY3Rpb24gc3BlY2lhbChjaGVjaywgYXJnMiwgYXJnMykge1xuICBjb25zdCBbZXJyb3IsIHBpcGVdID0gZ2V0RGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJzcGVjaWFsXCIsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghY2hlY2soaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoXG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgICBcInR5cGVcIixcbiAgICAgICAgICBcInNwZWNpYWxcIixcbiAgICAgICAgICBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhlY3V0ZVBpcGUoaW5wdXQsIHBpcGUsIGluZm8sIFwic3BlY2lhbFwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3NwZWNpYWwvc3BlY2lhbEFzeW5jLnRzXG5mdW5jdGlvbiBzcGVjaWFsQXN5bmMoY2hlY2ssIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwic3BlY2lhbFwiLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgaXQncyBhc3luYy5cbiAgICAgKi9cbiAgICBhc3luYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghYXdhaXQgY2hlY2soaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoXG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgICBcInR5cGVcIixcbiAgICAgICAgICBcInNwZWNpYWxcIixcbiAgICAgICAgICBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhlY3V0ZVBpcGVBc3luYyhpbnB1dCwgcGlwZSwgaW5mbywgXCJzcGVjaWFsXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc3ltYm9sL3N5bWJvbC50c1xuZnVuY3Rpb24gc3ltYm9sMihlcnJvcikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwic3ltYm9sXCIsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhcbiAgICAgICAgICBpbmZvLFxuICAgICAgICAgIFwidHlwZVwiLFxuICAgICAgICAgIFwic3ltYm9sXCIsXG4gICAgICAgICAgZXJyb3IgfHwgXCJJbnZhbGlkIHR5cGVcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc3ltYm9sL3N5bWJvbEFzeW5jLnRzXG5mdW5jdGlvbiBzeW1ib2xBc3luYyhlcnJvcikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwic3ltYm9sXCIsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJzeW1ib2xcIikge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgICAgXCJzeW1ib2xcIixcbiAgICAgICAgICBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy90dXBsZS91dGlscy9nZXRUdXBsZUFyZ3MvZ2V0VHVwbGVBcmdzLnRzXG5mdW5jdGlvbiBnZXRUdXBsZUFyZ3MoYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGFyZzEgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICBjb25zdCBbZXJyb3IyLCBwaXBlMl0gPSBnZXREZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgICByZXR1cm4gW2FyZzEsIGVycm9yMiwgcGlwZTJdO1xuICB9XG4gIGNvbnN0IFtlcnJvciwgcGlwZV0gPSBnZXREZWZhdWx0QXJncyhcbiAgICBhcmcxLFxuICAgIGFyZzJcbiAgKTtcbiAgcmV0dXJuIFt2b2lkIDAsIGVycm9yLCBwaXBlXTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdHVwbGUvdHVwbGUudHNcbmZ1bmN0aW9uIHR1cGxlKGl0ZW1zLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtyZXN0LCBlcnJvciwgcGlwZV0gPSBnZXRUdXBsZUFyZ3MoYXJnMiwgYXJnMywgYXJnNCk7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJ0dXBsZVwiLFxuICAgIC8qKlxuICAgICAqIFRoZSB0dXBsZSBpdGVtcyBhbmQgcmVzdCBzY2hlbWEuXG4gICAgICovXG4gICAgdHVwbGU6IHsgaXRlbXMsIHJlc3QgfSxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAhcmVzdCAmJiBpdGVtcy5sZW5ndGggIT09IGlucHV0Lmxlbmd0aCB8fCByZXN0ICYmIGl0ZW1zLmxlbmd0aCA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKGluZm8sIFwidHlwZVwiLCBcInR1cGxlXCIsIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIGxldCBpc3N1ZXM7XG4gICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IGl0ZW1zLmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlbXNba2V5XS5fcGFyc2UodmFsdWUyLCBpbmZvKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgIHNjaGVtYTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5mbz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgZm9yIChsZXQga2V5ID0gaXRlbXMubGVuZ3RoOyBrZXkgPCBpbnB1dC5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN0Ll9wYXJzZSh2YWx1ZTIsIGluZm8pO1xuICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgc2NoZW1hOiBcInR1cGxlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZm8/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpc3N1ZXMgPyB7IGlzc3VlcyB9IDogZXhlY3V0ZVBpcGUoXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgcGlwZSxcbiAgICAgICAgaW5mbyxcbiAgICAgICAgXCJ0dXBsZVwiXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdHVwbGUvdHVwbGVBc3luYy50c1xuZnVuY3Rpb24gdHVwbGVBc3luYyhpdGVtcywgYXJnMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBbcmVzdCwgZXJyb3IsIHBpcGVdID0gZ2V0VHVwbGVBcmdzKGFyZzIsIGFyZzMsIGFyZzQpO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2hlbWEgdHlwZS5cbiAgICAgKi9cbiAgICBzY2hlbWE6IFwidHVwbGVcIixcbiAgICAvKipcbiAgICAgKiBUaGUgdHVwbGUgaXRlbXMgYW5kIHJlc3Qgc2NoZW1hLlxuICAgICAqL1xuICAgIHR1cGxlOiB7IGl0ZW1zLCByZXN0IH0sXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAhcmVzdCAmJiBpdGVtcy5sZW5ndGggIT09IGlucHV0Lmxlbmd0aCB8fCByZXN0ICYmIGl0ZW1zLmxlbmd0aCA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKGluZm8sIFwidHlwZVwiLCBcInR1cGxlXCIsIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIGxldCBpc3N1ZXM7XG4gICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgLy8gUGFyc2Ugc2NoZW1hIG9mIGVhY2ggdHVwbGUgaXRlbVxuICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICBpdGVtcy5tYXAoYXN5bmMgKHNjaGVtYSwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoIShpbmZvPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZSh2YWx1ZTIsIGluZm8pO1xuICAgICAgICAgICAgICBpZiAoIShpbmZvPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICAvLyBJZiBuZWNlc3NhcnkgcGFyc2Ugc2NoZW1hIG9mIGVhY2ggcmVzdCBpdGVtXG4gICAgICAgIHJlc3QgJiYgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgaW5wdXQuc2xpY2UoaXRlbXMubGVuZ3RoKS5tYXAoYXN5bmMgKHZhbHVlMiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmICghKGluZm8/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICBjb25zdCBrZXkgPSBpdGVtcy5sZW5ndGggKyBpbmRleDtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzdC5fcGFyc2UodmFsdWUyLCBpbmZvKTtcbiAgICAgICAgICAgICAgaWYgKCEoaW5mbz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IFwidHVwbGVcIixcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlcyA9IHJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IHJlc3VsdC5vdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgXSkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICByZXR1cm4gaXNzdWVzID8geyBpc3N1ZXMgfSA6IGV4ZWN1dGVQaXBlQXN5bmMoXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgcGlwZSxcbiAgICAgICAgaW5mbyxcbiAgICAgICAgXCJ0dXBsZVwiXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5kZWZpbmVkVHlwZS91bmRlZmluZWRUeXBlLnRzXG5mdW5jdGlvbiB1bmRlZmluZWRUeXBlKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJ1bmRlZmluZWRcIixcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gZ2V0SXNzdWVzKFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgICAgXCJ1bmRlZmluZWRcIixcbiAgICAgICAgICBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmRlZmluZWRUeXBlL3VuZGVmaW5lZFR5cGVBc3luYy50c1xuZnVuY3Rpb24gdW5kZWZpbmVkVHlwZUFzeW5jKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJ1bmRlZmluZWRcIixcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoXG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgICBcInR5cGVcIixcbiAgICAgICAgICBcInVuZGVmaW5lZFwiLFxuICAgICAgICAgIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3VuaW9uL3VuaW9uLnRzXG5mdW5jdGlvbiB1bmlvbih1bmlvbjIsIGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJ1bmlvblwiLFxuICAgIC8qKlxuICAgICAqIFRoZSB1bmlvbiBzY2hlbWEuXG4gICAgICovXG4gICAgdW5pb246IHVuaW9uMixcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgbGV0IGlzc3VlcztcbiAgICAgIGxldCBvdXRwdXQ7XG4gICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiB1bmlvbjIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgaWYgKGlzc3Vlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlzc3Vlcy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0ID0gW3Jlc3VsdC5vdXRwdXRdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0ID8geyBvdXRwdXQ6IG91dHB1dFswXSB9IDogZ2V0SXNzdWVzKFxuICAgICAgICBpbmZvLFxuICAgICAgICBcInR5cGVcIixcbiAgICAgICAgXCJ1bmlvblwiLFxuICAgICAgICBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgaXNzdWVzXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5pb24vdW5pb25Bc3luYy50c1xuZnVuY3Rpb24gdW5pb25Bc3luYyh1bmlvbjIsIGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJ1bmlvblwiLFxuICAgIC8qKlxuICAgICAqIFRoZSB1bmlvbiBzY2hlbWEuXG4gICAgICovXG4gICAgdW5pb246IHVuaW9uMixcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBsZXQgaXNzdWVzO1xuICAgICAgbGV0IG91dHB1dDtcbiAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHVuaW9uMikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY2hlbWEuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICBpZiAoaXNzdWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaXNzdWVzLnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQgPSBbcmVzdWx0Lm91dHB1dF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQgPyB7IG91dHB1dDogb3V0cHV0WzBdIH0gOiBnZXRJc3N1ZXMoXG4gICAgICAgIGluZm8sXG4gICAgICAgIFwidHlwZVwiLFxuICAgICAgICBcInVuaW9uXCIsXG4gICAgICAgIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBpc3N1ZXNcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmtub3duL3Vua25vd24udHNcbmZ1bmN0aW9uIHVua25vd24ocGlwZSA9IFtdKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJ1bmtub3duXCIsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIHJldHVybiBleGVjdXRlUGlwZShpbnB1dCwgcGlwZSwgaW5mbywgXCJ1bmtub3duXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5rbm93bi91bmtub3duQXN5bmMudHNcbmZ1bmN0aW9uIHVua25vd25Bc3luYyhwaXBlID0gW10pIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NoZW1hIHR5cGUuXG4gICAgICovXG4gICAgc2NoZW1hOiBcInVua25vd25cIixcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZVBpcGVBc3luYyhpbnB1dCwgcGlwZSwgaW5mbywgXCJ1bmtub3duXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdm9pZFR5cGUvdm9pZFR5cGUudHNcbmZ1bmN0aW9uIHZvaWRUeXBlKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjaGVtYSB0eXBlLlxuICAgICAqL1xuICAgIHNjaGVtYTogXCJ2b2lkXCIsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGdldElzc3VlcyhpbmZvLCBcInR5cGVcIiwgXCJ2b2lkXCIsIGVycm9yIHx8IFwiSW52YWxpZCB0eXBlXCIsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3ZvaWRUeXBlL3ZvaWRUeXBlQXN5bmMudHNcbmZ1bmN0aW9uIHZvaWRUeXBlQXN5bmMoZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NoZW1hIHR5cGUuXG4gICAgICovXG4gICAgc2NoZW1hOiBcInZvaWRcIixcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGl0J3MgYXN5bmMuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBnZXRJc3N1ZXMoaW5mbywgXCJ0eXBlXCIsIFwidm9pZFwiLCBlcnJvciB8fCBcIkludmFsaWQgdHlwZVwiLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9rZXlvZi9rZXlvZi50c1xuZnVuY3Rpb24ga2V5b2Yoc2NoZW1hKSB7XG4gIHJldHVybiBlbnVtVHlwZShcbiAgICBPYmplY3Qua2V5cyhzY2hlbWEub2JqZWN0KVxuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9tZXJnZS9tZXJnZS50c1xuZnVuY3Rpb24gbWVyZ2Uoc2NoZW1hcywgYXJnMiwgYXJnMykge1xuICBjb25zdCBbZXJyb3IsIHBpcGVdID0gZ2V0RGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiBvYmplY3QoXG4gICAgc2NoZW1hcy5yZWR1Y2UoXG4gICAgICAob2JqZWN0Miwgc2NoZW1hczIpID0+ICh7IC4uLm9iamVjdDIsIC4uLnNjaGVtYXMyLm9iamVjdCB9KSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICBlcnJvcixcbiAgICBwaXBlXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL21lcmdlL21lcmdlQXN5bmMudHNcbmZ1bmN0aW9uIG1lcmdlQXN5bmMoc2NoZW1hcywgYXJnMiwgYXJnMykge1xuICBjb25zdCBbZXJyb3IsIHBpcGVdID0gZ2V0RGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiBvYmplY3RBc3luYyhcbiAgICBzY2hlbWFzLnJlZHVjZShcbiAgICAgIChvYmplY3QyLCBzY2hlbWFzMikgPT4gKHsgLi4ub2JqZWN0MiwgLi4uc2NoZW1hczIub2JqZWN0IH0pLFxuICAgICAge31cbiAgICApLFxuICAgIGVycm9yLFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvb21pdC9vbWl0LnRzXG5mdW5jdGlvbiBvbWl0KHNjaGVtYSwga2V5cywgYXJnMywgYXJnNCkge1xuICBjb25zdCBbZXJyb3IsIHBpcGVdID0gZ2V0RGVmYXVsdEFyZ3MoYXJnMywgYXJnNCk7XG4gIHJldHVybiBvYmplY3QoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLm9iamVjdCkucmVkdWNlKFxuICAgICAgKG9iamVjdDIsIFtrZXksIHNjaGVtYTJdKSA9PiBrZXlzLmluY2x1ZGVzKGtleSkgPyBvYmplY3QyIDogeyAuLi5vYmplY3QyLCBba2V5XTogc2NoZW1hMiB9LFxuICAgICAge31cbiAgICApLFxuICAgIGVycm9yLFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvb21pdC9vbWl0QXN5bmMudHNcbmZ1bmN0aW9uIG9taXRBc3luYyhzY2hlbWEsIGtleXMsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKGFyZzMsIGFyZzQpO1xuICByZXR1cm4gb2JqZWN0QXN5bmMoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLm9iamVjdCkucmVkdWNlKFxuICAgICAgKG9iamVjdDIsIFtrZXksIHNjaGVtYTJdKSA9PiBrZXlzLmluY2x1ZGVzKGtleSkgPyBvYmplY3QyIDogeyAuLi5vYmplY3QyLCBba2V5XTogc2NoZW1hMiB9LFxuICAgICAge31cbiAgICApLFxuICAgIGVycm9yLFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFyc2UvcGFyc2UudHNcbmZ1bmN0aW9uIHBhcnNlKHNjaGVtYSwgaW5wdXQsIGluZm8pIHtcbiAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlFcnJvcihyZXN1bHQuaXNzdWVzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0Lm91dHB1dDtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFyc2UvcGFyc2VBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VBc3luYyhzY2hlbWEsIGlucHV0LCBpbmZvKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgIHRocm93IG5ldyBWYWxpRXJyb3IocmVzdWx0Lmlzc3Vlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5vdXRwdXQ7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnRpYWwvcGFydGlhbC50c1xuZnVuY3Rpb24gcGFydGlhbChzY2hlbWEsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKGFyZzMsIGFyZzQpO1xuICByZXR1cm4gb2JqZWN0KFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5vYmplY3QpLnJlZHVjZShcbiAgICAgIChvYmplY3QyLCBba2V5LCBzY2hlbWEyXSkgPT4gKHtcbiAgICAgICAgLi4ub2JqZWN0MixcbiAgICAgICAgW2tleV06IG9wdGlvbmFsKHNjaGVtYTIpXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICBlcnJvcixcbiAgICAvLyBAdHMtaWdub3JlIEZJWE1FOiBSZW1vdmUgbGluZSBvbmNlIGJ1ZyBpbiBUUyBpcyBmaXhlZFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFydGlhbC9wYXJ0aWFsQXN5bmMudHNcbmZ1bmN0aW9uIHBhcnRpYWxBc3luYyhzY2hlbWEsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKGFyZzMsIGFyZzQpO1xuICByZXR1cm4gb2JqZWN0QXN5bmMoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLm9iamVjdCkucmVkdWNlKFxuICAgICAgKG9iamVjdDIsIFtrZXksIHNjaGVtYTJdKSA9PiAoe1xuICAgICAgICAuLi5vYmplY3QyLFxuICAgICAgICBba2V5XTogb3B0aW9uYWxBc3luYyhzY2hlbWEyKVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICksXG4gICAgZXJyb3IsXG4gICAgLy8gQHRzLWlnbm9yZSBGSVhNRTogUmVtb3ZlIGxpbmUgb25jZSBidWcgaW4gVFMgaXMgZml4ZWRcbiAgICBwaXBlXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BpY2svcGljay50c1xuZnVuY3Rpb24gcGljayhzY2hlbWEsIGtleXMsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKGFyZzMsIGFyZzQpO1xuICByZXR1cm4gb2JqZWN0KFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5vYmplY3QpLnJlZHVjZShcbiAgICAgIChvYmplY3QyLCBba2V5LCBzY2hlbWEyXSkgPT4ga2V5cy5pbmNsdWRlcyhrZXkpID8geyAuLi5vYmplY3QyLCBba2V5XTogc2NoZW1hMiB9IDogb2JqZWN0MixcbiAgICAgIHt9XG4gICAgKSxcbiAgICBlcnJvcixcbiAgICBwaXBlXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BpY2svcGlja0FzeW5jLnRzXG5mdW5jdGlvbiBwaWNrQXN5bmMoc2NoZW1hLCBrZXlzLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtlcnJvciwgcGlwZV0gPSBnZXREZWZhdWx0QXJncyhhcmczLCBhcmc0KTtcbiAgcmV0dXJuIG9iamVjdEFzeW5jKFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5vYmplY3QpLnJlZHVjZShcbiAgICAgIChvYmplY3QyLCBba2V5LCBzY2hlbWEyXSkgPT4ga2V5cy5pbmNsdWRlcyhrZXkpID8geyAuLi5vYmplY3QyLCBba2V5XTogc2NoZW1hMiB9IDogb2JqZWN0MixcbiAgICAgIHt9XG4gICAgKSxcbiAgICBlcnJvcixcbiAgICBwaXBlXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL3JlcXVpcmVkL3JlcXVpcmVkLnRzXG5mdW5jdGlvbiByZXF1aXJlZChzY2hlbWEsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKGFyZzMsIGFyZzQpO1xuICByZXR1cm4gb2JqZWN0KFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5vYmplY3QpLnJlZHVjZShcbiAgICAgIChvYmplY3QyLCBba2V5LCBzY2hlbWEyXSkgPT4gKHtcbiAgICAgICAgLi4ub2JqZWN0MixcbiAgICAgICAgW2tleV06IG5vbk9wdGlvbmFsKHNjaGVtYTIpXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICBlcnJvcixcbiAgICAvLyBAdHMtaWdub3JlIEZJWE1FOiBSZW1vdmUgbGluZSBvbmNlIGJ1ZyBpbiBUUyBpcyBmaXhlZFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcmVxdWlyZWQvcmVxdWlyZWRBc3luYy50c1xuZnVuY3Rpb24gcmVxdWlyZWRBc3luYyhzY2hlbWEsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGdldERlZmF1bHRBcmdzKGFyZzMsIGFyZzQpO1xuICByZXR1cm4gb2JqZWN0QXN5bmMoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLm9iamVjdCkucmVkdWNlKFxuICAgICAgKG9iamVjdDIsIFtrZXksIHNjaGVtYTJdKSA9PiAoe1xuICAgICAgICAuLi5vYmplY3QyLFxuICAgICAgICBba2V5XTogbm9uT3B0aW9uYWxBc3luYyhzY2hlbWEyKVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICksXG4gICAgZXJyb3IsXG4gICAgLy8gQHRzLWlnbm9yZSBGSVhNRTogUmVtb3ZlIGxpbmUgb25jZSBidWcgaW4gVFMgaXMgZml4ZWRcbiAgICBwaXBlXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL3NhZmVQYXJzZS9zYWZlUGFyc2UudHNcbmZ1bmN0aW9uIHNhZmVQYXJzZShzY2hlbWEsIGlucHV0LCBpbmZvKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICByZXR1cm4gcmVzdWx0Lmlzc3VlcyA/IHtcbiAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICBlcnJvcjogbmV3IFZhbGlFcnJvcihyZXN1bHQuaXNzdWVzKSxcbiAgICBpc3N1ZXM6IHJlc3VsdC5pc3N1ZXNcbiAgfSA6IHtcbiAgICBzdWNjZXNzOiB0cnVlLFxuICAgIGRhdGE6IHJlc3VsdC5vdXRwdXQsXG4gICAgb3V0cHV0OiByZXN1bHQub3V0cHV0XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3NhZmVQYXJzZS9zYWZlUGFyc2VBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gc2FmZVBhcnNlQXN5bmMoc2NoZW1hLCBpbnB1dCwgaW5mbykge1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY2hlbWEuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgcmV0dXJuIHJlc3VsdC5pc3N1ZXMgPyB7XG4gICAgc3VjY2VzczogZmFsc2UsXG4gICAgZXJyb3I6IG5ldyBWYWxpRXJyb3IocmVzdWx0Lmlzc3VlcyksXG4gICAgaXNzdWVzOiByZXN1bHQuaXNzdWVzXG4gIH0gOiB7XG4gICAgc3VjY2VzczogdHJ1ZSxcbiAgICBkYXRhOiByZXN1bHQub3V0cHV0LFxuICAgIG91dHB1dDogcmVzdWx0Lm91dHB1dFxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9zdHJpY3Qvc3RyaWN0LnRzXG5mdW5jdGlvbiBzdHJpY3Qoc2NoZW1hLCBlcnJvcikge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdW5rbm93biBpbnB1dCBiYXNlZCBvbiBpdHMgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBiZSBwYXJzZWQuXG4gICAgICogQHBhcmFtIGluZm8gVGhlIHBhcnNlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICAgICAgcmV0dXJuICFyZXN1bHQuaXNzdWVzICYmIC8vIENoZWNrIGxlbmd0aCBvZiBpbnB1dCBhbmQgb3V0cHV0IGtleXNcbiAgICAgIE9iamVjdC5rZXlzKGlucHV0KS5sZW5ndGggIT09IE9iamVjdC5rZXlzKHJlc3VsdC5vdXRwdXQpLmxlbmd0aCA/IGdldElzc3VlcyhpbmZvLCBcIm9iamVjdFwiLCBcInN0cmljdFwiLCBlcnJvciB8fCBcIkludmFsaWQga2V5c1wiLCBpbnB1dCkgOiByZXN1bHQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9zdHJpY3Qvc3RyaWN0QXN5bmMudHNcbmZ1bmN0aW9uIHN0cmljdEFzeW5jKHNjaGVtYSwgZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY2hlbWEuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICAgIHJldHVybiAhcmVzdWx0Lmlzc3VlcyAmJiAvLyBDaGVjayBsZW5ndGggb2YgaW5wdXQgYW5kIG91dHB1dCBrZXlzXG4gICAgICBPYmplY3Qua2V5cyhpbnB1dCkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhyZXN1bHQub3V0cHV0KS5sZW5ndGggPyBnZXRJc3N1ZXMoaW5mbywgXCJvYmplY3RcIiwgXCJzdHJpY3RcIiwgZXJyb3IgfHwgXCJJbnZhbGlkIGtleXNcIiwgaW5wdXQpIDogcmVzdWx0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvdHJhbnNmb3JtL3RyYW5zZm9ybS50c1xuZnVuY3Rpb24gdHJhbnNmb3JtKHNjaGVtYSwgYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgICByZXR1cm4gcmVzdWx0Lmlzc3VlcyA/IHJlc3VsdCA6IHsgb3V0cHV0OiBhY3Rpb24ocmVzdWx0Lm91dHB1dCkgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3RyYW5zZm9ybS90cmFuc2Zvcm1Bc3luYy50c1xuZnVuY3Rpb24gdHJhbnNmb3JtQXN5bmMoc2NoZW1hLCBhY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpdCdzIGFzeW5jLlxuICAgICAqL1xuICAgIGFzeW5jOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB1bmtub3duIGlucHV0IGJhc2VkIG9uIGl0cyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0gaW5mbyBUaGUgcGFyc2UgaW5mby5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgICByZXR1cm4gcmVzdWx0Lmlzc3VlcyA/IHJlc3VsdCA6IHsgb3V0cHV0OiBhd2FpdCBhY3Rpb24ocmVzdWx0Lm91dHB1dCkgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3Vud3JhcC91bndyYXAudHNcbmZ1bmN0aW9uIHVud3JhcChzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYS53cmFwcGVkO1xufVxuXG4vLyBzcmMvbWV0aG9kcy93aXRoRGVmYXVsdC93aXRoRGVmYXVsdC50c1xuZnVuY3Rpb24gd2l0aERlZmF1bHQoc2NoZW1hLCB2YWx1ZTIpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHVua25vd24gaW5wdXQgYmFzZWQgb24gaXRzIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBpbmZvIFRoZSBwYXJzZSBpbmZvLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBvdXRwdXQuXG4gICAgICovXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShcbiAgICAgICAgaW5wdXQgPT09IHZvaWQgMCA/IHR5cGVvZiB2YWx1ZTIgPT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlMigpIDogdmFsdWUyIDogaW5wdXQsXG4gICAgICAgIGluZm9cbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxudmFyIHVzZURlZmF1bHQgPSB3aXRoRGVmYXVsdDtcblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b0N1c3RvbS90b0N1c3RvbS50c1xuZnVuY3Rpb24gdG9DdXN0b20oYWN0aW9uKSB7XG4gIHJldHVybiAoaW5wdXQpID0+ICh7IG91dHB1dDogYWN0aW9uKGlucHV0KSB9KTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b0N1c3RvbS90b0N1c3RvbUFzeW5jLnRzXG5mdW5jdGlvbiB0b0N1c3RvbUFzeW5jKGFjdGlvbikge1xuICByZXR1cm4gYXN5bmMgKGlucHV0KSA9PiAoe1xuICAgIG91dHB1dDogYXdhaXQgYWN0aW9uKGlucHV0KVxuICB9KTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b0xvd2VyQ2FzZS90b0xvd2VyQ2FzZS50c1xuZnVuY3Rpb24gdG9Mb3dlckNhc2UoKSB7XG4gIHJldHVybiAoaW5wdXQpID0+ICh7XG4gICAgb3V0cHV0OiBpbnB1dC50b0xvY2FsZUxvd2VyQ2FzZSgpXG4gIH0pO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtYXRpb25zL3RvTWF4VmFsdWUvdG9NYXhWYWx1ZS50c1xuZnVuY3Rpb24gdG9NYXhWYWx1ZShyZXF1aXJlbWVudCkge1xuICByZXR1cm4gKGlucHV0KSA9PiAoe1xuICAgIG91dHB1dDogaW5wdXQgPiByZXF1aXJlbWVudCA/IHJlcXVpcmVtZW50IDogaW5wdXRcbiAgfSk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1hdGlvbnMvdG9NaW5WYWx1ZS90b01pblZhbHVlLnRzXG5mdW5jdGlvbiB0b01pblZhbHVlKHJlcXVpcmVtZW50KSB7XG4gIHJldHVybiAoaW5wdXQpID0+ICh7XG4gICAgb3V0cHV0OiBpbnB1dCA8IHJlcXVpcmVtZW50ID8gcmVxdWlyZW1lbnQgOiBpbnB1dFxuICB9KTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b1RyaW1tZWQvdG9UcmltbWVkLnRzXG5mdW5jdGlvbiB0b1RyaW1tZWQoKSB7XG4gIHJldHVybiAoaW5wdXQpID0+ICh7IG91dHB1dDogaW5wdXQudHJpbSgpIH0pO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtYXRpb25zL3RvVHJpbW1lZEVuZC90b1RyaW1tZWRFbmQudHNcbmZ1bmN0aW9uIHRvVHJpbW1lZEVuZCgpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4gKHsgb3V0cHV0OiBpbnB1dC50cmltRW5kKCkgfSk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1hdGlvbnMvdG9UcmltbWVkU3RhcnQvdG9UcmltbWVkU3RhcnQudHNcbmZ1bmN0aW9uIHRvVHJpbW1lZFN0YXJ0KCkge1xuICByZXR1cm4gKGlucHV0KSA9PiAoe1xuICAgIG91dHB1dDogaW5wdXQudHJpbVN0YXJ0KClcbiAgfSk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1hdGlvbnMvdG9VcHBlckNhc2UvdG9VcHBlckNhc2UudHNcbmZ1bmN0aW9uIHRvVXBwZXJDYXNlKCkge1xuICByZXR1cm4gKGlucHV0KSA9PiAoe1xuICAgIG91dHB1dDogaW5wdXQudG9VcHBlckNhc2UoKVxuICB9KTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2J5dGVzL2J5dGVzLnRzXG5mdW5jdGlvbiBieXRlcyhyZXF1aXJlbWVudCwgZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmIChuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoaW5wdXQpLmxlbmd0aCAhPT0gcmVxdWlyZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJieXRlc1wiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCBieXRlIGxlbmd0aFwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2N1c3RvbS9jdXN0b20udHNcbmZ1bmN0aW9uIGN1c3RvbShyZXF1aXJlbWVudCwgZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmICghcmVxdWlyZW1lbnQoaW5wdXQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc3N1ZToge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VzdG9tXCIsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgfHwgXCJJbnZhbGlkIGlucHV0XCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvY3VzdG9tL2N1c3RvbUFzeW5jLnRzXG5mdW5jdGlvbiBjdXN0b21Bc3luYyhyZXF1aXJlbWVudCwgZXJyb3IpIHtcbiAgcmV0dXJuIGFzeW5jIChpbnB1dCkgPT4ge1xuICAgIGlmICghYXdhaXQgcmVxdWlyZW1lbnQoaW5wdXQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc3N1ZToge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VzdG9tXCIsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgfHwgXCJJbnZhbGlkIGlucHV0XCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvZW1haWwvZW1haWwudHNcbmZ1bmN0aW9uIGVtYWlsKGVycm9yKSB7XG4gIHJldHVybiAoaW5wdXQpID0+IHtcbiAgICBpZiAoIS9eKChbXjw+KClbXFxdLiw7Olxcc0BcIl0rKFxcLltePD4oKVtcXF0uLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoW148PigpW1xcXS4sOzpcXHNAXCJdK1xcLikrW148PigpW1xcXS4sOzpcXHNAXCJdezIsfSkkL2kudGVzdChcbiAgICAgIGlucHV0XG4gICAgKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNzdWU6IHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtYWlsXCIsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgfHwgXCJJbnZhbGlkIGVtYWlsXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvZW1vamkvZW1vamkudHNcbmZ1bmN0aW9uIGVtb2ppKGVycm9yKSB7XG4gIHJldHVybiAoaW5wdXQpID0+IHtcbiAgICBpZiAoIS9eKFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9fFxccHtFbW9qaV9Db21wb25lbnR9KSskL3UudGVzdChpbnB1dCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJlbW9qaVwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCBlbW9qaVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2VuZHNXaXRoL2VuZHNXaXRoLnRzXG5mdW5jdGlvbiBlbmRzV2l0aChyZXF1aXJlbWVudCwgZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmICghaW5wdXQuZW5kc1dpdGgocmVxdWlyZW1lbnQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc3N1ZToge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwiZW5kc193aXRoXCIsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgfHwgXCJJbnZhbGlkIGVuZFwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2VxdWFsL2VxdWFsLnRzXG5mdW5jdGlvbiBlcXVhbChyZXF1aXJlbWVudCwgZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmIChpbnB1dCAhPT0gcmVxdWlyZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJlcXVhbFwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCBpbnB1dFwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2V4Y2x1ZGVzL2V4Y2x1ZGVzLnRzXG5mdW5jdGlvbiBleGNsdWRlcyhyZXF1aXJlbWVudCwgZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmIChpbnB1dC5pbmNsdWRlcyhyZXF1aXJlbWVudCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJleGNsdWRlc1wiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCBjb250ZW50XCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvZmluaXRlL2Zpbml0ZS50c1xuZnVuY3Rpb24gZmluaXRlKGVycm9yKSB7XG4gIHJldHVybiAoaW5wdXQpID0+IHtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpbnB1dCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJmaW5pdGVcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvciB8fCBcIkludmFsaWQgZmluaXRlIG51bWJlclwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2ltZWkvaW1laS50c1xuZnVuY3Rpb24gaW1laShlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKCEvXlxcZHsyfVsgfC98LV0/XFxkezZ9WyB8L3wtXT9cXGR7Nn1bIHwvfC1dP1xcZCQvLnRlc3QoaW5wdXQpIHx8ICFpc0x1aG5BbGdvKGlucHV0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNzdWU6IHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImltZWlcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvciB8fCBcIkludmFsaWQgSU1FSVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2luY2x1ZGVzL2luY2x1ZGVzLnRzXG5mdW5jdGlvbiBpbmNsdWRlcyhyZXF1aXJlbWVudCwgZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmICghaW5wdXQuaW5jbHVkZXMocmVxdWlyZW1lbnQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc3N1ZToge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwiaW5jbHVkZXNcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvciB8fCBcIkludmFsaWQgY29udGVudFwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2ludGVnZXIvaW50ZWdlci50c1xuZnVuY3Rpb24gaW50ZWdlcihlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNzdWU6IHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImludGVnZXJcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvciB8fCBcIkludmFsaWQgaW50ZWdlclwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2lwL2lwLnRzXG5mdW5jdGlvbiBpcChlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKCEvXigoMjVbMC01XXwoMlswLTRdfDFcXGR8WzEtOV18KVxcZClcXC4/XFxiKXs0fSQvLnRlc3QoaW5wdXQpICYmICEvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSkkLy50ZXN0KFxuICAgICAgaW5wdXRcbiAgICApKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc3N1ZToge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwiaXBcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvciB8fCBcIkludmFsaWQgSVBcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pcHY0L2lwdjQudHNcbmZ1bmN0aW9uIGlwdjQoZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmICghL14oKDI1WzAtNV18KDJbMC00XXwxXFxkfFsxLTldfClcXGQpXFwuP1xcYil7NH0kLy50ZXN0KGlucHV0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNzdWU6IHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwdjRcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvciB8fCBcIkludmFsaWQgSVAgdjRcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pcHY2L2lwdjYudHNcbmZ1bmN0aW9uIGlwdjYoZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmICghL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpJC8udGVzdChcbiAgICAgIGlucHV0XG4gICAgKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNzdWU6IHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwdjZcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvciB8fCBcIkludmFsaWQgSVAgdjZcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pc29EYXRlL2lzb0RhdGUudHNcbmZ1bmN0aW9uIGlzb0RhdGUoZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmICghL15cXGR7NH0tKDBbMS05XXwxWzAtMl0pLShbMTJdXFxkfDBbMS05XXwzWzAxXSkkLy50ZXN0KGlucHV0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNzdWU6IHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImlzb19kYXRlXCIsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgfHwgXCJJbnZhbGlkIGRhdGVcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pc29EYXRlVGltZS9pc29EYXRlVGltZS50c1xuZnVuY3Rpb24gaXNvRGF0ZVRpbWUoZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmICghL15cXGR7NH0tKDBbMS05XXwxWzAtMl0pLShbMTJdXFxkfDBbMS05XXwzWzAxXSlUKDBbMC05XXwxXFxkfDJbMC0zXSk6WzAtNV1cXGQkLy50ZXN0KFxuICAgICAgaW5wdXRcbiAgICApKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc3N1ZToge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwiaXNvX2RhdGVfdGltZVwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCBkYXRldGltZVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2lzb1RpbWUvaXNvVGltZS50c1xuZnVuY3Rpb24gaXNvVGltZShlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKCEvXigwWzAtOV18MVxcZHwyWzAtM10pOlswLTVdXFxkJC8udGVzdChpbnB1dCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJpc29fdGltZVwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCB0aW1lXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaXNvVGltZVNlY29uZC9pc29UaW1lU2Vjb25kLnRzXG5mdW5jdGlvbiBpc29UaW1lU2Vjb25kKGVycm9yKSB7XG4gIHJldHVybiAoaW5wdXQpID0+IHtcbiAgICBpZiAoIS9eKDBbMC05XXwxXFxkfDJbMC0zXSk6WzAtNV1cXGQ6WzAtNV1cXGQkLy50ZXN0KGlucHV0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNzdWU6IHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImlzb190aW1lX3NlY29uZFwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCB0aW1lXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaXNvVGltZXN0YW1wL2lzb1RpbWVzdGFtcC50c1xuZnVuY3Rpb24gaXNvVGltZXN0YW1wKGVycm9yKSB7XG4gIHJldHVybiAoaW5wdXQpID0+IHtcbiAgICBpZiAoIS9eXFxkezR9LSgwWzEtOV18MVswLTJdKS0oWzEyXVxcZHwwWzEtOV18M1swMV0pVCgwWzAtOV18MVxcZHwyWzAtM10pOlswLTVdXFxkOlswLTVdXFxkXFwuXFxkezN9WiQvLnRlc3QoXG4gICAgICBpbnB1dFxuICAgICkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJpc29fdGltZXN0YW1wXCIsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgfHwgXCJJbnZhbGlkIHRpbWVzdGFtcFwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2lzb1dlZWsvaXNvV2Vlay50c1xuZnVuY3Rpb24gaXNvV2VlayhlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKCEvXlxcZHs0fS1XKDBbMS05XXxbMS00XVxcZHw1WzAtM10pJC8udGVzdChpbnB1dCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJpc29fd2Vla1wiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCB3ZWVrXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvbGVuZ3RoL2xlbmd0aC50c1xuZnVuY3Rpb24gbGVuZ3RoKHJlcXVpcmVtZW50LCBlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCAhPT0gcmVxdWlyZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJsZW5ndGhcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvciB8fCBcIkludmFsaWQgbGVuZ3RoXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvbWF4Qnl0ZXMvbWF4Qnl0ZXMudHNcbmZ1bmN0aW9uIG1heEJ5dGVzKHJlcXVpcmVtZW50LCBlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpbnB1dCkubGVuZ3RoID4gcmVxdWlyZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJtYXhfYnl0ZXNcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvciB8fCBcIkludmFsaWQgYnl0ZSBsZW5ndGhcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9tYXhMZW5ndGgvbWF4TGVuZ3RoLnRzXG5mdW5jdGlvbiBtYXhMZW5ndGgocmVxdWlyZW1lbnQsIGVycm9yKSB7XG4gIHJldHVybiAoaW5wdXQpID0+IHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID4gcmVxdWlyZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJtYXhfbGVuZ3RoXCIsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgfHwgXCJJbnZhbGlkIGxlbmd0aFwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL21heFNpemUvbWF4U2l6ZS50c1xuZnVuY3Rpb24gbWF4U2l6ZShyZXF1aXJlbWVudCwgZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmIChpbnB1dC5zaXplID4gcmVxdWlyZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJtYXhfc2l6ZVwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCBzaXplXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvbWF4VmFsdWUvbWF4VmFsdWUudHNcbmZ1bmN0aW9uIG1heFZhbHVlKHJlcXVpcmVtZW50LCBlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKGlucHV0ID4gcmVxdWlyZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJtYXhfdmFsdWVcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvciB8fCBcIkludmFsaWQgdmFsdWVcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gIH07XG59XG52YXIgbWF4UmFuZ2UgPSBtYXhWYWx1ZTtcblxuLy8gc3JjL3ZhbGlkYXRpb25zL21pbkJ5dGVzL21pbkJ5dGVzLnRzXG5mdW5jdGlvbiBtaW5CeXRlcyhyZXF1aXJlbWVudCwgZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmIChuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoaW5wdXQpLmxlbmd0aCA8IHJlcXVpcmVtZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc3N1ZToge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwibWluX2J5dGVzXCIsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgfHwgXCJJbnZhbGlkIGJ5dGUgbGVuZ3RoXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvbWltZVR5cGUvbWltZVR5cGUudHNcbmZ1bmN0aW9uIG1pbWVUeXBlKHJlcXVpcmVtZW50LCBlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKCFyZXF1aXJlbWVudC5pbmNsdWRlcyhpbnB1dC50eXBlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNzdWU6IHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcIm1pbWVfdHlwZVwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCBNSU1FIHR5cGVcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9taW5MZW5ndGgvbWluTGVuZ3RoLnRzXG5mdW5jdGlvbiBtaW5MZW5ndGgocmVxdWlyZW1lbnQsIGVycm9yKSB7XG4gIHJldHVybiAoaW5wdXQpID0+IHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoIDwgcmVxdWlyZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJtaW5fbGVuZ3RoXCIsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgfHwgXCJJbnZhbGlkIGxlbmd0aFwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL21pblNpemUvbWluU2l6ZS50c1xuZnVuY3Rpb24gbWluU2l6ZShyZXF1aXJlbWVudCwgZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmIChpbnB1dC5zaXplIDwgcmVxdWlyZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJtaW5fc2l6ZVwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCBzaXplXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvbWluVmFsdWUvbWluVmFsdWUudHNcbmZ1bmN0aW9uIG1pblZhbHVlKHJlcXVpcmVtZW50LCBlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKGlucHV0IDwgcmVxdWlyZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJtaW5fdmFsdWVcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvciB8fCBcIkludmFsaWQgdmFsdWVcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gIH07XG59XG52YXIgbWluUmFuZ2UgPSBtaW5WYWx1ZTtcblxuLy8gc3JjL3ZhbGlkYXRpb25zL211bHRpcGxlT2YvbXVsdGlwbGVPZi50c1xuZnVuY3Rpb24gbXVsdGlwbGVPZihyZXF1aXJlbWVudCwgZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmIChpbnB1dCAlIHJlcXVpcmVtZW50ICE9PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc3N1ZToge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCBtdWx0aXBsZVwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL3JlZ2V4L3JlZ2V4LnRzXG5mdW5jdGlvbiByZWdleChyZXF1aXJlbWVudCwgZXJyb3IpIHtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGlmICghcmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJyZWdleFwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCByZWdleFwiLFxuICAgICAgICAgIGlucHV0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dDogaW5wdXQgfTtcbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL3NhZmVJbnRlZ2VyL3NhZmVJbnRlZ2VyLnRzXG5mdW5jdGlvbiBzYWZlSW50ZWdlcihlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpbnB1dCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzc3VlOiB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJzYWZlX2ludGVnZXJcIixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvciB8fCBcIkludmFsaWQgc2FmZSBpbnRlZ2VyXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvc2l6ZS9zaXplLnRzXG5mdW5jdGlvbiBzaXplKHJlcXVpcmVtZW50LCBlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKGlucHV0LnNpemUgIT09IHJlcXVpcmVtZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc3N1ZToge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwic2l6ZVwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCBzaXplXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvc3RhcnRzV2l0aC9zdGFydHNXaXRoLnRzXG5mdW5jdGlvbiBzdGFydHNXaXRoKHJlcXVpcmVtZW50LCBlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKCFpbnB1dC5zdGFydHNXaXRoKHJlcXVpcmVtZW50KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNzdWU6IHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcInN0YXJ0c193aXRoXCIsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgfHwgXCJJbnZhbGlkIHN0YXJ0XCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvdXJsL3VybC50c1xuZnVuY3Rpb24gdXJsKGVycm9yKSB7XG4gIHJldHVybiAoaW5wdXQpID0+IHtcbiAgICB0cnkge1xuICAgICAgbmV3IFVSTChpbnB1dCk7XG4gICAgICByZXR1cm4geyBvdXRwdXQ6IGlucHV0IH07XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNzdWU6IHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcInVybFwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCBVUkxcIixcbiAgICAgICAgICBpbnB1dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL3V1aWQvdXVpZC50c1xuZnVuY3Rpb24gdXVpZChlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKCEvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezEyfSQvaS50ZXN0KFxuICAgICAgaW5wdXRcbiAgICApKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc3N1ZToge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwidXVpZFwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIHx8IFwiSW52YWxpZCBVVUlEXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvdmFsdWUvdmFsdWUudHNcbmZ1bmN0aW9uIHZhbHVlKHJlcXVpcmVtZW50LCBlcnJvcikge1xuICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgaWYgKGlucHV0ICE9PSByZXF1aXJlbWVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNzdWU6IHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcInZhbHVlXCIsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgfHwgXCJJbnZhbGlkIHZhbHVlXCIsXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0OiBpbnB1dCB9O1xuICB9O1xufVxuZXhwb3J0IHtcbiAgVmFsaUVycm9yLFxuICBhbnksXG4gIGFueUFzeW5jLFxuICBhcnJheSxcbiAgYXJyYXlBc3luYyxcbiAgYmlnaW50LFxuICBiaWdpbnRBc3luYyxcbiAgYmxvYixcbiAgYmxvYkFzeW5jLFxuICBib29sZWFuLFxuICBib29sZWFuQXN5bmMsXG4gIGJyYW5kLFxuICBieXRlcyxcbiAgY29lcmNlLFxuICBjb2VyY2VBc3luYyxcbiAgY3VzdG9tLFxuICBjdXN0b21Bc3luYyxcbiAgZGF0ZSxcbiAgZGF0ZUFzeW5jLFxuICBlbWFpbCxcbiAgZW1vamksXG4gIGVuZHNXaXRoLFxuICBlbnVtVHlwZSxcbiAgZW51bVR5cGVBc3luYyxcbiAgZXF1YWwsXG4gIGV4Y2x1ZGVzLFxuICBleGVjdXRlUGlwZSxcbiAgZXhlY3V0ZVBpcGVBc3luYyxcbiAgZmFsbGJhY2ssXG4gIGZhbGxiYWNrQXN5bmMsXG4gIGZpbml0ZSxcbiAgZmxhdHRlbixcbiAgZ2V0RGVmYXVsdEFyZ3MsXG4gIGdldElzc3VlcyxcbiAgaW1laSxcbiAgaW5jbHVkZXMsXG4gIGluc3RhbmNlLFxuICBpbnN0YW5jZUFzeW5jLFxuICBpbnRlZ2VyLFxuICBpcCxcbiAgaXB2NCxcbiAgaXB2NixcbiAgaXMsXG4gIGlzTHVobkFsZ28sXG4gIGlzb0RhdGUsXG4gIGlzb0RhdGVUaW1lLFxuICBpc29UaW1lLFxuICBpc29UaW1lU2Vjb25kLFxuICBpc29UaW1lc3RhbXAsXG4gIGlzb1dlZWssXG4gIGtleW9mLFxuICBsZW5ndGgsXG4gIGxpdGVyYWwsXG4gIGxpdGVyYWxBc3luYyxcbiAgbWFwLFxuICBtYXBBc3luYyxcbiAgbWF4Qnl0ZXMsXG4gIG1heExlbmd0aCxcbiAgbWF4UmFuZ2UsXG4gIG1heFNpemUsXG4gIG1heFZhbHVlLFxuICBtZXJnZSxcbiAgbWVyZ2VBc3luYyxcbiAgbWltZVR5cGUsXG4gIG1pbkJ5dGVzLFxuICBtaW5MZW5ndGgsXG4gIG1pblJhbmdlLFxuICBtaW5TaXplLFxuICBtaW5WYWx1ZSxcbiAgbXVsdGlwbGVPZixcbiAgbmFuLFxuICBuYW5Bc3luYyxcbiAgbmF0aXZlRW51bSxcbiAgbmF0aXZlRW51bUFzeW5jLFxuICBuZXZlcixcbiAgbmV2ZXJBc3luYyxcbiAgbm9uTnVsbGFibGUsXG4gIG5vbk51bGxhYmxlQXN5bmMsXG4gIG5vbk51bGxpc2gsXG4gIG5vbk51bGxpc2hBc3luYyxcbiAgbm9uT3B0aW9uYWwsXG4gIG5vbk9wdGlvbmFsQXN5bmMsXG4gIG51bGxUeXBlLFxuICBudWxsVHlwZUFzeW5jLFxuICBudWxsYWJsZSxcbiAgbnVsbGFibGVBc3luYyxcbiAgbnVsbGlzaCxcbiAgbnVsbGlzaEFzeW5jLFxuICBudW1iZXIsXG4gIG51bWJlckFzeW5jLFxuICBvYmplY3QsXG4gIG9iamVjdEFzeW5jLFxuICBvbWl0LFxuICBvbWl0QXN5bmMsXG4gIG9wdGlvbmFsLFxuICBvcHRpb25hbEFzeW5jLFxuICBwYXJzZSxcbiAgcGFyc2VBc3luYyxcbiAgcGFydGlhbCxcbiAgcGFydGlhbEFzeW5jLFxuICBwaWNrLFxuICBwaWNrQXN5bmMsXG4gIHJlY29yZCxcbiAgcmVjb3JkQXN5bmMsXG4gIHJlY3Vyc2l2ZSxcbiAgcmVjdXJzaXZlQXN5bmMsXG4gIHJlZ2V4LFxuICByZXF1aXJlZCxcbiAgcmVxdWlyZWRBc3luYyxcbiAgc2FmZUludGVnZXIsXG4gIHNhZmVQYXJzZSxcbiAgc2FmZVBhcnNlQXN5bmMsXG4gIHNldCxcbiAgc2V0QXN5bmMsXG4gIHNpemUsXG4gIHNwZWNpYWwsXG4gIHNwZWNpYWxBc3luYyxcbiAgc3RhcnRzV2l0aCxcbiAgc3RyaWN0LFxuICBzdHJpY3RBc3luYyxcbiAgc3RyaW5nLFxuICBzdHJpbmdBc3luYyxcbiAgc3ltYm9sMiBhcyBzeW1ib2wsXG4gIHN5bWJvbEFzeW5jLFxuICB0b0N1c3RvbSxcbiAgdG9DdXN0b21Bc3luYyxcbiAgdG9Mb3dlckNhc2UsXG4gIHRvTWF4VmFsdWUsXG4gIHRvTWluVmFsdWUsXG4gIHRvVHJpbW1lZCxcbiAgdG9UcmltbWVkRW5kLFxuICB0b1RyaW1tZWRTdGFydCxcbiAgdG9VcHBlckNhc2UsXG4gIHRyYW5zZm9ybSxcbiAgdHJhbnNmb3JtQXN5bmMsXG4gIHR1cGxlLFxuICB0dXBsZUFzeW5jLFxuICB1bmRlZmluZWRUeXBlLFxuICB1bmRlZmluZWRUeXBlQXN5bmMsXG4gIHVuaW9uLFxuICB1bmlvbkFzeW5jLFxuICB1bmtub3duLFxuICB1bmtub3duQXN5bmMsXG4gIHVud3JhcCxcbiAgdXJsLFxuICB1c2VEZWZhdWx0LFxuICB1dWlkLFxuICB2YWx1ZSxcbiAgdm9pZFR5cGUsXG4gIHZvaWRUeXBlQXN5bmMsXG4gIHdpdGhEZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbImZsYXR0ZW4iLCJhcmcxIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNzdWVzIiwicmVkdWNlIiwiZmxhdEVycm9ycyIsImlzc3VlIiwicGF0aCIsIm1hcCIsImtleSIsImpvaW4iLCJuZXN0ZWQiLCJtZXNzYWdlIiwicm9vdCIsIlZhbGlFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJuYW1lIiwic3ltYm9sIiwiU3ltYm9sIiwiYnJhbmQiLCJzY2hlbWEiLCJjb2VyY2UiLCJhY3Rpb24iLCJfcGFyc2UiLCJpbnB1dCIsImluZm8iLCJjb2VyY2VBc3luYyIsImZhbGxiYWNrIiwidmFsdWUyIiwicmVzdWx0Iiwib3V0cHV0IiwiZmFsbGJhY2tBc3luYyIsImlzIiwiYWJvcnRFYXJseSIsImdldElzc3VlIiwicmVhc29uIiwidmFsaWRhdGlvbiIsIm9yaWdpbiIsImFib3J0UGlwZUVhcmx5IiwiZ2V0UGlwZUluZm8iLCJleGVjdXRlUGlwZSIsInBpcGUiLCJwYXJzZUluZm8iLCJsZW5ndGgiLCJwaXBlSW5mbyIsInB1c2giLCJleGVjdXRlUGlwZUFzeW5jIiwiZ2V0RGVmYXVsdEFyZ3MiLCJhcmcyIiwiZ2V0SXNzdWVzIiwiaXNMdWhuQWxnbyIsIm51bWJlcjIiLCJyZXBsYWNlIiwibGVuZ3RoMiIsImJpdCIsInN1bSIsImFueSIsImFzeW5jIiwiYW55QXN5bmMiLCJhcnJheSIsIml0ZW0iLCJhcmczIiwiZXJyb3IiLCJwYXRoSXRlbSIsInZhbHVlIiwidW5zaGlmdCIsImFycmF5QXN5bmMiLCJQcm9taXNlIiwiYWxsIiwiY2F0Y2giLCJiaWdpbnQiLCJiaWdpbnRBc3luYyIsImJsb2IiLCJCbG9iIiwiYmxvYkFzeW5jIiwiYm9vbGVhbiIsImJvb2xlYW5Bc3luYyIsImRhdGUiLCJEYXRlIiwiZGF0ZUFzeW5jIiwiZW51bVR5cGUiLCJlbnVtVmFsdWUiLCJlbnVtIiwiaW5jbHVkZXMiLCJlbnVtVHlwZUFzeW5jIiwiaW5zdGFuY2UiLCJvZiIsImNsYXNzIiwiaW5zdGFuY2VBc3luYyIsImxpdGVyYWwiLCJsaXRlcmFsMiIsImxpdGVyYWxBc3luYyIsImFyZzQiLCJNYXAiLCJpbnB1dEtleSIsImlucHV0VmFsdWUiLCJlbnRyaWVzIiwia2V5UmVzdWx0IiwidmFsdWVSZXN1bHQiLCJzZXQiLCJtYXBBc3luYyIsImZyb20iLCJ2YWx1ZTMiLCJuYW4iLCJOdW1iZXIiLCJpc05hTiIsIm5hbkFzeW5jIiwibmF0aXZlRW51bSIsIm5hdGl2ZUVudW0yIiwiT2JqZWN0IiwidmFsdWVzIiwibmF0aXZlRW51bUFzeW5jIiwibmV2ZXIiLCJuZXZlckFzeW5jIiwibm9uTnVsbGFibGUiLCJ3cmFwcGVkIiwibm9uTnVsbGFibGVBc3luYyIsIm5vbk51bGxpc2giLCJub25OdWxsaXNoQXN5bmMiLCJub25PcHRpb25hbCIsIm5vbk9wdGlvbmFsQXN5bmMiLCJudWxsYWJsZSIsIm51bGxhYmxlQXN5bmMiLCJudWxsaXNoIiwibnVsbGlzaEFzeW5jIiwibnVsbFR5cGUiLCJudWxsVHlwZUFzeW5jIiwibnVtYmVyIiwibnVtYmVyQXN5bmMiLCJvYmplY3QiLCJvYmplY3QyIiwiY2FjaGVkRW50cmllcyIsIm9iamVjdEFzeW5jIiwib3B0aW9uYWwiLCJvcHRpb25hbEFzeW5jIiwic3RyaW5nIiwic3RyaW5nQXN5bmMiLCJnZXRSZWNvcmRBcmdzIiwiZXJyb3IyIiwicGlwZTIiLCJCTE9DS0VEX0tFWVMiLCJyZWNvcmQiLCJyZWNvcmRBc3luYyIsInJlY3Vyc2l2ZSIsImdldHRlciIsInJlY3Vyc2l2ZUFzeW5jIiwiU2V0IiwiYWRkIiwic2V0QXN5bmMiLCJzcGVjaWFsIiwiY2hlY2siLCJzcGVjaWFsQXN5bmMiLCJzeW1ib2wyIiwic3ltYm9sQXN5bmMiLCJnZXRUdXBsZUFyZ3MiLCJ0dXBsZSIsIml0ZW1zIiwicmVzdCIsInR1cGxlQXN5bmMiLCJzbGljZSIsImluZGV4IiwidW5kZWZpbmVkVHlwZSIsInVuZGVmaW5lZFR5cGVBc3luYyIsInVuaW9uIiwidW5pb24yIiwidW5pb25Bc3luYyIsInVua25vd24iLCJ1bmtub3duQXN5bmMiLCJ2b2lkVHlwZSIsInZvaWRUeXBlQXN5bmMiLCJrZXlvZiIsImtleXMiLCJtZXJnZSIsInNjaGVtYXMiLCJzY2hlbWFzMiIsIm1lcmdlQXN5bmMiLCJvbWl0Iiwic2NoZW1hMiIsIm9taXRBc3luYyIsInBhcnNlIiwicGFyc2VBc3luYyIsInBhcnRpYWwiLCJwYXJ0aWFsQXN5bmMiLCJwaWNrIiwicGlja0FzeW5jIiwicmVxdWlyZWQiLCJyZXF1aXJlZEFzeW5jIiwic2FmZVBhcnNlIiwic3VjY2VzcyIsImRhdGEiLCJzYWZlUGFyc2VBc3luYyIsInN0cmljdCIsInN0cmljdEFzeW5jIiwidHJhbnNmb3JtIiwidHJhbnNmb3JtQXN5bmMiLCJ1bndyYXAiLCJ3aXRoRGVmYXVsdCIsInVzZURlZmF1bHQiLCJ0b0N1c3RvbSIsInRvQ3VzdG9tQXN5bmMiLCJ0b0xvd2VyQ2FzZSIsInRvTG9jYWxlTG93ZXJDYXNlIiwidG9NYXhWYWx1ZSIsInJlcXVpcmVtZW50IiwidG9NaW5WYWx1ZSIsInRvVHJpbW1lZCIsInRyaW0iLCJ0b1RyaW1tZWRFbmQiLCJ0cmltRW5kIiwidG9UcmltbWVkU3RhcnQiLCJ0cmltU3RhcnQiLCJ0b1VwcGVyQ2FzZSIsImJ5dGVzIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJjdXN0b20iLCJjdXN0b21Bc3luYyIsImVtYWlsIiwidGVzdCIsImVtb2ppIiwiZW5kc1dpdGgiLCJlcXVhbCIsImV4Y2x1ZGVzIiwiZmluaXRlIiwiaXNGaW5pdGUiLCJpbWVpIiwiaW50ZWdlciIsImlzSW50ZWdlciIsImlwIiwiaXB2NCIsImlwdjYiLCJpc29EYXRlIiwiaXNvRGF0ZVRpbWUiLCJpc29UaW1lIiwiaXNvVGltZVNlY29uZCIsImlzb1RpbWVzdGFtcCIsImlzb1dlZWsiLCJtYXhCeXRlcyIsIm1heExlbmd0aCIsIm1heFNpemUiLCJzaXplIiwibWF4VmFsdWUiLCJtYXhSYW5nZSIsIm1pbkJ5dGVzIiwibWltZVR5cGUiLCJ0eXBlIiwibWluTGVuZ3RoIiwibWluU2l6ZSIsIm1pblZhbHVlIiwibWluUmFuZ2UiLCJtdWx0aXBsZU9mIiwicmVnZXgiLCJzYWZlSW50ZWdlciIsImlzU2FmZUludGVnZXIiLCJzdGFydHNXaXRoIiwidXJsIiwiVVJMIiwiXyIsInV1aWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/valibot/dist/index.js\n");

/***/ })

};
;