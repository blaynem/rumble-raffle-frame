"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@shuding";
exports.ids = ["vendor-chunks/@shuding"];
exports.modules = {

/***/ "(rsc)/./node_modules/@shuding/opentype.js/dist/opentype.module.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@shuding/opentype.js/dist/opentype.module.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Font: () => (/* binding */ Font),\n/* harmony export */   Glyph: () => (/* binding */ Glyph),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   _parse: () => (/* binding */ parse),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   load: () => (/* binding */ load),\n/* harmony export */   loadSync: () => (/* binding */ loadSync),\n/* harmony export */   parse: () => (/* binding */ parseBuffer)\n/* harmony export */ });\n/**\n * https://opentype.js.org v1.3.5 | (c) Frederik De Bleser and other contributors | MIT License | Uses fflate by 101arrowz and string.prototype.codepointat polyfill by Mathias Bynens\n */ // DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */ 0,\n    0,\n    /* impossible */ 0\n]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */ 0,\n    0\n]);\n// code length index map\nvar clim = new u8([\n    16,\n    17,\n    18,\n    0,\n    8,\n    7,\n    9,\n    6,\n    10,\n    5,\n    11,\n    4,\n    12,\n    3,\n    13,\n    2,\n    14,\n    1,\n    15\n]);\n// get base, reverse index map from extra bits\nvar freb = function(eb, start) {\n    var b = new u16(31);\n    for(var i = 0; i < 31; ++i){\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for(var i = 1; i < 30; ++i){\n        for(var j = b[i]; j < b[i + 1]; ++j){\n            r[j] = j - b[i] << 5 | i;\n        }\n    }\n    return [\n        b,\n        r\n    ];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor(var i = 0; i < 32768; ++i){\n    // reverse table algorithm from SO\n    var x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;\n    x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;\n    x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;\n    rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = function(cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for(; i < s; ++i){\n        if (cd[i]) {\n            ++l[cd[i] - 1];\n        }\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for(i = 0; i < mb; ++i){\n        le[i] = le[i - 1] + l[i - 1] << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for(i = 0; i < s; ++i){\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = i << 4 | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for(var m = v | (1 << r_1) - 1; v <= m; ++v){\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    } else {\n        co = new u16(s);\n        for(i = 0; i < s; ++i){\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];\n            }\n        }\n    }\n    return co;\n};\n// fixed length tree\nvar flt = new u8(288);\nfor(var i = 0; i < 144; ++i){\n    flt[i] = 8;\n}\nfor(var i = 144; i < 256; ++i){\n    flt[i] = 9;\n}\nfor(var i = 256; i < 280; ++i){\n    flt[i] = 7;\n}\nfor(var i = 280; i < 288; ++i){\n    flt[i] = 8;\n}\n// fixed distance tree\nvar fdt = new u8(32);\nfor(var i = 0; i < 32; ++i){\n    fdt[i] = 5;\n}\n// fixed length map\nvar flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function(a) {\n    var m = a[0];\n    for(var i = 1; i < a.length; ++i){\n        if (a[i] > m) {\n            m = a[i];\n        }\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n};\n// get end of byte\nvar shft = function(p) {\n    return (p + 7) / 8 | 0;\n};\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function(v, s, e) {\n    if (s == null || s < 0) {\n        s = 0;\n    }\n    if (e == null || e > v.length) {\n        e = v.length;\n    }\n    // can't use .constructor in case user-supplied\n    var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// error codes\nvar ec = [\n    \"unexpected EOF\",\n    \"invalid block type\",\n    \"invalid length/literal\",\n    \"invalid distance\",\n    \"stream finished\",\n    \"no stream handler\",\n    ,\n    \"no callback\",\n    \"invalid UTF-8 data\",\n    \"extra field too long\",\n    \"date not in range 1980-2099\",\n    \"filename too long\",\n    \"stream finishing\",\n    \"invalid zip data\"\n];\nvar err = function(ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(e, err);\n    }\n    if (!nt) {\n        throw e;\n    }\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function(dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || st && st.f && !st.l) {\n        return buf || new u8(0);\n    }\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st) {\n        st = {};\n    }\n    // Assumes roughly 33% compression ratio average\n    if (!buf) {\n        buf = new u8(sl * 3);\n    }\n    // ensure buffer can fit at least l elements\n    var cbuf = function(l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n                if (t > sl) {\n                    if (noSt) {\n                        err(0);\n                    }\n                    break;\n                }\n                // ensure size\n                if (noBuf) {\n                    cbuf(bt + l);\n                }\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            } else if (type == 1) {\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            } else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for(var i = 0; i < hcLen; ++i){\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for(var i = 0; i < tl;){\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    } else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16) {\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        } else if (s == 17) {\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        } else if (s == 18) {\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        }\n                        while(n--){\n                            ldt[i++] = c;\n                        }\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            } else {\n                err(1);\n            }\n            if (pos > tbts) {\n                if (noSt) {\n                    err(0);\n                }\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf) {\n            cbuf(bt + 131072);\n        }\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for(;; lpos = pos){\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt) {\n                    err(0);\n                }\n                break;\n            }\n            if (!c) {\n                err(2);\n            }\n            if (sym < 256) {\n                buf[bt++] = sym;\n            } else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            } else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d) {\n                    err(3);\n                }\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt) {\n                        err(0);\n                    }\n                    break;\n                }\n                if (noBuf) {\n                    cbuf(bt + 131072);\n                }\n                var end = bt + add;\n                for(; bt < end; bt += 4){\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm) {\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n        }\n    }while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// text decoder\nvar td = typeof TextDecoder != \"undefined\" && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, {\n        stream: true\n    });\n    tds = 1;\n} catch (e) {}\n// Geometric objects\n// import BoundingBox from './bbox';\n/**\n * A bézier path containing a set of path commands similar to a SVG path.\n * Paths can be drawn on a context using `draw`.\n * @exports opentype.Path\n * @class\n * @constructor\n */ function Path() {\n    this.commands = [];\n    this.fill = \"black\";\n    this.stroke = null;\n    this.strokeWidth = 1;\n}\n/**\n * @param  {number} x\n * @param  {number} y\n */ Path.prototype.moveTo = function(x, y) {\n    this.commands.push({\n        type: \"M\",\n        x: x,\n        y: y\n    });\n};\n/**\n * @param  {number} x\n * @param  {number} y\n */ Path.prototype.lineTo = function(x, y) {\n    this.commands.push({\n        type: \"L\",\n        x: x,\n        y: y\n    });\n};\n/**\n * Draws cubic curve\n * @function\n * curveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */ /**\n * Draws cubic curve\n * @function\n * bezierCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n * @see curveTo\n */ Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {\n    this.commands.push({\n        type: \"C\",\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        x: x,\n        y: y\n    });\n};\n/**\n * Draws quadratic curve\n * @function\n * quadraticCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */ /**\n * Draws quadratic curve\n * @function\n * quadTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */ Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {\n    this.commands.push({\n        type: \"Q\",\n        x1: x1,\n        y1: y1,\n        x: x,\n        y: y\n    });\n};\n/**\n * Closes the path\n * @function closePath\n * @memberof opentype.Path.prototype\n */ /**\n * Close the path\n * @function close\n * @memberof opentype.Path.prototype\n */ Path.prototype.close = Path.prototype.closePath = function() {\n    this.commands.push({\n        type: \"Z\"\n    });\n};\n/**\n * Add the given path or list of commands to the commands of this path.\n * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.\n */ Path.prototype.extend = function(pathOrCommands) {\n    if (pathOrCommands.commands) {\n        pathOrCommands = pathOrCommands.commands;\n    }\n    // else if (pathOrCommands instanceof BoundingBox) {\n    //     const box = pathOrCommands;\n    //     this.moveTo(box.x1, box.y1);\n    //     this.lineTo(box.x2, box.y1);\n    //     this.lineTo(box.x2, box.y2);\n    //     this.lineTo(box.x1, box.y2);\n    //     this.close();\n    //     return;\n    // }\n    Array.prototype.push.apply(this.commands, pathOrCommands);\n};\n/**\n * Convert the Path to a string of path data instructions\n * See http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */ Path.prototype.toPathData = function(decimalPlaces) {\n    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;\n    function floatToString(v) {\n        if (Math.round(v) === v) {\n            return \"\" + Math.round(v);\n        } else {\n            return v.toFixed(decimalPlaces);\n        }\n    }\n    function packValues() {\n        var arguments$1 = arguments;\n        var s = \"\";\n        for(var i = 0; i < arguments.length; i += 1){\n            var v = arguments$1[i];\n            if (v >= 0 && i > 0) {\n                s += \" \";\n            }\n            s += floatToString(v);\n        }\n        return s;\n    }\n    var d = \"\";\n    for(var i = 0; i < this.commands.length; i += 1){\n        var cmd = this.commands[i];\n        if (cmd.type === \"M\") {\n            d += \"M\" + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === \"L\") {\n            d += \"L\" + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === \"C\") {\n            d += \"C\" + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === \"Q\") {\n            d += \"Q\" + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === \"Z\") {\n            d += \"Z\";\n        }\n    }\n    return d;\n};\n// Glyph encoding\nvar cffStandardStrings = [\n    \".notdef\",\n    \"space\",\n    \"exclam\",\n    \"quotedbl\",\n    \"numbersign\",\n    \"dollar\",\n    \"percent\",\n    \"ampersand\",\n    \"quoteright\",\n    \"parenleft\",\n    \"parenright\",\n    \"asterisk\",\n    \"plus\",\n    \"comma\",\n    \"hyphen\",\n    \"period\",\n    \"slash\",\n    \"zero\",\n    \"one\",\n    \"two\",\n    \"three\",\n    \"four\",\n    \"five\",\n    \"six\",\n    \"seven\",\n    \"eight\",\n    \"nine\",\n    \"colon\",\n    \"semicolon\",\n    \"less\",\n    \"equal\",\n    \"greater\",\n    \"question\",\n    \"at\",\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\",\n    \"G\",\n    \"H\",\n    \"I\",\n    \"J\",\n    \"K\",\n    \"L\",\n    \"M\",\n    \"N\",\n    \"O\",\n    \"P\",\n    \"Q\",\n    \"R\",\n    \"S\",\n    \"T\",\n    \"U\",\n    \"V\",\n    \"W\",\n    \"X\",\n    \"Y\",\n    \"Z\",\n    \"bracketleft\",\n    \"backslash\",\n    \"bracketright\",\n    \"asciicircum\",\n    \"underscore\",\n    \"quoteleft\",\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"g\",\n    \"h\",\n    \"i\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"m\",\n    \"n\",\n    \"o\",\n    \"p\",\n    \"q\",\n    \"r\",\n    \"s\",\n    \"t\",\n    \"u\",\n    \"v\",\n    \"w\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"braceleft\",\n    \"bar\",\n    \"braceright\",\n    \"asciitilde\",\n    \"exclamdown\",\n    \"cent\",\n    \"sterling\",\n    \"fraction\",\n    \"yen\",\n    \"florin\",\n    \"section\",\n    \"currency\",\n    \"quotesingle\",\n    \"quotedblleft\",\n    \"guillemotleft\",\n    \"guilsinglleft\",\n    \"guilsinglright\",\n    \"fi\",\n    \"fl\",\n    \"endash\",\n    \"dagger\",\n    \"daggerdbl\",\n    \"periodcentered\",\n    \"paragraph\",\n    \"bullet\",\n    \"quotesinglbase\",\n    \"quotedblbase\",\n    \"quotedblright\",\n    \"guillemotright\",\n    \"ellipsis\",\n    \"perthousand\",\n    \"questiondown\",\n    \"grave\",\n    \"acute\",\n    \"circumflex\",\n    \"tilde\",\n    \"macron\",\n    \"breve\",\n    \"dotaccent\",\n    \"dieresis\",\n    \"ring\",\n    \"cedilla\",\n    \"hungarumlaut\",\n    \"ogonek\",\n    \"caron\",\n    \"emdash\",\n    \"AE\",\n    \"ordfeminine\",\n    \"Lslash\",\n    \"Oslash\",\n    \"OE\",\n    \"ordmasculine\",\n    \"ae\",\n    \"dotlessi\",\n    \"lslash\",\n    \"oslash\",\n    \"oe\",\n    \"germandbls\",\n    \"onesuperior\",\n    \"logicalnot\",\n    \"mu\",\n    \"trademark\",\n    \"Eth\",\n    \"onehalf\",\n    \"plusminus\",\n    \"Thorn\",\n    \"onequarter\",\n    \"divide\",\n    \"brokenbar\",\n    \"degree\",\n    \"thorn\",\n    \"threequarters\",\n    \"twosuperior\",\n    \"registered\",\n    \"minus\",\n    \"eth\",\n    \"multiply\",\n    \"threesuperior\",\n    \"copyright\",\n    \"Aacute\",\n    \"Acircumflex\",\n    \"Adieresis\",\n    \"Agrave\",\n    \"Aring\",\n    \"Atilde\",\n    \"Ccedilla\",\n    \"Eacute\",\n    \"Ecircumflex\",\n    \"Edieresis\",\n    \"Egrave\",\n    \"Iacute\",\n    \"Icircumflex\",\n    \"Idieresis\",\n    \"Igrave\",\n    \"Ntilde\",\n    \"Oacute\",\n    \"Ocircumflex\",\n    \"Odieresis\",\n    \"Ograve\",\n    \"Otilde\",\n    \"Scaron\",\n    \"Uacute\",\n    \"Ucircumflex\",\n    \"Udieresis\",\n    \"Ugrave\",\n    \"Yacute\",\n    \"Ydieresis\",\n    \"Zcaron\",\n    \"aacute\",\n    \"acircumflex\",\n    \"adieresis\",\n    \"agrave\",\n    \"aring\",\n    \"atilde\",\n    \"ccedilla\",\n    \"eacute\",\n    \"ecircumflex\",\n    \"edieresis\",\n    \"egrave\",\n    \"iacute\",\n    \"icircumflex\",\n    \"idieresis\",\n    \"igrave\",\n    \"ntilde\",\n    \"oacute\",\n    \"ocircumflex\",\n    \"odieresis\",\n    \"ograve\",\n    \"otilde\",\n    \"scaron\",\n    \"uacute\",\n    \"ucircumflex\",\n    \"udieresis\",\n    \"ugrave\",\n    \"yacute\",\n    \"ydieresis\",\n    \"zcaron\",\n    \"exclamsmall\",\n    \"Hungarumlautsmall\",\n    \"dollaroldstyle\",\n    \"dollarsuperior\",\n    \"ampersandsmall\",\n    \"Acutesmall\",\n    \"parenleftsuperior\",\n    \"parenrightsuperior\",\n    \"266 ff\",\n    \"onedotenleader\",\n    \"zerooldstyle\",\n    \"oneoldstyle\",\n    \"twooldstyle\",\n    \"threeoldstyle\",\n    \"fouroldstyle\",\n    \"fiveoldstyle\",\n    \"sixoldstyle\",\n    \"sevenoldstyle\",\n    \"eightoldstyle\",\n    \"nineoldstyle\",\n    \"commasuperior\",\n    \"threequartersemdash\",\n    \"periodsuperior\",\n    \"questionsmall\",\n    \"asuperior\",\n    \"bsuperior\",\n    \"centsuperior\",\n    \"dsuperior\",\n    \"esuperior\",\n    \"isuperior\",\n    \"lsuperior\",\n    \"msuperior\",\n    \"nsuperior\",\n    \"osuperior\",\n    \"rsuperior\",\n    \"ssuperior\",\n    \"tsuperior\",\n    \"ff\",\n    \"ffi\",\n    \"ffl\",\n    \"parenleftinferior\",\n    \"parenrightinferior\",\n    \"Circumflexsmall\",\n    \"hyphensuperior\",\n    \"Gravesmall\",\n    \"Asmall\",\n    \"Bsmall\",\n    \"Csmall\",\n    \"Dsmall\",\n    \"Esmall\",\n    \"Fsmall\",\n    \"Gsmall\",\n    \"Hsmall\",\n    \"Ismall\",\n    \"Jsmall\",\n    \"Ksmall\",\n    \"Lsmall\",\n    \"Msmall\",\n    \"Nsmall\",\n    \"Osmall\",\n    \"Psmall\",\n    \"Qsmall\",\n    \"Rsmall\",\n    \"Ssmall\",\n    \"Tsmall\",\n    \"Usmall\",\n    \"Vsmall\",\n    \"Wsmall\",\n    \"Xsmall\",\n    \"Ysmall\",\n    \"Zsmall\",\n    \"colonmonetary\",\n    \"onefitted\",\n    \"rupiah\",\n    \"Tildesmall\",\n    \"exclamdownsmall\",\n    \"centoldstyle\",\n    \"Lslashsmall\",\n    \"Scaronsmall\",\n    \"Zcaronsmall\",\n    \"Dieresissmall\",\n    \"Brevesmall\",\n    \"Caronsmall\",\n    \"Dotaccentsmall\",\n    \"Macronsmall\",\n    \"figuredash\",\n    \"hypheninferior\",\n    \"Ogoneksmall\",\n    \"Ringsmall\",\n    \"Cedillasmall\",\n    \"questiondownsmall\",\n    \"oneeighth\",\n    \"threeeighths\",\n    \"fiveeighths\",\n    \"seveneighths\",\n    \"onethird\",\n    \"twothirds\",\n    \"zerosuperior\",\n    \"foursuperior\",\n    \"fivesuperior\",\n    \"sixsuperior\",\n    \"sevensuperior\",\n    \"eightsuperior\",\n    \"ninesuperior\",\n    \"zeroinferior\",\n    \"oneinferior\",\n    \"twoinferior\",\n    \"threeinferior\",\n    \"fourinferior\",\n    \"fiveinferior\",\n    \"sixinferior\",\n    \"seveninferior\",\n    \"eightinferior\",\n    \"nineinferior\",\n    \"centinferior\",\n    \"dollarinferior\",\n    \"periodinferior\",\n    \"commainferior\",\n    \"Agravesmall\",\n    \"Aacutesmall\",\n    \"Acircumflexsmall\",\n    \"Atildesmall\",\n    \"Adieresissmall\",\n    \"Aringsmall\",\n    \"AEsmall\",\n    \"Ccedillasmall\",\n    \"Egravesmall\",\n    \"Eacutesmall\",\n    \"Ecircumflexsmall\",\n    \"Edieresissmall\",\n    \"Igravesmall\",\n    \"Iacutesmall\",\n    \"Icircumflexsmall\",\n    \"Idieresissmall\",\n    \"Ethsmall\",\n    \"Ntildesmall\",\n    \"Ogravesmall\",\n    \"Oacutesmall\",\n    \"Ocircumflexsmall\",\n    \"Otildesmall\",\n    \"Odieresissmall\",\n    \"OEsmall\",\n    \"Oslashsmall\",\n    \"Ugravesmall\",\n    \"Uacutesmall\",\n    \"Ucircumflexsmall\",\n    \"Udieresissmall\",\n    \"Yacutesmall\",\n    \"Thornsmall\",\n    \"Ydieresissmall\",\n    \"001.000\",\n    \"001.001\",\n    \"001.002\",\n    \"001.003\",\n    \"Black\",\n    \"Bold\",\n    \"Book\",\n    \"Light\",\n    \"Medium\",\n    \"Regular\",\n    \"Roman\",\n    \"Semibold\"\n];\nvar cffStandardEncoding = [\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"space\",\n    \"exclam\",\n    \"quotedbl\",\n    \"numbersign\",\n    \"dollar\",\n    \"percent\",\n    \"ampersand\",\n    \"quoteright\",\n    \"parenleft\",\n    \"parenright\",\n    \"asterisk\",\n    \"plus\",\n    \"comma\",\n    \"hyphen\",\n    \"period\",\n    \"slash\",\n    \"zero\",\n    \"one\",\n    \"two\",\n    \"three\",\n    \"four\",\n    \"five\",\n    \"six\",\n    \"seven\",\n    \"eight\",\n    \"nine\",\n    \"colon\",\n    \"semicolon\",\n    \"less\",\n    \"equal\",\n    \"greater\",\n    \"question\",\n    \"at\",\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\",\n    \"G\",\n    \"H\",\n    \"I\",\n    \"J\",\n    \"K\",\n    \"L\",\n    \"M\",\n    \"N\",\n    \"O\",\n    \"P\",\n    \"Q\",\n    \"R\",\n    \"S\",\n    \"T\",\n    \"U\",\n    \"V\",\n    \"W\",\n    \"X\",\n    \"Y\",\n    \"Z\",\n    \"bracketleft\",\n    \"backslash\",\n    \"bracketright\",\n    \"asciicircum\",\n    \"underscore\",\n    \"quoteleft\",\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"g\",\n    \"h\",\n    \"i\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"m\",\n    \"n\",\n    \"o\",\n    \"p\",\n    \"q\",\n    \"r\",\n    \"s\",\n    \"t\",\n    \"u\",\n    \"v\",\n    \"w\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"braceleft\",\n    \"bar\",\n    \"braceright\",\n    \"asciitilde\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"exclamdown\",\n    \"cent\",\n    \"sterling\",\n    \"fraction\",\n    \"yen\",\n    \"florin\",\n    \"section\",\n    \"currency\",\n    \"quotesingle\",\n    \"quotedblleft\",\n    \"guillemotleft\",\n    \"guilsinglleft\",\n    \"guilsinglright\",\n    \"fi\",\n    \"fl\",\n    \"\",\n    \"endash\",\n    \"dagger\",\n    \"daggerdbl\",\n    \"periodcentered\",\n    \"\",\n    \"paragraph\",\n    \"bullet\",\n    \"quotesinglbase\",\n    \"quotedblbase\",\n    \"quotedblright\",\n    \"guillemotright\",\n    \"ellipsis\",\n    \"perthousand\",\n    \"\",\n    \"questiondown\",\n    \"\",\n    \"grave\",\n    \"acute\",\n    \"circumflex\",\n    \"tilde\",\n    \"macron\",\n    \"breve\",\n    \"dotaccent\",\n    \"dieresis\",\n    \"\",\n    \"ring\",\n    \"cedilla\",\n    \"\",\n    \"hungarumlaut\",\n    \"ogonek\",\n    \"caron\",\n    \"emdash\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"AE\",\n    \"\",\n    \"ordfeminine\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"Lslash\",\n    \"Oslash\",\n    \"OE\",\n    \"ordmasculine\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"ae\",\n    \"\",\n    \"\",\n    \"\",\n    \"dotlessi\",\n    \"\",\n    \"\",\n    \"lslash\",\n    \"oslash\",\n    \"oe\",\n    \"germandbls\"\n];\nvar cffExpertEncoding = [\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"space\",\n    \"exclamsmall\",\n    \"Hungarumlautsmall\",\n    \"\",\n    \"dollaroldstyle\",\n    \"dollarsuperior\",\n    \"ampersandsmall\",\n    \"Acutesmall\",\n    \"parenleftsuperior\",\n    \"parenrightsuperior\",\n    \"twodotenleader\",\n    \"onedotenleader\",\n    \"comma\",\n    \"hyphen\",\n    \"period\",\n    \"fraction\",\n    \"zerooldstyle\",\n    \"oneoldstyle\",\n    \"twooldstyle\",\n    \"threeoldstyle\",\n    \"fouroldstyle\",\n    \"fiveoldstyle\",\n    \"sixoldstyle\",\n    \"sevenoldstyle\",\n    \"eightoldstyle\",\n    \"nineoldstyle\",\n    \"colon\",\n    \"semicolon\",\n    \"commasuperior\",\n    \"threequartersemdash\",\n    \"periodsuperior\",\n    \"questionsmall\",\n    \"\",\n    \"asuperior\",\n    \"bsuperior\",\n    \"centsuperior\",\n    \"dsuperior\",\n    \"esuperior\",\n    \"\",\n    \"\",\n    \"isuperior\",\n    \"\",\n    \"\",\n    \"lsuperior\",\n    \"msuperior\",\n    \"nsuperior\",\n    \"osuperior\",\n    \"\",\n    \"\",\n    \"rsuperior\",\n    \"ssuperior\",\n    \"tsuperior\",\n    \"\",\n    \"ff\",\n    \"fi\",\n    \"fl\",\n    \"ffi\",\n    \"ffl\",\n    \"parenleftinferior\",\n    \"\",\n    \"parenrightinferior\",\n    \"Circumflexsmall\",\n    \"hyphensuperior\",\n    \"Gravesmall\",\n    \"Asmall\",\n    \"Bsmall\",\n    \"Csmall\",\n    \"Dsmall\",\n    \"Esmall\",\n    \"Fsmall\",\n    \"Gsmall\",\n    \"Hsmall\",\n    \"Ismall\",\n    \"Jsmall\",\n    \"Ksmall\",\n    \"Lsmall\",\n    \"Msmall\",\n    \"Nsmall\",\n    \"Osmall\",\n    \"Psmall\",\n    \"Qsmall\",\n    \"Rsmall\",\n    \"Ssmall\",\n    \"Tsmall\",\n    \"Usmall\",\n    \"Vsmall\",\n    \"Wsmall\",\n    \"Xsmall\",\n    \"Ysmall\",\n    \"Zsmall\",\n    \"colonmonetary\",\n    \"onefitted\",\n    \"rupiah\",\n    \"Tildesmall\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"exclamdownsmall\",\n    \"centoldstyle\",\n    \"Lslashsmall\",\n    \"\",\n    \"\",\n    \"Scaronsmall\",\n    \"Zcaronsmall\",\n    \"Dieresissmall\",\n    \"Brevesmall\",\n    \"Caronsmall\",\n    \"\",\n    \"Dotaccentsmall\",\n    \"\",\n    \"\",\n    \"Macronsmall\",\n    \"\",\n    \"\",\n    \"figuredash\",\n    \"hypheninferior\",\n    \"\",\n    \"\",\n    \"Ogoneksmall\",\n    \"Ringsmall\",\n    \"Cedillasmall\",\n    \"\",\n    \"\",\n    \"\",\n    \"onequarter\",\n    \"onehalf\",\n    \"threequarters\",\n    \"questiondownsmall\",\n    \"oneeighth\",\n    \"threeeighths\",\n    \"fiveeighths\",\n    \"seveneighths\",\n    \"onethird\",\n    \"twothirds\",\n    \"\",\n    \"\",\n    \"zerosuperior\",\n    \"onesuperior\",\n    \"twosuperior\",\n    \"threesuperior\",\n    \"foursuperior\",\n    \"fivesuperior\",\n    \"sixsuperior\",\n    \"sevensuperior\",\n    \"eightsuperior\",\n    \"ninesuperior\",\n    \"zeroinferior\",\n    \"oneinferior\",\n    \"twoinferior\",\n    \"threeinferior\",\n    \"fourinferior\",\n    \"fiveinferior\",\n    \"sixinferior\",\n    \"seveninferior\",\n    \"eightinferior\",\n    \"nineinferior\",\n    \"centinferior\",\n    \"dollarinferior\",\n    \"periodinferior\",\n    \"commainferior\",\n    \"Agravesmall\",\n    \"Aacutesmall\",\n    \"Acircumflexsmall\",\n    \"Atildesmall\",\n    \"Adieresissmall\",\n    \"Aringsmall\",\n    \"AEsmall\",\n    \"Ccedillasmall\",\n    \"Egravesmall\",\n    \"Eacutesmall\",\n    \"Ecircumflexsmall\",\n    \"Edieresissmall\",\n    \"Igravesmall\",\n    \"Iacutesmall\",\n    \"Icircumflexsmall\",\n    \"Idieresissmall\",\n    \"Ethsmall\",\n    \"Ntildesmall\",\n    \"Ogravesmall\",\n    \"Oacutesmall\",\n    \"Ocircumflexsmall\",\n    \"Otildesmall\",\n    \"Odieresissmall\",\n    \"OEsmall\",\n    \"Oslashsmall\",\n    \"Ugravesmall\",\n    \"Uacutesmall\",\n    \"Ucircumflexsmall\",\n    \"Udieresissmall\",\n    \"Yacutesmall\",\n    \"Thornsmall\",\n    \"Ydieresissmall\"\n];\n/**\n * This is the encoding used for fonts created from scratch.\n * It loops through all glyphs and finds the appropriate unicode value.\n * Since it's linear time, other encodings will be faster.\n * @exports opentype.DefaultEncoding\n * @class\n * @constructor\n * @param {opentype.Font}\n */ function DefaultEncoding(font) {\n    this.font = font;\n}\nDefaultEncoding.prototype.charToGlyphIndex = function(c) {\n    var code = c.codePointAt(0);\n    var glyphs = this.font.glyphs;\n    if (glyphs) {\n        for(var i = 0; i < glyphs.length; i += 1){\n            var glyph = glyphs.get(i);\n            for(var j = 0; j < glyph.unicodes.length; j += 1){\n                if (glyph.unicodes[j] === code) {\n                    return i;\n                }\n            }\n        }\n    }\n    return null;\n};\n/**\n * @exports opentype.CmapEncoding\n * @class\n * @constructor\n * @param {Object} cmap - a object with the cmap encoded data\n */ function CmapEncoding(cmap) {\n    this.cmap = cmap;\n}\n/**\n * @param  {string} c - the character\n * @return {number} The glyph index.\n */ CmapEncoding.prototype.charToGlyphIndex = function(c) {\n    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;\n};\n/**\n * @exports opentype.CffEncoding\n * @class\n * @constructor\n * @param {string} encoding - The encoding\n * @param {Array} charset - The character set.\n */ function CffEncoding(encoding, charset) {\n    this.encoding = encoding;\n    this.charset = charset;\n}\n/**\n * @param  {string} s - The character\n * @return {number} The index.\n */ CffEncoding.prototype.charToGlyphIndex = function(s) {\n    var code = s.codePointAt(0);\n    var charName = this.encoding[code];\n    return this.charset.indexOf(charName);\n};\nfunction addGlyphNamesAll(font) {\n    var glyph;\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n    for(var i = 0; i < charCodes.length; i += 1){\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        glyph = font.glyphs.get(glyphIndex);\n        glyph.addUnicode(parseInt(c));\n    }\n}\nfunction addGlyphNamesToUnicodeMap(font) {\n    font._IndexToUnicodeMap = {};\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n    for(var i = 0; i < charCodes.length; i += 1){\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        if (font._IndexToUnicodeMap[glyphIndex] === undefined) {\n            font._IndexToUnicodeMap[glyphIndex] = {\n                unicodes: [\n                    parseInt(c)\n                ]\n            };\n        } else {\n            font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));\n        }\n    }\n}\n/**\n * @alias opentype.addGlyphNames\n * @param {opentype.Font}\n * @param {Object}\n */ function addGlyphNames(font, opt) {\n    if (opt.lowMemory) {\n        addGlyphNamesToUnicodeMap(font);\n    } else {\n        addGlyphNamesAll(font);\n    }\n}\n// Run-time checking of preconditions.\nfunction fail(message) {\n    throw new Error(message);\n}\n// Precondition function that checks if the given predicate is true.\n// If not, it will throw an error.\nfunction argument(predicate, message) {\n    if (!predicate) {\n        fail(message);\n    }\n}\nvar check = {\n    fail: fail,\n    argument: argument,\n    assert: argument\n};\n// The Glyph object\n// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency\nfunction getPathDefinition(glyph, path) {\n    var _path = path || new Path();\n    return {\n        configurable: true,\n        get: function() {\n            if (typeof _path === \"function\") {\n                _path = _path();\n            }\n            return _path;\n        },\n        set: function(p) {\n            _path = p;\n        }\n    };\n}\n/**\n * @typedef GlyphOptions\n * @type Object\n * @property {string} [name] - The glyph name\n * @property {number} [unicode]\n * @property {Array} [unicodes]\n * @property {number} [xMin]\n * @property {number} [yMin]\n * @property {number} [xMax]\n * @property {number} [yMax]\n * @property {number} [advanceWidth]\n */ // A Glyph is an individual mark that often corresponds to a character.\n// Some glyphs, such as ligatures, are a combination of many characters.\n// Glyphs are the basic building blocks of a font.\n//\n// The `Glyph` class contains utility methods for drawing the path and its points.\n/**\n * @exports opentype.Glyph\n * @class\n * @param {GlyphOptions}\n * @constructor\n */ function Glyph(options) {\n    // By putting all the code on a prototype function (which is only declared once)\n    // we reduce the memory requirements for larger fonts by some 2%\n    this.bindConstructorValues(options);\n}\n/**\n * @param  {GlyphOptions}\n */ Glyph.prototype.bindConstructorValues = function(options) {\n    this.index = options.index || 0;\n    // These three values cannot be deferred for memory optimization:\n    this.name = options.name || null;\n    this.unicode = options.unicode || undefined;\n    this.unicodes = options.unicodes || options.unicode !== undefined ? [\n        options.unicode\n    ] : [];\n    // But by binding these values only when necessary, we reduce can\n    // the memory requirements by almost 3% for larger fonts.\n    if (\"xMin\" in options) {\n        this.xMin = options.xMin;\n    }\n    if (\"yMin\" in options) {\n        this.yMin = options.yMin;\n    }\n    if (\"xMax\" in options) {\n        this.xMax = options.xMax;\n    }\n    if (\"yMax\" in options) {\n        this.yMax = options.yMax;\n    }\n    if (\"advanceWidth\" in options) {\n        this.advanceWidth = options.advanceWidth;\n    }\n    // The path for a glyph is the most memory intensive, and is bound as a value\n    // with a getter/setter to ensure we actually do path parsing only once the\n    // path is actually needed by anything.\n    Object.defineProperty(this, \"path\", getPathDefinition(this, options.path));\n};\n/**\n * @param {number}\n */ Glyph.prototype.addUnicode = function(unicode) {\n    if (this.unicodes.length === 0) {\n        this.unicode = unicode;\n    }\n    this.unicodes.push(unicode);\n};\n// /**\n//  * Calculate the minimum bounding box for this glyph.\n//  * @return {opentype.BoundingBox}\n//  */\n// Glyph.prototype.getBoundingBox = function() {\n//     return this.path.getBoundingBox();\n// };\n/**\n * Convert the glyph to a Path we can draw on a drawing context.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n * @param  {opentype.Font} if hinting is to be used, the font\n * @return {opentype.Path}\n */ Glyph.prototype.getPath = function(x, y, fontSize, options, font) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    var commands;\n    var hPoints;\n    if (!options) {\n        options = {};\n    }\n    var xScale = options.xScale;\n    var yScale = options.yScale;\n    if (options.hinting && font && font.hinting) {\n        // in case of hinting, the hinting engine takes care\n        // of scaling the points (not the path) before hinting.\n        hPoints = this.path && font.hinting.exec(this, fontSize);\n    // in case the hinting engine failed hPoints is undefined\n    // and thus reverts to plain rending\n    }\n    if (hPoints) {\n        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency\n        commands = font.hinting.getCommands(hPoints);\n        x = Math.round(x);\n        y = Math.round(y);\n        // TODO in case of hinting xyScaling is not yet supported\n        xScale = yScale = 1;\n    } else {\n        commands = this.path.commands;\n        var scale = 1 / (this.path.unitsPerEm || 1000) * fontSize;\n        if (xScale === undefined) {\n            xScale = scale;\n        }\n        if (yScale === undefined) {\n            yScale = scale;\n        }\n    }\n    var p = new Path();\n    for(var i = 0; i < commands.length; i += 1){\n        var cmd = commands[i];\n        if (cmd.type === \"M\") {\n            p.moveTo(x + cmd.x * xScale, y + -cmd.y * yScale);\n        } else if (cmd.type === \"L\") {\n            p.lineTo(x + cmd.x * xScale, y + -cmd.y * yScale);\n        } else if (cmd.type === \"Q\") {\n            p.quadraticCurveTo(x + cmd.x1 * xScale, y + -cmd.y1 * yScale, x + cmd.x * xScale, y + -cmd.y * yScale);\n        } else if (cmd.type === \"C\") {\n            p.curveTo(x + cmd.x1 * xScale, y + -cmd.y1 * yScale, x + cmd.x2 * xScale, y + -cmd.y2 * yScale, x + cmd.x * xScale, y + -cmd.y * yScale);\n        } else if (cmd.type === \"Z\") {\n            p.closePath();\n        }\n    }\n    return p;\n};\n/**\n * Split the glyph into contours.\n * This function is here for backwards compatibility, and to\n * provide raw access to the TrueType glyph outlines.\n * @return {Array}\n */ Glyph.prototype.getContours = function() {\n    if (this.points === undefined) {\n        return [];\n    }\n    var contours = [];\n    var currentContour = [];\n    for(var i = 0; i < this.points.length; i += 1){\n        var pt = this.points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n    check.argument(currentContour.length === 0, \"There are still points left in the current contour.\");\n    return contours;\n};\n/**\n * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\n * @return {Object}\n */ Glyph.prototype.getMetrics = function() {\n    var commands = this.path.commands;\n    var xCoords = [];\n    var yCoords = [];\n    for(var i = 0; i < commands.length; i += 1){\n        var cmd = commands[i];\n        if (cmd.type !== \"Z\") {\n            xCoords.push(cmd.x);\n            yCoords.push(cmd.y);\n        }\n        if (cmd.type === \"Q\" || cmd.type === \"C\") {\n            xCoords.push(cmd.x1);\n            yCoords.push(cmd.y1);\n        }\n        if (cmd.type === \"C\") {\n            xCoords.push(cmd.x2);\n            yCoords.push(cmd.y2);\n        }\n    }\n    var metrics = {\n        xMin: Math.min.apply(null, xCoords),\n        yMin: Math.min.apply(null, yCoords),\n        xMax: Math.max.apply(null, xCoords),\n        yMax: Math.max.apply(null, yCoords),\n        leftSideBearing: this.leftSideBearing\n    };\n    if (!isFinite(metrics.xMin)) {\n        metrics.xMin = 0;\n    }\n    if (!isFinite(metrics.xMax)) {\n        metrics.xMax = this.advanceWidth;\n    }\n    if (!isFinite(metrics.yMin)) {\n        metrics.yMin = 0;\n    }\n    if (!isFinite(metrics.yMax)) {\n        metrics.yMax = 0;\n    }\n    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);\n    return metrics;\n};\n// The GlyphSet object\n// Define a property on the glyph that depends on the path being loaded.\nfunction defineDependentProperty(glyph, externalName, internalName) {\n    Object.defineProperty(glyph, externalName, {\n        get: function() {\n            // Request the path property to make sure the path is loaded.\n            glyph.path; // jshint ignore:line\n            return glyph[internalName];\n        },\n        set: function(newValue) {\n            glyph[internalName] = newValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\n/**\n * A GlyphSet represents all glyphs available in the font, but modelled using\n * a deferred glyph loader, for retrieving glyphs only once they are absolutely\n * necessary, to keep the memory footprint down.\n * @exports opentype.GlyphSet\n * @class\n * @param {opentype.Font}\n * @param {Array}\n */ function GlyphSet(font, glyphs) {\n    this.font = font;\n    this.glyphs = {};\n    if (Array.isArray(glyphs)) {\n        for(var i = 0; i < glyphs.length; i++){\n            var glyph = glyphs[i];\n            glyph.path.unitsPerEm = font.unitsPerEm;\n            this.glyphs[i] = glyph;\n        }\n    }\n    this.length = glyphs && glyphs.length || 0;\n}\n/**\n * @param  {number} index\n * @return {opentype.Glyph}\n */ GlyphSet.prototype.get = function(index) {\n    // this.glyphs[index] is 'undefined' when low memory mode is on. glyph is pushed on request only.\n    if (this.glyphs[index] === undefined) {\n        this.font._push(index);\n        if (typeof this.glyphs[index] === \"function\") {\n            this.glyphs[index] = this.glyphs[index]();\n        }\n        var glyph = this.glyphs[index];\n        var unicodeObj = this.font._IndexToUnicodeMap[index];\n        if (unicodeObj) {\n            for(var j = 0; j < unicodeObj.unicodes.length; j++){\n                glyph.addUnicode(unicodeObj.unicodes[j]);\n            }\n        }\n        this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;\n        this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;\n    } else {\n        if (typeof this.glyphs[index] === \"function\") {\n            this.glyphs[index] = this.glyphs[index]();\n        }\n    }\n    return this.glyphs[index];\n};\n/**\n * @param  {number} index\n * @param  {Object}\n */ GlyphSet.prototype.push = function(index, loader) {\n    this.glyphs[index] = loader;\n    this.length++;\n};\n/**\n * @alias opentype.glyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @return {opentype.Glyph}\n */ function glyphLoader(font, index) {\n    return new Glyph({\n        index: index,\n        font: font\n    });\n}\n/**\n * Generate a stub glyph that can be filled with all metadata *except*\n * the \"points\" and \"path\" properties, which must be loaded only once\n * the glyph's path is actually requested for text shaping.\n * @alias opentype.ttfGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseGlyph\n * @param  {Object} data\n * @param  {number} position\n * @param  {Function} buildPath\n * @return {opentype.Glyph}\n */ function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n    return function() {\n        var glyph = new Glyph({\n            index: index,\n            font: font\n        });\n        glyph.path = function() {\n            parseGlyph(glyph, data, position);\n            var path = buildPath(font.glyphs, glyph);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n        defineDependentProperty(glyph, \"xMin\", \"_xMin\");\n        defineDependentProperty(glyph, \"xMax\", \"_xMax\");\n        defineDependentProperty(glyph, \"yMin\", \"_yMin\");\n        defineDependentProperty(glyph, \"yMax\", \"_yMax\");\n        return glyph;\n    };\n}\n/**\n * @alias opentype.cffGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseCFFCharstring\n * @param  {string} charstring\n * @return {opentype.Glyph}\n */ function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n    return function() {\n        var glyph = new Glyph({\n            index: index,\n            font: font\n        });\n        glyph.path = function() {\n            var path = parseCFFCharstring(font, glyph, charstring);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n        return glyph;\n    };\n}\nvar glyphset = {\n    GlyphSet: GlyphSet,\n    glyphLoader: glyphLoader,\n    ttfGlyphLoader: ttfGlyphLoader,\n    cffGlyphLoader: cffGlyphLoader\n};\n// The Layout object is the prototype of Substitution objects, and provides\nfunction searchTag(arr, tag) {\n    /* jshint bitwise: false */ var imin = 0;\n    var imax = arr.length - 1;\n    while(imin <= imax){\n        var imid = imin + imax >>> 1;\n        var val = arr[imid].tag;\n        if (val === tag) {\n            return imid;\n        } else if (val < tag) {\n            imin = imid + 1;\n        } else {\n            imax = imid - 1;\n        }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\nfunction binSearch(arr, value) {\n    /* jshint bitwise: false */ var imin = 0;\n    var imax = arr.length - 1;\n    while(imin <= imax){\n        var imid = imin + imax >>> 1;\n        var val = arr[imid];\n        if (val === value) {\n            return imid;\n        } else if (val < value) {\n            imin = imid + 1;\n        } else {\n            imax = imid - 1;\n        }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n// binary search in a list of ranges (coverage, class definition)\nfunction searchRange(ranges, value) {\n    // jshint bitwise: false\n    var range;\n    var imin = 0;\n    var imax = ranges.length - 1;\n    while(imin <= imax){\n        var imid = imin + imax >>> 1;\n        range = ranges[imid];\n        var start = range.start;\n        if (start === value) {\n            return range;\n        } else if (start < value) {\n            imin = imid + 1;\n        } else {\n            imax = imid - 1;\n        }\n    }\n    if (imin > 0) {\n        range = ranges[imin - 1];\n        if (value > range.end) {\n            return 0;\n        }\n        return range;\n    }\n}\n/**\n * @exports opentype.Layout\n * @class\n */ function Layout(font, tableName) {\n    this.font = font;\n    this.tableName = tableName;\n}\nLayout.prototype = {\n    /**\n     * Binary search an object by \"tag\" property\n     * @instance\n     * @function searchTag\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {string} tag\n     * @return {number}\n     */ searchTag: searchTag,\n    /**\n     * Binary search in a list of numbers\n     * @instance\n     * @function binSearch\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {number} value\n     * @return {number}\n     */ binSearch: binSearch,\n    /**\n     * Get or create the Layout table (GSUB, GPOS etc).\n     * @param  {boolean} create - Whether to create a new one.\n     * @return {Object} The GSUB or GPOS table.\n     */ getTable: function(create) {\n        var layout = this.font.tables[this.tableName];\n        if (!layout && create) {\n            layout = this.font.tables[this.tableName] = this.createDefaultTable();\n        }\n        return layout;\n    },\n    /**\n     * Returns the best bet for a script name.\n     * Returns 'DFLT' if it exists.\n     * If not, returns 'latn' if it exists.\n     * If neither exist, returns undefined.\n     */ getDefaultScriptName: function() {\n        var layout = this.getTable();\n        if (!layout) {\n            return;\n        }\n        var hasLatn = false;\n        for(var i = 0; i < layout.scripts.length; i++){\n            var name = layout.scripts[i].tag;\n            if (name === \"DFLT\") {\n                return name;\n            }\n            if (name === \"latn\") {\n                hasLatn = true;\n            }\n        }\n        if (hasLatn) {\n            return \"latn\";\n        }\n    },\n    /**\n     * Returns all LangSysRecords in the given script.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n     * @return {Object} An object with tag and script properties.\n     */ getScriptTable: function(script, create) {\n        var layout = this.getTable(create);\n        if (layout) {\n            script = script || \"DFLT\";\n            var scripts = layout.scripts;\n            var pos = searchTag(layout.scripts, script);\n            if (pos >= 0) {\n                return scripts[pos].script;\n            } else if (create) {\n                var scr = {\n                    tag: script,\n                    script: {\n                        defaultLangSys: {\n                            reserved: 0,\n                            reqFeatureIndex: 0xffff,\n                            featureIndexes: []\n                        },\n                        langSysRecords: []\n                    }\n                };\n                scripts.splice(-1 - pos, 0, scr);\n                return scr.script;\n            }\n        }\n    },\n    /**\n     * Returns a language system table\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n     * @return {Object}\n     */ getLangSysTable: function(script, language, create) {\n        var scriptTable = this.getScriptTable(script, create);\n        if (scriptTable) {\n            if (!language || language === \"dflt\" || language === \"DFLT\") {\n                return scriptTable.defaultLangSys;\n            }\n            var pos = searchTag(scriptTable.langSysRecords, language);\n            if (pos >= 0) {\n                return scriptTable.langSysRecords[pos].langSys;\n            } else if (create) {\n                var langSysRecord = {\n                    tag: language,\n                    langSys: {\n                        reserved: 0,\n                        reqFeatureIndex: 0xffff,\n                        featureIndexes: []\n                    }\n                };\n                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);\n                return langSysRecord.langSys;\n            }\n        }\n    },\n    /**\n     * Get a specific feature table.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n     * @return {Object}\n     */ getFeatureTable: function(script, language, feature, create) {\n        var langSysTable = this.getLangSysTable(script, language, create);\n        if (langSysTable) {\n            var featureRecord;\n            var featIndexes = langSysTable.featureIndexes;\n            var allFeatures = this.font.tables[this.tableName].features;\n            // The FeatureIndex array of indices is in arbitrary order,\n            // even if allFeatures is sorted alphabetically by feature tag.\n            for(var i = 0; i < featIndexes.length; i++){\n                featureRecord = allFeatures[featIndexes[i]];\n                if (featureRecord.tag === feature) {\n                    return featureRecord.feature;\n                }\n            }\n            if (create) {\n                var index = allFeatures.length;\n                // Automatic ordering of features would require to shift feature indexes in the script list.\n                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, \"Features must be added in alphabetical order.\");\n                featureRecord = {\n                    tag: feature,\n                    feature: {\n                        params: 0,\n                        lookupListIndexes: []\n                    }\n                };\n                allFeatures.push(featureRecord);\n                featIndexes.push(index);\n                return featureRecord.feature;\n            }\n        }\n    },\n    /**\n     * Get the lookup tables of a given type for a script/language/feature.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - 4-letter feature code\n     * @param {number} lookupType - 1 to 9\n     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n     * @return {Object[]}\n     */ getLookupTables: function(script, language, feature, lookupType, create) {\n        var featureTable = this.getFeatureTable(script, language, feature, create);\n        var tables = [];\n        if (featureTable) {\n            var lookupTable;\n            var lookupListIndexes = featureTable.lookupListIndexes;\n            var allLookups = this.font.tables[this.tableName].lookups;\n            // lookupListIndexes are in no particular order, so use naive search.\n            for(var i = 0; i < lookupListIndexes.length; i++){\n                lookupTable = allLookups[lookupListIndexes[i]];\n                if (lookupTable.lookupType === lookupType) {\n                    tables.push(lookupTable);\n                }\n            }\n            if (tables.length === 0 && create) {\n                lookupTable = {\n                    lookupType: lookupType,\n                    lookupFlag: 0,\n                    subtables: [],\n                    markFilteringSet: undefined\n                };\n                var index = allLookups.length;\n                allLookups.push(lookupTable);\n                lookupListIndexes.push(index);\n                return [\n                    lookupTable\n                ];\n            }\n        }\n        return tables;\n    },\n    /**\n     * Find a glyph in a class definition table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table\n     * @param {object} classDefTable - an OpenType Layout class definition table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */ getGlyphClass: function(classDefTable, glyphIndex) {\n        switch(classDefTable.format){\n            case 1:\n                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {\n                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];\n                }\n                return 0;\n            case 2:\n                var range = searchRange(classDefTable.ranges, glyphIndex);\n                return range ? range.classId : 0;\n        }\n    },\n    /**\n     * Find a glyph in a coverage table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table\n     * @param {object} coverageTable - an OpenType Layout coverage table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */ getCoverageIndex: function(coverageTable, glyphIndex) {\n        switch(coverageTable.format){\n            case 1:\n                var index = binSearch(coverageTable.glyphs, glyphIndex);\n                return index >= 0 ? index : -1;\n            case 2:\n                var range = searchRange(coverageTable.ranges, glyphIndex);\n                return range ? range.index + glyphIndex - range.start : -1;\n        }\n    },\n    /**\n     * Returns the list of glyph indexes of a coverage table.\n     * Format 1: the list is stored raw\n     * Format 2: compact list as range records.\n     * @instance\n     * @param  {Object} coverageTable\n     * @return {Array}\n     */ expandCoverage: function(coverageTable) {\n        if (coverageTable.format === 1) {\n            return coverageTable.glyphs;\n        } else {\n            var glyphs = [];\n            var ranges = coverageTable.ranges;\n            for(var i = 0; i < ranges.length; i++){\n                var range = ranges[i];\n                var start = range.start;\n                var end = range.end;\n                for(var j = start; j <= end; j++){\n                    glyphs.push(j);\n                }\n            }\n            return glyphs;\n        }\n    }\n};\n// The Position object provides utility methods to manipulate\n/**\n * @exports opentype.Position\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */ function Position(font) {\n    Layout.call(this, font, \"gpos\");\n}\nPosition.prototype = Layout.prototype;\n/**\n * Init some data for faster and easier access later.\n */ Position.prototype.init = function() {\n    var script = this.getDefaultScriptName();\n    this.defaultKerningTables = this.getKerningTables(script);\n};\n/**\n * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.\n *\n * @param {integer} leftIndex - left glyph index\n * @param {integer} rightIndex - right glyph index\n * @returns {integer}\n */ Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {\n    for(var i = 0; i < kerningLookups.length; i++){\n        var subtables = kerningLookups[i].subtables;\n        for(var j = 0; j < subtables.length; j++){\n            var subtable = subtables[j];\n            var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);\n            if (covIndex < 0) {\n                continue;\n            }\n            switch(subtable.posFormat){\n                case 1:\n                    // Search Pair Adjustment Positioning Format 1\n                    var pairSet = subtable.pairSets[covIndex];\n                    for(var k = 0; k < pairSet.length; k++){\n                        var pair = pairSet[k];\n                        if (pair.secondGlyph === rightIndex) {\n                            return pair.value1 && pair.value1.xAdvance || 0;\n                        }\n                    }\n                    break; // left glyph found, not right glyph - try next subtable\n                case 2:\n                    // Search Pair Adjustment Positioning Format 2\n                    var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);\n                    var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);\n                    var pair$1 = subtable.classRecords[class1][class2];\n                    return pair$1.value1 && pair$1.value1.xAdvance || 0;\n            }\n        }\n    }\n    return 0;\n};\n/**\n * List all kerning lookup tables.\n *\n * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value\n * @param {string} [language='dflt']\n * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)\n */ Position.prototype.getKerningTables = function(script, language) {\n    if (this.font.tables.gpos) {\n        return this.getLookupTables(script, language, \"kern\", 2);\n    }\n};\n// The Substitution object provides utility methods to manipulate\n/**\n * @exports opentype.Substitution\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */ function Substitution(font) {\n    Layout.call(this, font, \"gsub\");\n}\n// Check if 2 arrays of primitives are equal.\nfunction arraysEqual(ar1, ar2) {\n    var n = ar1.length;\n    if (n !== ar2.length) {\n        return false;\n    }\n    for(var i = 0; i < n; i++){\n        if (ar1[i] !== ar2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n// Find the first subtable of a lookup table in a particular format.\nfunction getSubstFormat(lookupTable, format, defaultSubtable) {\n    var subtables = lookupTable.subtables;\n    for(var i = 0; i < subtables.length; i++){\n        var subtable = subtables[i];\n        if (subtable.substFormat === format) {\n            return subtable;\n        }\n    }\n    if (defaultSubtable) {\n        subtables.push(defaultSubtable);\n        return defaultSubtable;\n    }\n    return undefined;\n}\nSubstitution.prototype = Layout.prototype;\n/**\n * Create a default GSUB table.\n * @return {Object} gsub - The GSUB table.\n */ Substitution.prototype.createDefaultTable = function() {\n    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.\n    return {\n        version: 1,\n        scripts: [\n            {\n                tag: \"DFLT\",\n                script: {\n                    defaultLangSys: {\n                        reserved: 0,\n                        reqFeatureIndex: 0xffff,\n                        featureIndexes: []\n                    },\n                    langSysRecords: []\n                }\n            }\n        ],\n        features: [],\n        lookups: []\n    };\n};\n/**\n * List all single substitutions (lookup type 1) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)\n * @return {Array} substitutions - The list of substitutions.\n */ Substitution.prototype.getSingle = function(feature, script, language) {\n    var substitutions = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 1);\n    for(var idx = 0; idx < lookupTables.length; idx++){\n        var subtables = lookupTables[idx].subtables;\n        for(var i = 0; i < subtables.length; i++){\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var j = void 0;\n            if (subtable.substFormat === 1) {\n                var delta = subtable.deltaGlyphId;\n                for(j = 0; j < glyphs.length; j++){\n                    var glyph = glyphs[j];\n                    substitutions.push({\n                        sub: glyph,\n                        by: glyph + delta\n                    });\n                }\n            } else {\n                var substitute = subtable.substitute;\n                for(j = 0; j < glyphs.length; j++){\n                    substitutions.push({\n                        sub: glyphs[j],\n                        by: substitute[j]\n                    });\n                }\n            }\n        }\n    }\n    return substitutions;\n};\n/**\n * List all multiple substitutions (lookup type 2) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('ccmp', 'stch')\n * @return {Array} substitutions - The list of substitutions.\n */ Substitution.prototype.getMultiple = function(feature, script, language) {\n    var substitutions = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 2);\n    for(var idx = 0; idx < lookupTables.length; idx++){\n        var subtables = lookupTables[idx].subtables;\n        for(var i = 0; i < subtables.length; i++){\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var j = void 0;\n            for(j = 0; j < glyphs.length; j++){\n                var glyph = glyphs[j];\n                var replacements = subtable.sequences[j];\n                substitutions.push({\n                    sub: glyph,\n                    by: replacements\n                });\n            }\n        }\n    }\n    return substitutions;\n};\n/**\n * List all alternates (lookup type 3) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt'...)\n * @return {Array} alternates - The list of alternates\n */ Substitution.prototype.getAlternates = function(feature, script, language) {\n    var alternates = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 3);\n    for(var idx = 0; idx < lookupTables.length; idx++){\n        var subtables = lookupTables[idx].subtables;\n        for(var i = 0; i < subtables.length; i++){\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var alternateSets = subtable.alternateSets;\n            for(var j = 0; j < glyphs.length; j++){\n                alternates.push({\n                    sub: glyphs[j],\n                    by: alternateSets[j]\n                });\n            }\n        }\n    }\n    return alternates;\n};\n/**\n * List all ligatures (lookup type 4) for a given script, language, and feature.\n * The result is an array of ligature objects like { sub: [ids], by: id }\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} ligatures - The list of ligatures.\n */ Substitution.prototype.getLigatures = function(feature, script, language) {\n    var ligatures = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 4);\n    for(var idx = 0; idx < lookupTables.length; idx++){\n        var subtables = lookupTables[idx].subtables;\n        for(var i = 0; i < subtables.length; i++){\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var ligatureSets = subtable.ligatureSets;\n            for(var j = 0; j < glyphs.length; j++){\n                var startGlyph = glyphs[j];\n                var ligSet = ligatureSets[j];\n                for(var k = 0; k < ligSet.length; k++){\n                    var lig = ligSet[k];\n                    ligatures.push({\n                        sub: [\n                            startGlyph\n                        ].concat(lig.components),\n                        by: lig.ligGlyph\n                    });\n                }\n            }\n        }\n    }\n    return ligatures;\n};\n/**\n * Add or modify a single substitution (lookup type 1)\n * Format 2, more flexible, is always used.\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: id } (format 1 is not supported)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */ Substitution.prototype.addSingle = function(feature, substitution, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];\n    var subtable = getSubstFormat(lookupTable, 2, {\n        // lookup type 1 subtable, format 2, coverage format 1\n        substFormat: 2,\n        coverage: {\n            format: 1,\n            glyphs: []\n        },\n        substitute: []\n    });\n    check.assert(subtable.coverage.format === 1, \"Single: unable to modify coverage table format \" + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.substitute.splice(pos, 0, 0);\n    }\n    subtable.substitute[pos] = substitution.by;\n};\n/**\n * Add or modify a multiple substitution (lookup type 2)\n * @param {string} feature - 4-letter feature name ('ccmp', 'stch')\n * @param {Object} substitution - { sub: id, by: [id] } for format 2.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */ Substitution.prototype.addMultiple = function(feature, substitution, script, language) {\n    check.assert(substitution.by instanceof Array && substitution.by.length > 1, 'Multiple: \"by\" must be an array of two or more ids');\n    var lookupTable = this.getLookupTables(script, language, feature, 2, true)[0];\n    var subtable = getSubstFormat(lookupTable, 1, {\n        // lookup type 2 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: {\n            format: 1,\n            glyphs: []\n        },\n        sequences: []\n    });\n    check.assert(subtable.coverage.format === 1, \"Multiple: unable to modify coverage table format \" + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.sequences.splice(pos, 0, 0);\n    }\n    subtable.sequences[pos] = substitution.by;\n};\n/**\n * Add or modify an alternate substitution (lookup type 3)\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: [ids] }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */ Substitution.prototype.addAlternate = function(feature, substitution, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];\n    var subtable = getSubstFormat(lookupTable, 1, {\n        // lookup type 3 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: {\n            format: 1,\n            glyphs: []\n        },\n        alternateSets: []\n    });\n    check.assert(subtable.coverage.format === 1, \"Alternate: unable to modify coverage table format \" + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.alternateSets.splice(pos, 0, 0);\n    }\n    subtable.alternateSets[pos] = substitution.by;\n};\n/**\n * Add a ligature (lookup type 4)\n * Ligatures with more components must be stored ahead of those with fewer components in order to be found\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} ligature - { sub: [ids], by: id }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */ Substitution.prototype.addLigature = function(feature, ligature, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];\n    var subtable = lookupTable.subtables[0];\n    if (!subtable) {\n        subtable = {\n            // lookup type 4 subtable, format 1, coverage format 1\n            substFormat: 1,\n            coverage: {\n                format: 1,\n                glyphs: []\n            },\n            ligatureSets: []\n        };\n        lookupTable.subtables[0] = subtable;\n    }\n    check.assert(subtable.coverage.format === 1, \"Ligature: unable to modify coverage table format \" + subtable.coverage.format);\n    var coverageGlyph = ligature.sub[0];\n    var ligComponents = ligature.sub.slice(1);\n    var ligatureTable = {\n        ligGlyph: ligature.by,\n        components: ligComponents\n    };\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos >= 0) {\n        // ligatureSet already exists\n        var ligatureSet = subtable.ligatureSets[pos];\n        for(var i = 0; i < ligatureSet.length; i++){\n            // If ligature already exists, return.\n            if (arraysEqual(ligatureSet[i].components, ligComponents)) {\n                return;\n            }\n        }\n        // ligature does not exist: add it.\n        ligatureSet.push(ligatureTable);\n    } else {\n        // Create a new ligatureSet and add coverage for the first glyph.\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.ligatureSets.splice(pos, 0, [\n            ligatureTable\n        ]);\n    }\n};\n/**\n * List all feature data for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} substitutions - The list of substitutions.\n */ Substitution.prototype.getFeature = function(feature, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n        // ss01 - ss20\n        return this.getSingle(feature, script, language);\n    }\n    switch(feature){\n        case \"aalt\":\n        case \"salt\":\n            return this.getSingle(feature, script, language).concat(this.getAlternates(feature, script, language));\n        case \"dlig\":\n        case \"liga\":\n        case \"rlig\":\n            return this.getLigatures(feature, script, language);\n        case \"ccmp\":\n            return this.getMultiple(feature, script, language).concat(this.getLigatures(feature, script, language));\n        case \"stch\":\n            return this.getMultiple(feature, script, language);\n    }\n    return undefined;\n};\n/**\n * Add a substitution to a feature for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */ Substitution.prototype.add = function(feature, sub, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n        // ss01 - ss20\n        return this.addSingle(feature, sub, script, language);\n    }\n    switch(feature){\n        case \"aalt\":\n        case \"salt\":\n            if (typeof sub.by === \"number\") {\n                return this.addSingle(feature, sub, script, language);\n            }\n            return this.addAlternate(feature, sub, script, language);\n        case \"dlig\":\n        case \"liga\":\n        case \"rlig\":\n            return this.addLigature(feature, sub, script, language);\n        case \"ccmp\":\n            if (sub.by instanceof Array) {\n                return this.addMultiple(feature, sub, script, language);\n            }\n            return this.addLigature(feature, sub, script, language);\n    }\n    return undefined;\n};\nfunction checkArgument(expression, message) {\n    if (!expression) {\n        throw message;\n    }\n}\n// Parsing utility functions\n// Retrieve an unsigned byte from the DataView.\nfunction getByte(dataView, offset) {\n    return dataView.getUint8(offset);\n}\n// Retrieve an unsigned 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getUShort(dataView, offset) {\n    return dataView.getUint16(offset, false);\n}\n// Retrieve a signed 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getShort(dataView, offset) {\n    return dataView.getInt16(offset, false);\n}\n// Retrieve an unsigned 32-bit long from the DataView.\n// The value is stored in big endian.\nfunction getULong(dataView, offset) {\n    return dataView.getUint32(offset, false);\n}\n// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n// The value is stored in big endian.\nfunction getFixed(dataView, offset) {\n    var decimal = dataView.getInt16(offset, false);\n    var fraction = dataView.getUint16(offset + 2, false);\n    return decimal + fraction / 65535;\n}\n// Retrieve a 4-character tag from the DataView.\n// Tags are used to identify tables.\nfunction getTag(dataView, offset) {\n    var tag = \"\";\n    for(var i = offset; i < offset + 4; i += 1){\n        tag += String.fromCharCode(dataView.getInt8(i));\n    }\n    return tag;\n}\n// Retrieve an offset from the DataView.\n// Offsets are 1 to 4 bytes in length, depending on the offSize argument.\nfunction getOffset(dataView, offset, offSize) {\n    var v = 0;\n    for(var i = 0; i < offSize; i += 1){\n        v <<= 8;\n        v += dataView.getUint8(offset + i);\n    }\n    return v;\n}\n// Retrieve a number of bytes from start offset to the end offset from the DataView.\nfunction getBytes(dataView, startOffset, endOffset) {\n    var bytes = [];\n    for(var i = startOffset; i < endOffset; i += 1){\n        bytes.push(dataView.getUint8(i));\n    }\n    return bytes;\n}\n// Convert the list of bytes to a string.\nfunction bytesToString(bytes) {\n    var s = \"\";\n    for(var i = 0; i < bytes.length; i += 1){\n        s += String.fromCharCode(bytes[i]);\n    }\n    return s;\n}\nvar typeOffsets = {\n    byte: 1,\n    uShort: 2,\n    short: 2,\n    uLong: 4,\n    fixed: 4,\n    longDateTime: 8,\n    tag: 4\n};\n// A stateful parser that changes the offset whenever a value is retrieved.\n// The data is a DataView.\nfunction Parser(data, offset) {\n    this.data = data;\n    this.offset = offset;\n    this.relativeOffset = 0;\n}\nParser.prototype.parseByte = function() {\n    var v = this.data.getUint8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\nParser.prototype.parseChar = function() {\n    var v = this.data.getInt8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\nParser.prototype.parseCard8 = Parser.prototype.parseByte;\nParser.prototype.parseUShort = function() {\n    var v = this.data.getUint16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\nParser.prototype.parseCard16 = Parser.prototype.parseUShort;\nParser.prototype.parseSID = Parser.prototype.parseUShort;\nParser.prototype.parseOffset16 = Parser.prototype.parseUShort;\nParser.prototype.parseShort = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\nParser.prototype.parseF2Dot14 = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n    this.relativeOffset += 2;\n    return v;\n};\nParser.prototype.parseULong = function() {\n    var v = getULong(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\nParser.prototype.parseOffset32 = Parser.prototype.parseULong;\nParser.prototype.parseFixed = function() {\n    var v = getFixed(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\nParser.prototype.parseString = function(length) {\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    var string = \"\";\n    this.relativeOffset += length;\n    for(var i = 0; i < length; i++){\n        string += String.fromCharCode(dataView.getUint8(offset + i));\n    }\n    return string;\n};\nParser.prototype.parseTag = function() {\n    return this.parseString(4);\n};\n// LONGDATETIME is a 64-bit integer.\n// JavaScript and unix timestamps traditionally use 32 bits, so we\n// only take the last 32 bits.\n// + Since until 2038 those bits will be filled by zeros we can ignore them.\nParser.prototype.parseLongDateTime = function() {\n    var v = getULong(this.data, this.offset + this.relativeOffset + 4);\n    // Subtract seconds between 01/01/1904 and 01/01/1970\n    // to convert Apple Mac timestamp to Standard Unix timestamp\n    v -= 2082844800;\n    this.relativeOffset += 8;\n    return v;\n};\nParser.prototype.parseVersion = function(minorBase) {\n    var major = getUShort(this.data, this.offset + this.relativeOffset);\n    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n    // Default returns the correct number if minor = 0xN000 where N is 0-9\n    // Set minorBase to 1 for tables that use minor = N where N is 0-9\n    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);\n    this.relativeOffset += 4;\n    if (minorBase === undefined) {\n        minorBase = 0x1000;\n    }\n    return major + minor / minorBase / 10;\n};\nParser.prototype.skip = function(type, amount) {\n    if (amount === undefined) {\n        amount = 1;\n    }\n    this.relativeOffset += typeOffsets[type] * amount;\n};\n///// Parsing lists and records ///////////////////////////////\n// Parse a list of 32 bit unsigned integers.\nParser.prototype.parseULongList = function(count) {\n    if (count === undefined) {\n        count = this.parseULong();\n    }\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for(var i = 0; i < count; i++){\n        offsets[i] = dataView.getUint32(offset);\n        offset += 4;\n    }\n    this.relativeOffset += count * 4;\n    return offsets;\n};\n// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n// or provided as an argument.\nParser.prototype.parseOffset16List = Parser.prototype.parseUShortList = function(count) {\n    if (count === undefined) {\n        count = this.parseUShort();\n    }\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for(var i = 0; i < count; i++){\n        offsets[i] = dataView.getUint16(offset);\n        offset += 2;\n    }\n    this.relativeOffset += count * 2;\n    return offsets;\n};\n// Parses a list of 16 bit signed integers.\nParser.prototype.parseShortList = function(count) {\n    var list = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for(var i = 0; i < count; i++){\n        list[i] = dataView.getInt16(offset);\n        offset += 2;\n    }\n    this.relativeOffset += count * 2;\n    return list;\n};\n// Parses a list of bytes.\nParser.prototype.parseByteList = function(count) {\n    var list = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for(var i = 0; i < count; i++){\n        list[i] = dataView.getUint8(offset++);\n    }\n    this.relativeOffset += count;\n    return list;\n};\n/**\n * Parse a list of items.\n * Record count is optional, if omitted it is read from the stream.\n * itemCallback is one of the Parser methods.\n */ Parser.prototype.parseList = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseUShort();\n    }\n    var list = new Array(count);\n    for(var i = 0; i < count; i++){\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\nParser.prototype.parseList32 = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseULong();\n    }\n    var list = new Array(count);\n    for(var i = 0; i < count; i++){\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n/**\n * Parse a list of records.\n * Record count is optional, if omitted it is read from the stream.\n * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n */ Parser.prototype.parseRecordList = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseUShort();\n    }\n    var records = new Array(count);\n    var fields = Object.keys(recordDescription);\n    for(var i = 0; i < count; i++){\n        var rec = {};\n        for(var j = 0; j < fields.length; j++){\n            var fieldName = fields[j];\n            var fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\nParser.prototype.parseRecordList32 = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseULong();\n    }\n    var records = new Array(count);\n    var fields = Object.keys(recordDescription);\n    for(var i = 0; i < count; i++){\n        var rec = {};\n        for(var j = 0; j < fields.length; j++){\n            var fieldName = fields[j];\n            var fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n// Parse a data structure into an object\n// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\nParser.prototype.parseStruct = function(description) {\n    if (typeof description === \"function\") {\n        return description.call(this);\n    } else {\n        var fields = Object.keys(description);\n        var struct = {};\n        for(var j = 0; j < fields.length; j++){\n            var fieldName = fields[j];\n            var fieldType = description[fieldName];\n            struct[fieldName] = fieldType.call(this);\n        }\n        return struct;\n    }\n};\n/**\n * Parse a GPOS valueRecord\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat is optional, if omitted it is read from the stream.\n */ Parser.prototype.parseValueRecord = function(valueFormat) {\n    if (valueFormat === undefined) {\n        valueFormat = this.parseUShort();\n    }\n    if (valueFormat === 0) {\n        // valueFormat2 in kerning pairs is most often 0\n        // in this case return undefined instead of an empty object, to save space\n        return;\n    }\n    var valueRecord = {};\n    if (valueFormat & 0x0001) {\n        valueRecord.xPlacement = this.parseShort();\n    }\n    if (valueFormat & 0x0002) {\n        valueRecord.yPlacement = this.parseShort();\n    }\n    if (valueFormat & 0x0004) {\n        valueRecord.xAdvance = this.parseShort();\n    }\n    if (valueFormat & 0x0008) {\n        valueRecord.yAdvance = this.parseShort();\n    }\n    // Device table (non-variable font) / VariationIndex table (variable font) not supported\n    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls\n    if (valueFormat & 0x0010) {\n        valueRecord.xPlaDevice = undefined;\n        this.parseShort();\n    }\n    if (valueFormat & 0x0020) {\n        valueRecord.yPlaDevice = undefined;\n        this.parseShort();\n    }\n    if (valueFormat & 0x0040) {\n        valueRecord.xAdvDevice = undefined;\n        this.parseShort();\n    }\n    if (valueFormat & 0x0080) {\n        valueRecord.yAdvDevice = undefined;\n        this.parseShort();\n    }\n    return valueRecord;\n};\n/**\n * Parse a list of GPOS valueRecords\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat and valueCount are read from the stream.\n */ Parser.prototype.parseValueRecordList = function() {\n    var valueFormat = this.parseUShort();\n    var valueCount = this.parseUShort();\n    var values = new Array(valueCount);\n    for(var i = 0; i < valueCount; i++){\n        values[i] = this.parseValueRecord(valueFormat);\n    }\n    return values;\n};\nParser.prototype.parsePointer = function(description) {\n    var structOffset = this.parseOffset16();\n    if (structOffset > 0) {\n        // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\nParser.prototype.parsePointer32 = function(description) {\n    var structOffset = this.parseOffset32();\n    if (structOffset > 0) {\n        // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n/**\n * Parse a list of offsets to lists of 16-bit integers,\n * or a list of offsets to lists of offsets to any kind of items.\n * If itemCallback is not provided, a list of list of UShort is assumed.\n * If provided, itemCallback is called on each item and must parse the item.\n * See examples in tables/gsub.js\n */ Parser.prototype.parseListOfLists = function(itemCallback) {\n    var offsets = this.parseOffset16List();\n    var count = offsets.length;\n    var relativeOffset = this.relativeOffset;\n    var list = new Array(count);\n    for(var i = 0; i < count; i++){\n        var start = offsets[i];\n        if (start === 0) {\n            // NULL offset\n            // Add i as owned property to list. Convenient with assert.\n            list[i] = undefined;\n            continue;\n        }\n        this.relativeOffset = start;\n        if (itemCallback) {\n            var subOffsets = this.parseOffset16List();\n            var subList = new Array(subOffsets.length);\n            for(var j = 0; j < subOffsets.length; j++){\n                this.relativeOffset = start + subOffsets[j];\n                subList[j] = itemCallback.call(this);\n            }\n            list[i] = subList;\n        } else {\n            list[i] = this.parseUShortList();\n        }\n    }\n    this.relativeOffset = relativeOffset;\n    return list;\n};\n///// Complex tables parsing //////////////////////////////////\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n// parser.offset must point to the start of the table containing the coverage.\nParser.prototype.parseCoverage = function() {\n    var startOffset = this.offset + this.relativeOffset;\n    var format = this.parseUShort();\n    var count = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            glyphs: this.parseUShortList(count)\n        };\n    } else if (format === 2) {\n        var ranges = new Array(count);\n        for(var i = 0; i < count; i++){\n            ranges[i] = {\n                start: this.parseUShort(),\n                end: this.parseUShort(),\n                index: this.parseUShort()\n            };\n        }\n        return {\n            format: 2,\n            ranges: ranges\n        };\n    }\n    throw new Error(\"0x\" + startOffset.toString(16) + \": Coverage format must be 1 or 2.\");\n};\n// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\nParser.prototype.parseClassDef = function() {\n    var startOffset = this.offset + this.relativeOffset;\n    var format = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            startGlyph: this.parseUShort(),\n            classes: this.parseUShortList()\n        };\n    } else if (format === 2) {\n        return {\n            format: 2,\n            ranges: this.parseRecordList({\n                start: Parser.uShort,\n                end: Parser.uShort,\n                classId: Parser.uShort\n            })\n        };\n    }\n    throw new Error(\"0x\" + startOffset.toString(16) + \": ClassDef format must be 1 or 2.\");\n};\n///// Static methods ///////////////////////////////////\n// These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\nParser.list = function(count, itemCallback) {\n    return function() {\n        return this.parseList(count, itemCallback);\n    };\n};\nParser.list32 = function(count, itemCallback) {\n    return function() {\n        return this.parseList32(count, itemCallback);\n    };\n};\nParser.recordList = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList(count, recordDescription);\n    };\n};\nParser.recordList32 = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList32(count, recordDescription);\n    };\n};\nParser.pointer = function(description) {\n    return function() {\n        return this.parsePointer(description);\n    };\n};\nParser.pointer32 = function(description) {\n    return function() {\n        return this.parsePointer32(description);\n    };\n};\nParser.tag = Parser.prototype.parseTag;\nParser.byte = Parser.prototype.parseByte;\nParser.uShort = Parser.offset16 = Parser.prototype.parseUShort;\nParser.uShortList = Parser.prototype.parseUShortList;\nParser.uLong = Parser.offset32 = Parser.prototype.parseULong;\nParser.uLongList = Parser.prototype.parseULongList;\nParser.struct = Parser.prototype.parseStruct;\nParser.coverage = Parser.prototype.parseCoverage;\nParser.classDef = Parser.prototype.parseClassDef;\n///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\nvar langSysTable = {\n    reserved: Parser.uShort,\n    reqFeatureIndex: Parser.uShort,\n    featureIndexes: Parser.uShortList\n};\nParser.prototype.parseScriptList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        script: Parser.pointer({\n            defaultLangSys: Parser.pointer(langSysTable),\n            langSysRecords: Parser.recordList({\n                tag: Parser.tag,\n                langSys: Parser.pointer(langSysTable)\n            })\n        })\n    })) || [];\n};\nParser.prototype.parseFeatureList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        feature: Parser.pointer({\n            featureParams: Parser.offset16,\n            lookupListIndexes: Parser.uShortList\n        })\n    })) || [];\n};\nParser.prototype.parseLookupList = function(lookupTableParsers) {\n    return this.parsePointer(Parser.list(Parser.pointer(function() {\n        var lookupType = this.parseUShort();\n        check.argument(1 <= lookupType && lookupType <= 9, \"GPOS/GSUB lookup type \" + lookupType + \" unknown.\");\n        var lookupFlag = this.parseUShort();\n        var useMarkFilteringSet = lookupFlag & 0x10;\n        return {\n            lookupType: lookupType,\n            lookupFlag: lookupFlag,\n            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined\n        };\n    }))) || [];\n};\nParser.prototype.parseFeatureVariationsList = function() {\n    return this.parsePointer32(function() {\n        var majorVersion = this.parseUShort();\n        var minorVersion = this.parseUShort();\n        check.argument(majorVersion === 1 && minorVersion < 1, \"GPOS/GSUB feature variations table unknown.\");\n        var featureVariations = this.parseRecordList32({\n            conditionSetOffset: Parser.offset32,\n            featureTableSubstitutionOffset: Parser.offset32\n        });\n        return featureVariations;\n    }) || [];\n};\nvar parse = {\n    getByte: getByte,\n    getCard8: getByte,\n    getUShort: getUShort,\n    getCard16: getUShort,\n    getShort: getShort,\n    getULong: getULong,\n    getFixed: getFixed,\n    getTag: getTag,\n    getOffset: getOffset,\n    getBytes: getBytes,\n    bytesToString: bytesToString,\n    Parser: Parser\n};\n// The `glyf` table describes the glyphs in TrueType outline format.\n// Parse the coordinate data for a glyph.\nfunction parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n    var v;\n    if ((flag & shortVectorBitMask) > 0) {\n        // The coordinate is 1 byte long.\n        v = p.parseByte();\n        // The `same` bit is re-used for short values to signify the sign of the value.\n        if ((flag & sameBitMask) === 0) {\n            v = -v;\n        }\n        v = previousValue + v;\n    } else {\n        //  The coordinate is 2 bytes long.\n        // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n        if ((flag & sameBitMask) > 0) {\n            v = previousValue;\n        } else {\n            // Parse the coordinate as a signed 16-bit delta value.\n            v = previousValue + p.parseShort();\n        }\n    }\n    return v;\n}\n// Parse a TrueType glyph.\nfunction parseGlyph(glyph, data, start) {\n    var p = new parse.Parser(data, start);\n    glyph.numberOfContours = p.parseShort();\n    glyph._xMin = p.parseShort();\n    glyph._yMin = p.parseShort();\n    glyph._xMax = p.parseShort();\n    glyph._yMax = p.parseShort();\n    var flags;\n    var flag;\n    if (glyph.numberOfContours > 0) {\n        // This glyph is not a composite.\n        var endPointIndices = glyph.endPointIndices = [];\n        for(var i = 0; i < glyph.numberOfContours; i += 1){\n            endPointIndices.push(p.parseUShort());\n        }\n        glyph.instructionLength = p.parseUShort();\n        glyph.instructions = [];\n        for(var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1){\n            glyph.instructions.push(p.parseByte());\n        }\n        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n        flags = [];\n        for(var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1){\n            flag = p.parseByte();\n            flags.push(flag);\n            // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n            if ((flag & 8) > 0) {\n                var repeatCount = p.parseByte();\n                for(var j = 0; j < repeatCount; j += 1){\n                    flags.push(flag);\n                    i$2 += 1;\n                }\n            }\n        }\n        check.argument(flags.length === numberOfCoordinates, \"Bad flags.\");\n        if (endPointIndices.length > 0) {\n            var points = [];\n            var point;\n            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n            if (numberOfCoordinates > 0) {\n                for(var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1){\n                    flag = flags[i$3];\n                    point = {};\n                    point.onCurve = !!(flag & 1);\n                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;\n                    points.push(point);\n                }\n                var px = 0;\n                for(var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1){\n                    flag = flags[i$4];\n                    point = points[i$4];\n                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n                    px = point.x;\n                }\n                var py = 0;\n                for(var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1){\n                    flag = flags[i$5];\n                    point = points[i$5];\n                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n                    py = point.y;\n                }\n            }\n            glyph.points = points;\n        } else {\n            glyph.points = [];\n        }\n    } else if (glyph.numberOfContours === 0) {\n        glyph.points = [];\n    } else {\n        glyph.isComposite = true;\n        glyph.points = [];\n        glyph.components = [];\n        var moreComponents = true;\n        while(moreComponents){\n            flags = p.parseUShort();\n            var component = {\n                glyphIndex: p.parseUShort(),\n                xScale: 1,\n                scale01: 0,\n                scale10: 0,\n                yScale: 1,\n                dx: 0,\n                dy: 0\n            };\n            if ((flags & 1) > 0) {\n                // The arguments are words\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseShort();\n                    component.dy = p.parseShort();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [\n                        p.parseUShort(),\n                        p.parseUShort()\n                    ];\n                }\n            } else {\n                // The arguments are bytes\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseChar();\n                    component.dy = p.parseChar();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [\n                        p.parseByte(),\n                        p.parseByte()\n                    ];\n                }\n            }\n            if ((flags & 8) > 0) {\n                // We have a scale\n                component.xScale = component.yScale = p.parseF2Dot14();\n            } else if ((flags & 64) > 0) {\n                // We have an X / Y scale\n                component.xScale = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            } else if ((flags & 128) > 0) {\n                // We have a 2x2 transformation\n                component.xScale = p.parseF2Dot14();\n                component.scale01 = p.parseF2Dot14();\n                component.scale10 = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            }\n            glyph.components.push(component);\n            moreComponents = !!(flags & 32);\n        }\n        if (flags & 0x100) {\n            // We have instructions\n            glyph.instructionLength = p.parseUShort();\n            glyph.instructions = [];\n            for(var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1){\n                glyph.instructions.push(p.parseByte());\n            }\n        }\n    }\n}\n// Transform an array of points and return a new array.\nfunction transformPoints(points, transform) {\n    var newPoints = [];\n    for(var i = 0; i < points.length; i += 1){\n        var pt = points[i];\n        var newPt = {\n            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n            onCurve: pt.onCurve,\n            lastPointOfContour: pt.lastPointOfContour\n        };\n        newPoints.push(newPt);\n    }\n    return newPoints;\n}\nfunction getContours(points) {\n    var contours = [];\n    var currentContour = [];\n    for(var i = 0; i < points.length; i += 1){\n        var pt = points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n    check.argument(currentContour.length === 0, \"There are still points left in the current contour.\");\n    return contours;\n}\n// Convert the TrueType glyph outline to a Path.\nfunction getPath(points) {\n    var p = new Path();\n    if (!points) {\n        return p;\n    }\n    var contours = getContours(points);\n    for(var contourIndex = 0; contourIndex < contours.length; ++contourIndex){\n        var contour = contours[contourIndex];\n        var prev = null;\n        var curr = contour[contour.length - 1];\n        var next = contour[0];\n        if (curr.onCurve) {\n            p.moveTo(curr.x, curr.y);\n        } else {\n            if (next.onCurve) {\n                p.moveTo(next.x, next.y);\n            } else {\n                // If both first and last points are off-curve, start at their middle.\n                var start = {\n                    x: (curr.x + next.x) * 0.5,\n                    y: (curr.y + next.y) * 0.5\n                };\n                p.moveTo(start.x, start.y);\n            }\n        }\n        for(var i = 0; i < contour.length; ++i){\n            prev = curr;\n            curr = next;\n            next = contour[(i + 1) % contour.length];\n            if (curr.onCurve) {\n                // This is a straight line.\n                p.lineTo(curr.x, curr.y);\n            } else {\n                var prev2 = prev;\n                var next2 = next;\n                if (!prev.onCurve) {\n                    prev2 = {\n                        x: (curr.x + prev.x) * 0.5,\n                        y: (curr.y + prev.y) * 0.5\n                    };\n                }\n                if (!next.onCurve) {\n                    next2 = {\n                        x: (curr.x + next.x) * 0.5,\n                        y: (curr.y + next.y) * 0.5\n                    };\n                }\n                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);\n            }\n        }\n        p.closePath();\n    }\n    return p;\n}\nfunction buildPath(glyphs, glyph) {\n    if (glyph.isComposite) {\n        for(var j = 0; j < glyph.components.length; j += 1){\n            var component = glyph.components[j];\n            var componentGlyph = glyphs.get(component.glyphIndex);\n            // Force the ttfGlyphLoader to parse the glyph.\n            componentGlyph.getPath();\n            if (componentGlyph.points) {\n                var transformedPoints = void 0;\n                if (component.matchedPoints === undefined) {\n                    // component positioned by offset\n                    transformedPoints = transformPoints(componentGlyph.points, component);\n                } else {\n                    // component positioned by matched points\n                    if (component.matchedPoints[0] > glyph.points.length - 1 || component.matchedPoints[1] > componentGlyph.points.length - 1) {\n                        throw Error(\"Matched points out of range in \" + glyph.name);\n                    }\n                    var firstPt = glyph.points[component.matchedPoints[0]];\n                    var secondPt = componentGlyph.points[component.matchedPoints[1]];\n                    var transform = {\n                        xScale: component.xScale,\n                        scale01: component.scale01,\n                        scale10: component.scale10,\n                        yScale: component.yScale,\n                        dx: 0,\n                        dy: 0\n                    };\n                    secondPt = transformPoints([\n                        secondPt\n                    ], transform)[0];\n                    transform.dx = firstPt.x - secondPt.x;\n                    transform.dy = firstPt.y - secondPt.y;\n                    transformedPoints = transformPoints(componentGlyph.points, transform);\n                }\n                glyph.points = glyph.points.concat(transformedPoints);\n            }\n        }\n    }\n    return getPath(glyph.points);\n}\nfunction parseGlyfTableAll(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n    // The last element of the loca table is invalid.\n    for(var i = 0; i < loca.length - 1; i += 1){\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    }\n    return glyphs;\n}\nfunction parseGlyfTableOnLowMemory(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n    font._push = function(i) {\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    };\n    return glyphs;\n}\n// Parse all the glyphs according to the offsets from the `loca` table.\nfunction parseGlyfTable(data, start, loca, font, opt) {\n    if (opt.lowMemory) {\n        return parseGlyfTableOnLowMemory(data, start, loca, font);\n    } else {\n        return parseGlyfTableAll(data, start, loca, font);\n    }\n}\nvar glyf = {\n    getPath: getPath,\n    parse: parseGlyfTable\n};\n/* A TrueType font hinting interpreter.\n*\n* (c) 2017 Axel Kittenberger\n*\n* This interpreter has been implemented according to this documentation:\n* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n*\n* According to the documentation F24DOT6 values are used for pixels.\n* That means calculation is 1/64 pixel accurate and uses integer operations.\n* However, Javascript has floating point operations by default and only\n* those are available. One could make a case to simulate the 1/64 accuracy\n* exactly by truncating after every division operation\n* (for example with << 0) to get pixel exactly results as other TrueType\n* implementations. It may make sense since some fonts are pixel optimized\n* by hand using DELTAP instructions. The current implementation doesn't\n* and rather uses full floating point precision.\n*\n* xScale, yScale and rotation is currently ignored.\n*\n* A few non-trivial instructions are missing as I didn't encounter yet\n* a font that used them to test a possible implementation.\n*\n* Some fonts seem to use undocumented features regarding the twilight zone.\n* Only some of them are implemented as they were encountered.\n*\n* The exports.DEBUG statements are removed on the minified distribution file.\n*/ var instructionTable;\nvar exec;\nvar execGlyph;\nvar execComponent;\n/*\n* Creates a hinting object.\n*\n* There ought to be exactly one\n* for each truetype font that is used for hinting.\n*/ function Hinting(font) {\n    // the font this hinting object is for\n    this.font = font;\n    this.getCommands = function(hPoints) {\n        return glyf.getPath(hPoints).commands;\n    };\n    // cached states\n    this._fpgmState = this._prepState = undefined;\n    // errorState\n    // 0 ... all okay\n    // 1 ... had an error in a glyf,\n    //       continue working but stop spamming\n    //       the console\n    // 2 ... error at prep, stop hinting at this ppem\n    // 3 ... error at fpeg, stop hinting for this font at all\n    this._errorState = 0;\n}\n/*\n* Not rounding.\n*/ function roundOff(v) {\n    return v;\n}\n/*\n* Rounding to grid.\n*/ function roundToGrid(v) {\n    //Rounding in TT is supposed to \"symmetrical around zero\"\n    return Math.sign(v) * Math.round(Math.abs(v));\n}\n/*\n* Rounding to double grid.\n*/ function roundToDoubleGrid(v) {\n    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;\n}\n/*\n* Rounding to half grid.\n*/ function roundToHalfGrid(v) {\n    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);\n}\n/*\n* Rounding to up to grid.\n*/ function roundUpToGrid(v) {\n    return Math.sign(v) * Math.ceil(Math.abs(v));\n}\n/*\n* Rounding to down to grid.\n*/ function roundDownToGrid(v) {\n    return Math.sign(v) * Math.floor(Math.abs(v));\n}\n/*\n* Super rounding.\n*/ var roundSuper = function(v) {\n    var period = this.srPeriod;\n    var phase = this.srPhase;\n    var threshold = this.srThreshold;\n    var sign = 1;\n    if (v < 0) {\n        v = -v;\n        sign = -1;\n    }\n    v += threshold - phase;\n    v = Math.trunc(v / period) * period;\n    v += phase;\n    // according to http://xgridfit.sourceforge.net/round.html\n    if (v < 0) {\n        return phase * sign;\n    }\n    return v * sign;\n};\n/*\n* Unit vector of x-axis.\n*/ var xUnitVector = {\n    x: 1,\n    y: 0,\n    axis: \"x\",\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function(p1, p2, o1, o2) {\n        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);\n    },\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function(p, rp1, rp2, pv) {\n        var do1;\n        var do2;\n        var doa1;\n        var doa2;\n        var dm1;\n        var dm2;\n        var dt;\n        if (!pv || pv === this) {\n            do1 = p.xo - rp1.xo;\n            do2 = p.xo - rp2.xo;\n            dm1 = rp1.x - rp1.xo;\n            dm2 = rp2.x - rp2.xo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n            if (dt === 0) {\n                p.x = p.xo + (dm1 + dm2) / 2;\n                return;\n            }\n            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n        if (dt === 0) {\n            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n    // Slope of line normal to this\n    normalSlope: Number.NEGATIVE_INFINITY,\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'.\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function(p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.x = (org ? rp.xo : rp.x) + d;\n            return;\n        }\n        var rpx = org ? rp.xo : rp.x;\n        var rpy = org ? rp.yo : rp.y;\n        var rpdx = rpx + d * pv.x;\n        var rpdy = rpy + d * pv.y;\n        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;\n    },\n    // Slope of vector line.\n    slope: 0,\n    // Touches the point p.\n    touch: function(p) {\n        p.xTouched = true;\n    },\n    // Tests if a point p is touched.\n    touched: function(p) {\n        return p.xTouched;\n    },\n    // Untouches the point p.\n    untouch: function(p) {\n        p.xTouched = false;\n    }\n};\n/*\n* Unit vector of y-axis.\n*/ var yUnitVector = {\n    x: 0,\n    y: 1,\n    axis: \"y\",\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function(p1, p2, o1, o2) {\n        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);\n    },\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function(p, rp1, rp2, pv) {\n        var do1;\n        var do2;\n        var doa1;\n        var doa2;\n        var dm1;\n        var dm2;\n        var dt;\n        if (!pv || pv === this) {\n            do1 = p.yo - rp1.yo;\n            do2 = p.yo - rp2.yo;\n            dm1 = rp1.y - rp1.yo;\n            dm2 = rp2.y - rp2.yo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n            if (dt === 0) {\n                p.y = p.yo + (dm1 + dm2) / 2;\n                return;\n            }\n            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n        if (dt === 0) {\n            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n    // Slope of line normal to this.\n    normalSlope: 0,\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function(p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.y = (org ? rp.yo : rp.y) + d;\n            return;\n        }\n        var rpx = org ? rp.xo : rp.x;\n        var rpy = org ? rp.yo : rp.y;\n        var rpdx = rpx + d * pv.x;\n        var rpdy = rpy + d * pv.y;\n        p.y = rpdy + pv.normalSlope * (p.x - rpdx);\n    },\n    // Slope of vector line.\n    slope: Number.POSITIVE_INFINITY,\n    // Touches the point p.\n    touch: function(p) {\n        p.yTouched = true;\n    },\n    // Tests if a point p is touched.\n    touched: function(p) {\n        return p.yTouched;\n    },\n    // Untouches the point p.\n    untouch: function(p) {\n        p.yTouched = false;\n    }\n};\nObject.freeze(xUnitVector);\nObject.freeze(yUnitVector);\n/*\n* Creates a unit vector that is not x- or y-axis.\n*/ function UnitVector(x, y) {\n    this.x = x;\n    this.y = y;\n    this.axis = undefined;\n    this.slope = y / x;\n    this.normalSlope = -x / y;\n    Object.freeze(this);\n}\n/*\n* Gets the projected distance between two points.\n* o1/o2 ... if true, respective original position is used.\n*/ UnitVector.prototype.distance = function(p1, p2, o1, o2) {\n    return this.x * xUnitVector.distance(p1, p2, o1, o2) + this.y * yUnitVector.distance(p1, p2, o1, o2);\n};\n/*\n* Moves point p so the moved position has the same relative\n* position to the moved positions of rp1 and rp2 than the\n* original positions had.\n*\n* See APPENDIX on INTERPOLATE at the bottom of this file.\n*/ UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {\n    var dm1;\n    var dm2;\n    var do1;\n    var do2;\n    var doa1;\n    var doa2;\n    var dt;\n    do1 = pv.distance(p, rp1, true, true);\n    do2 = pv.distance(p, rp2, true, true);\n    dm1 = pv.distance(rp1, rp1, false, true);\n    dm2 = pv.distance(rp2, rp2, false, true);\n    doa1 = Math.abs(do1);\n    doa2 = Math.abs(do2);\n    dt = doa1 + doa2;\n    if (dt === 0) {\n        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n        return;\n    }\n    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n};\n/*\n* Sets the point 'p' relative to point 'rp'\n* by the distance 'd'\n*\n* See APPENDIX on SETRELATIVE at the bottom of this file.\n*\n* p   ...  point to set\n* rp  ... reference point\n* d   ... distance on projection vector\n* pv  ... projection vector (undefined = this)\n* org ... if true, uses the original position of rp as reference.\n*/ UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {\n    pv = pv || this;\n    var rpx = org ? rp.xo : rp.x;\n    var rpy = org ? rp.yo : rp.y;\n    var rpdx = rpx + d * pv.x;\n    var rpdy = rpy + d * pv.y;\n    var pvns = pv.normalSlope;\n    var fvs = this.slope;\n    var px = p.x;\n    var py = p.y;\n    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);\n    p.y = fvs * (p.x - px) + py;\n};\n/*\n* Touches the point p.\n*/ UnitVector.prototype.touch = function(p) {\n    p.xTouched = true;\n    p.yTouched = true;\n};\n/*\n* Returns a unit vector with x/y coordinates.\n*/ function getUnitVector(x, y) {\n    var d = Math.sqrt(x * x + y * y);\n    x /= d;\n    y /= d;\n    if (x === 1 && y === 0) {\n        return xUnitVector;\n    } else if (x === 0 && y === 1) {\n        return yUnitVector;\n    } else {\n        return new UnitVector(x, y);\n    }\n}\n/*\n* Creates a point in the hinting engine.\n*/ function HPoint(x, y, lastPointOfContour, onCurve) {\n    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value\n    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value\n    this.lastPointOfContour = lastPointOfContour;\n    this.onCurve = onCurve;\n    this.prevPointOnContour = undefined;\n    this.nextPointOnContour = undefined;\n    this.xTouched = false;\n    this.yTouched = false;\n    Object.preventExtensions(this);\n}\n/*\n* Returns the next touched point on the contour.\n*\n* v  ... unit vector to test touch axis.\n*/ HPoint.prototype.nextTouched = function(v) {\n    var p = this.nextPointOnContour;\n    while(!v.touched(p) && p !== this){\n        p = p.nextPointOnContour;\n    }\n    return p;\n};\n/*\n* Returns the previous touched point on the contour\n*\n* v  ... unit vector to test touch axis.\n*/ HPoint.prototype.prevTouched = function(v) {\n    var p = this.prevPointOnContour;\n    while(!v.touched(p) && p !== this){\n        p = p.prevPointOnContour;\n    }\n    return p;\n};\n/*\n* The zero point.\n*/ var HPZero = Object.freeze(new HPoint(0, 0));\n/*\n* The default state of the interpreter.\n*\n* Note: Freezing the defaultState and then deriving from it\n* makes the V8 Javascript engine going awkward,\n* so this is avoided, albeit the defaultState shouldn't\n* ever change.\n*/ var defaultState = {\n    cvCutIn: 17 / 16,\n    deltaBase: 9,\n    deltaShift: 0.125,\n    loop: 1,\n    minDis: 1,\n    autoFlip: true\n};\n/*\n* The current state of the interpreter.\n*\n* env  ... 'fpgm' or 'prep' or 'glyf'\n* prog ... the program\n*/ function State(env, prog) {\n    this.env = env;\n    this.stack = [];\n    this.prog = prog;\n    switch(env){\n        case \"glyf\":\n            this.zp0 = this.zp1 = this.zp2 = 1;\n            this.rp0 = this.rp1 = this.rp2 = 0;\n        /* fall through */ case \"prep\":\n            this.fv = this.pv = this.dpv = xUnitVector;\n            this.round = roundToGrid;\n    }\n}\n/*\n* Executes a glyph program.\n*\n* This does the hinting for each glyph.\n*\n* Returns an array of moved points.\n*\n* glyph: the glyph to hint\n* ppem: the size the glyph is rendered for\n*/ Hinting.prototype.exec = function(glyph, ppem) {\n    if (typeof ppem !== \"number\") {\n        throw new Error(\"Point size is not a number!\");\n    }\n    // Received a fatal error, don't do any hinting anymore.\n    if (this._errorState > 2) {\n        return;\n    }\n    var font = this.font;\n    var prepState = this._prepState;\n    if (!prepState || prepState.ppem !== ppem) {\n        var fpgmState = this._fpgmState;\n        if (!fpgmState) {\n            // Executes the fpgm state.\n            // This is used by fonts to define functions.\n            State.prototype = defaultState;\n            fpgmState = this._fpgmState = new State(\"fpgm\", font.tables.fpgm);\n            fpgmState.funcs = [];\n            fpgmState.font = font;\n            if (exports.DEBUG) {\n                console.log(\"---EXEC FPGM---\");\n                fpgmState.step = -1;\n            }\n            try {\n                exec(fpgmState);\n            } catch (e) {\n                console.log(\"Hinting error in FPGM:\" + e);\n                this._errorState = 3;\n                return;\n            }\n        }\n        // Executes the prep program for this ppem setting.\n        // This is used by fonts to set cvt values\n        // depending on to be rendered font size.\n        State.prototype = fpgmState;\n        prepState = this._prepState = new State(\"prep\", font.tables.prep);\n        prepState.ppem = ppem;\n        // Creates a copy of the cvt table\n        // and scales it to the current ppem setting.\n        var oCvt = font.tables.cvt;\n        if (oCvt) {\n            var cvt = prepState.cvt = new Array(oCvt.length);\n            var scale = ppem / font.unitsPerEm;\n            for(var c = 0; c < oCvt.length; c++){\n                cvt[c] = oCvt[c] * scale;\n            }\n        } else {\n            prepState.cvt = [];\n        }\n        if (exports.DEBUG) {\n            console.log(\"---EXEC PREP---\");\n            prepState.step = -1;\n        }\n        try {\n            exec(prepState);\n        } catch (e) {\n            if (this._errorState < 2) {\n                console.log(\"Hinting error in PREP:\" + e);\n            }\n            this._errorState = 2;\n        }\n    }\n    if (this._errorState > 1) {\n        return;\n    }\n    try {\n        return execGlyph(glyph, prepState);\n    } catch (e) {\n        if (this._errorState < 1) {\n            console.log(\"Hinting error:\" + e);\n            console.log(\"Note: further hinting errors are silenced\");\n        }\n        this._errorState = 1;\n        return undefined;\n    }\n};\n/*\n* Executes the hinting program for a glyph.\n*/ execGlyph = function(glyph, prepState) {\n    // original point positions\n    var xScale = prepState.ppem / prepState.font.unitsPerEm;\n    var yScale = xScale;\n    var components = glyph.components;\n    var contours;\n    var gZone;\n    var state;\n    State.prototype = prepState;\n    if (!components) {\n        state = new State(\"glyf\", glyph.instructions);\n        if (exports.DEBUG) {\n            console.log(\"---EXEC GLYPH---\");\n            state.step = -1;\n        }\n        execComponent(glyph, state, xScale, yScale);\n        gZone = state.gZone;\n    } else {\n        var font = prepState.font;\n        gZone = [];\n        contours = [];\n        for(var i = 0; i < components.length; i++){\n            var c = components[i];\n            var cg = font.glyphs.get(c.glyphIndex);\n            state = new State(\"glyf\", cg.instructions);\n            if (exports.DEBUG) {\n                console.log(\"---EXEC COMP \" + i + \"---\");\n                state.step = -1;\n            }\n            execComponent(cg, state, xScale, yScale);\n            // appends the computed points to the result array\n            // post processes the component points\n            var dx = Math.round(c.dx * xScale);\n            var dy = Math.round(c.dy * yScale);\n            var gz = state.gZone;\n            var cc = state.contours;\n            for(var pi = 0; pi < gz.length; pi++){\n                var p = gz[pi];\n                p.xTouched = p.yTouched = false;\n                p.xo = p.x = p.x + dx;\n                p.yo = p.y = p.y + dy;\n            }\n            var gLen = gZone.length;\n            gZone.push.apply(gZone, gz);\n            for(var j = 0; j < cc.length; j++){\n                contours.push(cc[j] + gLen);\n            }\n        }\n        if (glyph.instructions && !state.inhibitGridFit) {\n            // the composite has instructions on its own\n            state = new State(\"glyf\", glyph.instructions);\n            state.gZone = state.z0 = state.z1 = state.z2 = gZone;\n            state.contours = contours;\n            // note: HPZero cannot be used here, since\n            //       the point might be modified\n            gZone.push(new HPoint(0, 0), new HPoint(Math.round(glyph.advanceWidth * xScale), 0));\n            if (exports.DEBUG) {\n                console.log(\"---EXEC COMPOSITE---\");\n                state.step = -1;\n            }\n            exec(state);\n            gZone.length -= 2;\n        }\n    }\n    return gZone;\n};\n/*\n* Executes the hinting program for a component of a multi-component glyph\n* or of the glyph itself for a non-component glyph.\n*/ execComponent = function(glyph, state, xScale, yScale) {\n    var points = glyph.points || [];\n    var pLen = points.length;\n    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];\n    var contours = state.contours = [];\n    // Scales the original points and\n    // makes copies for the hinted points.\n    var cp; // current point\n    for(var i = 0; i < pLen; i++){\n        cp = points[i];\n        gZone[i] = new HPoint(cp.x * xScale, cp.y * yScale, cp.lastPointOfContour, cp.onCurve);\n    }\n    // Chain links the contours.\n    var sp; // start point\n    var np; // next point\n    for(var i$1 = 0; i$1 < pLen; i$1++){\n        cp = gZone[i$1];\n        if (!sp) {\n            sp = cp;\n            contours.push(i$1);\n        }\n        if (cp.lastPointOfContour) {\n            cp.nextPointOnContour = sp;\n            sp.prevPointOnContour = cp;\n            sp = undefined;\n        } else {\n            np = gZone[i$1 + 1];\n            cp.nextPointOnContour = np;\n            np.prevPointOnContour = cp;\n        }\n    }\n    if (state.inhibitGridFit) {\n        return;\n    }\n    if (exports.DEBUG) {\n        console.log(\"PROCESSING GLYPH\", state.stack);\n        for(var i$2 = 0; i$2 < pLen; i$2++){\n            console.log(i$2, gZone[i$2].x, gZone[i$2].y);\n        }\n    }\n    gZone.push(new HPoint(0, 0), new HPoint(Math.round(glyph.advanceWidth * xScale), 0));\n    exec(state);\n    // Removes the extra points.\n    gZone.length -= 2;\n    if (exports.DEBUG) {\n        console.log(\"FINISHED GLYPH\", state.stack);\n        for(var i$3 = 0; i$3 < pLen; i$3++){\n            console.log(i$3, gZone[i$3].x, gZone[i$3].y);\n        }\n    }\n};\n/*\n* Executes the program loaded in state.\n*/ exec = function(state) {\n    var prog = state.prog;\n    if (!prog) {\n        return;\n    }\n    var pLen = prog.length;\n    var ins;\n    for(state.ip = 0; state.ip < pLen; state.ip++){\n        if (exports.DEBUG) {\n            state.step++;\n        }\n        ins = instructionTable[prog[state.ip]];\n        if (!ins) {\n            throw new Error(\"unknown instruction: 0x\" + Number(prog[state.ip]).toString(16));\n        }\n        ins(state);\n    // very extensive debugging for each step\n    /*\n        if (exports.DEBUG) {\n            var da;\n            if (state.gZone) {\n                da = [];\n                for (let i = 0; i < state.gZone.length; i++)\n                {\n                    da.push(i + ' ' +\n                        state.gZone[i].x * 64 + ' ' +\n                        state.gZone[i].y * 64 + ' ' +\n                        (state.gZone[i].xTouched ? 'x' : '') +\n                        (state.gZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('GZ', da);\n            }\n\n            if (state.tZone) {\n                da = [];\n                for (let i = 0; i < state.tZone.length; i++) {\n                    da.push(i + ' ' +\n                        state.tZone[i].x * 64 + ' ' +\n                        state.tZone[i].y * 64 + ' ' +\n                        (state.tZone[i].xTouched ? 'x' : '') +\n                        (state.tZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('TZ', da);\n            }\n\n            if (state.stack.length > 10) {\n                console.log(\n                    state.stack.length,\n                    '...', state.stack.slice(state.stack.length - 10)\n                );\n            } else {\n                console.log(state.stack.length, state.stack);\n            }\n        }\n        */ }\n};\n/*\n* Initializes the twilight zone.\n*\n* This is only done if a SZPx instruction\n* refers to the twilight zone.\n*/ function initTZone(state) {\n    var tZone = state.tZone = new Array(state.gZone.length);\n    // no idea if this is actually correct...\n    for(var i = 0; i < tZone.length; i++){\n        tZone[i] = new HPoint(0, 0);\n    }\n}\n/*\n* Skips the instruction pointer ahead over an IF/ELSE block.\n* handleElse .. if true breaks on matching ELSE\n*/ function skip(state, handleElse) {\n    var prog = state.prog;\n    var ip = state.ip;\n    var nesting = 1;\n    var ins;\n    do {\n        ins = prog[++ip];\n        if (ins === 0x58) {\n            nesting++;\n        } else if (ins === 0x59) {\n            nesting--;\n        } else if (ins === 0x40) {\n            ip += prog[ip + 1] + 1;\n        } else if (ins === 0x41) {\n            ip += 2 * prog[ip + 1] + 1;\n        } else if (ins >= 0xB0 && ins <= 0xB7) {\n            ip += ins - 0xB0 + 1;\n        } else if (ins >= 0xB8 && ins <= 0xBF) {\n            ip += (ins - 0xB8 + 1) * 2;\n        } else if (handleElse && nesting === 1 && ins === 0x1B) {\n            break;\n        }\n    }while (nesting > 0);\n    state.ip = ip;\n}\n/*----------------------------------------------------------*\n*          And then a lot of instructions...                *\n*----------------------------------------------------------*/ // SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n// 0x00-0x01\nfunction SVTCA(v, state) {\n    if (exports.DEBUG) {\n        console.log(state.step, \"SVTCA[\" + v.axis + \"]\");\n    }\n    state.fv = state.pv = state.dpv = v;\n}\n// SPVTCA[a] Set Projection Vector to Coordinate Axis\n// 0x02-0x03\nfunction SPVTCA(v, state) {\n    if (exports.DEBUG) {\n        console.log(state.step, \"SPVTCA[\" + v.axis + \"]\");\n    }\n    state.pv = state.dpv = v;\n}\n// SFVTCA[a] Set Freedom Vector to Coordinate Axis\n// 0x04-0x05\nfunction SFVTCA(v, state) {\n    if (exports.DEBUG) {\n        console.log(state.step, \"SFVTCA[\" + v.axis + \"]\");\n    }\n    state.fv = v;\n}\n// SPVTL[a] Set Projection Vector To Line\n// 0x06-0x07\nfunction SPVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n    if (exports.DEBUG) {\n        console.log(\"SPVTL[\" + a + \"]\", p2i, p1i);\n    }\n    var dx;\n    var dy;\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n    state.pv = state.dpv = getUnitVector(dx, dy);\n}\n// SFVTL[a] Set Freedom Vector To Line\n// 0x08-0x09\nfunction SFVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n    if (exports.DEBUG) {\n        console.log(\"SFVTL[\" + a + \"]\", p2i, p1i);\n    }\n    var dx;\n    var dy;\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n    state.fv = getUnitVector(dx, dy);\n}\n// SPVFS[] Set Projection Vector From Stack\n// 0x0A\nfunction SPVFS(state) {\n    var stack = state.stack;\n    var y = stack.pop();\n    var x = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SPVFS[]\", y, x);\n    }\n    state.pv = state.dpv = getUnitVector(x, y);\n}\n// SFVFS[] Set Freedom Vector From Stack\n// 0x0B\nfunction SFVFS(state) {\n    var stack = state.stack;\n    var y = stack.pop();\n    var x = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SPVFS[]\", y, x);\n    }\n    state.fv = getUnitVector(x, y);\n}\n// GPV[] Get Projection Vector\n// 0x0C\nfunction GPV(state) {\n    var stack = state.stack;\n    var pv = state.pv;\n    if (exports.DEBUG) {\n        console.log(state.step, \"GPV[]\");\n    }\n    stack.push(pv.x * 0x4000);\n    stack.push(pv.y * 0x4000);\n}\n// GFV[] Get Freedom Vector\n// 0x0C\nfunction GFV(state) {\n    var stack = state.stack;\n    var fv = state.fv;\n    if (exports.DEBUG) {\n        console.log(state.step, \"GFV[]\");\n    }\n    stack.push(fv.x * 0x4000);\n    stack.push(fv.y * 0x4000);\n}\n// SFVTPV[] Set Freedom Vector To Projection Vector\n// 0x0E\nfunction SFVTPV(state) {\n    state.fv = state.pv;\n    if (exports.DEBUG) {\n        console.log(state.step, \"SFVTPV[]\");\n    }\n}\n// ISECT[] moves point p to the InterSECTion of two lines\n// 0x0F\nfunction ISECT(state) {\n    var stack = state.stack;\n    var pa0i = stack.pop();\n    var pa1i = stack.pop();\n    var pb0i = stack.pop();\n    var pb1i = stack.pop();\n    var pi = stack.pop();\n    var z0 = state.z0;\n    var z1 = state.z1;\n    var pa0 = z0[pa0i];\n    var pa1 = z0[pa1i];\n    var pb0 = z1[pb0i];\n    var pb1 = z1[pb1i];\n    var p = state.z2[pi];\n    if (exports.DEBUG) {\n        console.log(\"ISECT[], \", pa0i, pa1i, pb0i, pb1i, pi);\n    }\n    // math from\n    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n    var x1 = pa0.x;\n    var y1 = pa0.y;\n    var x2 = pa1.x;\n    var y2 = pa1.y;\n    var x3 = pb0.x;\n    var y3 = pb0.y;\n    var x4 = pb1.x;\n    var y4 = pb1.y;\n    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    var f1 = x1 * y2 - y1 * x2;\n    var f2 = x3 * y4 - y3 * x4;\n    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;\n    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;\n}\n// SRP0[] Set Reference Point 0\n// 0x10\nfunction SRP0(state) {\n    state.rp0 = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SRP0[]\", state.rp0);\n    }\n}\n// SRP1[] Set Reference Point 1\n// 0x11\nfunction SRP1(state) {\n    state.rp1 = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SRP1[]\", state.rp1);\n    }\n}\n// SRP1[] Set Reference Point 2\n// 0x12\nfunction SRP2(state) {\n    state.rp2 = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SRP2[]\", state.rp2);\n    }\n}\n// SZP0[] Set Zone Pointer 0\n// 0x13\nfunction SZP0(state) {\n    var n = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SZP0[]\", n);\n    }\n    state.zp0 = n;\n    switch(n){\n        case 0:\n            if (!state.tZone) {\n                initTZone(state);\n            }\n            state.z0 = state.tZone;\n            break;\n        case 1:\n            state.z0 = state.gZone;\n            break;\n        default:\n            throw new Error(\"Invalid zone pointer\");\n    }\n}\n// SZP1[] Set Zone Pointer 1\n// 0x14\nfunction SZP1(state) {\n    var n = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SZP1[]\", n);\n    }\n    state.zp1 = n;\n    switch(n){\n        case 0:\n            if (!state.tZone) {\n                initTZone(state);\n            }\n            state.z1 = state.tZone;\n            break;\n        case 1:\n            state.z1 = state.gZone;\n            break;\n        default:\n            throw new Error(\"Invalid zone pointer\");\n    }\n}\n// SZP2[] Set Zone Pointer 2\n// 0x15\nfunction SZP2(state) {\n    var n = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SZP2[]\", n);\n    }\n    state.zp2 = n;\n    switch(n){\n        case 0:\n            if (!state.tZone) {\n                initTZone(state);\n            }\n            state.z2 = state.tZone;\n            break;\n        case 1:\n            state.z2 = state.gZone;\n            break;\n        default:\n            throw new Error(\"Invalid zone pointer\");\n    }\n}\n// SZPS[] Set Zone PointerS\n// 0x16\nfunction SZPS(state) {\n    var n = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SZPS[]\", n);\n    }\n    state.zp0 = state.zp1 = state.zp2 = n;\n    switch(n){\n        case 0:\n            if (!state.tZone) {\n                initTZone(state);\n            }\n            state.z0 = state.z1 = state.z2 = state.tZone;\n            break;\n        case 1:\n            state.z0 = state.z1 = state.z2 = state.gZone;\n            break;\n        default:\n            throw new Error(\"Invalid zone pointer\");\n    }\n}\n// SLOOP[] Set LOOP variable\n// 0x17\nfunction SLOOP(state) {\n    state.loop = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SLOOP[]\", state.loop);\n    }\n}\n// RTG[] Round To Grid\n// 0x18\nfunction RTG(state) {\n    if (exports.DEBUG) {\n        console.log(state.step, \"RTG[]\");\n    }\n    state.round = roundToGrid;\n}\n// RTHG[] Round To Half Grid\n// 0x19\nfunction RTHG(state) {\n    if (exports.DEBUG) {\n        console.log(state.step, \"RTHG[]\");\n    }\n    state.round = roundToHalfGrid;\n}\n// SMD[] Set Minimum Distance\n// 0x1A\nfunction SMD(state) {\n    var d = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SMD[]\", d);\n    }\n    state.minDis = d / 0x40;\n}\n// ELSE[] ELSE clause\n// 0x1B\nfunction ELSE(state) {\n    // This instruction has been reached by executing a then branch\n    // so it just skips ahead until matching EIF.\n    //\n    // In case the IF was negative the IF[] instruction already\n    // skipped forward over the ELSE[]\n    if (exports.DEBUG) {\n        console.log(state.step, \"ELSE[]\");\n    }\n    skip(state, false);\n}\n// JMPR[] JuMP Relative\n// 0x1C\nfunction JMPR(state) {\n    var o = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"JMPR[]\", o);\n    }\n    // A jump by 1 would do nothing.\n    state.ip += o - 1;\n}\n// SCVTCI[] Set Control Value Table Cut-In\n// 0x1D\nfunction SCVTCI(state) {\n    var n = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SCVTCI[]\", n);\n    }\n    state.cvCutIn = n / 0x40;\n}\n// DUP[] DUPlicate top stack element\n// 0x20\nfunction DUP(state) {\n    var stack = state.stack;\n    if (exports.DEBUG) {\n        console.log(state.step, \"DUP[]\");\n    }\n    stack.push(stack[stack.length - 1]);\n}\n// POP[] POP top stack element\n// 0x21\nfunction POP(state) {\n    if (exports.DEBUG) {\n        console.log(state.step, \"POP[]\");\n    }\n    state.stack.pop();\n}\n// CLEAR[] CLEAR the stack\n// 0x22\nfunction CLEAR(state) {\n    if (exports.DEBUG) {\n        console.log(state.step, \"CLEAR[]\");\n    }\n    state.stack.length = 0;\n}\n// SWAP[] SWAP the top two elements on the stack\n// 0x23\nfunction SWAP(state) {\n    var stack = state.stack;\n    var a = stack.pop();\n    var b = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SWAP[]\");\n    }\n    stack.push(a);\n    stack.push(b);\n}\n// DEPTH[] DEPTH of the stack\n// 0x24\nfunction DEPTH(state) {\n    var stack = state.stack;\n    if (exports.DEBUG) {\n        console.log(state.step, \"DEPTH[]\");\n    }\n    stack.push(stack.length);\n}\n// LOOPCALL[] LOOPCALL function\n// 0x2A\nfunction LOOPCALL(state) {\n    var stack = state.stack;\n    var fn = stack.pop();\n    var c = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"LOOPCALL[]\", fn, c);\n    }\n    // saves callers program\n    var cip = state.ip;\n    var cprog = state.prog;\n    state.prog = state.funcs[fn];\n    // executes the function\n    for(var i = 0; i < c; i++){\n        exec(state);\n        if (exports.DEBUG) {\n            console.log(++state.step, i + 1 < c ? \"next loopcall\" : \"done loopcall\", i);\n        }\n    }\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n}\n// CALL[] CALL function\n// 0x2B\nfunction CALL(state) {\n    var fn = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"CALL[]\", fn);\n    }\n    // saves callers program\n    var cip = state.ip;\n    var cprog = state.prog;\n    state.prog = state.funcs[fn];\n    // executes the function\n    exec(state);\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n    if (exports.DEBUG) {\n        console.log(++state.step, \"returning from\", fn);\n    }\n}\n// CINDEX[] Copy the INDEXed element to the top of the stack\n// 0x25\nfunction CINDEX(state) {\n    var stack = state.stack;\n    var k = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"CINDEX[]\", k);\n    }\n    // In case of k == 1, it copies the last element after popping\n    // thus stack.length - k.\n    stack.push(stack[stack.length - k]);\n}\n// MINDEX[] Move the INDEXed element to the top of the stack\n// 0x26\nfunction MINDEX(state) {\n    var stack = state.stack;\n    var k = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"MINDEX[]\", k);\n    }\n    stack.push(stack.splice(stack.length - k, 1)[0]);\n}\n// FDEF[] Function DEFinition\n// 0x2C\nfunction FDEF(state) {\n    if (state.env !== \"fpgm\") {\n        throw new Error(\"FDEF not allowed here\");\n    }\n    var stack = state.stack;\n    var prog = state.prog;\n    var ip = state.ip;\n    var fn = stack.pop();\n    var ipBegin = ip;\n    if (exports.DEBUG) {\n        console.log(state.step, \"FDEF[]\", fn);\n    }\n    while(prog[++ip] !== 0x2D){}\n    state.ip = ip;\n    state.funcs[fn] = prog.slice(ipBegin + 1, ip);\n}\n// MDAP[a] Move Direct Absolute Point\n// 0x2E-0x2F\nfunction MDAP(round, state) {\n    var pi = state.stack.pop();\n    var p = state.z0[pi];\n    var fv = state.fv;\n    var pv = state.pv;\n    if (exports.DEBUG) {\n        console.log(state.step, \"MDAP[\" + round + \"]\", pi);\n    }\n    var d = pv.distance(p, HPZero);\n    if (round) {\n        d = state.round(d);\n    }\n    fv.setRelative(p, HPZero, d, pv);\n    fv.touch(p);\n    state.rp0 = state.rp1 = pi;\n}\n// IUP[a] Interpolate Untouched Points through the outline\n// 0x30\nfunction IUP(v, state) {\n    var z2 = state.z2;\n    var pLen = z2.length - 2;\n    var cp;\n    var pp;\n    var np;\n    if (exports.DEBUG) {\n        console.log(state.step, \"IUP[\" + v.axis + \"]\");\n    }\n    for(var i = 0; i < pLen; i++){\n        cp = z2[i]; // current point\n        // if this point has been touched go on\n        if (v.touched(cp)) {\n            continue;\n        }\n        pp = cp.prevTouched(v);\n        // no point on the contour has been touched?\n        if (pp === cp) {\n            continue;\n        }\n        np = cp.nextTouched(v);\n        if (pp === np) {\n            // only one point on the contour has been touched\n            // so simply moves the point like that\n            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);\n        }\n        v.interpolate(cp, pp, np, v);\n    }\n}\n// SHP[] SHift Point using reference point\n// 0x32-0x33\nfunction SHP(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var loop = state.loop;\n    var z2 = state.z2;\n    while(loop--){\n        var pi = stack.pop();\n        var p = z2[pi];\n        var d = pv.distance(rp, rp, false, true);\n        fv.setRelative(p, p, d, pv);\n        fv.touch(p);\n        if (exports.DEBUG) {\n            console.log(state.step, (state.loop > 1 ? \"loop \" + (state.loop - loop) + \": \" : \"\") + \"SHP[\" + (a ? \"rp1\" : \"rp2\") + \"]\", pi);\n        }\n    }\n    state.loop = 1;\n}\n// SHC[] SHift Contour using reference point\n// 0x36-0x37\nfunction SHC(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var ci = stack.pop();\n    var sp = state.z2[state.contours[ci]];\n    var p = sp;\n    if (exports.DEBUG) {\n        console.log(state.step, \"SHC[\" + a + \"]\", ci);\n    }\n    var d = pv.distance(rp, rp, false, true);\n    do {\n        if (p !== rp) {\n            fv.setRelative(p, p, d, pv);\n        }\n        p = p.nextPointOnContour;\n    }while (p !== sp);\n}\n// SHZ[] SHift Zone using reference point\n// 0x36-0x37\nfunction SHZ(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var e = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SHZ[\" + a + \"]\", e);\n    }\n    var z;\n    switch(e){\n        case 0:\n            z = state.tZone;\n            break;\n        case 1:\n            z = state.gZone;\n            break;\n        default:\n            throw new Error(\"Invalid zone\");\n    }\n    var p;\n    var d = pv.distance(rp, rp, false, true);\n    var pLen = z.length - 2;\n    for(var i = 0; i < pLen; i++){\n        p = z[i];\n        fv.setRelative(p, p, d, pv);\n    //if (p !== rp) fv.setRelative(p, p, d, pv);\n    }\n}\n// SHPIX[] SHift point by a PIXel amount\n// 0x38\nfunction SHPIX(state) {\n    var stack = state.stack;\n    var loop = state.loop;\n    var fv = state.fv;\n    var d = stack.pop() / 0x40;\n    var z2 = state.z2;\n    while(loop--){\n        var pi = stack.pop();\n        var p = z2[pi];\n        if (exports.DEBUG) {\n            console.log(state.step, (state.loop > 1 ? \"loop \" + (state.loop - loop) + \": \" : \"\") + \"SHPIX[]\", pi, d);\n        }\n        fv.setRelative(p, p, d);\n        fv.touch(p);\n    }\n    state.loop = 1;\n}\n// IP[] Interpolate Point\n// 0x39\nfunction IP(state) {\n    var stack = state.stack;\n    var rp1i = state.rp1;\n    var rp2i = state.rp2;\n    var loop = state.loop;\n    var rp1 = state.z0[rp1i];\n    var rp2 = state.z1[rp2i];\n    var fv = state.fv;\n    var pv = state.dpv;\n    var z2 = state.z2;\n    while(loop--){\n        var pi = stack.pop();\n        var p = z2[pi];\n        if (exports.DEBUG) {\n            console.log(state.step, (state.loop > 1 ? \"loop \" + (state.loop - loop) + \": \" : \"\") + \"IP[]\", pi, rp1i, \"<->\", rp2i);\n        }\n        fv.interpolate(p, rp1, rp2, pv);\n        fv.touch(p);\n    }\n    state.loop = 1;\n}\n// MSIRP[a] Move Stack Indirect Relative Point\n// 0x3A-0x3B\nfunction MSIRP(a, state) {\n    var stack = state.stack;\n    var d = stack.pop() / 64;\n    var pi = stack.pop();\n    var p = state.z1[pi];\n    var rp0 = state.z0[state.rp0];\n    var fv = state.fv;\n    var pv = state.pv;\n    fv.setRelative(p, rp0, d, pv);\n    fv.touch(p);\n    if (exports.DEBUG) {\n        console.log(state.step, \"MSIRP[\" + a + \"]\", d, pi);\n    }\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (a) {\n        state.rp0 = pi;\n    }\n}\n// ALIGNRP[] Align to reference point.\n// 0x3C\nfunction ALIGNRP(state) {\n    var stack = state.stack;\n    var rp0i = state.rp0;\n    var rp0 = state.z0[rp0i];\n    var loop = state.loop;\n    var fv = state.fv;\n    var pv = state.pv;\n    var z1 = state.z1;\n    while(loop--){\n        var pi = stack.pop();\n        var p = z1[pi];\n        if (exports.DEBUG) {\n            console.log(state.step, (state.loop > 1 ? \"loop \" + (state.loop - loop) + \": \" : \"\") + \"ALIGNRP[]\", pi);\n        }\n        fv.setRelative(p, rp0, 0, pv);\n        fv.touch(p);\n    }\n    state.loop = 1;\n}\n// RTG[] Round To Double Grid\n// 0x3D\nfunction RTDG(state) {\n    if (exports.DEBUG) {\n        console.log(state.step, \"RTDG[]\");\n    }\n    state.round = roundToDoubleGrid;\n}\n// MIAP[a] Move Indirect Absolute Point\n// 0x3E-0x3F\nfunction MIAP(round, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var pi = stack.pop();\n    var p = state.z0[pi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var cv = state.cvt[n];\n    if (exports.DEBUG) {\n        console.log(state.step, \"MIAP[\" + round + \"]\", n, \"(\", cv, \")\", pi);\n    }\n    var d = pv.distance(p, HPZero);\n    if (round) {\n        if (Math.abs(d - cv) < state.cvCutIn) {\n            d = cv;\n        }\n        d = state.round(d);\n    }\n    fv.setRelative(p, HPZero, d, pv);\n    if (state.zp0 === 0) {\n        p.xo = p.x;\n        p.yo = p.y;\n    }\n    fv.touch(p);\n    state.rp0 = state.rp1 = pi;\n}\n// NPUSB[] PUSH N Bytes\n// 0x40\nfunction NPUSHB(state) {\n    var prog = state.prog;\n    var ip = state.ip;\n    var stack = state.stack;\n    var n = prog[++ip];\n    if (exports.DEBUG) {\n        console.log(state.step, \"NPUSHB[]\", n);\n    }\n    for(var i = 0; i < n; i++){\n        stack.push(prog[++ip]);\n    }\n    state.ip = ip;\n}\n// NPUSHW[] PUSH N Words\n// 0x41\nfunction NPUSHW(state) {\n    var ip = state.ip;\n    var prog = state.prog;\n    var stack = state.stack;\n    var n = prog[++ip];\n    if (exports.DEBUG) {\n        console.log(state.step, \"NPUSHW[]\", n);\n    }\n    for(var i = 0; i < n; i++){\n        var w = prog[++ip] << 8 | prog[++ip];\n        if (w & 0x8000) {\n            w = -((w ^ 0xffff) + 1);\n        }\n        stack.push(w);\n    }\n    state.ip = ip;\n}\n// WS[] Write Store\n// 0x42\nfunction WS(state) {\n    var stack = state.stack;\n    var store = state.store;\n    if (!store) {\n        store = state.store = [];\n    }\n    var v = stack.pop();\n    var l = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"WS\", v, l);\n    }\n    store[l] = v;\n}\n// RS[] Read Store\n// 0x43\nfunction RS(state) {\n    var stack = state.stack;\n    var store = state.store;\n    var l = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"RS\", l);\n    }\n    var v = store && store[l] || 0;\n    stack.push(v);\n}\n// WCVTP[] Write Control Value Table in Pixel units\n// 0x44\nfunction WCVTP(state) {\n    var stack = state.stack;\n    var v = stack.pop();\n    var l = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"WCVTP\", v, l);\n    }\n    state.cvt[l] = v / 0x40;\n}\n// RCVT[] Read Control Value Table entry\n// 0x45\nfunction RCVT(state) {\n    var stack = state.stack;\n    var cvte = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"RCVT\", cvte);\n    }\n    stack.push(state.cvt[cvte] * 0x40);\n}\n// GC[] Get Coordinate projected onto the projection vector\n// 0x46-0x47\nfunction GC(a, state) {\n    var stack = state.stack;\n    var pi = stack.pop();\n    var p = state.z2[pi];\n    if (exports.DEBUG) {\n        console.log(state.step, \"GC[\" + a + \"]\", pi);\n    }\n    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);\n}\n// MD[a] Measure Distance\n// 0x49-0x4A\nfunction MD(a, state) {\n    var stack = state.stack;\n    var pi2 = stack.pop();\n    var pi1 = stack.pop();\n    var p2 = state.z1[pi2];\n    var p1 = state.z0[pi1];\n    var d = state.dpv.distance(p1, p2, a, a);\n    if (exports.DEBUG) {\n        console.log(state.step, \"MD[\" + a + \"]\", pi2, pi1, \"->\", d);\n    }\n    state.stack.push(Math.round(d * 64));\n}\n// MPPEM[] Measure Pixels Per EM\n// 0x4B\nfunction MPPEM(state) {\n    if (exports.DEBUG) {\n        console.log(state.step, \"MPPEM[]\");\n    }\n    state.stack.push(state.ppem);\n}\n// FLIPON[] set the auto FLIP Boolean to ON\n// 0x4D\nfunction FLIPON(state) {\n    if (exports.DEBUG) {\n        console.log(state.step, \"FLIPON[]\");\n    }\n    state.autoFlip = true;\n}\n// LT[] Less Than\n// 0x50\nfunction LT(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"LT[]\", e2, e1);\n    }\n    stack.push(e1 < e2 ? 1 : 0);\n}\n// LTEQ[] Less Than or EQual\n// 0x53\nfunction LTEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"LTEQ[]\", e2, e1);\n    }\n    stack.push(e1 <= e2 ? 1 : 0);\n}\n// GTEQ[] Greater Than\n// 0x52\nfunction GT(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"GT[]\", e2, e1);\n    }\n    stack.push(e1 > e2 ? 1 : 0);\n}\n// GTEQ[] Greater Than or EQual\n// 0x53\nfunction GTEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"GTEQ[]\", e2, e1);\n    }\n    stack.push(e1 >= e2 ? 1 : 0);\n}\n// EQ[] EQual\n// 0x54\nfunction EQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"EQ[]\", e2, e1);\n    }\n    stack.push(e2 === e1 ? 1 : 0);\n}\n// NEQ[] Not EQual\n// 0x55\nfunction NEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"NEQ[]\", e2, e1);\n    }\n    stack.push(e2 !== e1 ? 1 : 0);\n}\n// ODD[] ODD\n// 0x56\nfunction ODD(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"ODD[]\", n);\n    }\n    stack.push(Math.trunc(n) % 2 ? 1 : 0);\n}\n// EVEN[] EVEN\n// 0x57\nfunction EVEN(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"EVEN[]\", n);\n    }\n    stack.push(Math.trunc(n) % 2 ? 0 : 1);\n}\n// IF[] IF test\n// 0x58\nfunction IF(state) {\n    var test = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"IF[]\", test);\n    }\n    // if test is true it just continues\n    // if not the ip is skipped until matching ELSE or EIF\n    if (!test) {\n        skip(state, true);\n        if (exports.DEBUG) {\n            console.log(state.step, \"EIF[]\");\n        }\n    }\n}\n// EIF[] End IF\n// 0x59\nfunction EIF(state) {\n    // this can be reached normally when\n    // executing an else branch.\n    // -> just ignore it\n    if (exports.DEBUG) {\n        console.log(state.step, \"EIF[]\");\n    }\n}\n// AND[] logical AND\n// 0x5A\nfunction AND(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"AND[]\", e2, e1);\n    }\n    stack.push(e2 && e1 ? 1 : 0);\n}\n// OR[] logical OR\n// 0x5B\nfunction OR(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"OR[]\", e2, e1);\n    }\n    stack.push(e2 || e1 ? 1 : 0);\n}\n// NOT[] logical NOT\n// 0x5C\nfunction NOT(state) {\n    var stack = state.stack;\n    var e = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"NOT[]\", e);\n    }\n    stack.push(e ? 0 : 1);\n}\n// DELTAP1[] DELTA exception P1\n// DELTAP2[] DELTA exception P2\n// DELTAP3[] DELTA exception P3\n// 0x5D, 0x71, 0x72\nfunction DELTAP123(b, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var fv = state.fv;\n    var pv = state.pv;\n    var ppem = state.ppem;\n    var base = state.deltaBase + (b - 1) * 16;\n    var ds = state.deltaShift;\n    var z0 = state.z0;\n    if (exports.DEBUG) {\n        console.log(state.step, \"DELTAP[\" + b + \"]\", n, stack);\n    }\n    for(var i = 0; i < n; i++){\n        var pi = stack.pop();\n        var arg = stack.pop();\n        var appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) {\n            continue;\n        }\n        var mag = (arg & 0x0F) - 8;\n        if (mag >= 0) {\n            mag++;\n        }\n        if (exports.DEBUG) {\n            console.log(state.step, \"DELTAPFIX\", pi, \"by\", mag * ds);\n        }\n        var p = z0[pi];\n        fv.setRelative(p, p, mag * ds, pv);\n    }\n}\n// SDB[] Set Delta Base in the graphics state\n// 0x5E\nfunction SDB(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SDB[]\", n);\n    }\n    state.deltaBase = n;\n}\n// SDS[] Set Delta Shift in the graphics state\n// 0x5F\nfunction SDS(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SDS[]\", n);\n    }\n    state.deltaShift = Math.pow(0.5, n);\n}\n// ADD[] ADD\n// 0x60\nfunction ADD(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"ADD[]\", n2, n1);\n    }\n    stack.push(n1 + n2);\n}\n// SUB[] SUB\n// 0x61\nfunction SUB(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SUB[]\", n2, n1);\n    }\n    stack.push(n1 - n2);\n}\n// DIV[] DIV\n// 0x62\nfunction DIV(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"DIV[]\", n2, n1);\n    }\n    stack.push(n1 * 64 / n2);\n}\n// MUL[] MUL\n// 0x63\nfunction MUL(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"MUL[]\", n2, n1);\n    }\n    stack.push(n1 * n2 / 64);\n}\n// ABS[] ABSolute value\n// 0x64\nfunction ABS(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"ABS[]\", n);\n    }\n    stack.push(Math.abs(n));\n}\n// NEG[] NEGate\n// 0x65\nfunction NEG(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"NEG[]\", n);\n    }\n    stack.push(-n);\n}\n// FLOOR[] FLOOR\n// 0x66\nfunction FLOOR(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"FLOOR[]\", n);\n    }\n    stack.push(Math.floor(n / 0x40) * 0x40);\n}\n// CEILING[] CEILING\n// 0x67\nfunction CEILING(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"CEILING[]\", n);\n    }\n    stack.push(Math.ceil(n / 0x40) * 0x40);\n}\n// ROUND[ab] ROUND value\n// 0x68-0x6B\nfunction ROUND(dt, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"ROUND[]\");\n    }\n    stack.push(state.round(n / 0x40) * 0x40);\n}\n// WCVTF[] Write Control Value Table in Funits\n// 0x70\nfunction WCVTF(state) {\n    var stack = state.stack;\n    var v = stack.pop();\n    var l = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"WCVTF[]\", v, l);\n    }\n    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;\n}\n// DELTAC1[] DELTA exception C1\n// DELTAC2[] DELTA exception C2\n// DELTAC3[] DELTA exception C3\n// 0x73, 0x74, 0x75\nfunction DELTAC123(b, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var ppem = state.ppem;\n    var base = state.deltaBase + (b - 1) * 16;\n    var ds = state.deltaShift;\n    if (exports.DEBUG) {\n        console.log(state.step, \"DELTAC[\" + b + \"]\", n, stack);\n    }\n    for(var i = 0; i < n; i++){\n        var c = stack.pop();\n        var arg = stack.pop();\n        var appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) {\n            continue;\n        }\n        var mag = (arg & 0x0F) - 8;\n        if (mag >= 0) {\n            mag++;\n        }\n        var delta = mag * ds;\n        if (exports.DEBUG) {\n            console.log(state.step, \"DELTACFIX\", c, \"by\", delta);\n        }\n        state.cvt[c] += delta;\n    }\n}\n// SROUND[] Super ROUND\n// 0x76\nfunction SROUND(state) {\n    var n = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"SROUND[]\", n);\n    }\n    state.round = roundSuper;\n    var period;\n    switch(n & 0xC0){\n        case 0x00:\n            period = 0.5;\n            break;\n        case 0x40:\n            period = 1;\n            break;\n        case 0x80:\n            period = 2;\n            break;\n        default:\n            throw new Error(\"invalid SROUND value\");\n    }\n    state.srPeriod = period;\n    switch(n & 0x30){\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5 * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default:\n            throw new Error(\"invalid SROUND value\");\n    }\n    n &= 0x0F;\n    if (n === 0) {\n        state.srThreshold = 0;\n    } else {\n        state.srThreshold = (n / 8 - 0.5) * period;\n    }\n}\n// S45ROUND[] Super ROUND 45 degrees\n// 0x77\nfunction S45ROUND(state) {\n    var n = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"S45ROUND[]\", n);\n    }\n    state.round = roundSuper;\n    var period;\n    switch(n & 0xC0){\n        case 0x00:\n            period = Math.sqrt(2) / 2;\n            break;\n        case 0x40:\n            period = Math.sqrt(2);\n            break;\n        case 0x80:\n            period = 2 * Math.sqrt(2);\n            break;\n        default:\n            throw new Error(\"invalid S45ROUND value\");\n    }\n    state.srPeriod = period;\n    switch(n & 0x30){\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5 * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default:\n            throw new Error(\"invalid S45ROUND value\");\n    }\n    n &= 0x0F;\n    if (n === 0) {\n        state.srThreshold = 0;\n    } else {\n        state.srThreshold = (n / 8 - 0.5) * period;\n    }\n}\n// ROFF[] Round Off\n// 0x7A\nfunction ROFF(state) {\n    if (exports.DEBUG) {\n        console.log(state.step, \"ROFF[]\");\n    }\n    state.round = roundOff;\n}\n// RUTG[] Round Up To Grid\n// 0x7C\nfunction RUTG(state) {\n    if (exports.DEBUG) {\n        console.log(state.step, \"RUTG[]\");\n    }\n    state.round = roundUpToGrid;\n}\n// RDTG[] Round Down To Grid\n// 0x7D\nfunction RDTG(state) {\n    if (exports.DEBUG) {\n        console.log(state.step, \"RDTG[]\");\n    }\n    state.round = roundDownToGrid;\n}\n// SCANCTRL[] SCAN conversion ConTRoL\n// 0x85\nfunction SCANCTRL(state) {\n    var n = state.stack.pop();\n    // ignored by opentype.js\n    if (exports.DEBUG) {\n        console.log(state.step, \"SCANCTRL[]\", n);\n    }\n}\n// SDPVTL[a] Set Dual Projection Vector To Line\n// 0x86-0x87\nfunction SDPVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n    if (exports.DEBUG) {\n        console.log(state.step, \"SDPVTL[\" + a + \"]\", p2i, p1i);\n    }\n    var dx;\n    var dy;\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n    state.dpv = getUnitVector(dx, dy);\n}\n// GETINFO[] GET INFOrmation\n// 0x88\nfunction GETINFO(state) {\n    var stack = state.stack;\n    var sel = stack.pop();\n    var r = 0;\n    if (exports.DEBUG) {\n        console.log(state.step, \"GETINFO[]\", sel);\n    }\n    // v35 as in no subpixel hinting\n    if (sel & 0x01) {\n        r = 35;\n    }\n    // TODO rotation and stretch currently not supported\n    // and thus those GETINFO are always 0.\n    // opentype.js is always gray scaling\n    if (sel & 0x20) {\n        r |= 0x1000;\n    }\n    stack.push(r);\n}\n// ROLL[] ROLL the top three stack elements\n// 0x8A\nfunction ROLL(state) {\n    var stack = state.stack;\n    var a = stack.pop();\n    var b = stack.pop();\n    var c = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"ROLL[]\");\n    }\n    stack.push(b);\n    stack.push(a);\n    stack.push(c);\n}\n// MAX[] MAXimum of top two stack elements\n// 0x8B\nfunction MAX(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"MAX[]\", e2, e1);\n    }\n    stack.push(Math.max(e1, e2));\n}\n// MIN[] MINimum of top two stack elements\n// 0x8C\nfunction MIN(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"MIN[]\", e2, e1);\n    }\n    stack.push(Math.min(e1, e2));\n}\n// SCANTYPE[] SCANTYPE\n// 0x8D\nfunction SCANTYPE(state) {\n    var n = state.stack.pop();\n    // ignored by opentype.js\n    if (exports.DEBUG) {\n        console.log(state.step, \"SCANTYPE[]\", n);\n    }\n}\n// INSTCTRL[] INSTCTRL\n// 0x8D\nfunction INSTCTRL(state) {\n    var s = state.stack.pop();\n    var v = state.stack.pop();\n    if (exports.DEBUG) {\n        console.log(state.step, \"INSTCTRL[]\", s, v);\n    }\n    switch(s){\n        case 1:\n            state.inhibitGridFit = !!v;\n            return;\n        case 2:\n            state.ignoreCvt = !!v;\n            return;\n        default:\n            throw new Error(\"invalid INSTCTRL[] selector\");\n    }\n}\n// PUSHB[abc] PUSH Bytes\n// 0xB0-0xB7\nfunction PUSHB(n, state) {\n    var stack = state.stack;\n    var prog = state.prog;\n    var ip = state.ip;\n    if (exports.DEBUG) {\n        console.log(state.step, \"PUSHB[\" + n + \"]\");\n    }\n    for(var i = 0; i < n; i++){\n        stack.push(prog[++ip]);\n    }\n    state.ip = ip;\n}\n// PUSHW[abc] PUSH Words\n// 0xB8-0xBF\nfunction PUSHW(n, state) {\n    var ip = state.ip;\n    var prog = state.prog;\n    var stack = state.stack;\n    if (exports.DEBUG) {\n        console.log(state.ip, \"PUSHW[\" + n + \"]\");\n    }\n    for(var i = 0; i < n; i++){\n        var w = prog[++ip] << 8 | prog[++ip];\n        if (w & 0x8000) {\n            w = -((w ^ 0xffff) + 1);\n        }\n        stack.push(w);\n    }\n    state.ip = ip;\n}\n// MDRP[abcde] Move Direct Relative Point\n// 0xD0-0xEF\n// (if indirect is 0)\n//\n// and\n//\n// MIRP[abcde] Move Indirect Relative Point\n// 0xE0-0xFF\n// (if indirect is 1)\nfunction MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n    var stack = state.stack;\n    var cvte = indirect && stack.pop();\n    var pi = stack.pop();\n    var rp0i = state.rp0;\n    var rp = state.z0[rp0i];\n    var p = state.z1[pi];\n    var md = state.minDis;\n    var fv = state.fv;\n    var pv = state.dpv;\n    var od; // original distance\n    var d; // moving distance\n    var sign; // sign of distance\n    var cv;\n    d = od = pv.distance(p, rp, true, true);\n    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0\n    // TODO consider autoFlip\n    d = Math.abs(d);\n    if (indirect) {\n        cv = state.cvt[cvte];\n        if (ro && Math.abs(d - cv) < state.cvCutIn) {\n            d = cv;\n        }\n    }\n    if (keepD && d < md) {\n        d = md;\n    }\n    if (ro) {\n        d = state.round(d);\n    }\n    fv.setRelative(p, rp, sign * d, pv);\n    fv.touch(p);\n    if (exports.DEBUG) {\n        console.log(state.step, (indirect ? \"MIRP[\" : \"MDRP[\") + (setRp0 ? \"M\" : \"m\") + (keepD ? \">\" : \"_\") + (ro ? \"R\" : \"_\") + (dt === 0 ? \"Gr\" : dt === 1 ? \"Bl\" : dt === 2 ? \"Wh\" : \"\") + \"]\", indirect ? cvte + \"(\" + state.cvt[cvte] + \",\" + cv + \")\" : \"\", pi, \"(d =\", od, \"->\", sign * d, \")\");\n    }\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (setRp0) {\n        state.rp0 = pi;\n    }\n}\n/*\n* The instruction table.\n*/ instructionTable = [\n    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),\n    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),\n    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),\n    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),\n    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),\n    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),\n    /* 0x06 */ SPVTL.bind(undefined, 0),\n    /* 0x07 */ SPVTL.bind(undefined, 1),\n    /* 0x08 */ SFVTL.bind(undefined, 0),\n    /* 0x09 */ SFVTL.bind(undefined, 1),\n    /* 0x0A */ SPVFS,\n    /* 0x0B */ SFVFS,\n    /* 0x0C */ GPV,\n    /* 0x0D */ GFV,\n    /* 0x0E */ SFVTPV,\n    /* 0x0F */ ISECT,\n    /* 0x10 */ SRP0,\n    /* 0x11 */ SRP1,\n    /* 0x12 */ SRP2,\n    /* 0x13 */ SZP0,\n    /* 0x14 */ SZP1,\n    /* 0x15 */ SZP2,\n    /* 0x16 */ SZPS,\n    /* 0x17 */ SLOOP,\n    /* 0x18 */ RTG,\n    /* 0x19 */ RTHG,\n    /* 0x1A */ SMD,\n    /* 0x1B */ ELSE,\n    /* 0x1C */ JMPR,\n    /* 0x1D */ SCVTCI,\n    /* 0x1E */ undefined,\n    /* 0x1F */ undefined,\n    /* 0x20 */ DUP,\n    /* 0x21 */ POP,\n    /* 0x22 */ CLEAR,\n    /* 0x23 */ SWAP,\n    /* 0x24 */ DEPTH,\n    /* 0x25 */ CINDEX,\n    /* 0x26 */ MINDEX,\n    /* 0x27 */ undefined,\n    /* 0x28 */ undefined,\n    /* 0x29 */ undefined,\n    /* 0x2A */ LOOPCALL,\n    /* 0x2B */ CALL,\n    /* 0x2C */ FDEF,\n    /* 0x2D */ undefined,\n    /* 0x2E */ MDAP.bind(undefined, 0),\n    /* 0x2F */ MDAP.bind(undefined, 1),\n    /* 0x30 */ IUP.bind(undefined, yUnitVector),\n    /* 0x31 */ IUP.bind(undefined, xUnitVector),\n    /* 0x32 */ SHP.bind(undefined, 0),\n    /* 0x33 */ SHP.bind(undefined, 1),\n    /* 0x34 */ SHC.bind(undefined, 0),\n    /* 0x35 */ SHC.bind(undefined, 1),\n    /* 0x36 */ SHZ.bind(undefined, 0),\n    /* 0x37 */ SHZ.bind(undefined, 1),\n    /* 0x38 */ SHPIX,\n    /* 0x39 */ IP,\n    /* 0x3A */ MSIRP.bind(undefined, 0),\n    /* 0x3B */ MSIRP.bind(undefined, 1),\n    /* 0x3C */ ALIGNRP,\n    /* 0x3D */ RTDG,\n    /* 0x3E */ MIAP.bind(undefined, 0),\n    /* 0x3F */ MIAP.bind(undefined, 1),\n    /* 0x40 */ NPUSHB,\n    /* 0x41 */ NPUSHW,\n    /* 0x42 */ WS,\n    /* 0x43 */ RS,\n    /* 0x44 */ WCVTP,\n    /* 0x45 */ RCVT,\n    /* 0x46 */ GC.bind(undefined, 0),\n    /* 0x47 */ GC.bind(undefined, 1),\n    /* 0x48 */ undefined,\n    /* 0x49 */ MD.bind(undefined, 0),\n    /* 0x4A */ MD.bind(undefined, 1),\n    /* 0x4B */ MPPEM,\n    /* 0x4C */ undefined,\n    /* 0x4D */ FLIPON,\n    /* 0x4E */ undefined,\n    /* 0x4F */ undefined,\n    /* 0x50 */ LT,\n    /* 0x51 */ LTEQ,\n    /* 0x52 */ GT,\n    /* 0x53 */ GTEQ,\n    /* 0x54 */ EQ,\n    /* 0x55 */ NEQ,\n    /* 0x56 */ ODD,\n    /* 0x57 */ EVEN,\n    /* 0x58 */ IF,\n    /* 0x59 */ EIF,\n    /* 0x5A */ AND,\n    /* 0x5B */ OR,\n    /* 0x5C */ NOT,\n    /* 0x5D */ DELTAP123.bind(undefined, 1),\n    /* 0x5E */ SDB,\n    /* 0x5F */ SDS,\n    /* 0x60 */ ADD,\n    /* 0x61 */ SUB,\n    /* 0x62 */ DIV,\n    /* 0x63 */ MUL,\n    /* 0x64 */ ABS,\n    /* 0x65 */ NEG,\n    /* 0x66 */ FLOOR,\n    /* 0x67 */ CEILING,\n    /* 0x68 */ ROUND.bind(undefined, 0),\n    /* 0x69 */ ROUND.bind(undefined, 1),\n    /* 0x6A */ ROUND.bind(undefined, 2),\n    /* 0x6B */ ROUND.bind(undefined, 3),\n    /* 0x6C */ undefined,\n    /* 0x6D */ undefined,\n    /* 0x6E */ undefined,\n    /* 0x6F */ undefined,\n    /* 0x70 */ WCVTF,\n    /* 0x71 */ DELTAP123.bind(undefined, 2),\n    /* 0x72 */ DELTAP123.bind(undefined, 3),\n    /* 0x73 */ DELTAC123.bind(undefined, 1),\n    /* 0x74 */ DELTAC123.bind(undefined, 2),\n    /* 0x75 */ DELTAC123.bind(undefined, 3),\n    /* 0x76 */ SROUND,\n    /* 0x77 */ S45ROUND,\n    /* 0x78 */ undefined,\n    /* 0x79 */ undefined,\n    /* 0x7A */ ROFF,\n    /* 0x7B */ undefined,\n    /* 0x7C */ RUTG,\n    /* 0x7D */ RDTG,\n    /* 0x7E */ POP,\n    /* 0x7F */ POP,\n    /* 0x80 */ undefined,\n    /* 0x81 */ undefined,\n    /* 0x82 */ undefined,\n    /* 0x83 */ undefined,\n    /* 0x84 */ undefined,\n    /* 0x85 */ SCANCTRL,\n    /* 0x86 */ SDPVTL.bind(undefined, 0),\n    /* 0x87 */ SDPVTL.bind(undefined, 1),\n    /* 0x88 */ GETINFO,\n    /* 0x89 */ undefined,\n    /* 0x8A */ ROLL,\n    /* 0x8B */ MAX,\n    /* 0x8C */ MIN,\n    /* 0x8D */ SCANTYPE,\n    /* 0x8E */ INSTCTRL,\n    /* 0x8F */ undefined,\n    /* 0x90 */ undefined,\n    /* 0x91 */ undefined,\n    /* 0x92 */ undefined,\n    /* 0x93 */ undefined,\n    /* 0x94 */ undefined,\n    /* 0x95 */ undefined,\n    /* 0x96 */ undefined,\n    /* 0x97 */ undefined,\n    /* 0x98 */ undefined,\n    /* 0x99 */ undefined,\n    /* 0x9A */ undefined,\n    /* 0x9B */ undefined,\n    /* 0x9C */ undefined,\n    /* 0x9D */ undefined,\n    /* 0x9E */ undefined,\n    /* 0x9F */ undefined,\n    /* 0xA0 */ undefined,\n    /* 0xA1 */ undefined,\n    /* 0xA2 */ undefined,\n    /* 0xA3 */ undefined,\n    /* 0xA4 */ undefined,\n    /* 0xA5 */ undefined,\n    /* 0xA6 */ undefined,\n    /* 0xA7 */ undefined,\n    /* 0xA8 */ undefined,\n    /* 0xA9 */ undefined,\n    /* 0xAA */ undefined,\n    /* 0xAB */ undefined,\n    /* 0xAC */ undefined,\n    /* 0xAD */ undefined,\n    /* 0xAE */ undefined,\n    /* 0xAF */ undefined,\n    /* 0xB0 */ PUSHB.bind(undefined, 1),\n    /* 0xB1 */ PUSHB.bind(undefined, 2),\n    /* 0xB2 */ PUSHB.bind(undefined, 3),\n    /* 0xB3 */ PUSHB.bind(undefined, 4),\n    /* 0xB4 */ PUSHB.bind(undefined, 5),\n    /* 0xB5 */ PUSHB.bind(undefined, 6),\n    /* 0xB6 */ PUSHB.bind(undefined, 7),\n    /* 0xB7 */ PUSHB.bind(undefined, 8),\n    /* 0xB8 */ PUSHW.bind(undefined, 1),\n    /* 0xB9 */ PUSHW.bind(undefined, 2),\n    /* 0xBA */ PUSHW.bind(undefined, 3),\n    /* 0xBB */ PUSHW.bind(undefined, 4),\n    /* 0xBC */ PUSHW.bind(undefined, 5),\n    /* 0xBD */ PUSHW.bind(undefined, 6),\n    /* 0xBE */ PUSHW.bind(undefined, 7),\n    /* 0xBF */ PUSHW.bind(undefined, 8),\n    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),\n    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),\n    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),\n    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),\n    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),\n    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),\n    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),\n    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),\n    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),\n    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),\n    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),\n    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),\n    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),\n    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),\n    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),\n    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),\n    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),\n    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),\n    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),\n    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),\n    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),\n    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),\n    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),\n    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),\n    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),\n    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),\n    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),\n    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),\n    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),\n    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),\n    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),\n    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),\n    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),\n    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),\n    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),\n    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),\n    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),\n    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),\n    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),\n    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),\n    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),\n    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),\n    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),\n    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),\n    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),\n    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),\n    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),\n    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),\n    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),\n    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),\n    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),\n    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),\n    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),\n    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),\n    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),\n    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),\n    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),\n    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),\n    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),\n    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),\n    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),\n    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),\n    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),\n    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)\n];\n/*****************************\n  Mathematical Considerations\n******************************\n\nfv ... refers to freedom vector\npv ... refers to projection vector\nrp ... refers to reference point\np  ... refers to to point being operated on\nd  ... refers to distance\n\nSETRELATIVE:\n============\n\ncase freedom vector == x-axis:\n------------------------------\n\n                        (pv)\n                     .-'\n              rpd .-'\n               .-*\n          d .-'90°'\n         .-'       '\n      .-'           '\n   *-'               ' b\n  rp                  '\n                       '\n                        '\n            p *----------*-------------- (fv)\n                          pm\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b\n\n   y - rpdy = pvns * (x- rpdx)\n\n   y = p.y\n\n   x = rpdx + ( p.y - rpdy ) / pvns\n\n\ncase freedom vector == y-axis:\n------------------------------\n\n    * pm\n    |\\\n    | \\\n    |  \\\n    |   \\\n    |    \\\n    |     \\\n    |      \\\n    |       \\\n    |        \\\n    |         \\ b\n    |          \\\n    |           \\\n    |            \\    .-' (pv)\n    |         90° \\.-'\n    |           .-'* rpd\n    |        .-'\n    *     *-'  d\n    p     rp\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b:\n           pvns ... normal slope to pv\n\n   y - rpdy = pvns * (x - rpdx)\n\n   x = p.x\n\n   y = rpdy +  pvns * (p.x - rpdx)\n\n\n\ngeneric case:\n-------------\n\n\n                              .'(fv)\n                            .'\n                          .* pm\n                        .' !\n                      .'    .\n                    .'      !\n                  .'         . b\n                .'           !\n               *              .\n              p               !\n                         90°   .    ... (pv)\n                           ...-*-'''\n                  ...---'''    rpd\n         ...---'''   d\n   *--'''\n  rp\n\n    rpdx = rpx + d * pv.x\n    rpdy = rpy + d * pv.y\n\n equation of line b:\n    pvns... normal slope to pv\n\n    y - rpdy = pvns * (x - rpdx)\n\n equation of freedom vector line:\n    fvs ... slope of freedom vector (=fy/fx)\n\n    y - py = fvs * (x - px)\n\n\n  on pm both equations are true for same x/y\n\n    y - rpdy = pvns * (x - rpdx)\n\n    y - py = fvs * (x - px)\n\n  form to y and set equal:\n\n    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n  expand:\n\n    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n  switch:\n\n    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n  solve for x:\n\n    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n          fvs * px - pvns * rpdx + rpdy - py\n    x =  -----------------------------------\n                 fvs - pvns\n\n  and:\n\n    y = fvs * (x - px) + py\n\n\n\nINTERPOLATE:\n============\n\nExamples of point interpolation.\n\nThe weight of the movement of the reference point gets bigger\nthe further the other reference point is away, thus the safest\noption (that is avoiding 0/0 divisions) is to weight the\noriginal distance of the other point by the sum of both distances.\n\nIf the sum of both distances is 0, then move the point by the\narithmetic average of the movement of both reference points.\n\n\n\n\n           (+6)\n    rp1o *---->*rp1\n         .     .                          (+12)\n         .     .                  rp2o *---------->* rp2\n         .     .                       .           .\n         .     .                       .           .\n         .    10          20           .           .\n         |.........|...................|           .\n               .   .                               .\n               .   . (+8)                          .\n                po *------>*p                      .\n               .           .                       .\n               .    12     .          24           .\n               |...........|.......................|\n                                  36\n\n\n-------\n\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .                      (-10)\n         .         .              rp2 *<---------* rpo2\n         .         .                   .         .\n         .         .                   .         .\n         .    10   .          30       .         .\n         |.........|.............................|\n                   .                   .\n                   . (+5)              .\n                po *--->* p            .\n                   .    .              .\n                   .    .   20         .\n                   |....|..............|\n                     5        15\n\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .\n    rp2o *-------->*rp2\n\n\n                               (+10)\n                          po *-------->* p\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .(+30)\n    rp2o *---------------------------->*rp2\n\n\n                                        (+25)\n                          po *----------------------->* p\n\n\n\nvim: set ts=4 sw=4 expandtab:\n*****/ /**\n * Converts a string into a list of tokens.\n */ /**\n * Create a new token\n * @param {string} char a single char\n */ function Token(char) {\n    this.char = char;\n    this.state = {};\n    this.activeState = null;\n}\n/**\n * Create a new context range\n * @param {number} startIndex range start index\n * @param {number} endOffset range end index offset\n * @param {string} contextName owner context name\n */ function ContextRange(startIndex, endOffset, contextName) {\n    this.contextName = contextName;\n    this.startIndex = startIndex;\n    this.endOffset = endOffset;\n}\n/**\n * Check context start and end\n * @param {string} contextName a unique context name\n * @param {function} checkStart a predicate function the indicates a context's start\n * @param {function} checkEnd a predicate function the indicates a context's end\n */ function ContextChecker(contextName, checkStart, checkEnd) {\n    this.contextName = contextName;\n    this.openRange = null;\n    this.ranges = [];\n    this.checkStart = checkStart;\n    this.checkEnd = checkEnd;\n}\n/**\n * @typedef ContextParams\n * @type Object\n * @property {array} context context items\n * @property {number} currentIndex current item index\n */ /**\n * Create a context params\n * @param {array} context a list of items\n * @param {number} currentIndex current item index\n */ function ContextParams(context, currentIndex) {\n    this.context = context;\n    this.index = currentIndex;\n    this.length = context.length;\n    this.current = context[currentIndex];\n    this.backtrack = context.slice(0, currentIndex);\n    this.lookahead = context.slice(currentIndex + 1);\n}\n/**\n * Create an event instance\n * @param {string} eventId event unique id\n */ function Event(eventId) {\n    this.eventId = eventId;\n    this.subscribers = [];\n}\n/**\n * Initialize a core events and auto subscribe required event handlers\n * @param {any} events an object that enlists core events handlers\n */ function initializeCoreEvents(events) {\n    var this$1 = this;\n    var coreEvents = [\n        \"start\",\n        \"end\",\n        \"next\",\n        \"newToken\",\n        \"contextStart\",\n        \"contextEnd\",\n        \"insertToken\",\n        \"removeToken\",\n        \"removeRange\",\n        \"replaceToken\",\n        \"replaceRange\",\n        \"composeRUD\",\n        \"updateContextsRanges\"\n    ];\n    coreEvents.forEach(function(eventId) {\n        Object.defineProperty(this$1.events, eventId, {\n            value: new Event(eventId)\n        });\n    });\n    if (!!events) {\n        coreEvents.forEach(function(eventId) {\n            var event = events[eventId];\n            if (typeof event === \"function\") {\n                this$1.events[eventId].subscribe(event);\n            }\n        });\n    }\n    var requiresContextUpdate = [\n        \"insertToken\",\n        \"removeToken\",\n        \"removeRange\",\n        \"replaceToken\",\n        \"replaceRange\",\n        \"composeRUD\"\n    ];\n    requiresContextUpdate.forEach(function(eventId) {\n        this$1.events[eventId].subscribe(this$1.updateContextsRanges);\n    });\n}\n/**\n * Converts a string into a list of tokens\n * @param {any} events tokenizer core events\n */ function Tokenizer(events) {\n    this.tokens = [];\n    this.registeredContexts = {};\n    this.contextCheckers = [];\n    this.events = {};\n    this.registeredModifiers = [];\n    initializeCoreEvents.call(this, events);\n}\n/**\n * Sets the state of a token, usually called by a state modifier.\n * @param {string} key state item key\n * @param {any} value state item value\n */ Token.prototype.setState = function(key, value) {\n    this.state[key] = value;\n    this.activeState = {\n        key: key,\n        value: this.state[key]\n    };\n    return this.activeState;\n};\nToken.prototype.getState = function(stateId) {\n    return this.state[stateId] || null;\n};\n/**\n * Checks if an index exists in the tokens list.\n * @param {number} index token index\n */ Tokenizer.prototype.inboundIndex = function(index) {\n    return index >= 0 && index < this.tokens.length;\n};\n/**\n * Compose and apply a list of operations (replace, update, delete)\n * @param {array} RUDs replace, update and delete operations\n * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)\n */ Tokenizer.prototype.composeRUD = function(RUDs) {\n    var this$1 = this;\n    var silent = true;\n    var state = RUDs.map(function(RUD) {\n        return this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent));\n    });\n    var hasFAILObject = function(obj) {\n        return typeof obj === \"object\" && obj.hasOwnProperty(\"FAIL\");\n    };\n    if (state.every(hasFAILObject)) {\n        return {\n            FAIL: \"composeRUD: one or more operations hasn't completed successfully\",\n            report: state.filter(hasFAILObject)\n        };\n    }\n    this.dispatch(\"composeRUD\", [\n        state.filter(function(op) {\n            return !hasFAILObject(op);\n        })\n    ]);\n};\n/**\n * Replace a range of tokens with a list of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {token} tokens a list of tokens to replace\n * @param {boolean} silent dispatch events and update context ranges\n */ Tokenizer.prototype.replaceRange = function(startIndex, offset, tokens, silent) {\n    offset = offset !== null ? offset : this.tokens.length;\n    var isTokenType = tokens.every(function(token) {\n        return token instanceof Token;\n    });\n    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {\n        var replaced = this.tokens.splice.apply(this.tokens, [\n            startIndex,\n            offset\n        ].concat(tokens));\n        if (!silent) {\n            this.dispatch(\"replaceToken\", [\n                startIndex,\n                offset,\n                tokens\n            ]);\n        }\n        return [\n            replaced,\n            tokens\n        ];\n    } else {\n        return {\n            FAIL: \"replaceRange: invalid tokens or startIndex.\"\n        };\n    }\n};\n/**\n * Replace a token with another token\n * @param {number} index token index\n * @param {token} token a token to replace\n * @param {boolean} silent dispatch events and update context ranges\n */ Tokenizer.prototype.replaceToken = function(index, token, silent) {\n    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {\n        var replaced = this.tokens.splice(index, 1, token);\n        if (!silent) {\n            this.dispatch(\"replaceToken\", [\n                index,\n                token\n            ]);\n        }\n        return [\n            replaced[0],\n            token\n        ];\n    } else {\n        return {\n            FAIL: \"replaceToken: invalid token or index.\"\n        };\n    }\n};\n/**\n * Removes a range of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {boolean} silent dispatch events and update context ranges\n */ Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {\n    offset = !isNaN(offset) ? offset : this.tokens.length;\n    var tokens = this.tokens.splice(startIndex, offset);\n    if (!silent) {\n        this.dispatch(\"removeRange\", [\n            tokens,\n            startIndex,\n            offset\n        ]);\n    }\n    return tokens;\n};\n/**\n * Remove a token at a certain index\n * @param {number} index token index\n * @param {boolean} silent dispatch events and update context ranges\n */ Tokenizer.prototype.removeToken = function(index, silent) {\n    if (!isNaN(index) && this.inboundIndex(index)) {\n        var token = this.tokens.splice(index, 1);\n        if (!silent) {\n            this.dispatch(\"removeToken\", [\n                token,\n                index\n            ]);\n        }\n        return token;\n    } else {\n        return {\n            FAIL: \"removeToken: invalid token index.\"\n        };\n    }\n};\n/**\n * Insert a list of tokens at a certain index\n * @param {array} tokens a list of tokens to insert\n * @param {number} index insert the list of tokens at index\n * @param {boolean} silent dispatch events and update context ranges\n */ Tokenizer.prototype.insertToken = function(tokens, index, silent) {\n    var tokenType = tokens.every(function(token) {\n        return token instanceof Token;\n    });\n    if (tokenType) {\n        this.tokens.splice.apply(this.tokens, [\n            index,\n            0\n        ].concat(tokens));\n        if (!silent) {\n            this.dispatch(\"insertToken\", [\n                tokens,\n                index\n            ]);\n        }\n        return tokens;\n    } else {\n        return {\n            FAIL: \"insertToken: invalid token(s).\"\n        };\n    }\n};\n/**\n * A state modifier that is called on 'newToken' event\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a function to update token state\n */ Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {\n    this.events.newToken.subscribe(function(token, contextParams) {\n        var conditionParams = [\n            token,\n            contextParams\n        ];\n        var canApplyModifier = condition === null || condition.apply(this, conditionParams) === true;\n        var modifierParams = [\n            token,\n            contextParams\n        ];\n        if (canApplyModifier) {\n            var newStateValue = modifier.apply(this, modifierParams);\n            token.setState(modifierId, newStateValue);\n        }\n    });\n    this.registeredModifiers.push(modifierId);\n};\n/**\n * Subscribe a handler to an event\n * @param {function} eventHandler an event handler function\n */ Event.prototype.subscribe = function(eventHandler) {\n    if (typeof eventHandler === \"function\") {\n        return this.subscribers.push(eventHandler) - 1;\n    } else {\n        return {\n            FAIL: \"invalid '\" + this.eventId + \"' event handler\"\n        };\n    }\n};\n/**\n * Unsubscribe an event handler\n * @param {string} subsId subscription id\n */ Event.prototype.unsubscribe = function(subsId) {\n    this.subscribers.splice(subsId, 1);\n};\n/**\n * Sets context params current value index\n * @param {number} index context params current value index\n */ ContextParams.prototype.setCurrentIndex = function(index) {\n    this.index = index;\n    this.current = this.context[index];\n    this.backtrack = this.context.slice(0, index);\n    this.lookahead = this.context.slice(index + 1);\n};\n/**\n * Get an item at an offset from the current value\n * example (current value is 3):\n *  1    2   [3]   4    5   |   items values\n * -2   -1    0    1    2   |   offset values\n * @param {number} offset an offset from current value index\n */ ContextParams.prototype.get = function(offset) {\n    switch(true){\n        case offset === 0:\n            return this.current;\n        case offset < 0 && Math.abs(offset) <= this.backtrack.length:\n            return this.backtrack.slice(offset)[0];\n        case offset > 0 && offset <= this.lookahead.length:\n            return this.lookahead[offset - 1];\n        default:\n            return null;\n    }\n};\n/**\n * Converts a context range into a string value\n * @param {contextRange} range a context range\n */ Tokenizer.prototype.rangeToText = function(range) {\n    if (range instanceof ContextRange) {\n        return this.getRangeTokens(range).map(function(token) {\n            return token.char;\n        }).join(\"\");\n    }\n};\n/**\n * Converts all tokens into a string\n */ Tokenizer.prototype.getText = function() {\n    return this.tokens.map(function(token) {\n        return token.char;\n    }).join(\"\");\n};\n/**\n * Get a context by name\n * @param {string} contextName context name to get\n */ Tokenizer.prototype.getContext = function(contextName) {\n    var context = this.registeredContexts[contextName];\n    return !!context ? context : null;\n};\n/**\n * Subscribes a new event handler to an event\n * @param {string} eventName event name to subscribe to\n * @param {function} eventHandler a function to be invoked on event\n */ Tokenizer.prototype.on = function(eventName, eventHandler) {\n    var event = this.events[eventName];\n    if (!!event) {\n        return event.subscribe(eventHandler);\n    } else {\n        return null;\n    }\n};\n/**\n * Dispatches an event\n * @param {string} eventName event name\n * @param {any} args event handler arguments\n */ Tokenizer.prototype.dispatch = function(eventName, args) {\n    var this$1 = this;\n    var event = this.events[eventName];\n    if (event instanceof Event) {\n        event.subscribers.forEach(function(subscriber) {\n            subscriber.apply(this$1, args || []);\n        });\n    }\n};\n/**\n * Register a new context checker\n * @param {string} contextName a unique context name\n * @param {function} contextStartCheck a predicate function that returns true on context start\n * @param {function} contextEndCheck  a predicate function that returns true on context end\n * TODO: call tokenize on registration to update context ranges with the new context.\n */ Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {\n    if (!!this.getContext(contextName)) {\n        return {\n            FAIL: \"context name '\" + contextName + \"' is already registered.\"\n        };\n    }\n    if (typeof contextStartCheck !== \"function\") {\n        return {\n            FAIL: \"missing context start check.\"\n        };\n    }\n    if (typeof contextEndCheck !== \"function\") {\n        return {\n            FAIL: \"missing context end check.\"\n        };\n    }\n    var contextCheckers = new ContextChecker(contextName, contextStartCheck, contextEndCheck);\n    this.registeredContexts[contextName] = contextCheckers;\n    this.contextCheckers.push(contextCheckers);\n    return contextCheckers;\n};\n/**\n * Gets a context range tokens\n * @param {contextRange} range a context range\n */ Tokenizer.prototype.getRangeTokens = function(range) {\n    var endIndex = range.startIndex + range.endOffset;\n    return [].concat(this.tokens.slice(range.startIndex, endIndex));\n};\n/**\n * Gets the ranges of a context\n * @param {string} contextName context name\n */ Tokenizer.prototype.getContextRanges = function(contextName) {\n    var context = this.getContext(contextName);\n    if (!!context) {\n        return context.ranges;\n    } else {\n        return {\n            FAIL: \"context checker '\" + contextName + \"' is not registered.\"\n        };\n    }\n};\n/**\n * Resets context ranges to run context update\n */ Tokenizer.prototype.resetContextsRanges = function() {\n    var registeredContexts = this.registeredContexts;\n    for(var contextName in registeredContexts){\n        if (registeredContexts.hasOwnProperty(contextName)) {\n            var context = registeredContexts[contextName];\n            context.ranges = [];\n        }\n    }\n};\n/**\n * Updates context ranges\n */ Tokenizer.prototype.updateContextsRanges = function() {\n    this.resetContextsRanges();\n    var chars = this.tokens.map(function(token) {\n        return token.char;\n    });\n    for(var i = 0; i < chars.length; i++){\n        var contextParams = new ContextParams(chars, i);\n        this.runContextCheck(contextParams);\n    }\n    this.dispatch(\"updateContextsRanges\", [\n        this.registeredContexts\n    ]);\n};\n/**\n * Sets the end offset of an open range\n * @param {number} offset range end offset\n * @param {string} contextName context name\n */ Tokenizer.prototype.setEndOffset = function(offset, contextName) {\n    var startIndex = this.getContext(contextName).openRange.startIndex;\n    var range = new ContextRange(startIndex, offset, contextName);\n    var ranges = this.getContext(contextName).ranges;\n    range.rangeId = contextName + \".\" + ranges.length;\n    ranges.push(range);\n    this.getContext(contextName).openRange = null;\n    return range;\n};\n/**\n * Runs a context check on the current context\n * @param {contextParams} contextParams current context params\n */ Tokenizer.prototype.runContextCheck = function(contextParams) {\n    var this$1 = this;\n    var index = contextParams.index;\n    this.contextCheckers.forEach(function(contextChecker) {\n        var contextName = contextChecker.contextName;\n        var openRange = this$1.getContext(contextName).openRange;\n        if (!openRange && contextChecker.checkStart(contextParams)) {\n            openRange = new ContextRange(index, null, contextName);\n            this$1.getContext(contextName).openRange = openRange;\n            this$1.dispatch(\"contextStart\", [\n                contextName,\n                index\n            ]);\n        }\n        if (!!openRange && contextChecker.checkEnd(contextParams)) {\n            var offset = index - openRange.startIndex + 1;\n            var range = this$1.setEndOffset(offset, contextName);\n            this$1.dispatch(\"contextEnd\", [\n                contextName,\n                range\n            ]);\n        }\n    });\n};\n/**\n * Converts a text into a list of tokens\n * @param {string} text a text to tokenize\n */ Tokenizer.prototype.tokenize = function(text) {\n    this.tokens = [];\n    this.resetContextsRanges();\n    var chars = Array.from(text);\n    this.dispatch(\"start\");\n    for(var i = 0; i < chars.length; i++){\n        var char = chars[i];\n        var contextParams = new ContextParams(chars, i);\n        this.dispatch(\"next\", [\n            contextParams\n        ]);\n        this.runContextCheck(contextParams);\n        var token = new Token(char);\n        this.tokens.push(token);\n        this.dispatch(\"newToken\", [\n            token,\n            contextParams\n        ]);\n    }\n    this.dispatch(\"end\", [\n        this.tokens\n    ]);\n    return this.tokens;\n};\n// ╭─┄┄┄────────────────────────┄─────────────────────────────────────────────╮\n// ┊ Character Class Assertions ┊ Checks if a char belongs to a certain class ┊\n// ╰─╾──────────────────────────┄─────────────────────────────────────────────╯\n// jscs:disable maximumLineLength\n/**\n * Check if a char is Arabic\n * @param {string} c a single char\n */ function isArabicChar(c) {\n    return /[\\u0600-\\u065F\\u066A-\\u06D2\\u06FA-\\u06FF]/.test(c);\n}\n/**\n * Check if a char is an isolated arabic char\n * @param {string} c a single char\n */ function isIsolatedArabicChar(char) {\n    return /[\\u0630\\u0690\\u0621\\u0631\\u0661\\u0671\\u0622\\u0632\\u0672\\u0692\\u06C2\\u0623\\u0673\\u0693\\u06C3\\u0624\\u0694\\u06C4\\u0625\\u0675\\u0695\\u06C5\\u06E5\\u0676\\u0696\\u06C6\\u0627\\u0677\\u0697\\u06C7\\u0648\\u0688\\u0698\\u06C8\\u0689\\u0699\\u06C9\\u068A\\u06CA\\u066B\\u068B\\u06CB\\u068C\\u068D\\u06CD\\u06FD\\u068E\\u06EE\\u06FE\\u062F\\u068F\\u06CF\\u06EF]/.test(char);\n}\n/**\n * Check if a char is an Arabic Tashkeel char\n * @param {string} c a single char\n */ function isTashkeelArabicChar(char) {\n    return /[\\u0600-\\u0605\\u060C-\\u060E\\u0610-\\u061B\\u061E\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED]/.test(char);\n}\n/**\n * Check if a char is Latin\n * @param {string} c a single char\n */ function isLatinChar(c) {\n    return /[A-z]/.test(c);\n}\n/**\n * Check if a char is whitespace char\n * @param {string} c a single char\n */ function isWhiteSpace(c) {\n    return /\\s/.test(c);\n}\n/**\n * Query a feature by some of it's properties to lookup a glyph substitution.\n */ /**\n * Create feature query instance\n * @param {Font} font opentype font instance\n */ function FeatureQuery(font) {\n    this.font = font;\n    this.features = {};\n}\n/**\n * @typedef SubstitutionAction\n * @type Object\n * @property {number} id substitution type\n * @property {string} tag feature tag\n * @property {any} substitution substitution value(s)\n */ /**\n * Create a substitution action instance\n * @param {SubstitutionAction} action\n */ function SubstitutionAction(action) {\n    this.id = action.id;\n    this.tag = action.tag;\n    this.substitution = action.substitution;\n}\n/**\n * Lookup a coverage table\n * @param {number} glyphIndex glyph index\n * @param {CoverageTable} coverage coverage table\n */ function lookupCoverage(glyphIndex, coverage) {\n    if (!glyphIndex) {\n        return -1;\n    }\n    switch(coverage.format){\n        case 1:\n            return coverage.glyphs.indexOf(glyphIndex);\n        case 2:\n            var ranges = coverage.ranges;\n            for(var i = 0; i < ranges.length; i++){\n                var range = ranges[i];\n                if (glyphIndex >= range.start && glyphIndex <= range.end) {\n                    var offset = glyphIndex - range.start;\n                    return range.index + offset;\n                }\n            }\n            break;\n        default:\n            return -1; // not found\n    }\n    return -1;\n}\n/**\n * Handle a single substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */ function singleSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) {\n        return null;\n    }\n    return glyphIndex + subtable.deltaGlyphId;\n}\n/**\n * Handle a single substitution - format 2\n * @param {ContextParams} contextParams context params to lookup\n */ function singleSubstitutionFormat2(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) {\n        return null;\n    }\n    return subtable.substitute[substituteIndex];\n}\n/**\n * Lookup a list of coverage tables\n * @param {any} coverageList a list of coverage tables\n * @param {ContextParams} contextParams context params to lookup\n */ function lookupCoverageList(coverageList, contextParams) {\n    var lookupList = [];\n    for(var i = 0; i < coverageList.length; i++){\n        var coverage = coverageList[i];\n        var glyphIndex = contextParams.current;\n        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;\n        var lookupIndex = lookupCoverage(glyphIndex, coverage);\n        if (lookupIndex !== -1) {\n            lookupList.push(lookupIndex);\n        }\n    }\n    if (lookupList.length !== coverageList.length) {\n        return -1;\n    }\n    return lookupList;\n}\n/**\n * Handle chaining context substitution - format 3\n * @param {ContextParams} contextParams context params to lookup\n */ function chainingSubstitutionFormat3(contextParams, subtable) {\n    var lookupsCount = subtable.inputCoverage.length + subtable.lookaheadCoverage.length + subtable.backtrackCoverage.length;\n    if (contextParams.context.length < lookupsCount) {\n        return [];\n    }\n    // INPUT LOOKUP //\n    var inputLookups = lookupCoverageList(subtable.inputCoverage, contextParams);\n    if (inputLookups === -1) {\n        return [];\n    }\n    // LOOKAHEAD LOOKUP //\n    var lookaheadOffset = subtable.inputCoverage.length - 1;\n    if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) {\n        return [];\n    }\n    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);\n    while(lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)){\n        lookaheadContext.shift();\n    }\n    var lookaheadParams = new ContextParams(lookaheadContext, 0);\n    var lookaheadLookups = lookupCoverageList(subtable.lookaheadCoverage, lookaheadParams);\n    // BACKTRACK LOOKUP //\n    var backtrackContext = [].concat(contextParams.backtrack);\n    backtrackContext.reverse();\n    while(backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)){\n        backtrackContext.shift();\n    }\n    if (backtrackContext.length < subtable.backtrackCoverage.length) {\n        return [];\n    }\n    var backtrackParams = new ContextParams(backtrackContext, 0);\n    var backtrackLookups = lookupCoverageList(subtable.backtrackCoverage, backtrackParams);\n    var contextRulesMatch = inputLookups.length === subtable.inputCoverage.length && lookaheadLookups.length === subtable.lookaheadCoverage.length && backtrackLookups.length === subtable.backtrackCoverage.length;\n    var substitutions = [];\n    if (contextRulesMatch) {\n        for(var i = 0; i < subtable.lookupRecords.length; i++){\n            var lookupRecord = subtable.lookupRecords[i];\n            var lookupListIndex = lookupRecord.lookupListIndex;\n            var lookupTable = this.getLookupByIndex(lookupListIndex);\n            for(var s = 0; s < lookupTable.subtables.length; s++){\n                var subtable$1 = lookupTable.subtables[s];\n                var lookup = this.getLookupMethod(lookupTable, subtable$1);\n                var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);\n                if (substitutionType === \"12\") {\n                    for(var n = 0; n < inputLookups.length; n++){\n                        var glyphIndex = contextParams.get(n);\n                        var substitution = lookup(glyphIndex);\n                        if (substitution) {\n                            substitutions.push(substitution);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return substitutions;\n}\n/**\n * Handle ligature substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */ function ligatureSubstitutionFormat1(contextParams, subtable) {\n    // COVERAGE LOOKUP //\n    var glyphIndex = contextParams.current;\n    var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (ligSetIndex === -1) {\n        return null;\n    }\n    // COMPONENTS LOOKUP\n    // (!) note, components are ordered in the written direction.\n    var ligature;\n    var ligatureSet = subtable.ligatureSets[ligSetIndex];\n    for(var s = 0; s < ligatureSet.length; s++){\n        ligature = ligatureSet[s];\n        for(var l = 0; l < ligature.components.length; l++){\n            var lookaheadItem = contextParams.lookahead[l];\n            var component = ligature.components[l];\n            if (lookaheadItem !== component) {\n                break;\n            }\n            if (l === ligature.components.length - 1) {\n                return ligature;\n            }\n        }\n    }\n    return null;\n}\n/**\n * Handle decomposition substitution - format 1\n * @param {number} glyphIndex glyph index\n * @param {any} subtable subtable\n */ function decompositionSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) {\n        return null;\n    }\n    return subtable.sequences[substituteIndex];\n}\n/**\n * Get default script features indexes\n */ FeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function() {\n    var scripts = this.font.tables.gsub.scripts;\n    for(var s = 0; s < scripts.length; s++){\n        var script = scripts[s];\n        if (script.tag === \"DFLT\") {\n            return script.script.defaultLangSys.featureIndexes;\n        }\n    }\n    return [];\n};\n/**\n * Get feature indexes of a specific script\n * @param {string} scriptTag script tag\n */ FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {\n    var tables = this.font.tables;\n    if (!tables.gsub) {\n        return [];\n    }\n    if (!scriptTag) {\n        return this.getDefaultScriptFeaturesIndexes();\n    }\n    var scripts = this.font.tables.gsub.scripts;\n    for(var i = 0; i < scripts.length; i++){\n        var script = scripts[i];\n        if (script.tag === scriptTag && script.script.defaultLangSys) {\n            return script.script.defaultLangSys.featureIndexes;\n        } else {\n            var langSysRecords = script.langSysRecords;\n            if (!!langSysRecords) {\n                for(var j = 0; j < langSysRecords.length; j++){\n                    var langSysRecord = langSysRecords[j];\n                    if (langSysRecord.tag === scriptTag) {\n                        var langSys = langSysRecord.langSys;\n                        return langSys.featureIndexes;\n                    }\n                }\n            }\n        }\n    }\n    return this.getDefaultScriptFeaturesIndexes();\n};\n/**\n * Map a feature tag to a gsub feature\n * @param {any} features gsub features\n * @param {string} scriptTag script tag\n */ FeatureQuery.prototype.mapTagsToFeatures = function(features, scriptTag) {\n    var tags = {};\n    for(var i = 0; i < features.length; i++){\n        var tag = features[i].tag;\n        var feature = features[i].feature;\n        tags[tag] = feature;\n    }\n    this.features[scriptTag].tags = tags;\n};\n/**\n * Get features of a specific script\n * @param {string} scriptTag script tag\n */ FeatureQuery.prototype.getScriptFeatures = function(scriptTag) {\n    var features = this.features[scriptTag];\n    if (this.features.hasOwnProperty(scriptTag)) {\n        return features;\n    }\n    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);\n    if (!featuresIndexes) {\n        return null;\n    }\n    var gsub = this.font.tables.gsub;\n    features = featuresIndexes.map(function(index) {\n        return gsub.features[index];\n    });\n    this.features[scriptTag] = features;\n    this.mapTagsToFeatures(features, scriptTag);\n    return features;\n};\n/**\n * Get substitution type\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */ FeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {\n    var lookupType = lookupTable.lookupType.toString();\n    var substFormat = subtable.substFormat.toString();\n    return lookupType + substFormat;\n};\n/**\n * Get lookup method\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */ FeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {\n    var this$1 = this;\n    var substitutionType = this.getSubstitutionType(lookupTable, subtable);\n    switch(substitutionType){\n        case \"11\":\n            return function(glyphIndex) {\n                return singleSubstitutionFormat1.apply(this$1, [\n                    glyphIndex,\n                    subtable\n                ]);\n            };\n        case \"12\":\n            return function(glyphIndex) {\n                return singleSubstitutionFormat2.apply(this$1, [\n                    glyphIndex,\n                    subtable\n                ]);\n            };\n        case \"63\":\n            return function(contextParams) {\n                return chainingSubstitutionFormat3.apply(this$1, [\n                    contextParams,\n                    subtable\n                ]);\n            };\n        case \"41\":\n            return function(contextParams) {\n                return ligatureSubstitutionFormat1.apply(this$1, [\n                    contextParams,\n                    subtable\n                ]);\n            };\n        case \"21\":\n            return function(glyphIndex) {\n                return decompositionSubstitutionFormat1.apply(this$1, [\n                    glyphIndex,\n                    subtable\n                ]);\n            };\n        default:\n            throw new Error(\"lookupType: \" + lookupTable.lookupType + \" - \" + \"substFormat: \" + subtable.substFormat + \" \" + \"is not yet supported\");\n    }\n};\n/**\n * [ LOOKUP TYPES ]\n * -------------------------------\n * Single                        1;\n * Multiple                      2;\n * Alternate                     3;\n * Ligature                      4;\n * Context                       5;\n * ChainingContext               6;\n * ExtensionSubstitution         7;\n * ReverseChainingContext        8;\n * -------------------------------\n *\n */ /**\n * @typedef FQuery\n * @type Object\n * @param {string} tag feature tag\n * @param {string} script feature script\n * @param {ContextParams} contextParams context params\n */ /**\n * Lookup a feature using a query parameters\n * @param {FQuery} query feature query\n */ FeatureQuery.prototype.lookupFeature = function(query) {\n    var contextParams = query.contextParams;\n    var currentIndex = contextParams.index;\n    var feature = this.getFeature({\n        tag: query.tag,\n        script: query.script\n    });\n    if (!feature) {\n        return new Error(\"font '\" + this.font.names.fullName.en + \"' \" + \"doesn't support feature '\" + query.tag + \"' \" + \"for script '\" + query.script + \"'.\");\n    }\n    var lookups = this.getFeatureLookups(feature);\n    var substitutions = [].concat(contextParams.context);\n    for(var l = 0; l < lookups.length; l++){\n        var lookupTable = lookups[l];\n        var subtables = this.getLookupSubtables(lookupTable);\n        for(var s = 0; s < subtables.length; s++){\n            var subtable = subtables[s];\n            var substType = this.getSubstitutionType(lookupTable, subtable);\n            var lookup = this.getLookupMethod(lookupTable, subtable);\n            var substitution = void 0;\n            switch(substType){\n                case \"11\":\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 11,\n                            tag: query.tag,\n                            substitution: substitution\n                        }));\n                    }\n                    break;\n                case \"12\":\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 12,\n                            tag: query.tag,\n                            substitution: substitution\n                        }));\n                    }\n                    break;\n                case \"63\":\n                    substitution = lookup(contextParams);\n                    if (Array.isArray(substitution) && substitution.length) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 63,\n                            tag: query.tag,\n                            substitution: substitution\n                        }));\n                    }\n                    break;\n                case \"41\":\n                    substitution = lookup(contextParams);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 41,\n                            tag: query.tag,\n                            substitution: substitution\n                        }));\n                    }\n                    break;\n                case \"21\":\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 21,\n                            tag: query.tag,\n                            substitution: substitution\n                        }));\n                    }\n                    break;\n            }\n            contextParams = new ContextParams(substitutions, currentIndex);\n            if (Array.isArray(substitution) && !substitution.length) {\n                continue;\n            }\n            substitution = null;\n        }\n    }\n    return substitutions.length ? substitutions : null;\n};\n/**\n * Checks if a font supports a specific features\n * @param {FQuery} query feature query object\n */ FeatureQuery.prototype.supports = function(query) {\n    if (!query.script) {\n        return false;\n    }\n    this.getScriptFeatures(query.script);\n    var supportedScript = this.features.hasOwnProperty(query.script);\n    if (!query.tag) {\n        return supportedScript;\n    }\n    var supportedFeature = this.features[query.script].some(function(feature) {\n        return feature.tag === query.tag;\n    });\n    return supportedScript && supportedFeature;\n};\n/**\n * Get lookup table subtables\n * @param {any} lookupTable lookup table\n */ FeatureQuery.prototype.getLookupSubtables = function(lookupTable) {\n    return lookupTable.subtables || null;\n};\n/**\n * Get lookup table by index\n * @param {number} index lookup table index\n */ FeatureQuery.prototype.getLookupByIndex = function(index) {\n    var lookups = this.font.tables.gsub.lookups;\n    return lookups[index] || null;\n};\n/**\n * Get lookup tables for a feature\n * @param {string} feature\n */ FeatureQuery.prototype.getFeatureLookups = function(feature) {\n    // TODO: memoize\n    return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));\n};\n/**\n * Query a feature by it's properties\n * @param {any} query an object that describes the properties of a query\n */ FeatureQuery.prototype.getFeature = function getFeature(query) {\n    if (!this.font) {\n        return {\n            FAIL: \"No font was found\"\n        };\n    }\n    if (!this.features.hasOwnProperty(query.script)) {\n        this.getScriptFeatures(query.script);\n    }\n    var scriptFeatures = this.features[query.script];\n    if (!scriptFeatures) {\n        return {\n            FAIL: \"No feature for script \" + query.script\n        };\n    }\n    if (!scriptFeatures.tags[query.tag]) {\n        return null;\n    }\n    return this.features[query.script].tags[query.tag];\n};\n/**\n * Arabic word context checkers\n */ function arabicWordStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return(// ? arabic first char\n    prevChar === null && isArabicChar(char) || // ? arabic char preceded with a non arabic char\n    !isArabicChar(prevChar) && isArabicChar(char));\n}\nfunction arabicWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    return(// ? last arabic char\n    nextChar === null || // ? next char is not arabic\n    !isArabicChar(nextChar));\n}\nvar arabicWordCheck = {\n    startCheck: arabicWordStartCheck,\n    endCheck: arabicWordEndCheck\n};\n/**\n * Arabic sentence context checkers\n */ function arabicSentenceStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return(// ? an arabic char preceded with a non arabic char\n    (isArabicChar(char) || isTashkeelArabicChar(char)) && !isArabicChar(prevChar));\n}\nfunction arabicSentenceEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    switch(true){\n        case nextChar === null:\n            return true;\n        case !isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar):\n            var nextIsWhitespace = isWhiteSpace(nextChar);\n            if (!nextIsWhitespace) {\n                return true;\n            }\n            if (nextIsWhitespace) {\n                var arabicCharAhead = false;\n                arabicCharAhead = contextParams.lookahead.some(function(c) {\n                    return isArabicChar(c) || isTashkeelArabicChar(c);\n                });\n                if (!arabicCharAhead) {\n                    return true;\n                }\n            }\n            break;\n        default:\n            return false;\n    }\n}\nvar arabicSentenceCheck = {\n    startCheck: arabicSentenceStartCheck,\n    endCheck: arabicSentenceEndCheck\n};\n/**\n * Apply single substitution format 1\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */ function singleSubstitutionFormat1$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution);\n}\n/**\n * Apply single substitution format 2\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */ function singleSubstitutionFormat2$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution);\n}\n/**\n * Apply chaining context substitution format 3\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */ function chainingSubstitutionFormat3$1(action, tokens, index) {\n    action.substitution.forEach(function(subst, offset) {\n        var token = tokens[index + offset];\n        token.setState(action.tag, subst);\n    });\n}\n/**\n * Apply ligature substitution format 1\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */ function ligatureSubstitutionFormat1$1(action, tokens, index) {\n    var token = tokens[index];\n    token.setState(action.tag, action.substitution.ligGlyph);\n    var compsCount = action.substitution.components.length;\n    for(var i = 0; i < compsCount; i++){\n        token = tokens[index + i + 1];\n        token.setState(\"deleted\", true);\n    }\n}\n/**\n * Supported substitutions\n */ var SUBSTITUTIONS = {\n    11: singleSubstitutionFormat1$1,\n    12: singleSubstitutionFormat2$1,\n    63: chainingSubstitutionFormat3$1,\n    41: ligatureSubstitutionFormat1$1\n};\n/**\n * Apply substitutions to a list of tokens\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */ function applySubstitution(action, tokens, index) {\n    if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {\n        SUBSTITUTIONS[action.id](action, tokens, index);\n    }\n}\n/**\n * Apply Arabic presentation forms to a range of tokens\n */ /**\n * Check if a char can be connected to it's preceding char\n * @param {ContextParams} charContextParams context params of a char\n */ function willConnectPrev(charContextParams) {\n    var backtrack = [].concat(charContextParams.backtrack);\n    for(var i = backtrack.length - 1; i >= 0; i--){\n        var prevChar = backtrack[i];\n        var isolated = isIsolatedArabicChar(prevChar);\n        var tashkeel = isTashkeelArabicChar(prevChar);\n        if (!isolated && !tashkeel) {\n            return true;\n        }\n        if (isolated) {\n            return false;\n        }\n    }\n    return false;\n}\n/**\n * Check if a char can be connected to it's proceeding char\n * @param {ContextParams} charContextParams context params of a char\n */ function willConnectNext(charContextParams) {\n    if (isIsolatedArabicChar(charContextParams.current)) {\n        return false;\n    }\n    for(var i = 0; i < charContextParams.lookahead.length; i++){\n        var nextChar = charContextParams.lookahead[i];\n        var tashkeel = isTashkeelArabicChar(nextChar);\n        if (!tashkeel) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Apply arabic presentation forms to a list of tokens\n * @param {ContextRange} range a range of tokens\n */ function arabicPresentationForms(range) {\n    var this$1 = this;\n    var script = \"arab\";\n    var tags = this.featuresTags[script];\n    var tokens = this.tokenizer.getRangeTokens(range);\n    if (tokens.length === 1) {\n        return;\n    }\n    var contextParams = new ContextParams(tokens.map(function(token) {\n        return token.getState(\"glyphIndex\");\n    }), 0);\n    var charContextParams = new ContextParams(tokens.map(function(token) {\n        return token.char;\n    }), 0);\n    tokens.forEach(function(token, index) {\n        if (isTashkeelArabicChar(token.char)) {\n            return;\n        }\n        contextParams.setCurrentIndex(index);\n        charContextParams.setCurrentIndex(index);\n        var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)\n        if (willConnectPrev(charContextParams)) {\n            CONNECT |= 1;\n        }\n        if (willConnectNext(charContextParams)) {\n            CONNECT |= 2;\n        }\n        var tag;\n        switch(CONNECT){\n            case 1:\n                tag = \"fina\";\n                break;\n            case 2:\n                tag = \"init\";\n                break;\n            case 3:\n                tag = \"medi\";\n                break;\n        }\n        if (tags.indexOf(tag) === -1) {\n            return;\n        }\n        var substitutions = this$1.query.lookupFeature({\n            tag: tag,\n            script: script,\n            contextParams: contextParams\n        });\n        if (substitutions instanceof Error) {\n            return console.info(substitutions.message);\n        }\n        substitutions.forEach(function(action, index) {\n            if (action instanceof SubstitutionAction) {\n                applySubstitution(action, tokens, index);\n                contextParams.context[index] = action.substitution;\n            }\n        });\n    });\n}\n/**\n * Apply Arabic required ligatures feature to a range of tokens\n */ /**\n * Update context params\n * @param {any} tokens a list of tokens\n * @param {number} index current item index\n */ function getContextParams(tokens, index) {\n    var context = tokens.map(function(token) {\n        return token.activeState.value;\n    });\n    return new ContextParams(context, index || 0);\n}\n/**\n * Apply Arabic required ligatures to a context range\n * @param {ContextRange} range a range of tokens\n */ function arabicRequiredLigatures(range) {\n    var this$1 = this;\n    var script = \"arab\";\n    var tokens = this.tokenizer.getRangeTokens(range);\n    var contextParams = getContextParams(tokens);\n    contextParams.context.forEach(function(glyphIndex, index) {\n        contextParams.setCurrentIndex(index);\n        var substitutions = this$1.query.lookupFeature({\n            tag: \"rlig\",\n            script: script,\n            contextParams: contextParams\n        });\n        if (substitutions.length) {\n            substitutions.forEach(function(action) {\n                return applySubstitution(action, tokens, index);\n            });\n            contextParams = getContextParams(tokens);\n        }\n    });\n}\n/**\n * Latin word context checkers\n */ function latinWordStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return(// ? latin first char\n    prevChar === null && isLatinChar(char) || // ? latin char preceded with a non latin char\n    !isLatinChar(prevChar) && isLatinChar(char));\n}\nfunction latinWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    return(// ? last latin char\n    nextChar === null || // ? next char is not latin\n    !isLatinChar(nextChar));\n}\nvar latinWordCheck = {\n    startCheck: latinWordStartCheck,\n    endCheck: latinWordEndCheck\n};\n/**\n * Apply Latin ligature feature to a range of tokens\n */ /**\n * Update context params\n * @param {any} tokens a list of tokens\n * @param {number} index current item index\n */ function getContextParams$1(tokens, index) {\n    var context = tokens.map(function(token) {\n        return token.activeState.value;\n    });\n    return new ContextParams(context, index || 0);\n}\n/**\n * Apply Arabic required ligatures to a context range\n * @param {ContextRange} range a range of tokens\n */ function latinLigature(range) {\n    var this$1 = this;\n    var script = \"latn\";\n    var tokens = this.tokenizer.getRangeTokens(range);\n    var contextParams = getContextParams$1(tokens);\n    contextParams.context.forEach(function(glyphIndex, index) {\n        contextParams.setCurrentIndex(index);\n        var substitutions = this$1.query.lookupFeature({\n            tag: \"liga\",\n            script: script,\n            contextParams: contextParams\n        });\n        if (substitutions.length) {\n            substitutions.forEach(function(action) {\n                return applySubstitution(action, tokens, index);\n            });\n            contextParams = getContextParams$1(tokens);\n        }\n    });\n}\n/**\n * Infer bidirectional properties for a given text and apply\n * the corresponding layout rules.\n */ /**\n * Create Bidi. features\n * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'\n */ function Bidi(baseDir) {\n    this.baseDir = baseDir || \"ltr\";\n    this.tokenizer = new Tokenizer();\n    this.featuresTags = {};\n}\n/**\n * Sets Bidi text\n * @param {string} text a text input\n */ Bidi.prototype.setText = function(text) {\n    this.text = text;\n};\n/**\n * Store essential context checks:\n * arabic word check for applying gsub features\n * arabic sentence check for adjusting arabic layout\n */ Bidi.prototype.contextChecks = {\n    latinWordCheck: latinWordCheck,\n    arabicWordCheck: arabicWordCheck,\n    arabicSentenceCheck: arabicSentenceCheck\n};\n/**\n * Register arabic word check\n */ function registerContextChecker(checkId) {\n    var check = this.contextChecks[checkId + \"Check\"];\n    return this.tokenizer.registerContextChecker(checkId, check.startCheck, check.endCheck);\n}\n/**\n * Perform pre tokenization procedure then\n * tokenize text input\n */ function tokenizeText() {\n    registerContextChecker.call(this, \"latinWord\");\n    registerContextChecker.call(this, \"arabicWord\");\n    registerContextChecker.call(this, \"arabicSentence\");\n    return this.tokenizer.tokenize(this.text);\n}\n/**\n * Reverse arabic sentence layout\n * TODO: check base dir before applying adjustments - priority low\n */ function reverseArabicSentences() {\n    var this$1 = this;\n    var ranges = this.tokenizer.getContextRanges(\"arabicSentence\");\n    ranges.forEach(function(range) {\n        var rangeTokens = this$1.tokenizer.getRangeTokens(range);\n        this$1.tokenizer.replaceRange(range.startIndex, range.endOffset, rangeTokens.reverse());\n    });\n}\n/**\n * Register supported features tags\n * @param {script} script script tag\n * @param {Array} tags features tags list\n */ Bidi.prototype.registerFeatures = function(script, tags) {\n    var this$1 = this;\n    var supportedTags = tags.filter(function(tag) {\n        return this$1.query.supports({\n            script: script,\n            tag: tag\n        });\n    });\n    if (!this.featuresTags.hasOwnProperty(script)) {\n        this.featuresTags[script] = supportedTags;\n    } else {\n        this.featuresTags[script] = this.featuresTags[script].concat(supportedTags);\n    }\n};\n/**\n * Apply GSUB features\n * @param {Array} tagsList a list of features tags\n * @param {string} script a script tag\n * @param {Font} font opentype font instance\n */ Bidi.prototype.applyFeatures = function(font, features) {\n    if (!font) {\n        throw new Error(\"No valid font was provided to apply features\");\n    }\n    if (!this.query) {\n        this.query = new FeatureQuery(font);\n    }\n    for(var f = 0; f < features.length; f++){\n        var feature = features[f];\n        if (!this.query.supports({\n            script: feature.script\n        })) {\n            continue;\n        }\n        this.registerFeatures(feature.script, feature.tags);\n    }\n};\n/**\n * Register a state modifier\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a modifier function to set token state\n */ Bidi.prototype.registerModifier = function(modifierId, condition, modifier) {\n    this.tokenizer.registerModifier(modifierId, condition, modifier);\n};\n/**\n * Check if 'glyphIndex' is registered\n */ function checkGlyphIndexStatus() {\n    if (this.tokenizer.registeredModifiers.indexOf(\"glyphIndex\") === -1) {\n        throw new Error(\"glyphIndex modifier is required to apply \" + \"arabic presentation features.\");\n    }\n}\n/**\n * Apply arabic presentation forms features\n */ function applyArabicPresentationForms() {\n    var this$1 = this;\n    var script = \"arab\";\n    if (!this.featuresTags.hasOwnProperty(script)) {\n        return;\n    }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges(\"arabicWord\");\n    ranges.forEach(function(range) {\n        arabicPresentationForms.call(this$1, range);\n    });\n}\n/**\n * Apply required arabic ligatures\n */ function applyArabicRequireLigatures() {\n    var this$1 = this;\n    var script = \"arab\";\n    if (!this.featuresTags.hasOwnProperty(script)) {\n        return;\n    }\n    var tags = this.featuresTags[script];\n    if (tags.indexOf(\"rlig\") === -1) {\n        return;\n    }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges(\"arabicWord\");\n    ranges.forEach(function(range) {\n        arabicRequiredLigatures.call(this$1, range);\n    });\n}\n/**\n * Apply required arabic ligatures\n */ function applyLatinLigatures() {\n    var this$1 = this;\n    var script = \"latn\";\n    if (!this.featuresTags.hasOwnProperty(script)) {\n        return;\n    }\n    var tags = this.featuresTags[script];\n    if (tags.indexOf(\"liga\") === -1) {\n        return;\n    }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges(\"latinWord\");\n    ranges.forEach(function(range) {\n        latinLigature.call(this$1, range);\n    });\n}\n/**\n * Check if a context is registered\n * @param {string} contextId context id\n */ Bidi.prototype.checkContextReady = function(contextId) {\n    return !!this.tokenizer.getContext(contextId);\n};\n/**\n * Apply features to registered contexts\n */ Bidi.prototype.applyFeaturesToContexts = function() {\n    if (this.checkContextReady(\"arabicWord\")) {\n        applyArabicPresentationForms.call(this);\n        applyArabicRequireLigatures.call(this);\n    }\n    if (this.checkContextReady(\"latinWord\")) {\n        applyLatinLigatures.call(this);\n    }\n    if (this.checkContextReady(\"arabicSentence\")) {\n        reverseArabicSentences.call(this);\n    }\n};\n/**\n * process text input\n * @param {string} text an input text\n */ Bidi.prototype.processText = function(text) {\n    if (!this.text || this.text !== text) {\n        this.setText(text);\n        tokenizeText.call(this);\n        this.applyFeaturesToContexts();\n    }\n};\n/**\n * Process a string of text to identify and adjust\n * bidirectional text entities.\n * @param {string} text input text\n */ Bidi.prototype.getBidiText = function(text) {\n    this.processText(text);\n    return this.tokenizer.getText();\n};\n/**\n * Get the current state index of each token\n * @param {text} text an input text\n */ Bidi.prototype.getTextGlyphs = function(text) {\n    this.processText(text);\n    var indexes = [];\n    for(var i = 0; i < this.tokenizer.tokens.length; i++){\n        var token = this.tokenizer.tokens[i];\n        if (token.state.deleted) {\n            continue;\n        }\n        var index = token.activeState.value;\n        indexes.push(Array.isArray(index) ? index[0] : index);\n    }\n    return indexes;\n};\n// The Font object\n/**\n * @typedef FontOptions\n * @type Object\n * @property {Boolean} empty - whether to create a new empty font\n * @property {string} familyName\n * @property {string} styleName\n * @property {string=} fullName\n * @property {string=} postScriptName\n * @property {string=} designer\n * @property {string=} designerURL\n * @property {string=} manufacturer\n * @property {string=} manufacturerURL\n * @property {string=} license\n * @property {string=} licenseURL\n * @property {string=} version\n * @property {string=} description\n * @property {string=} copyright\n * @property {string=} trademark\n * @property {Number} unitsPerEm\n * @property {Number} ascender\n * @property {Number} descender\n * @property {Number} createdTimestamp\n * @property {string=} weightClass\n * @property {string=} widthClass\n * @property {string=} fsSelection\n */ /**\n * A Font represents a loaded OpenType font file.\n * It contains a set of glyphs and methods to draw text on a drawing context,\n * or to get a path representing the text.\n * @exports opentype.Font\n * @class\n * @param {FontOptions}\n * @constructor\n */ function Font(options) {\n    options = options || {};\n    options.tables = options.tables || {};\n    if (!options.empty) {\n        // Check that we've provided the minimum set of names.\n        checkArgument(options.familyName, \"When creating a new Font object, familyName is required.\");\n        checkArgument(options.styleName, \"When creating a new Font object, styleName is required.\");\n        checkArgument(options.unitsPerEm, \"When creating a new Font object, unitsPerEm is required.\");\n        checkArgument(options.ascender, \"When creating a new Font object, ascender is required.\");\n        checkArgument(options.descender <= 0, \"When creating a new Font object, negative descender value is required.\");\n        this.unitsPerEm = options.unitsPerEm || 1000;\n        this.ascender = options.ascender;\n        this.descender = options.descender;\n        this.createdTimestamp = options.createdTimestamp;\n        this.tables = Object.assign(options.tables, {\n            os2: Object.assign({\n                usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,\n                usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,\n                fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR\n            }, options.tables.os2)\n        });\n    }\n    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.\n    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);\n    this.encoding = new DefaultEncoding(this);\n    this.position = new Position(this);\n    this.substitution = new Substitution(this);\n    this.tables = this.tables || {};\n    // needed for low memory mode only.\n    this._push = null;\n    this._hmtxTableData = {};\n    Object.defineProperty(this, \"hinting\", {\n        get: function() {\n            if (this._hinting) {\n                return this._hinting;\n            }\n            if (this.outlinesFormat === \"truetype\") {\n                return this._hinting = new Hinting(this);\n            }\n        }\n    });\n}\n/**\n * Check if the font has a glyph for the given character.\n * @param  {string}\n * @return {Boolean}\n */ Font.prototype.hasChar = function(c) {\n    return this.encoding.charToGlyphIndex(c) !== null;\n};\n/**\n * Convert the given character to a single glyph index.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {Number}\n */ Font.prototype.charToGlyphIndex = function(s) {\n    return this.encoding.charToGlyphIndex(s);\n};\n/**\n * Convert the given character to a single Glyph object.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {opentype.Glyph}\n */ Font.prototype.charToGlyph = function(c) {\n    var glyphIndex = this.charToGlyphIndex(c);\n    var glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n    return glyph;\n};\n/**\n * Update features\n * @param {any} options features options\n */ Font.prototype.updateFeatures = function(options) {\n    // TODO: update all features options not only 'latn'.\n    return this.defaultRenderOptions.features.map(function(feature) {\n        if (feature.script === \"latn\") {\n            return {\n                script: \"latn\",\n                tags: feature.tags.filter(function(tag) {\n                    return options[tag];\n                })\n            };\n        } else {\n            return feature;\n        }\n    });\n};\n/**\n * Convert the given text to a list of Glyph objects.\n * Note that there is no strict one-to-one mapping between characters and\n * glyphs, so the list of returned glyphs can be larger or smaller than the\n * length of the given string.\n * @param  {string}\n * @param  {GlyphRenderOptions} [options]\n * @return {opentype.Glyph[]}\n */ Font.prototype.stringToGlyphs = function(s, options) {\n    var this$1 = this;\n    var bidi = new Bidi();\n    // Create and register 'glyphIndex' state modifier\n    var charToGlyphIndexMod = function(token) {\n        return this$1.charToGlyphIndex(token.char);\n    };\n    bidi.registerModifier(\"glyphIndex\", null, charToGlyphIndexMod);\n    // roll-back to default features\n    var features = options ? this.updateFeatures(options.features) : this.defaultRenderOptions.features;\n    bidi.applyFeatures(this, features);\n    var indexes = bidi.getTextGlyphs(s);\n    var length = indexes.length;\n    // convert glyph indexes to glyph objects\n    var glyphs = new Array(length);\n    var notdef = this.glyphs.get(0);\n    for(var i = 0; i < length; i += 1){\n        glyphs[i] = this.glyphs.get(indexes[i]) || notdef;\n    }\n    return glyphs;\n};\n/**\n * Retrieve the value of the kerning pair between the left glyph (or its index)\n * and the right glyph (or its index). If no kerning pair is found, return 0.\n * The kerning value gets added to the advance width when calculating the spacing\n * between glyphs.\n * For GPOS kerning, this method uses the default script and language, which covers\n * most use cases. To have greater control, use font.position.getKerningValue .\n * @param  {opentype.Glyph} leftGlyph\n * @param  {opentype.Glyph} rightGlyph\n * @return {Number}\n */ Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {\n    leftGlyph = leftGlyph.index || leftGlyph;\n    rightGlyph = rightGlyph.index || rightGlyph;\n    var gposKerning = this.position.defaultKerningTables;\n    if (gposKerning) {\n        return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);\n    }\n    // \"kern\" table\n    return this.kerningPairs[leftGlyph + \",\" + rightGlyph] || 0;\n};\n/**\n * @typedef GlyphRenderOptions\n * @type Object\n * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.\n *                               See https://www.microsoft.com/typography/otspec/scripttags.htm\n * @property {string} [language='dflt'] - language system used to determine which features to apply.\n *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx\n * @property {boolean} [kerning=true] - whether to include kerning values\n * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.\n *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm\n */ Font.prototype.defaultRenderOptions = {\n    kerning: true,\n    features: [\n        /**\n         * these 4 features are required to render Arabic text properly\n         * and shouldn't be turned off when rendering arabic text.\n         */ {\n            script: \"arab\",\n            tags: [\n                \"init\",\n                \"medi\",\n                \"fina\",\n                \"rlig\"\n            ]\n        },\n        {\n            script: \"latn\",\n            tags: [\n                \"liga\",\n                \"rlig\"\n            ]\n        }\n    ]\n};\n/**\n * Helper function that invokes the given callback for each glyph in the given text.\n * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text\n * @param {string} text - The text to apply.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @param  {Function} callback\n */ Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    options = Object.assign({}, this.defaultRenderOptions, options);\n    var fontScale = 1 / this.unitsPerEm * fontSize;\n    var glyphs = this.stringToGlyphs(text, options);\n    var kerningLookups;\n    if (options.kerning) {\n        var script = options.script || this.position.getDefaultScriptName();\n        kerningLookups = this.position.getKerningTables(script, options.language);\n    }\n    for(var i = 0; i < glyphs.length; i += 1){\n        var glyph = glyphs[i];\n        callback.call(this, glyph, x, y, fontSize, options);\n        if (glyph.advanceWidth) {\n            x += glyph.advanceWidth * fontScale;\n        }\n        if (options.kerning && i < glyphs.length - 1) {\n            // We should apply position adjustment lookups in a more generic way.\n            // Here we only use the xAdvance value.\n            var kerningValue = kerningLookups ? this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) : this.getKerningValue(glyph, glyphs[i + 1]);\n            x += kerningValue * fontScale;\n        }\n        if (options.letterSpacing) {\n            x += options.letterSpacing * fontSize;\n        } else if (options.tracking) {\n            x += options.tracking / 1000 * fontSize;\n        }\n    }\n    return x;\n};\n/**\n * Create a Path object that represents the given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path}\n */ Font.prototype.getPath = function(text, x, y, fontSize, options) {\n    var fullPath = new Path();\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n        fullPath.extend(glyphPath);\n    });\n    return fullPath;\n};\n/**\n * Create an array of Path objects that represent the glyphs of a given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path[]}\n */ Font.prototype.getPaths = function(text, x, y, fontSize, options) {\n    var glyphPaths = [];\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n        glyphPaths.push(glyphPath);\n    });\n    return glyphPaths;\n};\n/**\n * Returns the advance width of a text.\n *\n * This is something different than Path.getBoundingBox() as for example a\n * suffixed whitespace increases the advanceWidth but not the bounding box\n * or an overhanging letter like a calligraphic 'f' might have a quite larger\n * bounding box than its advance width.\n *\n * This corresponds to canvas2dContext.measureText(text).width\n *\n * @param  {string} text - The text to create.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return advance width\n */ Font.prototype.getAdvanceWidth = function(text, fontSize, options) {\n    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});\n};\n/**\n * @private\n */ Font.prototype.fsSelectionValues = {\n    ITALIC: 0x001,\n    UNDERSCORE: 0x002,\n    NEGATIVE: 0x004,\n    OUTLINED: 0x008,\n    STRIKEOUT: 0x010,\n    BOLD: 0x020,\n    REGULAR: 0x040,\n    USER_TYPO_METRICS: 0x080,\n    WWS: 0x100,\n    OBLIQUE: 0x200\n};\n/**\n * @private\n */ Font.prototype.usWidthClasses = {\n    ULTRA_CONDENSED: 1,\n    EXTRA_CONDENSED: 2,\n    CONDENSED: 3,\n    SEMI_CONDENSED: 4,\n    MEDIUM: 5,\n    SEMI_EXPANDED: 6,\n    EXPANDED: 7,\n    EXTRA_EXPANDED: 8,\n    ULTRA_EXPANDED: 9\n};\n/**\n * @private\n */ Font.prototype.usWeightClasses = {\n    THIN: 100,\n    EXTRA_LIGHT: 200,\n    LIGHT: 300,\n    NORMAL: 400,\n    MEDIUM: 500,\n    SEMI_BOLD: 600,\n    BOLD: 700,\n    EXTRA_BOLD: 800,\n    BLACK: 900\n};\n// The `cmap` table stores the mappings from characters to glyphs.\nfunction parseCmapTableFormat12(cmap, p) {\n    //Skip reserved.\n    p.parseUShort();\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseULong();\n    cmap.language = p.parseULong();\n    var groupCount;\n    cmap.groupCount = groupCount = p.parseULong();\n    cmap.glyphIndexMap = {};\n    for(var i = 0; i < groupCount; i += 1){\n        var startCharCode = p.parseULong();\n        var endCharCode = p.parseULong();\n        var startGlyphId = p.parseULong();\n        for(var c = startCharCode; c <= endCharCode; c += 1){\n            cmap.glyphIndexMap[c] = startGlyphId;\n            startGlyphId++;\n        }\n    }\n}\nfunction parseCmapTableFormat4(cmap, p, data, start, offset) {\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseUShort();\n    cmap.language = p.parseUShort();\n    // segCount is stored x 2.\n    var segCount;\n    cmap.segCount = segCount = p.parseUShort() >> 1;\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip(\"uShort\", 3);\n    // The \"unrolled\" mapping from character codes to glyph indices.\n    cmap.glyphIndexMap = {};\n    var endCountParser = new parse.Parser(data, start + offset + 14);\n    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);\n    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);\n    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);\n    var glyphIndexOffset = start + offset + 16 + segCount * 8;\n    for(var i = 0; i < segCount - 1; i += 1){\n        var glyphIndex = void 0;\n        var endCount = endCountParser.parseUShort();\n        var startCount = startCountParser.parseUShort();\n        var idDelta = idDeltaParser.parseShort();\n        var idRangeOffset = idRangeOffsetParser.parseUShort();\n        for(var c = startCount; c <= endCount; c += 1){\n            if (idRangeOffset !== 0) {\n                // The idRangeOffset is relative to the current position in the idRangeOffset array.\n                // Take the current offset in the idRangeOffset array.\n                glyphIndexOffset = idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2;\n                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n                glyphIndexOffset += idRangeOffset;\n                // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n                glyphIndexOffset += (c - startCount) * 2;\n                glyphIndex = parse.getUShort(data, glyphIndexOffset);\n                if (glyphIndex !== 0) {\n                    glyphIndex = glyphIndex + idDelta & 0xffff;\n                }\n            } else {\n                glyphIndex = c + idDelta & 0xffff;\n            }\n            cmap.glyphIndexMap[c] = glyphIndex;\n        }\n    }\n}\n// Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n// There are many available formats, but we only support the Windows format 4 and 12.\n// This function returns a `CmapEncoding` object or null if no supported format could be found.\nfunction parseCmapTable(data, start) {\n    var cmap = {};\n    cmap.version = parse.getUShort(data, start);\n    check.argument(cmap.version === 0, \"cmap table version should be 0.\");\n    // The cmap table can contain many sub-tables, each with their own format.\n    // We're only interested in a \"platform 0\" (Unicode format) and \"platform 3\" (Windows format) table.\n    cmap.numTables = parse.getUShort(data, start + 2);\n    var offset = -1;\n    for(var i = cmap.numTables - 1; i >= 0; i -= 1){\n        var platformId = parse.getUShort(data, start + 4 + i * 8);\n        var encodingId = parse.getUShort(data, start + 4 + i * 8 + 2);\n        if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10) || platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4)) {\n            offset = parse.getULong(data, start + 4 + i * 8 + 4);\n            break;\n        }\n    }\n    if (offset === -1) {\n        // There is no cmap table in the font that we support.\n        throw new Error(\"No valid cmap sub-tables found.\");\n    }\n    var p = new parse.Parser(data, start + offset);\n    cmap.format = p.parseUShort();\n    if (cmap.format === 12) {\n        parseCmapTableFormat12(cmap, p);\n    } else if (cmap.format === 4) {\n        parseCmapTableFormat4(cmap, p, data, start, offset);\n    } else {\n        throw new Error(\"Only format 4 and 12 cmap tables are supported (found format \" + cmap.format + \").\");\n    }\n    return cmap;\n}\nvar cmap = {\n    parse: parseCmapTable\n};\n// The `CFF` table contains the glyph outlines in PostScript format.\n// Subroutines are encoded using the negative half of the number space.\n// See type 2 chapter 4.7 \"Subroutine operators\".\nfunction calcCFFSubroutineBias(subrs) {\n    var bias;\n    if (subrs.length < 1240) {\n        bias = 107;\n    } else if (subrs.length < 33900) {\n        bias = 1131;\n    } else {\n        bias = 32768;\n    }\n    return bias;\n}\n// Parse a `CFF` INDEX array.\n// An index array consists of a list of offsets, then a list of objects at those offsets.\nfunction parseCFFIndex(data, start, conversionFn) {\n    var offsets = [];\n    var objects = [];\n    var count = parse.getCard16(data, start);\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + (count + 1) * offsetSize + 2;\n        var pos = start + 3;\n        for(var i = 0; i < count + 1; i += 1){\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n    for(var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1){\n        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);\n        if (conversionFn) {\n            value = conversionFn(value);\n        }\n        objects.push(value);\n    }\n    return {\n        objects: objects,\n        startOffset: start,\n        endOffset: endOffset\n    };\n}\nfunction parseCFFIndexLowMemory(data, start) {\n    var offsets = [];\n    var count = parse.getCard16(data, start);\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + (count + 1) * offsetSize + 2;\n        var pos = start + 3;\n        for(var i = 0; i < count + 1; i += 1){\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n    return {\n        offsets: offsets,\n        startOffset: start,\n        endOffset: endOffset\n    };\n}\nfunction getCffIndexObject(i, offsets, data, start, conversionFn) {\n    var count = parse.getCard16(data, start);\n    var objectOffset = 0;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + (count + 1) * offsetSize + 2;\n    }\n    var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);\n    if (conversionFn) {\n        value = conversionFn(value);\n    }\n    return value;\n}\n// Parse a `CFF` DICT real value.\nfunction parseFloatOperand(parser) {\n    var s = \"\";\n    var eof = 15;\n    var lookup = [\n        \"0\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \".\",\n        \"E\",\n        \"E-\",\n        null,\n        \"-\"\n    ];\n    while(true){\n        var b = parser.parseByte();\n        var n1 = b >> 4;\n        var n2 = b & 15;\n        if (n1 === eof) {\n            break;\n        }\n        s += lookup[n1];\n        if (n2 === eof) {\n            break;\n        }\n        s += lookup[n2];\n    }\n    return parseFloat(s);\n}\n// Parse a `CFF` DICT operand.\nfunction parseOperand(parser, b0) {\n    var b1;\n    var b2;\n    var b3;\n    var b4;\n    if (b0 === 28) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        return b1 << 8 | b2;\n    }\n    if (b0 === 29) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        b3 = parser.parseByte();\n        b4 = parser.parseByte();\n        return b1 << 24 | b2 << 16 | b3 << 8 | b4;\n    }\n    if (b0 === 30) {\n        return parseFloatOperand(parser);\n    }\n    if (b0 >= 32 && b0 <= 246) {\n        return b0 - 139;\n    }\n    if (b0 >= 247 && b0 <= 250) {\n        b1 = parser.parseByte();\n        return (b0 - 247) * 256 + b1 + 108;\n    }\n    if (b0 >= 251 && b0 <= 254) {\n        b1 = parser.parseByte();\n        return -(b0 - 251) * 256 - b1 - 108;\n    }\n    throw new Error(\"Invalid b0 \" + b0);\n}\n// Convert the entries returned by `parseDict` to a proper dictionary.\n// If a value is a list of one, it is unpacked.\nfunction entriesToObject(entries) {\n    var o = {};\n    for(var i = 0; i < entries.length; i += 1){\n        var key = entries[i][0];\n        var values = entries[i][1];\n        var value = void 0;\n        if (values.length === 1) {\n            value = values[0];\n        } else {\n            value = values;\n        }\n        if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n            throw new Error(\"Object \" + o + \" already has key \" + key);\n        }\n        o[key] = value;\n    }\n    return o;\n}\n// Parse a `CFF` DICT object.\n// A dictionary contains key-value pairs in a compact tokenized format.\nfunction parseCFFDict(data, start, size) {\n    start = start !== undefined ? start : 0;\n    var parser = new parse.Parser(data, start);\n    var entries = [];\n    var operands = [];\n    size = size !== undefined ? size : data.length;\n    while(parser.relativeOffset < size){\n        var op = parser.parseByte();\n        // The first byte for each dict item distinguishes between operator (key) and operand (value).\n        // Values <= 21 are operators.\n        if (op <= 21) {\n            // Two-byte operators have an initial escape byte of 12.\n            if (op === 12) {\n                op = 1200 + parser.parseByte();\n            }\n            entries.push([\n                op,\n                operands\n            ]);\n            operands = [];\n        } else {\n            // Since the operands (values) come before the operators (keys), we store all operands in a list\n            // until we encounter an operator.\n            operands.push(parseOperand(parser, op));\n        }\n    }\n    return entriesToObject(entries);\n}\n// Given a String Index (SID), return the value of the string.\n// Strings below index 392 are standard CFF strings and are not encoded in the font.\nfunction getCFFString(strings, index) {\n    if (index <= 390) {\n        index = cffStandardStrings[index];\n    } else {\n        index = strings[index - 391];\n    }\n    return index;\n}\n// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\nfunction interpretDict(dict, meta, strings) {\n    var newDict = {};\n    var value;\n    // Because we also want to include missing values, we start out from the meta list\n    // and lookup values in the dict.\n    for(var i = 0; i < meta.length; i += 1){\n        var m = meta[i];\n        if (Array.isArray(m.type)) {\n            var values = [];\n            values.length = m.type.length;\n            for(var j = 0; j < m.type.length; j++){\n                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;\n                if (value === undefined) {\n                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;\n                }\n                if (m.type[j] === \"SID\") {\n                    value = getCFFString(strings, value);\n                }\n                values[j] = value;\n            }\n            newDict[m.name] = values;\n        } else {\n            value = dict[m.op];\n            if (value === undefined) {\n                value = m.value !== undefined ? m.value : null;\n            }\n            if (m.type === \"SID\") {\n                value = getCFFString(strings, value);\n            }\n            newDict[m.name] = value;\n        }\n    }\n    return newDict;\n}\n// Parse the CFF header.\nfunction parseCFFHeader(data, start) {\n    var header = {};\n    header.formatMajor = parse.getCard8(data, start);\n    header.formatMinor = parse.getCard8(data, start + 1);\n    header.size = parse.getCard8(data, start + 2);\n    header.offsetSize = parse.getCard8(data, start + 3);\n    header.startOffset = start;\n    header.endOffset = start + 4;\n    return header;\n}\nvar TOP_DICT_META = [\n    {\n        name: \"version\",\n        op: 0,\n        type: \"SID\"\n    },\n    {\n        name: \"notice\",\n        op: 1,\n        type: \"SID\"\n    },\n    {\n        name: \"copyright\",\n        op: 1200,\n        type: \"SID\"\n    },\n    {\n        name: \"fullName\",\n        op: 2,\n        type: \"SID\"\n    },\n    {\n        name: \"familyName\",\n        op: 3,\n        type: \"SID\"\n    },\n    {\n        name: \"weight\",\n        op: 4,\n        type: \"SID\"\n    },\n    {\n        name: \"isFixedPitch\",\n        op: 1201,\n        type: \"number\",\n        value: 0\n    },\n    {\n        name: \"italicAngle\",\n        op: 1202,\n        type: \"number\",\n        value: 0\n    },\n    {\n        name: \"underlinePosition\",\n        op: 1203,\n        type: \"number\",\n        value: -100\n    },\n    {\n        name: \"underlineThickness\",\n        op: 1204,\n        type: \"number\",\n        value: 50\n    },\n    {\n        name: \"paintType\",\n        op: 1205,\n        type: \"number\",\n        value: 0\n    },\n    {\n        name: \"charstringType\",\n        op: 1206,\n        type: \"number\",\n        value: 2\n    },\n    {\n        name: \"fontMatrix\",\n        op: 1207,\n        type: [\n            \"real\",\n            \"real\",\n            \"real\",\n            \"real\",\n            \"real\",\n            \"real\"\n        ],\n        value: [\n            0.001,\n            0,\n            0,\n            0.001,\n            0,\n            0\n        ]\n    },\n    {\n        name: \"uniqueId\",\n        op: 13,\n        type: \"number\"\n    },\n    {\n        name: \"fontBBox\",\n        op: 5,\n        type: [\n            \"number\",\n            \"number\",\n            \"number\",\n            \"number\"\n        ],\n        value: [\n            0,\n            0,\n            0,\n            0\n        ]\n    },\n    {\n        name: \"strokeWidth\",\n        op: 1208,\n        type: \"number\",\n        value: 0\n    },\n    {\n        name: \"xuid\",\n        op: 14,\n        type: [],\n        value: null\n    },\n    {\n        name: \"charset\",\n        op: 15,\n        type: \"offset\",\n        value: 0\n    },\n    {\n        name: \"encoding\",\n        op: 16,\n        type: \"offset\",\n        value: 0\n    },\n    {\n        name: \"charStrings\",\n        op: 17,\n        type: \"offset\",\n        value: 0\n    },\n    {\n        name: \"private\",\n        op: 18,\n        type: [\n            \"number\",\n            \"offset\"\n        ],\n        value: [\n            0,\n            0\n        ]\n    },\n    {\n        name: \"ros\",\n        op: 1230,\n        type: [\n            \"SID\",\n            \"SID\",\n            \"number\"\n        ]\n    },\n    {\n        name: \"cidFontVersion\",\n        op: 1231,\n        type: \"number\",\n        value: 0\n    },\n    {\n        name: \"cidFontRevision\",\n        op: 1232,\n        type: \"number\",\n        value: 0\n    },\n    {\n        name: \"cidFontType\",\n        op: 1233,\n        type: \"number\",\n        value: 0\n    },\n    {\n        name: \"cidCount\",\n        op: 1234,\n        type: \"number\",\n        value: 8720\n    },\n    {\n        name: \"uidBase\",\n        op: 1235,\n        type: \"number\"\n    },\n    {\n        name: \"fdArray\",\n        op: 1236,\n        type: \"offset\"\n    },\n    {\n        name: \"fdSelect\",\n        op: 1237,\n        type: \"offset\"\n    },\n    {\n        name: \"fontName\",\n        op: 1238,\n        type: \"SID\"\n    }\n];\nvar PRIVATE_DICT_META = [\n    {\n        name: \"subrs\",\n        op: 19,\n        type: \"offset\",\n        value: 0\n    },\n    {\n        name: \"defaultWidthX\",\n        op: 20,\n        type: \"number\",\n        value: 0\n    },\n    {\n        name: \"nominalWidthX\",\n        op: 21,\n        type: \"number\",\n        value: 0\n    }\n];\n// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n// The top dictionary contains the essential metadata for the font, together with the private dictionary.\nfunction parseCFFTopDict(data, strings) {\n    var dict = parseCFFDict(data, 0, data.byteLength);\n    return interpretDict(dict, TOP_DICT_META, strings);\n}\n// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\nfunction parseCFFPrivateDict(data, start, size, strings) {\n    var dict = parseCFFDict(data, start, size);\n    return interpretDict(dict, PRIVATE_DICT_META, strings);\n}\n// Returns a list of \"Top DICT\"s found using an INDEX list.\n// Used to read both the usual high-level Top DICTs and also the FDArray\n// discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n// a Private DICT that is read and saved into the Top DICT.\n//\n// In addition to the expected/optional values as outlined in TOP_DICT_META\n// the following values might be saved into the Top DICT.\n//\n//    _subrs []        array of local CFF subroutines from Private DICT\n//    _subrsBias       bias value computed from number of subroutines\n//                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n//    _defaultWidthX   default widths for CFF characters\n//    _nominalWidthX   bias added to width embedded within glyph description\n//\n//    _privateDict     saved copy of parsed Private DICT from Top DICT\nfunction gatherCFFTopDicts(data, start, cffIndex, strings) {\n    var topDictArray = [];\n    for(var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1){\n        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);\n        var topDict = parseCFFTopDict(topDictData, strings);\n        topDict._subrs = [];\n        topDict._subrsBias = 0;\n        topDict._defaultWidthX = 0;\n        topDict._nominalWidthX = 0;\n        var privateSize = topDict.private[0];\n        var privateOffset = topDict.private[1];\n        if (privateSize !== 0 && privateOffset !== 0) {\n            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);\n            topDict._defaultWidthX = privateDict.defaultWidthX;\n            topDict._nominalWidthX = privateDict.nominalWidthX;\n            if (privateDict.subrs !== 0) {\n                var subrOffset = privateOffset + privateDict.subrs;\n                var subrIndex = parseCFFIndex(data, subrOffset + start);\n                topDict._subrs = subrIndex.objects;\n                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);\n            }\n            topDict._privateDict = privateDict;\n        }\n        topDictArray.push(topDict);\n    }\n    return topDictArray;\n}\n// Parse the CFF charset table, which contains internal names for all the glyphs.\n// This function will return a list of glyph names.\n// See Adobe TN #5176 chapter 13, \"Charsets\".\nfunction parseCFFCharset(data, start, nGlyphs, strings) {\n    var sid;\n    var count;\n    var parser = new parse.Parser(data, start);\n    // The .notdef glyph is not included, so subtract 1.\n    nGlyphs -= 1;\n    var charset = [\n        \".notdef\"\n    ];\n    var format = parser.parseCard8();\n    if (format === 0) {\n        for(var i = 0; i < nGlyphs; i += 1){\n            sid = parser.parseSID();\n            charset.push(getCFFString(strings, sid));\n        }\n    } else if (format === 1) {\n        while(charset.length <= nGlyphs){\n            sid = parser.parseSID();\n            count = parser.parseCard8();\n            for(var i$1 = 0; i$1 <= count; i$1 += 1){\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else if (format === 2) {\n        while(charset.length <= nGlyphs){\n            sid = parser.parseSID();\n            count = parser.parseCard16();\n            for(var i$2 = 0; i$2 <= count; i$2 += 1){\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else {\n        throw new Error(\"Unknown charset format \" + format);\n    }\n    return charset;\n}\n// Parse the CFF encoding data. Only one encoding can be specified per font.\n// See Adobe TN #5176 chapter 12, \"Encodings\".\nfunction parseCFFEncoding(data, start, charset) {\n    var code;\n    var enc = {};\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        var nCodes = parser.parseCard8();\n        for(var i = 0; i < nCodes; i += 1){\n            code = parser.parseCard8();\n            enc[code] = i;\n        }\n    } else if (format === 1) {\n        var nRanges = parser.parseCard8();\n        code = 1;\n        for(var i$1 = 0; i$1 < nRanges; i$1 += 1){\n            var first = parser.parseCard8();\n            var nLeft = parser.parseCard8();\n            for(var j = first; j <= first + nLeft; j += 1){\n                enc[j] = code;\n                code += 1;\n            }\n        }\n    } else {\n        throw new Error(\"Unknown encoding format \" + format);\n    }\n    return new CffEncoding(enc, charset);\n}\n// Take in charstring code and return a Glyph object.\n// The encoding is described in the Type 2 Charstring Format\n// https://www.microsoft.com/typography/OTSPEC/charstr2.htm\nfunction parseCFFCharstring(font, glyph, code) {\n    var c1x;\n    var c1y;\n    var c2x;\n    var c2y;\n    var p = new Path();\n    var stack = [];\n    var nStems = 0;\n    var haveWidth = false;\n    var open = false;\n    var x = 0;\n    var y = 0;\n    var subrs;\n    var subrsBias;\n    var defaultWidthX;\n    var nominalWidthX;\n    if (font.isCIDFont) {\n        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];\n        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];\n        subrs = fdDict._subrs;\n        subrsBias = fdDict._subrsBias;\n        defaultWidthX = fdDict._defaultWidthX;\n        nominalWidthX = fdDict._nominalWidthX;\n    } else {\n        subrs = font.tables.cff.topDict._subrs;\n        subrsBias = font.tables.cff.topDict._subrsBias;\n        defaultWidthX = font.tables.cff.topDict._defaultWidthX;\n        nominalWidthX = font.tables.cff.topDict._nominalWidthX;\n    }\n    var width = defaultWidthX;\n    function newContour(x, y) {\n        if (open) {\n            p.closePath();\n        }\n        p.moveTo(x, y);\n        open = true;\n    }\n    function parseStems() {\n        var hasWidthArg;\n        // The number of stem operators on the stack is always even.\n        // If the value is uneven, that means a width is specified.\n        hasWidthArg = stack.length % 2 !== 0;\n        if (hasWidthArg && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n        }\n        nStems += stack.length >> 1;\n        stack.length = 0;\n        haveWidth = true;\n    }\n    function parse(code) {\n        var b1;\n        var b2;\n        var b3;\n        var b4;\n        var codeIndex;\n        var subrCode;\n        var jpx;\n        var jpy;\n        var c3x;\n        var c3y;\n        var c4x;\n        var c4y;\n        var i = 0;\n        while(i < code.length){\n            var v = code[i];\n            i += 1;\n            switch(v){\n                case 1:\n                    parseStems();\n                    break;\n                case 3:\n                    parseStems();\n                    break;\n                case 4:\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n                    y += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 5:\n                    while(stack.length > 0){\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n                    break;\n                case 6:\n                    while(stack.length > 0){\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n                    break;\n                case 7:\n                    while(stack.length > 0){\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                    }\n                    break;\n                case 8:\n                    while(stack.length > 0){\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n                    break;\n                case 10:\n                    codeIndex = stack.pop() + subrsBias;\n                    subrCode = subrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n                    break;\n                case 11:\n                    return;\n                case 12:\n                    v = code[i];\n                    i += 1;\n                    switch(v){\n                        case 35:\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n                            c1x = x + stack.shift(); // dx1\n                            c1y = y + stack.shift(); // dy1\n                            c2x = c1x + stack.shift(); // dx2\n                            c2y = c1y + stack.shift(); // dy2\n                            jpx = c2x + stack.shift(); // dx3\n                            jpy = c2y + stack.shift(); // dy3\n                            c3x = jpx + stack.shift(); // dx4\n                            c3y = jpy + stack.shift(); // dy4\n                            c4x = c3x + stack.shift(); // dx5\n                            c4y = c3y + stack.shift(); // dy5\n                            x = c4x + stack.shift(); // dx6\n                            y = c4y + stack.shift(); // dy6\n                            stack.shift(); // flex depth\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 34:\n                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n                            c1x = x + stack.shift(); // dx1\n                            c1y = y; // dy1\n                            c2x = c1x + stack.shift(); // dx2\n                            c2y = c1y + stack.shift(); // dy2\n                            jpx = c2x + stack.shift(); // dx3\n                            jpy = c2y; // dy3\n                            c3x = jpx + stack.shift(); // dx4\n                            c3y = c2y; // dy4\n                            c4x = c3x + stack.shift(); // dx5\n                            c4y = y; // dy5\n                            x = c4x + stack.shift(); // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 36:\n                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n                            c1x = x + stack.shift(); // dx1\n                            c1y = y + stack.shift(); // dy1\n                            c2x = c1x + stack.shift(); // dx2\n                            c2y = c1y + stack.shift(); // dy2\n                            jpx = c2x + stack.shift(); // dx3\n                            jpy = c2y; // dy3\n                            c3x = jpx + stack.shift(); // dx4\n                            c3y = c2y; // dy4\n                            c4x = c3x + stack.shift(); // dx5\n                            c4y = c3y + stack.shift(); // dy5\n                            x = c4x + stack.shift(); // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 37:\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n                            c1x = x + stack.shift(); // dx1\n                            c1y = y + stack.shift(); // dy1\n                            c2x = c1x + stack.shift(); // dx2\n                            c2y = c1y + stack.shift(); // dy2\n                            jpx = c2x + stack.shift(); // dx3\n                            jpy = c2y + stack.shift(); // dy3\n                            c3x = jpx + stack.shift(); // dx4\n                            c3y = jpy + stack.shift(); // dy4\n                            c4x = c3x + stack.shift(); // dx5\n                            c4y = c3y + stack.shift(); // dy5\n                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                                x = c4x + stack.shift();\n                            } else {\n                                y = c4y + stack.shift();\n                            }\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        default:\n                            console.log(\"Glyph \" + glyph.index + \": unknown operator \" + 1200 + v);\n                            stack.length = 0;\n                    }\n                    break;\n                case 14:\n                    if (stack.length > 0 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n                    if (open) {\n                        p.closePath();\n                        open = false;\n                    }\n                    break;\n                case 18:\n                    parseStems();\n                    break;\n                case 19:\n                case 20:\n                    parseStems();\n                    i += nStems + 7 >> 3;\n                    break;\n                case 21:\n                    if (stack.length > 2 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n                    y += stack.pop();\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 22:\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 23:\n                    parseStems();\n                    break;\n                case 24:\n                    while(stack.length > 2){\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n                    x += stack.shift();\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                    break;\n                case 25:\n                    while(stack.length > 6){\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n                    c1x = x + stack.shift();\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    break;\n                case 26:\n                    if (stack.length % 2) {\n                        x += stack.shift();\n                    }\n                    while(stack.length > 0){\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x;\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n                    break;\n                case 27:\n                    if (stack.length % 2) {\n                        y += stack.shift();\n                    }\n                    while(stack.length > 0){\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y;\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n                    break;\n                case 28:\n                    b1 = code[i];\n                    b2 = code[i + 1];\n                    stack.push((b1 << 24 | b2 << 16) >> 16);\n                    i += 2;\n                    break;\n                case 29:\n                    codeIndex = stack.pop() + font.gsubrsBias;\n                    subrCode = font.gsubrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n                    break;\n                case 30:\n                    while(stack.length > 0){\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n                    break;\n                case 31:\n                    while(stack.length > 0){\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n                    break;\n                default:\n                    if (v < 32) {\n                        console.log(\"Glyph \" + glyph.index + \": unknown operator \" + v);\n                    } else if (v < 247) {\n                        stack.push(v - 139);\n                    } else if (v < 251) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push((v - 247) * 256 + b1 + 108);\n                    } else if (v < 255) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push(-(v - 251) * 256 - b1 - 108);\n                    } else {\n                        b1 = code[i];\n                        b2 = code[i + 1];\n                        b3 = code[i + 2];\n                        b4 = code[i + 3];\n                        i += 4;\n                        stack.push((b1 << 24 | b2 << 16 | b3 << 8 | b4) / 65536);\n                    }\n            }\n        }\n    }\n    parse(code);\n    glyph.advanceWidth = width;\n    return p;\n}\nfunction parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n    var fdSelect = [];\n    var fdIndex;\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        // Simple list of nGlyphs elements\n        for(var iGid = 0; iGid < nGlyphs; iGid++){\n            fdIndex = parser.parseCard8();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error(\"CFF table CID Font FDSelect has bad FD index value \" + fdIndex + \" (FD count \" + fdArrayCount + \")\");\n            }\n            fdSelect.push(fdIndex);\n        }\n    } else if (format === 3) {\n        // Ranges\n        var nRanges = parser.parseCard16();\n        var first = parser.parseCard16();\n        if (first !== 0) {\n            throw new Error(\"CFF Table CID Font FDSelect format 3 range has bad initial GID \" + first);\n        }\n        var next;\n        for(var iRange = 0; iRange < nRanges; iRange++){\n            fdIndex = parser.parseCard8();\n            next = parser.parseCard16();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error(\"CFF table CID Font FDSelect has bad FD index value \" + fdIndex + \" (FD count \" + fdArrayCount + \")\");\n            }\n            if (next > nGlyphs) {\n                throw new Error(\"CFF Table CID Font FDSelect format 3 range has bad GID \" + next);\n            }\n            for(; first < next; first++){\n                fdSelect.push(fdIndex);\n            }\n            first = next;\n        }\n        if (next !== nGlyphs) {\n            throw new Error(\"CFF Table CID Font FDSelect format 3 range has bad final GID \" + next);\n        }\n    } else {\n        throw new Error(\"CFF Table CID Font FDSelect table has unsupported format \" + format);\n    }\n    return fdSelect;\n}\n// Parse the `CFF` table, which contains the glyph outlines in PostScript format.\nfunction parseCFFTable(data, start, font, opt) {\n    font.tables.cff = {};\n    var header = parseCFFHeader(data, start);\n    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);\n    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);\n    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n    font.gsubrs = globalSubrIndex.objects;\n    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);\n    if (topDictArray.length !== 1) {\n        throw new Error(\"CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = \" + topDictArray.length);\n    }\n    var topDict = topDictArray[0];\n    font.tables.cff.topDict = topDict;\n    if (topDict._privateDict) {\n        font.defaultWidthX = topDict._privateDict.defaultWidthX;\n        font.nominalWidthX = topDict._privateDict.nominalWidthX;\n    }\n    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n        font.isCIDFont = true;\n    }\n    if (font.isCIDFont) {\n        var fdArrayOffset = topDict.fdArray;\n        var fdSelectOffset = topDict.fdSelect;\n        if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n            throw new Error(\"Font is marked as a CID font, but FDArray and/or FDSelect information is missing\");\n        }\n        fdArrayOffset += start;\n        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);\n        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);\n        topDict._fdArray = fdArray;\n        fdSelectOffset += start;\n        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);\n    }\n    var privateDictOffset = start + topDict.private[1];\n    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);\n    font.defaultWidthX = privateDict.defaultWidthX;\n    font.nominalWidthX = privateDict.nominalWidthX;\n    if (privateDict.subrs !== 0) {\n        var subrOffset = privateDictOffset + privateDict.subrs;\n        var subrIndex = parseCFFIndex(data, subrOffset);\n        font.subrs = subrIndex.objects;\n        font.subrsBias = calcCFFSubroutineBias(font.subrs);\n    } else {\n        font.subrs = [];\n        font.subrsBias = 0;\n    }\n    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n    var charStringsIndex;\n    if (opt.lowMemory) {\n        charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings);\n        font.nGlyphs = charStringsIndex.offsets.length;\n    } else {\n        charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n        font.nGlyphs = charStringsIndex.objects.length;\n    }\n    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);\n    if (topDict.encoding === 0) {\n        // Standard encoding\n        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);\n    } else if (topDict.encoding === 1) {\n        // Expert encoding\n        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);\n    } else {\n        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);\n    }\n    // Prefer the CMAP encoding to the CFF encoding.\n    font.encoding = font.encoding || font.cffEncoding;\n    font.glyphs = new glyphset.GlyphSet(font);\n    if (opt.lowMemory) {\n        font._push = function(i) {\n            var charString = getCffIndexObject(i, charStringsIndex.offsets, data, start + topDict.charStrings);\n            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n        };\n    } else {\n        for(var i = 0; i < font.nGlyphs; i += 1){\n            var charString = charStringsIndex.objects[i];\n            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n        }\n    }\n}\nvar cff = {\n    parse: parseCFFTable\n};\n// The `fvar` table stores font variation axes and instances.\nfunction parseFvarAxis(data, start, names) {\n    var axis = {};\n    var p = new parse.Parser(data, start);\n    axis.tag = p.parseTag();\n    axis.minValue = p.parseFixed();\n    axis.defaultValue = p.parseFixed();\n    axis.maxValue = p.parseFixed();\n    p.skip(\"uShort\", 1); // reserved for flags; no values defined\n    axis.name = names[p.parseUShort()] || {};\n    return axis;\n}\nfunction parseFvarInstance(data, start, axes, names) {\n    var inst = {};\n    var p = new parse.Parser(data, start);\n    inst.name = names[p.parseUShort()] || {};\n    p.skip(\"uShort\", 1); // reserved for flags; no values defined\n    inst.coordinates = {};\n    for(var i = 0; i < axes.length; ++i){\n        inst.coordinates[axes[i].tag] = p.parseFixed();\n    }\n    return inst;\n}\nfunction parseFvarTable(data, start, names) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 0x00010000, \"Unsupported fvar table version.\");\n    var offsetToData = p.parseOffset16();\n    // Skip countSizePairs.\n    p.skip(\"uShort\", 1);\n    var axisCount = p.parseUShort();\n    var axisSize = p.parseUShort();\n    var instanceCount = p.parseUShort();\n    var instanceSize = p.parseUShort();\n    var axes = [];\n    for(var i = 0; i < axisCount; i++){\n        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));\n    }\n    var instances = [];\n    var instanceStart = start + offsetToData + axisCount * axisSize;\n    for(var j = 0; j < instanceCount; j++){\n        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));\n    }\n    return {\n        axes: axes,\n        instances: instances\n    };\n}\nvar fvar = {\n    parse: parseFvarTable\n};\n// The `GDEF` table contains various glyph properties\nvar attachList = function() {\n    return {\n        coverage: this.parsePointer(Parser.coverage),\n        attachPoints: this.parseList(Parser.pointer(Parser.uShortList))\n    };\n};\nvar caretValue = function() {\n    var format = this.parseUShort();\n    check.argument(format === 1 || format === 2 || format === 3, \"Unsupported CaretValue table version.\");\n    if (format === 1) {\n        return {\n            coordinate: this.parseShort()\n        };\n    } else if (format === 2) {\n        return {\n            pointindex: this.parseShort()\n        };\n    } else if (format === 3) {\n        // Device / Variation Index tables unsupported\n        return {\n            coordinate: this.parseShort()\n        };\n    }\n};\nvar ligGlyph = function() {\n    return this.parseList(Parser.pointer(caretValue));\n};\nvar ligCaretList = function() {\n    return {\n        coverage: this.parsePointer(Parser.coverage),\n        ligGlyphs: this.parseList(Parser.pointer(ligGlyph))\n    };\n};\nvar markGlyphSets = function() {\n    this.parseUShort(); // Version\n    return this.parseList(Parser.pointer(Parser.coverage));\n};\nfunction parseGDEFTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3, \"Unsupported GDEF table version.\");\n    var gdef = {\n        version: tableVersion,\n        classDef: p.parsePointer(Parser.classDef),\n        attachList: p.parsePointer(attachList),\n        ligCaretList: p.parsePointer(ligCaretList),\n        markAttachClassDef: p.parsePointer(Parser.classDef)\n    };\n    if (tableVersion >= 1.2) {\n        gdef.markGlyphSets = p.parsePointer(markGlyphSets);\n    }\n    return gdef;\n}\nvar gdef = {\n    parse: parseGDEFTable\n};\n// The `GPOS` table contains kerning pairs, among other things.\nvar subtableParsers = new Array(10); // subtableParsers[0] is unused\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable\n// this = Parser instance\nsubtableParsers[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset;\n    var posformat = this.parseUShort();\n    if (posformat === 1) {\n        return {\n            posFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            value: this.parseValueRecord()\n        };\n    } else if (posformat === 2) {\n        return {\n            posFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            values: this.parseValueRecordList()\n        };\n    }\n    check.assert(false, \"0x\" + start.toString(16) + \": GPOS lookup type 1 format must be 1 or 2.\");\n};\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable\nsubtableParsers[2] = function parseLookup2() {\n    var start = this.offset + this.relativeOffset;\n    var posFormat = this.parseUShort();\n    check.assert(posFormat === 1 || posFormat === 2, \"0x\" + start.toString(16) + \": GPOS lookup type 2 format must be 1 or 2.\");\n    var coverage = this.parsePointer(Parser.coverage);\n    var valueFormat1 = this.parseUShort();\n    var valueFormat2 = this.parseUShort();\n    if (posFormat === 1) {\n        // Adjustments for Glyph Pairs\n        return {\n            posFormat: posFormat,\n            coverage: coverage,\n            valueFormat1: valueFormat1,\n            valueFormat2: valueFormat2,\n            pairSets: this.parseList(Parser.pointer(Parser.list(function() {\n                return {\n                    // pairValueRecord\n                    secondGlyph: this.parseUShort(),\n                    value1: this.parseValueRecord(valueFormat1),\n                    value2: this.parseValueRecord(valueFormat2)\n                };\n            })))\n        };\n    } else if (posFormat === 2) {\n        var classDef1 = this.parsePointer(Parser.classDef);\n        var classDef2 = this.parsePointer(Parser.classDef);\n        var class1Count = this.parseUShort();\n        var class2Count = this.parseUShort();\n        return {\n            // Class Pair Adjustment\n            posFormat: posFormat,\n            coverage: coverage,\n            valueFormat1: valueFormat1,\n            valueFormat2: valueFormat2,\n            classDef1: classDef1,\n            classDef2: classDef2,\n            class1Count: class1Count,\n            class2Count: class2Count,\n            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {\n                return {\n                    value1: this.parseValueRecord(valueFormat1),\n                    value2: this.parseValueRecord(valueFormat2)\n                };\n            }))\n        };\n    }\n};\nsubtableParsers[3] = function parseLookup3() {\n    return {\n        error: \"GPOS Lookup 3 not supported\"\n    };\n};\nsubtableParsers[4] = function parseLookup4() {\n    return {\n        error: \"GPOS Lookup 4 not supported\"\n    };\n};\nsubtableParsers[5] = function parseLookup5() {\n    return {\n        error: \"GPOS Lookup 5 not supported\"\n    };\n};\nsubtableParsers[6] = function parseLookup6() {\n    return {\n        error: \"GPOS Lookup 6 not supported\"\n    };\n};\nsubtableParsers[7] = function parseLookup7() {\n    return {\n        error: \"GPOS Lookup 7 not supported\"\n    };\n};\nsubtableParsers[8] = function parseLookup8() {\n    return {\n        error: \"GPOS Lookup 8 not supported\"\n    };\n};\nsubtableParsers[9] = function parseLookup9() {\n    return {\n        error: \"GPOS Lookup 9 not supported\"\n    };\n};\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos\nfunction parseGposTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.1, \"Unsupported GPOS table version \" + tableVersion);\n    if (tableVersion === 1) {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers)\n        };\n    } else {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers),\n            variations: p.parseFeatureVariationsList()\n        };\n    }\n}\nvar gpos = {\n    parse: parseGposTable\n};\n// The `GSUB` table contains ligatures, among other things.\nvar subtableParsers$1 = new Array(9); // subtableParsers[0] is unused\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS\nsubtableParsers$1[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            deltaGlyphId: this.parseUShort()\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            substitute: this.parseOffset16List()\n        };\n    }\n    check.assert(false, \"0x\" + start.toString(16) + \": lookup type 1 format must be 1 or 2.\");\n};\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS\nsubtableParsers$1[2] = function parseLookup2() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, \"GSUB Multiple Substitution Subtable identifier-format must be 1\");\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        sequences: this.parseListOfLists()\n    };\n};\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS\nsubtableParsers$1[3] = function parseLookup3() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, \"GSUB Alternate Substitution Subtable identifier-format must be 1\");\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        alternateSets: this.parseListOfLists()\n    };\n};\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS\nsubtableParsers$1[4] = function parseLookup4() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, \"GSUB ligature table identifier-format must be 1\");\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        ligatureSets: this.parseListOfLists(function() {\n            return {\n                ligGlyph: this.parseUShort(),\n                components: this.parseUShortList(this.parseUShort() - 1)\n            };\n        })\n    };\n};\nvar lookupRecordDesc = {\n    sequenceIndex: Parser.uShort,\n    lookupListIndex: Parser.uShort\n};\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF\nsubtableParsers$1[5] = function parseLookup5() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            ruleSets: this.parseListOfLists(function() {\n                var glyphCount = this.parseUShort();\n                var substCount = this.parseUShort();\n                return {\n                    input: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            classDef: this.parsePointer(Parser.classDef),\n            classSets: this.parseListOfLists(function() {\n                var glyphCount = this.parseUShort();\n                var substCount = this.parseUShort();\n                return {\n                    classes: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 3) {\n        var glyphCount = this.parseUShort();\n        var substCount = this.parseUShort();\n        return {\n            substFormat: substFormat,\n            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n        };\n    }\n    check.assert(false, \"0x\" + start.toString(16) + \": lookup type 5 format must be 1, 2 or 3.\");\n};\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC\nsubtableParsers$1[6] = function parseLookup6() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            chainRuleSets: this.parseListOfLists(function() {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            backtrackClassDef: this.parsePointer(Parser.classDef),\n            inputClassDef: this.parsePointer(Parser.classDef),\n            lookaheadClassDef: this.parsePointer(Parser.classDef),\n            chainClassSet: this.parseListOfLists(function() {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 3) {\n        return {\n            substFormat: 3,\n            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(lookupRecordDesc)\n        };\n    }\n    check.assert(false, \"0x\" + start.toString(16) + \": lookup type 6 format must be 1, 2 or 3.\");\n};\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES\nsubtableParsers$1[7] = function parseLookup7() {\n    // Extension Substitution subtable\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, \"GSUB Extension Substitution subtable identifier-format must be 1\");\n    var extensionLookupType = this.parseUShort();\n    var extensionParser = new Parser(this.data, this.offset + this.parseULong());\n    return {\n        substFormat: 1,\n        lookupType: extensionLookupType,\n        extension: subtableParsers$1[extensionLookupType].call(extensionParser)\n    };\n};\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS\nsubtableParsers$1[8] = function parseLookup8() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, \"GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1\");\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        substitutes: this.parseUShortList()\n    };\n};\n// https://www.microsoft.com/typography/OTSPEC/gsub.htm\nfunction parseGsubTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.1, \"Unsupported GSUB table version.\");\n    if (tableVersion === 1) {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers$1)\n        };\n    } else {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers$1),\n            variations: p.parseFeatureVariationsList()\n        };\n    }\n}\nvar gsub = {\n    parse: parseGsubTable\n};\n// The `head` table contains global information about the font.\n// Parse the header `head` table\nfunction parseHeadTable(data, start) {\n    var head = {};\n    var p = new parse.Parser(data, start);\n    head.version = p.parseVersion();\n    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;\n    head.checkSumAdjustment = p.parseULong();\n    head.magicNumber = p.parseULong();\n    check.argument(head.magicNumber === 0x5f0f3cf5, \"Font header has wrong magic number.\");\n    head.flags = p.parseUShort();\n    head.unitsPerEm = p.parseUShort();\n    head.created = p.parseLongDateTime();\n    head.modified = p.parseLongDateTime();\n    head.xMin = p.parseShort();\n    head.yMin = p.parseShort();\n    head.xMax = p.parseShort();\n    head.yMax = p.parseShort();\n    head.macStyle = p.parseUShort();\n    head.lowestRecPPEM = p.parseUShort();\n    head.fontDirectionHint = p.parseShort();\n    head.indexToLocFormat = p.parseShort();\n    head.glyphDataFormat = p.parseShort();\n    return head;\n}\nvar head = {\n    parse: parseHeadTable\n};\n// The `hhea` table contains information for horizontal layout.\n// Parse the horizontal header `hhea` table\nfunction parseHheaTable(data, start) {\n    var hhea = {};\n    var p = new parse.Parser(data, start);\n    hhea.version = p.parseVersion();\n    hhea.ascender = p.parseShort();\n    hhea.descender = p.parseShort();\n    hhea.lineGap = p.parseShort();\n    hhea.advanceWidthMax = p.parseUShort();\n    hhea.minLeftSideBearing = p.parseShort();\n    hhea.minRightSideBearing = p.parseShort();\n    hhea.xMaxExtent = p.parseShort();\n    hhea.caretSlopeRise = p.parseShort();\n    hhea.caretSlopeRun = p.parseShort();\n    hhea.caretOffset = p.parseShort();\n    p.relativeOffset += 8;\n    hhea.metricDataFormat = p.parseShort();\n    hhea.numberOfHMetrics = p.parseUShort();\n    return hhea;\n}\nvar hhea = {\n    parse: parseHheaTable\n};\n// The `hmtx` table contains the horizontal metrics for all glyphs.\nfunction parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for(var i = 0; i < numGlyphs; i += 1){\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n        var glyph = glyphs.get(i);\n        glyph.advanceWidth = advanceWidth;\n        glyph.leftSideBearing = leftSideBearing;\n    }\n}\nfunction parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {\n    font._hmtxTableData = {};\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for(var i = 0; i < numGlyphs; i += 1){\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n        font._hmtxTableData[i] = {\n            advanceWidth: advanceWidth,\n            leftSideBearing: leftSideBearing\n        };\n    }\n}\n// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.\n// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.\nfunction parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {\n    if (opt.lowMemory) {\n        parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs);\n    } else {\n        parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs);\n    }\n}\nvar hmtx = {\n    parse: parseHmtxTable\n};\n// The `kern` table contains kerning pairs.\nfunction parseWindowsKernTable(p) {\n    var pairs = {};\n    // Skip nTables.\n    p.skip(\"uShort\");\n    var subtableVersion = p.parseUShort();\n    check.argument(subtableVersion === 0, \"Unsupported kern sub-table version.\");\n    // Skip subtableLength, subtableCoverage\n    p.skip(\"uShort\", 2);\n    var nPairs = p.parseUShort();\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip(\"uShort\", 3);\n    for(var i = 0; i < nPairs; i += 1){\n        var leftIndex = p.parseUShort();\n        var rightIndex = p.parseUShort();\n        var value = p.parseShort();\n        pairs[leftIndex + \",\" + rightIndex] = value;\n    }\n    return pairs;\n}\nfunction parseMacKernTable(p) {\n    var pairs = {};\n    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.\n    // Skip the rest.\n    p.skip(\"uShort\");\n    var nTables = p.parseULong();\n    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');\n    if (nTables > 1) {\n        console.warn(\"Only the first kern subtable is supported.\");\n    }\n    p.skip(\"uLong\");\n    var coverage = p.parseUShort();\n    var subtableVersion = coverage & 0xFF;\n    p.skip(\"uShort\");\n    if (subtableVersion === 0) {\n        var nPairs = p.parseUShort();\n        // Skip searchRange, entrySelector, rangeShift.\n        p.skip(\"uShort\", 3);\n        for(var i = 0; i < nPairs; i += 1){\n            var leftIndex = p.parseUShort();\n            var rightIndex = p.parseUShort();\n            var value = p.parseShort();\n            pairs[leftIndex + \",\" + rightIndex] = value;\n        }\n    }\n    return pairs;\n}\n// Parse the `kern` table which contains kerning pairs.\nfunction parseKernTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseUShort();\n    if (tableVersion === 0) {\n        return parseWindowsKernTable(p);\n    } else if (tableVersion === 1) {\n        return parseMacKernTable(p);\n    } else {\n        throw new Error(\"Unsupported kern table version (\" + tableVersion + \").\");\n    }\n}\nvar kern = {\n    parse: parseKernTable\n};\n// The `ltag` table stores IETF BCP-47 language tags. It allows supporting\nfunction parseLtagTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, \"Unsupported ltag table version.\");\n    // The 'ltag' specification does not define any flags; skip the field.\n    p.skip(\"uLong\", 1);\n    var numTags = p.parseULong();\n    var tags = [];\n    for(var i = 0; i < numTags; i++){\n        var tag = \"\";\n        var offset = start + p.parseUShort();\n        var length = p.parseUShort();\n        for(var j = offset; j < offset + length; ++j){\n            tag += String.fromCharCode(data.getInt8(j));\n        }\n        tags.push(tag);\n    }\n    return tags;\n}\nvar ltag = {\n    parse: parseLtagTable\n};\n// The `loca` table stores the offsets to the locations of the glyphs in the font.\n// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,\n// relative to the beginning of the glyphData table.\n// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)\n// The loca table has two versions: a short version where offsets are stored as uShorts, and a long\n// version where offsets are stored as uLongs. The `head` table specifies which version to use\n// (under indexToLocFormat).\nfunction parseLocaTable(data, start, numGlyphs, shortVersion) {\n    var p = new parse.Parser(data, start);\n    var parseFn = shortVersion ? p.parseUShort : p.parseULong;\n    // There is an extra entry after the last index element to compute the length of the last glyph.\n    // That's why we use numGlyphs + 1.\n    var glyphOffsets = [];\n    for(var i = 0; i < numGlyphs + 1; i += 1){\n        var glyphOffset = parseFn.call(p);\n        if (shortVersion) {\n            // The short table version stores the actual offset divided by 2.\n            glyphOffset *= 2;\n        }\n        glyphOffsets.push(glyphOffset);\n    }\n    return glyphOffsets;\n}\nvar loca = {\n    parse: parseLocaTable\n};\n// The `maxp` table establishes the memory requirements for the font.\n// Parse the maximum profile `maxp` table.\nfunction parseMaxpTable(data, start) {\n    var maxp = {};\n    var p = new parse.Parser(data, start);\n    maxp.version = p.parseVersion();\n    maxp.numGlyphs = p.parseUShort();\n    if (maxp.version === 1.0) {\n        maxp.maxPoints = p.parseUShort();\n        maxp.maxContours = p.parseUShort();\n        maxp.maxCompositePoints = p.parseUShort();\n        maxp.maxCompositeContours = p.parseUShort();\n        maxp.maxZones = p.parseUShort();\n        maxp.maxTwilightPoints = p.parseUShort();\n        maxp.maxStorage = p.parseUShort();\n        maxp.maxFunctionDefs = p.parseUShort();\n        maxp.maxInstructionDefs = p.parseUShort();\n        maxp.maxStackElements = p.parseUShort();\n        maxp.maxSizeOfInstructions = p.parseUShort();\n        maxp.maxComponentElements = p.parseUShort();\n        maxp.maxComponentDepth = p.parseUShort();\n    }\n    return maxp;\n}\nvar maxp = {\n    parse: parseMaxpTable\n};\n// The `OS/2` table contains metrics required in OpenType fonts.\n// Parse the OS/2 and Windows metrics `OS/2` table\nfunction parseOS2Table(data, start) {\n    var os2 = {};\n    var p = new parse.Parser(data, start);\n    os2.version = p.parseUShort();\n    os2.xAvgCharWidth = p.parseShort();\n    os2.usWeightClass = p.parseUShort();\n    os2.usWidthClass = p.parseUShort();\n    os2.fsType = p.parseUShort();\n    os2.ySubscriptXSize = p.parseShort();\n    os2.ySubscriptYSize = p.parseShort();\n    os2.ySubscriptXOffset = p.parseShort();\n    os2.ySubscriptYOffset = p.parseShort();\n    os2.ySuperscriptXSize = p.parseShort();\n    os2.ySuperscriptYSize = p.parseShort();\n    os2.ySuperscriptXOffset = p.parseShort();\n    os2.ySuperscriptYOffset = p.parseShort();\n    os2.yStrikeoutSize = p.parseShort();\n    os2.yStrikeoutPosition = p.parseShort();\n    os2.sFamilyClass = p.parseShort();\n    os2.panose = [];\n    for(var i = 0; i < 10; i++){\n        os2.panose[i] = p.parseByte();\n    }\n    os2.ulUnicodeRange1 = p.parseULong();\n    os2.ulUnicodeRange2 = p.parseULong();\n    os2.ulUnicodeRange3 = p.parseULong();\n    os2.ulUnicodeRange4 = p.parseULong();\n    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());\n    os2.fsSelection = p.parseUShort();\n    os2.usFirstCharIndex = p.parseUShort();\n    os2.usLastCharIndex = p.parseUShort();\n    os2.sTypoAscender = p.parseShort();\n    os2.sTypoDescender = p.parseShort();\n    os2.sTypoLineGap = p.parseShort();\n    os2.usWinAscent = p.parseUShort();\n    os2.usWinDescent = p.parseUShort();\n    if (os2.version >= 1) {\n        os2.ulCodePageRange1 = p.parseULong();\n        os2.ulCodePageRange2 = p.parseULong();\n    }\n    if (os2.version >= 2) {\n        os2.sxHeight = p.parseShort();\n        os2.sCapHeight = p.parseShort();\n        os2.usDefaultChar = p.parseUShort();\n        os2.usBreakChar = p.parseUShort();\n        os2.usMaxContent = p.parseUShort();\n    }\n    return os2;\n}\nvar os2 = {\n    parse: parseOS2Table\n};\n// The `post` table stores additional PostScript information, such as glyph names.\n// Parse the PostScript `post` table\nfunction parsePostTable(data, start) {\n    var post = {};\n    var p = new parse.Parser(data, start);\n    post.version = p.parseVersion();\n    post.italicAngle = p.parseFixed();\n    post.underlinePosition = p.parseShort();\n    post.underlineThickness = p.parseShort();\n    post.isFixedPitch = p.parseULong();\n    post.minMemType42 = p.parseULong();\n    post.maxMemType42 = p.parseULong();\n    post.minMemType1 = p.parseULong();\n    post.maxMemType1 = p.parseULong();\n    post.names = [];\n    switch(post.version){\n        case 1:\n            break;\n        case 2:\n            post.numberOfGlyphs = p.parseUShort();\n            post.glyphNameIndex = new Array(post.numberOfGlyphs);\n            for(var i = 0; i < post.numberOfGlyphs; i++){\n                post.glyphNameIndex[i] = p.parseUShort();\n            }\n            break;\n        case 2.5:\n            post.numberOfGlyphs = p.parseUShort();\n            post.offset = new Array(post.numberOfGlyphs);\n            for(var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++){\n                post.offset[i$1] = p.parseChar();\n            }\n            break;\n    }\n    return post;\n}\nvar post = {\n    parse: parsePostTable\n};\n// Data types used in the OpenType font file.\n/**\n * @exports opentype.decode\n * @class\n */ var decode = {};\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */ decode.UTF8 = function(data, offset, numBytes) {\n    var codePoints = [];\n    var numChars = numBytes;\n    for(var j = 0; j < numChars; j++, offset += 1){\n        codePoints[j] = data.getUint8(offset);\n    }\n    return String.fromCharCode.apply(null, codePoints);\n};\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */ decode.UTF16 = function(data, offset, numBytes) {\n    var codePoints = [];\n    var numChars = numBytes / 2;\n    for(var j = 0; j < numChars; j++, offset += 2){\n        codePoints[j] = data.getUint16(offset);\n    }\n    return String.fromCharCode.apply(null, codePoints);\n};\n// Data for converting old eight-bit Macintosh encodings to Unicode.\n// This representation is optimized for decoding; encoding is slower\n// and needs more memory. The assumption is that all opentype.js users\n// want to open fonts, but saving a font will be comparatively rare\n// so it can be more expensive. Keyed by IANA character set name.\n//\n// Python script for generating these strings:\n//\n//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n//     print(s.encode('utf-8'))\n/**\n * @private\n */ var eightBitMacEncodings = {\n    \"x-mac-croatian\": \"\\xc4\\xc5\\xc7\\xc9\\xd1\\xd6\\xdc\\xe1\\xe0\\xe2\\xe4\\xe3\\xe5\\xe7\\xe9\\xe8\\xea\\xeb\\xed\\xec\\xee\\xef\\xf1\\xf3\\xf2\\xf4\\xf6\\xf5\\xfa\\xf9\\xfb\\xfc†\\xb0\\xa2\\xa3\\xa7•\\xb6\\xdf\\xaeŠ™\\xb4\\xa8≠Ž\\xd8∞\\xb1≤≥∆\\xb5∂∑∏š∫\\xaa\\xbaΩž\\xf8\" + \"\\xbf\\xa1\\xac√ƒ≈Ć\\xabČ…\\xa0\\xc0\\xc3\\xd5ŒœĐ—“”‘’\\xf7◊\\xa9⁄€‹›\\xc6\\xbb–\\xb7‚„‰\\xc2ć\\xc1č\\xc8\\xcd\\xce\\xcf\\xcc\\xd3\\xd4đ\\xd2\\xda\\xdb\\xd9ıˆ˜\\xafπ\\xcb˚\\xb8\\xca\\xe6ˇ\",\n    \"x-mac-cyrillic\": \"АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†\\xb0Ґ\\xa3\\xa7•\\xb6І\\xae\\xa9™Ђђ≠Ѓѓ∞\\xb1≤≥і\\xb5ґЈЄєЇїЉљЊњ\" + \"јЅ\\xac√ƒ≈∆\\xab\\xbb…\\xa0ЋћЌќѕ–—“”‘’\\xf7„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю\",\n    \"x-mac-gaelic\": \"\\xc4\\xc5\\xc7\\xc9\\xd1\\xd6\\xdc\\xe1\\xe0\\xe2\\xe4\\xe3\\xe5\\xe7\\xe9\\xe8\\xea\\xeb\\xed\\xec\\xee\\xef\\xf1\\xf3\\xf2\\xf4\\xf6\\xf5\\xfa\\xf9\\xfb\\xfc†\\xb0\\xa2\\xa3\\xa7•\\xb6\\xdf\\xae\\xa9™\\xb4\\xa8≠\\xc6\\xd8Ḃ\\xb1≤≥ḃĊċḊḋḞḟĠġṀ\\xe6\\xf8\" + \"ṁṖṗɼƒſṠ\\xab\\xbb…\\xa0\\xc0\\xc3\\xd5Œœ–—“”‘’ṡẛ\\xffŸṪ€‹›Ŷŷṫ\\xb7Ỳỳ⁊\\xc2\\xca\\xc1\\xcb\\xc8\\xcd\\xce\\xcf\\xcc\\xd3\\xd4♣\\xd2\\xda\\xdb\\xd9ı\\xdd\\xfdŴŵẄẅẀẁẂẃ\",\n    \"x-mac-greek\": \"\\xc4\\xb9\\xb2\\xc9\\xb3\\xd6\\xdc΅\\xe0\\xe2\\xe4΄\\xa8\\xe7\\xe9\\xe8\\xea\\xeb\\xa3™\\xee\\xef•\\xbd‰\\xf4\\xf6\\xa6€\\xf9\\xfb\\xfc†ΓΔΘΛΞΠ\\xdf\\xae\\xa9ΣΪ\\xa7≠\\xb0\\xb7Α\\xb1≤≥\\xa5ΒΕΖΗΙΚΜΦΫΨΩ\" + \"άΝ\\xacΟΡ≈Τ\\xab\\xbb…\\xa0ΥΧΆΈœ–―“”‘’\\xf7ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\\xad\",\n    \"x-mac-icelandic\": \"\\xc4\\xc5\\xc7\\xc9\\xd1\\xd6\\xdc\\xe1\\xe0\\xe2\\xe4\\xe3\\xe5\\xe7\\xe9\\xe8\\xea\\xeb\\xed\\xec\\xee\\xef\\xf1\\xf3\\xf2\\xf4\\xf6\\xf5\\xfa\\xf9\\xfb\\xfc\\xdd\\xb0\\xa2\\xa3\\xa7•\\xb6\\xdf\\xae\\xa9™\\xb4\\xa8≠\\xc6\\xd8∞\\xb1≤≥\\xa5\\xb5∂∑∏π∫\\xaa\\xbaΩ\\xe6\\xf8\" + \"\\xbf\\xa1\\xac√ƒ≈∆\\xab\\xbb…\\xa0\\xc0\\xc3\\xd5Œœ–—“”‘’\\xf7◊\\xffŸ⁄€\\xd0\\xf0\\xde\\xfe\\xfd\\xb7‚„‰\\xc2\\xca\\xc1\\xcb\\xc8\\xcd\\xce\\xcf\\xcc\\xd3\\xd4\\xd2\\xda\\xdb\\xd9ıˆ˜\\xaf˘˙˚\\xb8˝˛ˇ\",\n    \"x-mac-inuit\": \"ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ\\xb0ᒡᒥᒦ•\\xb6ᒧ\\xae\\xa9™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ\" + \"ᓘᓚᓛᓪᔨᔩᔪᔫᔭ…\\xa0ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł\",\n    \"x-mac-ce\": \"\\xc4Āā\\xc9Ą\\xd6\\xdc\\xe1ąČ\\xe4čĆć\\xe9ŹźĎ\\xedďĒēĖ\\xf3ė\\xf4\\xf6\\xf5\\xfaĚě\\xfc†\\xb0Ę\\xa3\\xa7•\\xb6\\xdf\\xae\\xa9™ę\\xa8≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ\" + \"ņŃ\\xac√ńŇ∆\\xab\\xbb…\\xa0ňŐ\\xd5őŌ–—“”‘’\\xf7◊ōŔŕŘ‹›řŖŗŠ‚„šŚś\\xc1Ťť\\xcdŽžŪ\\xd3\\xd4ūŮ\\xdaůŰűŲų\\xdd\\xfdķŻŁżĢˇ\",\n    macintosh: \"\\xc4\\xc5\\xc7\\xc9\\xd1\\xd6\\xdc\\xe1\\xe0\\xe2\\xe4\\xe3\\xe5\\xe7\\xe9\\xe8\\xea\\xeb\\xed\\xec\\xee\\xef\\xf1\\xf3\\xf2\\xf4\\xf6\\xf5\\xfa\\xf9\\xfb\\xfc†\\xb0\\xa2\\xa3\\xa7•\\xb6\\xdf\\xae\\xa9™\\xb4\\xa8≠\\xc6\\xd8∞\\xb1≤≥\\xa5\\xb5∂∑∏π∫\\xaa\\xbaΩ\\xe6\\xf8\" + \"\\xbf\\xa1\\xac√ƒ≈∆\\xab\\xbb…\\xa0\\xc0\\xc3\\xd5Œœ–—“”‘’\\xf7◊\\xffŸ⁄€‹›ﬁﬂ‡\\xb7‚„‰\\xc2\\xca\\xc1\\xcb\\xc8\\xcd\\xce\\xcf\\xcc\\xd3\\xd4\\xd2\\xda\\xdb\\xd9ıˆ˜\\xaf˘˙˚\\xb8˝˛ˇ\",\n    \"x-mac-romanian\": \"\\xc4\\xc5\\xc7\\xc9\\xd1\\xd6\\xdc\\xe1\\xe0\\xe2\\xe4\\xe3\\xe5\\xe7\\xe9\\xe8\\xea\\xeb\\xed\\xec\\xee\\xef\\xf1\\xf3\\xf2\\xf4\\xf6\\xf5\\xfa\\xf9\\xfb\\xfc†\\xb0\\xa2\\xa3\\xa7•\\xb6\\xdf\\xae\\xa9™\\xb4\\xa8≠ĂȘ∞\\xb1≤≥\\xa5\\xb5∂∑∏π∫\\xaa\\xbaΩăș\" + \"\\xbf\\xa1\\xac√ƒ≈∆\\xab\\xbb…\\xa0\\xc0\\xc3\\xd5Œœ–—“”‘’\\xf7◊\\xffŸ⁄€‹›Țț‡\\xb7‚„‰\\xc2\\xca\\xc1\\xcb\\xc8\\xcd\\xce\\xcf\\xcc\\xd3\\xd4\\xd2\\xda\\xdb\\xd9ıˆ˜\\xaf˘˙˚\\xb8˝˛ˇ\",\n    \"x-mac-turkish\": \"\\xc4\\xc5\\xc7\\xc9\\xd1\\xd6\\xdc\\xe1\\xe0\\xe2\\xe4\\xe3\\xe5\\xe7\\xe9\\xe8\\xea\\xeb\\xed\\xec\\xee\\xef\\xf1\\xf3\\xf2\\xf4\\xf6\\xf5\\xfa\\xf9\\xfb\\xfc†\\xb0\\xa2\\xa3\\xa7•\\xb6\\xdf\\xae\\xa9™\\xb4\\xa8≠\\xc6\\xd8∞\\xb1≤≥\\xa5\\xb5∂∑∏π∫\\xaa\\xbaΩ\\xe6\\xf8\" + \"\\xbf\\xa1\\xac√ƒ≈∆\\xab\\xbb…\\xa0\\xc0\\xc3\\xd5Œœ–—“”‘’\\xf7◊\\xffŸĞğİıŞş‡\\xb7‚„‰\\xc2\\xca\\xc1\\xcb\\xc8\\xcd\\xce\\xcf\\xcc\\xd3\\xd4\\xd2\\xda\\xdb\\xd9ˆ˜\\xaf˘˙˚\\xb8˝˛ˇ\"\n};\n/**\n * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n * string, or 'undefined' if the encoding is unsupported. For example, we do\n * not support Chinese, Japanese or Korean because these would need large\n * mapping tables.\n * @param {DataView} dataView\n * @param {number} offset\n * @param {number} dataLength\n * @param {string} encoding\n * @returns {string}\n */ decode.MACSTRING = function(dataView, offset, dataLength, encoding) {\n    var table = eightBitMacEncodings[encoding];\n    if (table === undefined) {\n        return undefined;\n    }\n    var result = \"\";\n    for(var i = 0; i < dataLength; i++){\n        var c = dataView.getUint8(offset + i);\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c <= 0x7F) {\n            result += String.fromCharCode(c);\n        } else {\n            result += table[c & 0x7F];\n        }\n    }\n    return result;\n};\n// The `GPOS` table contains kerning pairs, among other things.\n// Parse the metadata `meta` table.\n// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html\nfunction parseMetaTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, \"Unsupported META table version.\");\n    p.parseULong(); // flags - currently unused and set to 0\n    p.parseULong(); // tableOffset\n    var numDataMaps = p.parseULong();\n    var tags = {};\n    for(var i = 0; i < numDataMaps; i++){\n        var tag = p.parseTag();\n        var dataOffset = p.parseULong();\n        var dataLength = p.parseULong();\n        var text = decode.UTF8(data, start + dataOffset, dataLength);\n        tags[tag] = text;\n    }\n    return tags;\n}\nvar meta = {\n    parse: parseMetaTable\n};\n// opentype.js\n/**\n * The opentype library.\n * @namespace opentype\n */ // Table Directory Entries //////////////////////////////////////////////\n/**\n * Parses OpenType table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */ function parseOpenTypeTableEntries(data, numTables) {\n    var tableEntries = [];\n    var p = 12;\n    for(var i = 0; i < numTables; i += 1){\n        var tag = parse.getTag(data, p);\n        var checksum = parse.getULong(data, p + 4);\n        var offset = parse.getULong(data, p + 8);\n        var length = parse.getULong(data, p + 12);\n        tableEntries.push({\n            tag: tag,\n            checksum: checksum,\n            offset: offset,\n            length: length,\n            compression: false\n        });\n        p += 16;\n    }\n    return tableEntries;\n}\n/**\n * Parses WOFF table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */ function parseWOFFTableEntries(data, numTables) {\n    var tableEntries = [];\n    var p = 44; // offset to the first table directory entry.\n    for(var i = 0; i < numTables; i += 1){\n        var tag = parse.getTag(data, p);\n        var offset = parse.getULong(data, p + 4);\n        var compLength = parse.getULong(data, p + 8);\n        var origLength = parse.getULong(data, p + 12);\n        var compression = void 0;\n        if (compLength < origLength) {\n            compression = \"WOFF\";\n        } else {\n            compression = false;\n        }\n        tableEntries.push({\n            tag: tag,\n            offset: offset,\n            compression: compression,\n            compressedLength: compLength,\n            length: origLength\n        });\n        p += 20;\n    }\n    return tableEntries;\n}\n/**\n * @typedef TableData\n * @type Object\n * @property {DataView} data - The DataView\n * @property {number} offset - The data offset.\n */ /**\n * @param  {DataView}\n * @param  {Object}\n * @return {TableData}\n */ function uncompressTable(data, tableEntry) {\n    if (tableEntry.compression === \"WOFF\") {\n        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);\n        var outBuffer = new Uint8Array(tableEntry.length);\n        inflateSync(inBuffer, outBuffer);\n        if (outBuffer.byteLength !== tableEntry.length) {\n            throw new Error(\"Decompression error: \" + tableEntry.tag + \" decompressed length doesn't match recorded length\");\n        }\n        var view = new DataView(outBuffer.buffer, 0);\n        return {\n            data: view,\n            offset: 0\n        };\n    } else {\n        return {\n            data: data,\n            offset: tableEntry.offset\n        };\n    }\n}\n// Public API ///////////////////////////////////////////////////////////\n/**\n * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n * Throws an error if the font could not be parsed.\n * @param  {ArrayBuffer}\n * @param  {Object} opt - options for parsing\n * @return {opentype.Font}\n */ function parseBuffer(buffer, opt) {\n    opt = opt === undefined || opt === null ? {} : opt;\n    var indexToLocFormat;\n    // Since the constructor can also be called to create new fonts from scratch, we indicate this\n    // should be an empty font that we'll fill with our own data.\n    var font = new Font({\n        empty: true\n    });\n    // OpenType fonts use big endian byte ordering.\n    // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n    // Instead we use DataViews where we can specify endianness.\n    var data = new DataView(buffer, 0);\n    var numTables;\n    var tableEntries = [];\n    var signature = parse.getTag(data, 0);\n    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === \"true\" || signature === \"typ1\") {\n        font.outlinesFormat = \"truetype\";\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === \"OTTO\") {\n        font.outlinesFormat = \"cff\";\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === \"wOFF\") {\n        var flavor = parse.getTag(data, 4);\n        if (flavor === String.fromCharCode(0, 1, 0, 0)) {\n            font.outlinesFormat = \"truetype\";\n        } else if (flavor === \"OTTO\") {\n            font.outlinesFormat = \"cff\";\n        } else {\n            throw new Error(\"Unsupported OpenType flavor \" + signature);\n        }\n        numTables = parse.getUShort(data, 12);\n        tableEntries = parseWOFFTableEntries(data, numTables);\n    } else {\n        throw new Error(\"Unsupported OpenType signature \" + signature);\n    }\n    var cffTableEntry;\n    var fvarTableEntry;\n    var glyfTableEntry;\n    var gdefTableEntry;\n    var gposTableEntry;\n    var gsubTableEntry;\n    var hmtxTableEntry;\n    var kernTableEntry;\n    var locaTableEntry;\n    var metaTableEntry;\n    var p;\n    for(var i = 0; i < numTables; i += 1){\n        var tableEntry = tableEntries[i];\n        var table = void 0;\n        switch(tableEntry.tag){\n            case \"cmap\":\n                table = uncompressTable(data, tableEntry);\n                font.tables.cmap = cmap.parse(table.data, table.offset);\n                font.encoding = new CmapEncoding(font.tables.cmap);\n                break;\n            case \"cvt \":\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.cvt = p.parseShortList(tableEntry.length / 2);\n                break;\n            case \"fvar\":\n                fvarTableEntry = tableEntry;\n                break;\n            case \"fpgm\":\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.fpgm = p.parseByteList(tableEntry.length);\n                break;\n            case \"head\":\n                table = uncompressTable(data, tableEntry);\n                font.tables.head = head.parse(table.data, table.offset);\n                font.unitsPerEm = font.tables.head.unitsPerEm;\n                indexToLocFormat = font.tables.head.indexToLocFormat;\n                break;\n            case \"hhea\":\n                table = uncompressTable(data, tableEntry);\n                font.tables.hhea = hhea.parse(table.data, table.offset);\n                font.ascender = font.tables.hhea.ascender;\n                font.descender = font.tables.hhea.descender;\n                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n                break;\n            case \"hmtx\":\n                hmtxTableEntry = tableEntry;\n                break;\n            case \"ltag\":\n                table = uncompressTable(data, tableEntry);\n                ltagTable = ltag.parse(table.data, table.offset);\n                break;\n            case \"maxp\":\n                table = uncompressTable(data, tableEntry);\n                font.tables.maxp = maxp.parse(table.data, table.offset);\n                font.numGlyphs = font.tables.maxp.numGlyphs;\n                break;\n            case \"OS/2\":\n                table = uncompressTable(data, tableEntry);\n                font.tables.os2 = os2.parse(table.data, table.offset);\n                break;\n            case \"post\":\n                table = uncompressTable(data, tableEntry);\n                font.tables.post = post.parse(table.data, table.offset);\n                break;\n            case \"prep\":\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.prep = p.parseByteList(tableEntry.length);\n                break;\n            case \"glyf\":\n                glyfTableEntry = tableEntry;\n                break;\n            case \"loca\":\n                locaTableEntry = tableEntry;\n                break;\n            case \"CFF \":\n                cffTableEntry = tableEntry;\n                break;\n            case \"kern\":\n                kernTableEntry = tableEntry;\n                break;\n            case \"GDEF\":\n                gdefTableEntry = tableEntry;\n                break;\n            case \"GPOS\":\n                gposTableEntry = tableEntry;\n                break;\n            case \"GSUB\":\n                gsubTableEntry = tableEntry;\n                break;\n            case \"meta\":\n                metaTableEntry = tableEntry;\n                break;\n        }\n    }\n    if (glyfTableEntry && locaTableEntry) {\n        var shortVersion = indexToLocFormat === 0;\n        var locaTable = uncompressTable(data, locaTableEntry);\n        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);\n        var glyfTable = uncompressTable(data, glyfTableEntry);\n        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt);\n    } else if (cffTableEntry) {\n        var cffTable = uncompressTable(data, cffTableEntry);\n        cff.parse(cffTable.data, cffTable.offset, font, opt);\n    } else {\n        throw new Error(\"Font doesn't contain TrueType or CFF outlines.\");\n    }\n    var hmtxTable = uncompressTable(data, hmtxTableEntry);\n    hmtx.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt);\n    addGlyphNames(font, opt);\n    if (kernTableEntry) {\n        var kernTable = uncompressTable(data, kernTableEntry);\n        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);\n    } else {\n        font.kerningPairs = {};\n    }\n    if (gdefTableEntry) {\n        var gdefTable = uncompressTable(data, gdefTableEntry);\n        font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);\n    }\n    if (gposTableEntry) {\n        var gposTable = uncompressTable(data, gposTableEntry);\n        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);\n        font.position.init();\n    }\n    if (gsubTableEntry) {\n        var gsubTable = uncompressTable(data, gsubTableEntry);\n        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);\n    }\n    if (fvarTableEntry) {\n        var fvarTable = uncompressTable(data, fvarTableEntry);\n        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);\n    }\n    if (metaTableEntry) {\n        var metaTable = uncompressTable(data, metaTableEntry);\n        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);\n        font.metas = font.tables.meta;\n    }\n    return font;\n}\nfunction load() {}\nfunction loadSync() {}\nvar opentype = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Font: Font,\n    Glyph: Glyph,\n    Path: Path,\n    _parse: parse,\n    parse: parseBuffer,\n    load: load,\n    loadSync: loadSync\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (opentype);\n //# sourceMappingURL=opentype.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNodWRpbmcvb3BlbnR5cGUuanMvZGlzdC9vcGVudHlwZS5tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUVELDJGQUEyRjtBQUUzRixvRUFBb0U7QUFDcEUsSUFBSUEsS0FBS0MsWUFBWUMsTUFBTUMsYUFBYUMsTUFBTUM7QUFDOUMsMEJBQTBCO0FBQzFCLElBQUlDLE9BQU8sSUFBSU4sR0FBRztJQUFDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRyxVQUFVLEdBQUc7SUFBRztJQUFHLGNBQWMsR0FBRztDQUFFO0FBQ2hKLDRCQUE0QjtBQUM1QixnQkFBZ0I7QUFDaEIsSUFBSU8sT0FBTyxJQUFJUCxHQUFHO0lBQUM7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUksVUFBVSxHQUFHO0lBQUc7Q0FBRTtBQUN2SSx3QkFBd0I7QUFDeEIsSUFBSVEsT0FBTyxJQUFJUixHQUFHO0lBQUM7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7Q0FBRztBQUNwRiw4Q0FBOEM7QUFDOUMsSUFBSVMsT0FBTyxTQUFVQyxFQUFFLEVBQUVDLEtBQUs7SUFDMUIsSUFBSUMsSUFBSSxJQUFJVixJQUFJO0lBQ2hCLElBQUssSUFBSVcsSUFBSSxHQUFHQSxJQUFJLElB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Q0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUFZO0FBRWhCLElBQUlDLHNCQUFzQjtJQUN0QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FBYztBQUVsQixJQUFJQyxvQkFBb0I7SUFDcEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lB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Q2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ2pELFFBQVEsR0FBR21yQixVQUFVTyxJQUFJLENBQUMxckIsV0FBVyxHQUFHLEdBQUcsR0FBRyxHQUFHO0NBQ3BEO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXVPSSxHQUVKOztDQUVDLEdBRUQ7OztDQUdDLEdBQ0QsU0FBUzJyQixNQUFNQyxJQUFJO0lBQ2YsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO0lBQ1osSUFBSSxDQUFDOUssS0FBSyxHQUFHLENBQUM7SUFDZCxJQUFJLENBQUMrSyxXQUFXLEdBQUc7QUFDdkI7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNDLGFBQWFDLFVBQVUsRUFBRXpiLFNBQVMsRUFBRTBiLFdBQVc7SUFDcEQsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO0lBQ25CLElBQUksQ0FBQ0QsVUFBVSxHQUFHQTtJQUNsQixJQUFJLENBQUN6YixTQUFTLEdBQUdBO0FBQ3JCO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTMmIsZUFBZUQsV0FBVyxFQUFFRSxVQUFVLEVBQUVDLFFBQVE7SUFDckQsSUFBSSxDQUFDSCxXQUFXLEdBQUdBO0lBQ25CLElBQUksQ0FBQ0ksU0FBUyxHQUFHO0lBQ2pCLElBQUksQ0FBQ2hsQixNQUFNLEdBQUcsRUFBRTtJQUNoQixJQUFJLENBQUM4a0IsVUFBVSxHQUFHQTtJQUNsQixJQUFJLENBQUNDLFFBQVEsR0FBR0E7QUFDcEI7QUFFQTs7Ozs7Q0FLQyxHQUVEOzs7O0NBSUMsR0FDRCxTQUFTRSxjQUFjQyxPQUFPLEVBQUVDLFlBQVk7SUFDeEMsSUFBSSxDQUFDRCxPQUFPLEdBQUdBO0lBQ2YsSUFBSSxDQUFDanBCLEtBQUssR0FBR2twQjtJQUNiLElBQUksQ0FBQ3J6QixNQUFNLEdBQUdvekIsUUFBUXB6QixNQUFNO0lBQzVCLElBQUksQ0FBQ3N6QixPQUFPLEdBQUdGLE9BQU8sQ0FBQ0MsYUFBYTtJQUNwQyxJQUFJLENBQUNFLFNBQVMsR0FBR0gsUUFBUTVkLEtBQUssQ0FBQyxHQUFHNmQ7SUFDbEMsSUFBSSxDQUFDRyxTQUFTLEdBQUdKLFFBQVE1ZCxLQUFLLENBQUM2ZCxlQUFlO0FBQ2xEO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0ksTUFBTUMsT0FBTztJQUNsQixJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDZixJQUFJLENBQUNDLFdBQVcsR0FBRyxFQUFFO0FBQ3pCO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0MscUJBQXFCQyxNQUFNO0lBQ2hDLElBQUlDLFNBQVMsSUFBSTtJQUVqQixJQUFJQyxhQUFhO1FBQ2I7UUFBUztRQUFPO1FBQVE7UUFBWTtRQUNwQztRQUFjO1FBQWU7UUFBZTtRQUM1QztRQUFnQjtRQUFnQjtRQUFjO0tBQ2pEO0lBRURBLFdBQVdDLE9BQU8sQ0FBQyxTQUFVTixPQUFPO1FBQ2hDOXFCLE9BQU8rQixjQUFjLENBQUNtcEIsT0FBT0QsTUFBTSxFQUFFSCxTQUFTO1lBQzFDMWxCLE9BQU8sSUFBSXlsQixNQUFNQztRQUNyQjtJQUNKO0lBRUEsSUFBSSxDQUFDLENBQUNHLFFBQVE7UUFDVkUsV0FBV0MsT0FBTyxDQUFDLFNBQVVOLE9BQU87WUFDaEMsSUFBSU8sUUFBUUosTUFBTSxDQUFDSCxRQUFRO1lBQzNCLElBQUksT0FBT08sVUFBVSxZQUFZO2dCQUM3QkgsT0FBT0QsTUFBTSxDQUFDSCxRQUFRLENBQUNRLFNBQVMsQ0FBQ0Q7WUFDckM7UUFDSjtJQUNKO0lBQ0EsSUFBSUUsd0JBQXdCO1FBQ3hCO1FBQWU7UUFBZTtRQUM5QjtRQUFnQjtRQUFnQjtLQUNuQztJQUNEQSxzQkFBc0JILE9BQU8sQ0FBQyxTQUFVTixPQUFPO1FBQzNDSSxPQUFPRCxNQUFNLENBQUNILFFBQVEsQ0FBQ1EsU0FBUyxDQUM1QkosT0FBT00sb0JBQW9CO0lBRW5DO0FBQ0o7QUFFQTs7O0NBR0MsR0FDRCxTQUFTQyxVQUFVUixNQUFNO0lBQ3JCLElBQUksQ0FBQ1MsTUFBTSxHQUFHLEVBQUU7SUFDaEIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRyxDQUFDO0lBQzNCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLEVBQUU7SUFDekIsSUFBSSxDQUFDWCxNQUFNLEdBQUcsQ0FBQztJQUNmLElBQUksQ0FBQ1ksbUJBQW1CLEdBQUcsRUFBRTtJQUU3QmIscUJBQXFCcmlCLElBQUksQ0FBQyxJQUFJLEVBQUVzaUI7QUFDcEM7QUFFQTs7OztDQUlDLEdBQ0RwQixNQUFNaHRCLFNBQVMsQ0FBQ2l2QixRQUFRLEdBQUcsU0FBU0MsR0FBRyxFQUFFM21CLEtBQUs7SUFDMUMsSUFBSSxDQUFDNFosS0FBSyxDQUFDK00sSUFBSSxHQUFHM21CO0lBQ2xCLElBQUksQ0FBQzJrQixXQUFXLEdBQUc7UUFBRWdDLEtBQUtBO1FBQUszbUIsT0FBTyxJQUFJLENBQUM0WixLQUFLLENBQUMrTSxJQUFJO0lBQUM7SUFDdEQsT0FBTyxJQUFJLENBQUNoQyxXQUFXO0FBQzNCO0FBRUFGLE1BQU1odEIsU0FBUyxDQUFDbXZCLFFBQVEsR0FBRyxTQUFVQyxPQUFPO0lBQ3hDLE9BQU8sSUFBSSxDQUFDak4sS0FBSyxDQUFDaU4sUUFBUSxJQUFJO0FBQ2xDO0FBRUE7OztDQUdDLEdBQ0RSLFVBQVU1dUIsU0FBUyxDQUFDcXZCLFlBQVksR0FBRyxTQUFTM3FCLEtBQUs7SUFDN0MsT0FBT0EsU0FBUyxLQUFLQSxRQUFRLElBQUksQ0FBQ21xQixNQUFNLENBQUN0MEIsTUFBTTtBQUNuRDtBQUVBOzs7O0NBSUMsR0FDRHEwQixVQUFVNXVCLFNBQVMsQ0FBQ3N2QixVQUFVLEdBQUcsU0FBVUMsSUFBSTtJQUMzQyxJQUFJbEIsU0FBUyxJQUFJO0lBRWpCLElBQUltQixTQUFTO0lBQ2IsSUFBSXJOLFFBQVFvTixLQUFLRSxHQUFHLENBQUMsU0FBVUMsR0FBRztRQUFJLE9BQ2xDckIsTUFBTSxDQUFDcUIsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDeHVCLEtBQUssQ0FBQ210QixRQUFRcUIsSUFBSTNmLEtBQUssQ0FBQyxHQUFHWCxNQUFNLENBQUNvZ0I7SUFDbEQ7SUFDSCxJQUFJRyxnQkFBZ0IsU0FBVUMsR0FBRztRQUFJLE9BQ2pDLE9BQU9BLFFBQVEsWUFDZkEsSUFBSUMsY0FBYyxDQUFDO0lBQ3BCO0lBQ0gsSUFBSTFOLE1BQU0yTixLQUFLLENBQUNILGdCQUFnQjtRQUM1QixPQUFPO1lBQ0hJLE1BQU07WUFDTkMsUUFBUTdOLE1BQU04TixNQUFNLENBQUNOO1FBQ3pCO0lBQ0o7SUFDQSxJQUFJLENBQUNPLFFBQVEsQ0FBQyxjQUFjO1FBQUMvTixNQUFNOE4sTUFBTSxDQUFDLFNBQVVFLEVBQUU7WUFBSSxPQUFPLENBQUNSLGNBQWNRO1FBQUs7S0FBRztBQUM1RjtBQUVBOzs7Ozs7Q0FNQyxHQUNEdkIsVUFBVTV1QixTQUFTLENBQUNvd0IsWUFBWSxHQUFHLFNBQVVoRCxVQUFVLEVBQUU1YyxNQUFNLEVBQUVxZSxNQUFNLEVBQUVXLE1BQU07SUFDM0VoZixTQUFTQSxXQUFXLE9BQU9BLFNBQVMsSUFBSSxDQUFDcWUsTUFBTSxDQUFDdDBCLE1BQU07SUFDdEQsSUFBSTgxQixjQUFjeEIsT0FBT2lCLEtBQUssQ0FBQyxTQUFVUSxLQUFLO1FBQUksT0FBT0EsaUJBQWlCdEQ7SUFBTztJQUNqRixJQUFJLENBQUN1RCxNQUFNbkQsZUFBZSxJQUFJLENBQUNpQyxZQUFZLENBQUNqQyxlQUFlaUQsYUFBYTtRQUNwRSxJQUFJRyxXQUFXLElBQUksQ0FBQzNCLE1BQU0sQ0FBQ2psQixNQUFNLENBQUMxSSxLQUFLLENBQ25DLElBQUksQ0FBQzJ0QixNQUFNLEVBQUU7WUFBQ3pCO1lBQVk1YztTQUFPLENBQUNwQixNQUFNLENBQUN5ZjtRQUU3QyxJQUFJLENBQUNXLFFBQVE7WUFBRSxJQUFJLENBQUNVLFFBQVEsQ0FBQyxnQkFBZ0I7Z0JBQUM5QztnQkFBWTVjO2dCQUFRcWU7YUFBTztRQUFHO1FBQzVFLE9BQU87WUFBQzJCO1lBQVUzQjtTQUFPO0lBQzdCLE9BQU87UUFDSCxPQUFPO1lBQUVrQixNQUFNO1FBQThDO0lBQ2pFO0FBQ0o7QUFFQTs7Ozs7Q0FLQyxHQUNEbkIsVUFBVTV1QixTQUFTLENBQUN5d0IsWUFBWSxHQUFHLFNBQVUvckIsS0FBSyxFQUFFNHJCLEtBQUssRUFBRWQsTUFBTTtJQUM3RCxJQUFJLENBQUNlLE1BQU03ckIsVUFBVSxJQUFJLENBQUMycUIsWUFBWSxDQUFDM3FCLFVBQVU0ckIsaUJBQWlCdEQsT0FBTztRQUNyRSxJQUFJd0QsV0FBVyxJQUFJLENBQUMzQixNQUFNLENBQUNqbEIsTUFBTSxDQUFDbEYsT0FBTyxHQUFHNHJCO1FBQzVDLElBQUksQ0FBQ2QsUUFBUTtZQUFFLElBQUksQ0FBQ1UsUUFBUSxDQUFDLGdCQUFnQjtnQkFBQ3hyQjtnQkFBTzRyQjthQUFNO1FBQUc7UUFDOUQsT0FBTztZQUFDRSxRQUFRLENBQUMsRUFBRTtZQUFFRjtTQUFNO0lBQy9CLE9BQU87UUFDSCxPQUFPO1lBQUVQLE1BQU07UUFBd0M7SUFDM0Q7QUFDSjtBQUVBOzs7OztDQUtDLEdBQ0RuQixVQUFVNXVCLFNBQVMsQ0FBQzB3QixXQUFXLEdBQUcsU0FBU3RELFVBQVUsRUFBRTVjLE1BQU0sRUFBRWdmLE1BQU07SUFDakVoZixTQUFTLENBQUMrZixNQUFNL2YsVUFBVUEsU0FBUyxJQUFJLENBQUNxZSxNQUFNLENBQUN0MEIsTUFBTTtJQUNyRCxJQUFJczBCLFNBQVMsSUFBSSxDQUFDQSxNQUFNLENBQUNqbEIsTUFBTSxDQUFDd2pCLFlBQVk1YztJQUM1QyxJQUFJLENBQUNnZixRQUFRO1FBQUUsSUFBSSxDQUFDVSxRQUFRLENBQUMsZUFBZTtZQUFDckI7WUFBUXpCO1lBQVk1YztTQUFPO0lBQUc7SUFDM0UsT0FBT3FlO0FBQ1g7QUFFQTs7OztDQUlDLEdBQ0RELFVBQVU1dUIsU0FBUyxDQUFDMndCLFdBQVcsR0FBRyxTQUFTanNCLEtBQUssRUFBRThxQixNQUFNO0lBQ3BELElBQUksQ0FBQ2UsTUFBTTdyQixVQUFVLElBQUksQ0FBQzJxQixZQUFZLENBQUMzcUIsUUFBUTtRQUMzQyxJQUFJNHJCLFFBQVEsSUFBSSxDQUFDekIsTUFBTSxDQUFDamxCLE1BQU0sQ0FBQ2xGLE9BQU87UUFDdEMsSUFBSSxDQUFDOHFCLFFBQVE7WUFBRSxJQUFJLENBQUNVLFFBQVEsQ0FBQyxlQUFlO2dCQUFDSTtnQkFBTzVyQjthQUFNO1FBQUc7UUFDN0QsT0FBTzRyQjtJQUNYLE9BQU87UUFDSCxPQUFPO1lBQUVQLE1BQU07UUFBb0M7SUFDdkQ7QUFDSjtBQUVBOzs7OztDQUtDLEdBQ0RuQixVQUFVNXVCLFNBQVMsQ0FBQzR3QixXQUFXLEdBQUcsU0FBVS9CLE1BQU0sRUFBRW5xQixLQUFLLEVBQUU4cUIsTUFBTTtJQUM3RCxJQUFJcUIsWUFBWWhDLE9BQU9pQixLQUFLLENBQ3hCLFNBQVVRLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJ0RDtJQUFPO0lBRXRELElBQUk2RCxXQUFXO1FBQ1gsSUFBSSxDQUFDaEMsTUFBTSxDQUFDamxCLE1BQU0sQ0FBQzFJLEtBQUssQ0FDcEIsSUFBSSxDQUFDMnRCLE1BQU0sRUFBRTtZQUFDbnFCO1lBQU87U0FBRSxDQUFDMEssTUFBTSxDQUFDeWY7UUFFbkMsSUFBSSxDQUFDVyxRQUFRO1lBQUUsSUFBSSxDQUFDVSxRQUFRLENBQUMsZUFBZTtnQkFBQ3JCO2dCQUFRbnFCO2FBQU07UUFBRztRQUM5RCxPQUFPbXFCO0lBQ1gsT0FBTztRQUNILE9BQU87WUFBRWtCLE1BQU07UUFBaUM7SUFDcEQ7QUFDSjtBQUVBOzs7OztDQUtDLEdBQ0RuQixVQUFVNXVCLFNBQVMsQ0FBQzh3QixnQkFBZ0IsR0FBRyxTQUFTQyxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsUUFBUTtJQUMzRSxJQUFJLENBQUM3QyxNQUFNLENBQUM4QyxRQUFRLENBQUN6QyxTQUFTLENBQUMsU0FBUzZCLEtBQUssRUFBRWEsYUFBYTtRQUN4RCxJQUFJQyxrQkFBa0I7WUFBQ2Q7WUFBT2E7U0FBYztRQUM1QyxJQUFJRSxtQkFDQUwsY0FBYyxRQUNkQSxVQUFVOXZCLEtBQUssQ0FBQyxJQUFJLEVBQUVrd0IscUJBQXFCO1FBRS9DLElBQUlFLGlCQUFpQjtZQUFDaEI7WUFBT2E7U0FBYztRQUMzQyxJQUFJRSxrQkFBa0I7WUFDbEIsSUFBSUUsZ0JBQWdCTixTQUFTL3ZCLEtBQUssQ0FBQyxJQUFJLEVBQUVvd0I7WUFDekNoQixNQUFNckIsUUFBUSxDQUFDOEIsWUFBWVE7UUFDL0I7SUFDSjtJQUNBLElBQUksQ0FBQ3ZDLG1CQUFtQixDQUFDN3VCLElBQUksQ0FBQzR3QjtBQUNsQztBQUVBOzs7Q0FHQyxHQUNEL0MsTUFBTWh1QixTQUFTLENBQUN5dUIsU0FBUyxHQUFHLFNBQVUrQyxZQUFZO0lBQzlDLElBQUksT0FBT0EsaUJBQWlCLFlBQVk7UUFDcEMsT0FBUSxJQUFLLENBQUN0RCxXQUFXLENBQUMvdEIsSUFBSSxDQUFDcXhCLGdCQUFpQjtJQUNwRCxPQUFPO1FBQ0gsT0FBTztZQUFFekIsTUFBTyxjQUFlLElBQUksQ0FBQzlCLE9BQU8sR0FBSTtRQUFrQjtJQUNyRTtBQUNKO0FBRUE7OztDQUdDLEdBQ0RELE1BQU1odUIsU0FBUyxDQUFDeXhCLFdBQVcsR0FBRyxTQUFVQyxNQUFNO0lBQzFDLElBQUksQ0FBQ3hELFdBQVcsQ0FBQ3RrQixNQUFNLENBQUM4bkIsUUFBUTtBQUNwQztBQUVBOzs7Q0FHQyxHQUNEaEUsY0FBYzF0QixTQUFTLENBQUMyeEIsZUFBZSxHQUFHLFNBQVNqdEIsS0FBSztJQUNwRCxJQUFJLENBQUNBLEtBQUssR0FBR0E7SUFDYixJQUFJLENBQUNtcEIsT0FBTyxHQUFHLElBQUksQ0FBQ0YsT0FBTyxDQUFDanBCLE1BQU07SUFDbEMsSUFBSSxDQUFDb3BCLFNBQVMsR0FBRyxJQUFJLENBQUNILE9BQU8sQ0FBQzVkLEtBQUssQ0FBQyxHQUFHckw7SUFDdkMsSUFBSSxDQUFDcXBCLFNBQVMsR0FBRyxJQUFJLENBQUNKLE9BQU8sQ0FBQzVkLEtBQUssQ0FBQ3JMLFFBQVE7QUFDaEQ7QUFFQTs7Ozs7O0NBTUMsR0FDRGdwQixjQUFjMXRCLFNBQVMsQ0FBQ3NDLEdBQUcsR0FBRyxTQUFVa08sTUFBTTtJQUMxQyxPQUFRO1FBQ0osS0FBTUEsV0FBVztZQUNiLE9BQU8sSUFBSSxDQUFDcWQsT0FBTztRQUN2QixLQUFNcmQsU0FBUyxLQUFLblQsS0FBSzhlLEdBQUcsQ0FBQzNMLFdBQVcsSUFBSSxDQUFDc2QsU0FBUyxDQUFDdnpCLE1BQU07WUFDekQsT0FBTyxJQUFJLENBQUN1ekIsU0FBUyxDQUFDL2QsS0FBSyxDQUFDUyxPQUFPLENBQUMsRUFBRTtRQUMxQyxLQUFNQSxTQUFTLEtBQUtBLFVBQVUsSUFBSSxDQUFDdWQsU0FBUyxDQUFDeHpCLE1BQU07WUFDL0MsT0FBTyxJQUFJLENBQUN3ekIsU0FBUyxDQUFDdmQsU0FBUyxFQUFFO1FBQ3JDO1lBQ0ksT0FBTztJQUNmO0FBQ0o7QUFFQTs7O0NBR0MsR0FDRG9lLFVBQVU1dUIsU0FBUyxDQUFDNHhCLFdBQVcsR0FBRyxTQUFVbHBCLEtBQUs7SUFDN0MsSUFBSUEsaUJBQWlCeWtCLGNBQWM7UUFDL0IsT0FDSSxJQUFJLENBQUMwRSxjQUFjLENBQUNucEIsT0FDZittQixHQUFHLENBQUMsU0FBVWEsS0FBSztZQUFJLE9BQU9BLE1BQU1yRCxJQUFJO1FBQUUsR0FBRzZFLElBQUksQ0FBQztJQUUvRDtBQUNKO0FBRUE7O0NBRUMsR0FDRGxELFVBQVU1dUIsU0FBUyxDQUFDK3hCLE9BQU8sR0FBRztJQUMxQixPQUFPLElBQUksQ0FBQ2xELE1BQU0sQ0FBQ1ksR0FBRyxDQUFDLFNBQVVhLEtBQUs7UUFBSSxPQUFPQSxNQUFNckQsSUFBSTtJQUFFLEdBQUc2RSxJQUFJLENBQUM7QUFDekU7QUFFQTs7O0NBR0MsR0FDRGxELFVBQVU1dUIsU0FBUyxDQUFDZ3lCLFVBQVUsR0FBRyxTQUFVM0UsV0FBVztJQUNsRCxJQUFJTSxVQUFVLElBQUksQ0FBQ21CLGtCQUFrQixDQUFDekIsWUFBWTtJQUNsRCxPQUFPLENBQUMsQ0FBQ00sVUFBVUEsVUFBVTtBQUNqQztBQUVBOzs7O0NBSUMsR0FDRGlCLFVBQVU1dUIsU0FBUyxDQUFDaXlCLEVBQUUsR0FBRyxTQUFTQyxTQUFTLEVBQUVWLFlBQVk7SUFDckQsSUFBSWhELFFBQVEsSUFBSSxDQUFDSixNQUFNLENBQUM4RCxVQUFVO0lBQ2xDLElBQUksQ0FBQyxDQUFDMUQsT0FBTztRQUNULE9BQU9BLE1BQU1DLFNBQVMsQ0FBQytDO0lBQzNCLE9BQU87UUFDSCxPQUFPO0lBQ1g7QUFDSjtBQUVBOzs7O0NBSUMsR0FDRDVDLFVBQVU1dUIsU0FBUyxDQUFDa3dCLFFBQVEsR0FBRyxTQUFTZ0MsU0FBUyxFQUFFQyxJQUFJO0lBQ25ELElBQUk5RCxTQUFTLElBQUk7SUFFakIsSUFBSUcsUUFBUSxJQUFJLENBQUNKLE1BQU0sQ0FBQzhELFVBQVU7SUFDbEMsSUFBSTFELGlCQUFpQlIsT0FBTztRQUN4QlEsTUFBTU4sV0FBVyxDQUFDSyxPQUFPLENBQUMsU0FBVTZELFVBQVU7WUFDMUNBLFdBQVdseEIsS0FBSyxDQUFDbXRCLFFBQVE4RCxRQUFRLEVBQUU7UUFDdkM7SUFDSjtBQUNKO0FBRUE7Ozs7OztDQU1DLEdBQ0R2RCxVQUFVNXVCLFNBQVMsQ0FBQ3F5QixzQkFBc0IsR0FBRyxTQUFTaEYsV0FBVyxFQUFFaUYsaUJBQWlCLEVBQUVDLGVBQWU7SUFDakcsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDUCxVQUFVLENBQUMzRSxjQUFjO1FBQUUsT0FBTztZQUN6QzBDLE1BQ0MsbUJBQW1CMUMsY0FBYztRQUN0QztJQUFHO0lBQ0gsSUFBSSxPQUFPaUYsc0JBQXNCLFlBQVk7UUFBRSxPQUFPO1lBQ2xEdkMsTUFDQTtRQUNKO0lBQUc7SUFDSCxJQUFJLE9BQU93QyxvQkFBb0IsWUFBWTtRQUFFLE9BQU87WUFDaER4QyxNQUNBO1FBQ0o7SUFBRztJQUNILElBQUloQixrQkFBa0IsSUFBSXpCLGVBQ3RCRCxhQUFhaUYsbUJBQW1CQztJQUVwQyxJQUFJLENBQUN6RCxrQkFBa0IsQ0FBQ3pCLFlBQVksR0FBRzBCO0lBQ3ZDLElBQUksQ0FBQ0EsZUFBZSxDQUFDNXVCLElBQUksQ0FBQzR1QjtJQUMxQixPQUFPQTtBQUNYO0FBRUE7OztDQUdDLEdBQ0RILFVBQVU1dUIsU0FBUyxDQUFDNnhCLGNBQWMsR0FBRyxTQUFTbnBCLEtBQUs7SUFDL0MsSUFBSThwQixXQUFXOXBCLE1BQU0wa0IsVUFBVSxHQUFHMWtCLE1BQU1pSixTQUFTO0lBQ2pELE9BQU8sRUFBRSxDQUFDdkMsTUFBTSxDQUNaLElBQUksQ0FBQ3lmLE1BQU0sQ0FDTjllLEtBQUssQ0FBQ3JILE1BQU0wa0IsVUFBVSxFQUFFb0Y7QUFFckM7QUFFQTs7O0NBR0MsR0FDRDVELFVBQVU1dUIsU0FBUyxDQUFDeXlCLGdCQUFnQixHQUFHLFNBQVNwRixXQUFXO0lBQ3ZELElBQUlNLFVBQVUsSUFBSSxDQUFDcUUsVUFBVSxDQUFDM0U7SUFDOUIsSUFBSSxDQUFDLENBQUNNLFNBQVM7UUFDWCxPQUFPQSxRQUFRbGxCLE1BQU07SUFDekIsT0FBTztRQUNILE9BQU87WUFBRXNuQixNQUFPLHNCQUFzQjFDLGNBQWM7UUFBd0I7SUFDaEY7QUFDSjtBQUVBOztDQUVDLEdBQ0R1QixVQUFVNXVCLFNBQVMsQ0FBQzB5QixtQkFBbUIsR0FBRztJQUN0QyxJQUFJNUQscUJBQXFCLElBQUksQ0FBQ0Esa0JBQWtCO0lBQ2hELElBQUssSUFBSXpCLGVBQWV5QixtQkFBb0I7UUFDeEMsSUFBSUEsbUJBQW1CZSxjQUFjLENBQUN4QyxjQUFjO1lBQ2hELElBQUlNLFVBQVVtQixrQkFBa0IsQ0FBQ3pCLFlBQVk7WUFDN0NNLFFBQVFsbEIsTUFBTSxHQUFHLEVBQUU7UUFDdkI7SUFDSjtBQUNKO0FBRUE7O0NBRUMsR0FDRG1tQixVQUFVNXVCLFNBQVMsQ0FBQzJ1QixvQkFBb0IsR0FBRztJQUN2QyxJQUFJLENBQUMrRCxtQkFBbUI7SUFDeEIsSUFBSUMsUUFBUSxJQUFJLENBQUM5RCxNQUFNLENBQUNZLEdBQUcsQ0FBQyxTQUFVYSxLQUFLO1FBQUksT0FBT0EsTUFBTXJELElBQUk7SUFBRTtJQUNsRSxJQUFLLElBQUl4ekIsSUFBSSxHQUFHQSxJQUFJazVCLE1BQU1wNEIsTUFBTSxFQUFFZCxJQUFLO1FBQ25DLElBQUkwM0IsZ0JBQWdCLElBQUl6RCxjQUFjaUYsT0FBT2w1QjtRQUM3QyxJQUFJLENBQUNtNUIsZUFBZSxDQUFDekI7SUFDekI7SUFDQSxJQUFJLENBQUNqQixRQUFRLENBQUMsd0JBQXdCO1FBQUMsSUFBSSxDQUFDcEIsa0JBQWtCO0tBQUM7QUFDbkU7QUFFQTs7OztDQUlDLEdBQ0RGLFVBQVU1dUIsU0FBUyxDQUFDNnlCLFlBQVksR0FBRyxTQUFVcmlCLE1BQU0sRUFBRTZjLFdBQVc7SUFDNUQsSUFBSUQsYUFBYSxJQUFJLENBQUM0RSxVQUFVLENBQUMzRSxhQUFhSSxTQUFTLENBQUNMLFVBQVU7SUFDbEUsSUFBSTFrQixRQUFRLElBQUl5a0IsYUFBYUMsWUFBWTVjLFFBQVE2YztJQUNqRCxJQUFJNWtCLFNBQVMsSUFBSSxDQUFDdXBCLFVBQVUsQ0FBQzNFLGFBQWE1a0IsTUFBTTtJQUNoREMsTUFBTW9xQixPQUFPLEdBQUd6RixjQUFjLE1BQU81a0IsT0FBT2xPLE1BQU07SUFDbERrTyxPQUFPdEksSUFBSSxDQUFDdUk7SUFDWixJQUFJLENBQUNzcEIsVUFBVSxDQUFDM0UsYUFBYUksU0FBUyxHQUFHO0lBQ3pDLE9BQU8va0I7QUFDWDtBQUVBOzs7Q0FHQyxHQUNEa21CLFVBQVU1dUIsU0FBUyxDQUFDNHlCLGVBQWUsR0FBRyxTQUFTekIsYUFBYTtJQUN4RCxJQUFJOUMsU0FBUyxJQUFJO0lBRWpCLElBQUkzcEIsUUFBUXlzQixjQUFjenNCLEtBQUs7SUFDL0IsSUFBSSxDQUFDcXFCLGVBQWUsQ0FBQ1IsT0FBTyxDQUFDLFNBQVV3RSxjQUFjO1FBQ2pELElBQUkxRixjQUFjMEYsZUFBZTFGLFdBQVc7UUFDNUMsSUFBSUksWUFBWVksT0FBTzJELFVBQVUsQ0FBQzNFLGFBQWFJLFNBQVM7UUFDeEQsSUFBSSxDQUFDQSxhQUFhc0YsZUFBZXhGLFVBQVUsQ0FBQzRELGdCQUFnQjtZQUN4RDFELFlBQVksSUFBSU4sYUFBYXpvQixPQUFPLE1BQU0yb0I7WUFDMUNnQixPQUFPMkQsVUFBVSxDQUFDM0UsYUFBYUksU0FBUyxHQUFHQTtZQUMzQ1ksT0FBTzZCLFFBQVEsQ0FBQyxnQkFBZ0I7Z0JBQUM3QztnQkFBYTNvQjthQUFNO1FBQ3hEO1FBQ0EsSUFBSSxDQUFDLENBQUMrb0IsYUFBYXNGLGVBQWV2RixRQUFRLENBQUMyRCxnQkFBZ0I7WUFDdkQsSUFBSTNnQixTQUFTLFFBQVNpZCxVQUFVTCxVQUFVLEdBQUk7WUFDOUMsSUFBSTFrQixRQUFRMmxCLE9BQU93RSxZQUFZLENBQUNyaUIsUUFBUTZjO1lBQ3hDZ0IsT0FBTzZCLFFBQVEsQ0FBQyxjQUFjO2dCQUFDN0M7Z0JBQWEza0I7YUFBTTtRQUN0RDtJQUNKO0FBQ0o7QUFFQTs7O0NBR0MsR0FDRGttQixVQUFVNXVCLFNBQVMsQ0FBQ2d6QixRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUN6QyxJQUFJLENBQUNwRSxNQUFNLEdBQUcsRUFBRTtJQUNoQixJQUFJLENBQUM2RCxtQkFBbUI7SUFDeEIsSUFBSUMsUUFBUTF4QixNQUFNaXlCLElBQUksQ0FBQ0Q7SUFDdkIsSUFBSSxDQUFDL0MsUUFBUSxDQUFDO0lBQ2QsSUFBSyxJQUFJejJCLElBQUksR0FBR0EsSUFBSWs1QixNQUFNcDRCLE1BQU0sRUFBRWQsSUFBSztRQUNuQyxJQUFJd3pCLE9BQU8wRixLQUFLLENBQUNsNUIsRUFBRTtRQUNuQixJQUFJMDNCLGdCQUFnQixJQUFJekQsY0FBY2lGLE9BQU9sNUI7UUFDN0MsSUFBSSxDQUFDeTJCLFFBQVEsQ0FBQyxRQUFRO1lBQUNpQjtTQUFjO1FBQ3JDLElBQUksQ0FBQ3lCLGVBQWUsQ0FBQ3pCO1FBQ3JCLElBQUliLFFBQVEsSUFBSXRELE1BQU1DO1FBQ3RCLElBQUksQ0FBQzRCLE1BQU0sQ0FBQzF1QixJQUFJLENBQUNtd0I7UUFDakIsSUFBSSxDQUFDSixRQUFRLENBQUMsWUFBWTtZQUFDSTtZQUFPYTtTQUFjO0lBQ3BEO0lBQ0EsSUFBSSxDQUFDakIsUUFBUSxDQUFDLE9BQU87UUFBQyxJQUFJLENBQUNyQixNQUFNO0tBQUM7SUFDbEMsT0FBTyxJQUFJLENBQUNBLE1BQU07QUFDdEI7QUFFQSwrRUFBK0U7QUFDL0UsK0VBQStFO0FBQy9FLCtFQUErRTtBQUMvRSxpQ0FBaUM7QUFDakM7OztDQUdDLEdBQ0QsU0FBU3NFLGFBQWEzMEIsQ0FBQztJQUNuQixPQUFPLDRDQUE0QzJSLElBQUksQ0FBQzNSO0FBQzVEO0FBRUE7OztDQUdDLEdBQ0QsU0FBUzQwQixxQkFBcUJuRyxJQUFJO0lBQzlCLE9BQU8sbVVBQW1VOWMsSUFBSSxDQUFDOGM7QUFDblY7QUFFQTs7O0NBR0MsR0FDRCxTQUFTb0cscUJBQXFCcEcsSUFBSTtJQUM5QixPQUFPLHdIQUF3SDljLElBQUksQ0FBQzhjO0FBQ3hJO0FBRUE7OztDQUdDLEdBQ0QsU0FBU3FHLFlBQVk5MEIsQ0FBQztJQUNsQixPQUFPLFFBQVEyUixJQUFJLENBQUMzUjtBQUN4QjtBQUVBOzs7Q0FHQyxHQUNELFNBQVMrMEIsYUFBYS8wQixDQUFDO0lBQ25CLE9BQU8sS0FBSzJSLElBQUksQ0FBQzNSO0FBQ3JCO0FBRUE7O0NBRUMsR0FFRDs7O0NBR0MsR0FDRCxTQUFTZzFCLGFBQWF2eEIsSUFBSTtJQUN0QixJQUFJLENBQUNBLElBQUksR0FBR0E7SUFDWixJQUFJLENBQUN1SSxRQUFRLEdBQUcsQ0FBQztBQUNyQjtBQUVBOzs7Ozs7Q0FNQyxHQUVEOzs7Q0FHQyxHQUNELFNBQVNpcEIsbUJBQW1CQyxNQUFNO0lBQzlCLElBQUksQ0FBQ0MsRUFBRSxHQUFHRCxPQUFPQyxFQUFFO0lBQ25CLElBQUksQ0FBQzFyQixHQUFHLEdBQUd5ckIsT0FBT3pyQixHQUFHO0lBQ3JCLElBQUksQ0FBQ3VILFlBQVksR0FBR2trQixPQUFPbGtCLFlBQVk7QUFDM0M7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU29rQixlQUFldndCLFVBQVUsRUFBRW1KLFFBQVE7SUFDeEMsSUFBSSxDQUFDbkosWUFBWTtRQUFFLE9BQU8sQ0FBQztJQUFHO0lBQzlCLE9BQVFtSixTQUFTbEIsTUFBTTtRQUNuQixLQUFLO1lBQ0QsT0FBT2tCLFNBQVNwSyxNQUFNLENBQUNXLE9BQU8sQ0FBQ007UUFFbkMsS0FBSztZQUNELElBQUlvRixTQUFTK0QsU0FBUy9ELE1BQU07WUFDNUIsSUFBSyxJQUFJaFAsSUFBSSxHQUFHQSxJQUFJZ1AsT0FBT2xPLE1BQU0sRUFBRWQsSUFBSztnQkFDcEMsSUFBSWlQLFFBQVFELE1BQU0sQ0FBQ2hQLEVBQUU7Z0JBQ3JCLElBQUk0SixjQUFjcUYsTUFBTW5QLEtBQUssSUFBSThKLGNBQWNxRixNQUFNekosR0FBRyxFQUFFO29CQUN0RCxJQUFJdVIsU0FBU25OLGFBQWFxRixNQUFNblAsS0FBSztvQkFDckMsT0FBT21QLE1BQU1oRSxLQUFLLEdBQUc4TDtnQkFDekI7WUFDSjtZQUNBO1FBQ0o7WUFDSSxPQUFPLENBQUMsR0FBRyxZQUFZO0lBQy9CO0lBQ0EsT0FBTyxDQUFDO0FBQ1o7QUFFQTs7O0NBR0MsR0FDRCxTQUFTcWpCLDBCQUEwQnh3QixVQUFVLEVBQUVpSixRQUFRO0lBQ25ELElBQUl3bkIsa0JBQWtCRixlQUFldndCLFlBQVlpSixTQUFTRSxRQUFRO0lBQ2xFLElBQUlzbkIsb0JBQW9CLENBQUMsR0FBRztRQUFFLE9BQU87SUFBTTtJQUMzQyxPQUFPendCLGFBQWFpSixTQUFTK0IsWUFBWTtBQUM3QztBQUVBOzs7Q0FHQyxHQUNELFNBQVMwbEIsMEJBQTBCMXdCLFVBQVUsRUFBRWlKLFFBQVE7SUFDbkQsSUFBSXduQixrQkFBa0JGLGVBQWV2d0IsWUFBWWlKLFNBQVNFLFFBQVE7SUFDbEUsSUFBSXNuQixvQkFBb0IsQ0FBQyxHQUFHO1FBQUUsT0FBTztJQUFNO0lBQzNDLE9BQU94bkIsU0FBU2tDLFVBQVUsQ0FBQ3NsQixnQkFBZ0I7QUFDL0M7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU0UsbUJBQW1CQyxZQUFZLEVBQUU5QyxhQUFhO0lBQ25ELElBQUkrQyxhQUFhLEVBQUU7SUFDbkIsSUFBSyxJQUFJejZCLElBQUksR0FBR0EsSUFBSXc2QixhQUFhMTVCLE1BQU0sRUFBRWQsSUFBSztRQUMxQyxJQUFJK1MsV0FBV3luQixZQUFZLENBQUN4NkIsRUFBRTtRQUM5QixJQUFJNEosYUFBYTh0QixjQUFjdEQsT0FBTztRQUN0Q3hxQixhQUFhcEMsTUFBTWdHLE9BQU8sQ0FBQzVELGNBQWNBLFVBQVUsQ0FBQyxFQUFFLEdBQUdBO1FBQ3pELElBQUk4d0IsY0FBY1AsZUFBZXZ3QixZQUFZbUo7UUFDN0MsSUFBSTJuQixnQkFBZ0IsQ0FBQyxHQUFHO1lBQ3BCRCxXQUFXL3pCLElBQUksQ0FBQ2cwQjtRQUNwQjtJQUNKO0lBQ0EsSUFBSUQsV0FBVzM1QixNQUFNLEtBQUswNUIsYUFBYTE1QixNQUFNLEVBQUU7UUFBRSxPQUFPLENBQUM7SUFBRztJQUM1RCxPQUFPMjVCO0FBQ1g7QUFFQTs7O0NBR0MsR0FDRCxTQUFTRSw0QkFBNEJqRCxhQUFhLEVBQUU3a0IsUUFBUTtJQUN4RCxJQUFJK25CLGVBQ0EvbkIsU0FBU2dvQixhQUFhLENBQUMvNUIsTUFBTSxHQUM3QitSLFNBQVNpb0IsaUJBQWlCLENBQUNoNkIsTUFBTSxHQUNqQytSLFNBQVNrb0IsaUJBQWlCLENBQUNqNkIsTUFBTTtJQUVyQyxJQUFJNDJCLGNBQWN4RCxPQUFPLENBQUNwekIsTUFBTSxHQUFHODVCLGNBQWM7UUFBRSxPQUFPLEVBQUU7SUFBRTtJQUM5RCxrQkFBa0I7SUFDbEIsSUFBSUksZUFBZVQsbUJBQ2YxbkIsU0FBU2dvQixhQUFhLEVBQUVuRDtJQUU1QixJQUFJc0QsaUJBQWlCLENBQUMsR0FBRztRQUFFLE9BQU8sRUFBRTtJQUFFO0lBQ3RDLHNCQUFzQjtJQUN0QixJQUFJQyxrQkFBa0Jwb0IsU0FBU2dvQixhQUFhLENBQUMvNUIsTUFBTSxHQUFHO0lBQ3RELElBQUk0MkIsY0FBY3BELFNBQVMsQ0FBQ3h6QixNQUFNLEdBQUcrUixTQUFTaW9CLGlCQUFpQixDQUFDaDZCLE1BQU0sRUFBRTtRQUFFLE9BQU8sRUFBRTtJQUFFO0lBQ3JGLElBQUlvNkIsbUJBQW1CeEQsY0FBY3BELFNBQVMsQ0FBQ2hlLEtBQUssQ0FBQzJrQjtJQUNyRCxNQUFPQyxpQkFBaUJwNkIsTUFBTSxJQUFJODRCLHFCQUFxQnNCLGdCQUFnQixDQUFDLEVBQUUsQ0FBQzFILElBQUksRUFBRztRQUM5RTBILGlCQUFpQkMsS0FBSztJQUMxQjtJQUNBLElBQUlDLGtCQUFrQixJQUFJbkgsY0FBY2lILGtCQUFrQjtJQUMxRCxJQUFJRyxtQkFBbUJkLG1CQUNuQjFuQixTQUFTaW9CLGlCQUFpQixFQUFFTTtJQUVoQyxzQkFBc0I7SUFDdEIsSUFBSUUsbUJBQW1CLEVBQUUsQ0FBQzNsQixNQUFNLENBQUMraEIsY0FBY3JELFNBQVM7SUFDeERpSCxpQkFBaUJDLE9BQU87SUFDeEIsTUFBT0QsaUJBQWlCeDZCLE1BQU0sSUFBSTg0QixxQkFBcUIwQixnQkFBZ0IsQ0FBQyxFQUFFLENBQUM5SCxJQUFJLEVBQUc7UUFDOUU4SCxpQkFBaUJILEtBQUs7SUFDMUI7SUFDQSxJQUFJRyxpQkFBaUJ4NkIsTUFBTSxHQUFHK1IsU0FBU2tvQixpQkFBaUIsQ0FBQ2o2QixNQUFNLEVBQUU7UUFBRSxPQUFPLEVBQUU7SUFBRTtJQUM5RSxJQUFJMDZCLGtCQUFrQixJQUFJdkgsY0FBY3FILGtCQUFrQjtJQUMxRCxJQUFJRyxtQkFBbUJsQixtQkFDbkIxbkIsU0FBU2tvQixpQkFBaUIsRUFBRVM7SUFFaEMsSUFBSUUsb0JBQ0FWLGFBQWFsNkIsTUFBTSxLQUFLK1IsU0FBU2dvQixhQUFhLENBQUMvNUIsTUFBTSxJQUNyRHU2QixpQkFBaUJ2NkIsTUFBTSxLQUFLK1IsU0FBU2lvQixpQkFBaUIsQ0FBQ2g2QixNQUFNLElBQzdEMjZCLGlCQUFpQjM2QixNQUFNLEtBQUsrUixTQUFTa29CLGlCQUFpQixDQUFDajZCLE1BQU07SUFFakUsSUFBSTBULGdCQUFnQixFQUFFO0lBQ3RCLElBQUlrbkIsbUJBQW1CO1FBQ25CLElBQUssSUFBSTE3QixJQUFJLEdBQUdBLElBQUk2UyxTQUFTOG9CLGFBQWEsQ0FBQzc2QixNQUFNLEVBQUVkLElBQUs7WUFDcEQsSUFBSTQ3QixlQUFlL29CLFNBQVM4b0IsYUFBYSxDQUFDMzdCLEVBQUU7WUFDNUMsSUFBSTY3QixrQkFBa0JELGFBQWFDLGVBQWU7WUFDbEQsSUFBSXhxQixjQUFjLElBQUksQ0FBQ3lxQixnQkFBZ0IsQ0FBQ0Q7WUFDeEMsSUFBSyxJQUFJaDdCLElBQUksR0FBR0EsSUFBSXdRLFlBQVlJLFNBQVMsQ0FBQzNRLE1BQU0sRUFBRUQsSUFBSztnQkFDbkQsSUFBSWs3QixhQUFhMXFCLFlBQVlJLFNBQVMsQ0FBQzVRLEVBQUU7Z0JBQ3pDLElBQUltN0IsU0FBUyxJQUFJLENBQUNDLGVBQWUsQ0FBQzVxQixhQUFhMHFCO2dCQUMvQyxJQUFJRyxtQkFBbUIsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQzlxQixhQUFhMHFCO2dCQUM3RCxJQUFJRyxxQkFBcUIsTUFBTTtvQkFDM0IsSUFBSyxJQUFJNzVCLElBQUksR0FBR0EsSUFBSTI0QixhQUFhbDZCLE1BQU0sRUFBRXVCLElBQUs7d0JBQzFDLElBQUl1SCxhQUFhOHRCLGNBQWM3dUIsR0FBRyxDQUFDeEc7d0JBQ25DLElBQUkwVCxlQUFlaW1CLE9BQU9weUI7d0JBQzFCLElBQUltTSxjQUFjOzRCQUFFdkIsY0FBYzlOLElBQUksQ0FBQ3FQO3dCQUFlO29CQUMxRDtnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU92QjtBQUNYO0FBRUE7OztDQUdDLEdBQ0QsU0FBUzRuQiw0QkFBNEIxRSxhQUFhLEVBQUU3a0IsUUFBUTtJQUN4RCxxQkFBcUI7SUFDckIsSUFBSWpKLGFBQWE4dEIsY0FBY3RELE9BQU87SUFDdEMsSUFBSWlJLGNBQWNsQyxlQUFldndCLFlBQVlpSixTQUFTRSxRQUFRO0lBQzlELElBQUlzcEIsZ0JBQWdCLENBQUMsR0FBRztRQUFFLE9BQU87SUFBTTtJQUN2QyxvQkFBb0I7SUFDcEIsNkRBQTZEO0lBQzdELElBQUlqbUI7SUFDSixJQUFJSSxjQUFjM0QsU0FBUzJDLFlBQVksQ0FBQzZtQixZQUFZO0lBQ3BELElBQUssSUFBSXg3QixJQUFJLEdBQUdBLElBQUkyVixZQUFZMVYsTUFBTSxFQUFFRCxJQUFLO1FBQ3pDdVYsV0FBV0ksV0FBVyxDQUFDM1YsRUFBRTtRQUN6QixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSXFWLFNBQVNSLFVBQVUsQ0FBQzlVLE1BQU0sRUFBRUMsSUFBSztZQUNqRCxJQUFJdTdCLGdCQUFnQjVFLGNBQWNwRCxTQUFTLENBQUN2ekIsRUFBRTtZQUM5QyxJQUFJcWYsWUFBWWhLLFNBQVNSLFVBQVUsQ0FBQzdVLEVBQUU7WUFDdEMsSUFBSXU3QixrQkFBa0JsYyxXQUFXO2dCQUFFO1lBQU87WUFDMUMsSUFBSXJmLE1BQU1xVixTQUFTUixVQUFVLENBQUM5VSxNQUFNLEdBQUcsR0FBRztnQkFBRSxPQUFPc1Y7WUFBVTtRQUNqRTtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNtbUIsaUNBQWlDM3lCLFVBQVUsRUFBRWlKLFFBQVE7SUFDMUQsSUFBSXduQixrQkFBa0JGLGVBQWV2d0IsWUFBWWlKLFNBQVNFLFFBQVE7SUFDbEUsSUFBSXNuQixvQkFBb0IsQ0FBQyxHQUFHO1FBQUUsT0FBTztJQUFNO0lBQzNDLE9BQU94bkIsU0FBU3FDLFNBQVMsQ0FBQ21sQixnQkFBZ0I7QUFDOUM7QUFFQTs7Q0FFQyxHQUNETixhQUFheHpCLFNBQVMsQ0FBQ2kyQiwrQkFBK0IsR0FBRztJQUNyRCxJQUFJOXNCLFVBQVUsSUFBSSxDQUFDbEgsSUFBSSxDQUFDZ0IsTUFBTSxDQUFDaXpCLElBQUksQ0FBQy9zQixPQUFPO0lBQzNDLElBQUssSUFBSTdPLElBQUksR0FBR0EsSUFBSTZPLFFBQVE1TyxNQUFNLEVBQUVELElBQUs7UUFDckMsSUFBSStPLFNBQVNGLE9BQU8sQ0FBQzdPLEVBQUU7UUFDdkIsSUFBSStPLE9BQU9wQixHQUFHLEtBQUssUUFBUTtZQUFFLE9BQ3pCb0IsT0FBT0EsTUFBTSxDQUFDRSxjQUFjLENBQUNHLGNBQWM7UUFDNUM7SUFDUDtJQUNBLE9BQU8sRUFBRTtBQUNiO0FBRUE7OztDQUdDLEdBQ0Q4cEIsYUFBYXh6QixTQUFTLENBQUNtMkIsd0JBQXdCLEdBQUcsU0FBU0MsU0FBUztJQUNoRSxJQUFJbnpCLFNBQVMsSUFBSSxDQUFDaEIsSUFBSSxDQUFDZ0IsTUFBTTtJQUM3QixJQUFJLENBQUNBLE9BQU9pekIsSUFBSSxFQUFFO1FBQUUsT0FBTyxFQUFFO0lBQUU7SUFDL0IsSUFBSSxDQUFDRSxXQUFXO1FBQUUsT0FBTyxJQUFJLENBQUNILCtCQUErQjtJQUFJO0lBQ2pFLElBQUk5c0IsVUFBVSxJQUFJLENBQUNsSCxJQUFJLENBQUNnQixNQUFNLENBQUNpekIsSUFBSSxDQUFDL3NCLE9BQU87SUFDM0MsSUFBSyxJQUFJMVAsSUFBSSxHQUFHQSxJQUFJMFAsUUFBUTVPLE1BQU0sRUFBRWQsSUFBSztRQUNyQyxJQUFJNFAsU0FBU0YsT0FBTyxDQUFDMVAsRUFBRTtRQUN2QixJQUFJNFAsT0FBT3BCLEdBQUcsS0FBS211QixhQUFhL3NCLE9BQU9BLE1BQU0sQ0FBQ0UsY0FBYyxFQUFFO1lBQzFELE9BQU9GLE9BQU9BLE1BQU0sQ0FBQ0UsY0FBYyxDQUFDRyxjQUFjO1FBQ3RELE9BQU87WUFDSCxJQUFJQyxpQkFBaUJOLE9BQU9NLGNBQWM7WUFDMUMsSUFBSSxDQUFDLENBQUNBLGdCQUFnQjtnQkFDbEIsSUFBSyxJQUFJaFEsSUFBSSxHQUFHQSxJQUFJZ1EsZUFBZXBQLE1BQU0sRUFBRVosSUFBSztvQkFDNUMsSUFBSXNRLGdCQUFnQk4sY0FBYyxDQUFDaFEsRUFBRTtvQkFDckMsSUFBSXNRLGNBQWNoQyxHQUFHLEtBQUttdUIsV0FBVzt3QkFDakMsSUFBSXBzQixVQUFVQyxjQUFjRCxPQUFPO3dCQUNuQyxPQUFPQSxRQUFRTixjQUFjO29CQUNqQztnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU8sSUFBSSxDQUFDdXNCLCtCQUErQjtBQUMvQztBQUVBOzs7O0NBSUMsR0FDRHpDLGFBQWF4ekIsU0FBUyxDQUFDcTJCLGlCQUFpQixHQUFHLFNBQVU3ckIsUUFBUSxFQUFFNHJCLFNBQVM7SUFDcEUsSUFBSUUsT0FBTyxDQUFDO0lBQ1osSUFBSyxJQUFJNzhCLElBQUksR0FBR0EsSUFBSStRLFNBQVNqUSxNQUFNLEVBQUVkLElBQUs7UUFDdEMsSUFBSXdPLE1BQU11QyxRQUFRLENBQUMvUSxFQUFFLENBQUN3TyxHQUFHO1FBQ3pCLElBQUlrQyxVQUFVSyxRQUFRLENBQUMvUSxFQUFFLENBQUMwUSxPQUFPO1FBQ2pDbXNCLElBQUksQ0FBQ3J1QixJQUFJLEdBQUdrQztJQUNoQjtJQUNBLElBQUksQ0FBQ0ssUUFBUSxDQUFDNHJCLFVBQVUsQ0FBQ0UsSUFBSSxHQUFHQTtBQUNwQztBQUVBOzs7Q0FHQyxHQUNEOUMsYUFBYXh6QixTQUFTLENBQUN1MkIsaUJBQWlCLEdBQUcsU0FBVUgsU0FBUztJQUMxRCxJQUFJNXJCLFdBQVcsSUFBSSxDQUFDQSxRQUFRLENBQUM0ckIsVUFBVTtJQUN2QyxJQUFJLElBQUksQ0FBQzVyQixRQUFRLENBQUNxbEIsY0FBYyxDQUFDdUcsWUFBWTtRQUFFLE9BQU81ckI7SUFBVTtJQUNoRSxJQUFJZ3NCLGtCQUFrQixJQUFJLENBQUNMLHdCQUF3QixDQUFDQztJQUNwRCxJQUFJLENBQUNJLGlCQUFpQjtRQUFFLE9BQU87SUFBTTtJQUNyQyxJQUFJTixPQUFPLElBQUksQ0FBQ2owQixJQUFJLENBQUNnQixNQUFNLENBQUNpekIsSUFBSTtJQUNoQzFyQixXQUFXZ3NCLGdCQUFnQi9HLEdBQUcsQ0FBQyxTQUFVL3FCLEtBQUs7UUFBSSxPQUFPd3hCLEtBQUsxckIsUUFBUSxDQUFDOUYsTUFBTTtJQUFFO0lBQy9FLElBQUksQ0FBQzhGLFFBQVEsQ0FBQzRyQixVQUFVLEdBQUc1ckI7SUFDM0IsSUFBSSxDQUFDNnJCLGlCQUFpQixDQUFDN3JCLFVBQVU0ckI7SUFDakMsT0FBTzVyQjtBQUNYO0FBRUE7Ozs7Q0FJQyxHQUNEZ3BCLGFBQWF4ekIsU0FBUyxDQUFDNDFCLG1CQUFtQixHQUFHLFNBQVM5cUIsV0FBVyxFQUFFd0IsUUFBUTtJQUN2RSxJQUFJMUIsYUFBYUUsWUFBWUYsVUFBVSxDQUFDMkwsUUFBUTtJQUNoRCxJQUFJekksY0FBY3hCLFNBQVN3QixXQUFXLENBQUN5SSxRQUFRO0lBQy9DLE9BQU8zTCxhQUFha0Q7QUFDeEI7QUFFQTs7OztDQUlDLEdBQ0QwbEIsYUFBYXh6QixTQUFTLENBQUMwMUIsZUFBZSxHQUFHLFNBQVM1cUIsV0FBVyxFQUFFd0IsUUFBUTtJQUNuRSxJQUFJK2hCLFNBQVMsSUFBSTtJQUVqQixJQUFJc0gsbUJBQW1CLElBQUksQ0FBQ0MsbUJBQW1CLENBQUM5cUIsYUFBYXdCO0lBQzdELE9BQVFxcEI7UUFDSixLQUFLO1lBQ0QsT0FBTyxTQUFVdHlCLFVBQVU7Z0JBQUksT0FBT3d3QiwwQkFBMEIzeUIsS0FBSyxDQUNqRW10QixRQUFRO29CQUFDaHJCO29CQUFZaUo7aUJBQVM7WUFDL0I7UUFDUCxLQUFLO1lBQ0QsT0FBTyxTQUFVakosVUFBVTtnQkFBSSxPQUFPMHdCLDBCQUEwQjd5QixLQUFLLENBQ2pFbXRCLFFBQVE7b0JBQUNockI7b0JBQVlpSjtpQkFBUztZQUMvQjtRQUNQLEtBQUs7WUFDRCxPQUFPLFNBQVU2a0IsYUFBYTtnQkFBSSxPQUFPaUQsNEJBQTRCbHpCLEtBQUssQ0FDdEVtdEIsUUFBUTtvQkFBQzhDO29CQUFlN2tCO2lCQUFTO1lBQ2xDO1FBQ1AsS0FBSztZQUNELE9BQU8sU0FBVTZrQixhQUFhO2dCQUFJLE9BQU8wRSw0QkFBNEIzMEIsS0FBSyxDQUN0RW10QixRQUFRO29CQUFDOEM7b0JBQWU3a0I7aUJBQVM7WUFDbEM7UUFDUCxLQUFLO1lBQ0QsT0FBTyxTQUFVakosVUFBVTtnQkFBSSxPQUFPMnlCLGlDQUFpQzkwQixLQUFLLENBQ3hFbXRCLFFBQVE7b0JBQUNockI7b0JBQVlpSjtpQkFBUztZQUMvQjtRQUNQO1lBQ0ksTUFBTSxJQUFJL1AsTUFDTixpQkFBa0J1TyxZQUFZRixVQUFVLEdBQUksUUFDNUMsa0JBQW1CMEIsU0FBU3dCLFdBQVcsR0FBSSxNQUMzQztJQUVaO0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBRUQ7Ozs7OztDQU1DLEdBRUQ7OztDQUdDLEdBQ0QwbEIsYUFBYXh6QixTQUFTLENBQUN5MkIsYUFBYSxHQUFHLFNBQVVDLEtBQUs7SUFDbEQsSUFBSXZGLGdCQUFnQnVGLE1BQU12RixhQUFhO0lBQ3ZDLElBQUl2RCxlQUFldUQsY0FBY3pzQixLQUFLO0lBQ3RDLElBQUl5RixVQUFVLElBQUksQ0FBQytGLFVBQVUsQ0FBQztRQUMxQmpJLEtBQUt5dUIsTUFBTXp1QixHQUFHO1FBQUVvQixRQUFRcXRCLE1BQU1ydEIsTUFBTTtJQUN4QztJQUNBLElBQUksQ0FBQ2MsU0FBUztRQUFFLE9BQU8sSUFBSTVOLE1BQ3ZCLFdBQVksSUFBSSxDQUFDMEYsSUFBSSxDQUFDMDBCLEtBQUssQ0FBQ0MsUUFBUSxDQUFDQyxFQUFFLEdBQUksT0FDM0MsOEJBQStCSCxNQUFNenVCLEdBQUcsR0FBSSxPQUM1QyxpQkFBa0J5dUIsTUFBTXJ0QixNQUFNLEdBQUk7SUFDbkM7SUFDSCxJQUFJMkIsVUFBVSxJQUFJLENBQUM4ckIsaUJBQWlCLENBQUMzc0I7SUFDckMsSUFBSThELGdCQUFnQixFQUFFLENBQUNtQixNQUFNLENBQUMraEIsY0FBY3hELE9BQU87SUFDbkQsSUFBSyxJQUFJbnpCLElBQUksR0FBR0EsSUFBSXdRLFFBQVF6USxNQUFNLEVBQUVDLElBQUs7UUFDckMsSUFBSXNRLGNBQWNFLE9BQU8sQ0FBQ3hRLEVBQUU7UUFDNUIsSUFBSTBRLFlBQVksSUFBSSxDQUFDNnJCLGtCQUFrQixDQUFDanNCO1FBQ3hDLElBQUssSUFBSXhRLElBQUksR0FBR0EsSUFBSTRRLFVBQVUzUSxNQUFNLEVBQUVELElBQUs7WUFDdkMsSUFBSWdTLFdBQVdwQixTQUFTLENBQUM1USxFQUFFO1lBQzNCLElBQUkwOEIsWUFBWSxJQUFJLENBQUNwQixtQkFBbUIsQ0FBQzlxQixhQUFhd0I7WUFDdEQsSUFBSW1wQixTQUFTLElBQUksQ0FBQ0MsZUFBZSxDQUFDNXFCLGFBQWF3QjtZQUMvQyxJQUFJa0QsZUFBZ0IsS0FBSztZQUN6QixPQUFRd25CO2dCQUNKLEtBQUs7b0JBQ0R4bkIsZUFBZWltQixPQUFPdEUsY0FBY3RELE9BQU87b0JBQzNDLElBQUlyZSxjQUFjO3dCQUNkdkIsY0FBY3JFLE1BQU0sQ0FBQ2drQixjQUFjLEdBQUcsSUFBSTZGLG1CQUFtQjs0QkFDekRFLElBQUk7NEJBQUkxckIsS0FBS3l1QixNQUFNenVCLEdBQUc7NEJBQUV1SCxjQUFjQTt3QkFDMUM7b0JBQ0o7b0JBQ0E7Z0JBQ0osS0FBSztvQkFDREEsZUFBZWltQixPQUFPdEUsY0FBY3RELE9BQU87b0JBQzNDLElBQUlyZSxjQUFjO3dCQUNkdkIsY0FBY3JFLE1BQU0sQ0FBQ2drQixjQUFjLEdBQUcsSUFBSTZGLG1CQUFtQjs0QkFDekRFLElBQUk7NEJBQUkxckIsS0FBS3l1QixNQUFNenVCLEdBQUc7NEJBQUV1SCxjQUFjQTt3QkFDMUM7b0JBQ0o7b0JBQ0E7Z0JBQ0osS0FBSztvQkFDREEsZUFBZWltQixPQUFPdEU7b0JBQ3RCLElBQUlsd0IsTUFBTWdHLE9BQU8sQ0FBQ3VJLGlCQUFpQkEsYUFBYWpWLE1BQU0sRUFBRTt3QkFDcEQwVCxjQUFjckUsTUFBTSxDQUFDZ2tCLGNBQWMsR0FBRyxJQUFJNkYsbUJBQW1COzRCQUN6REUsSUFBSTs0QkFBSTFyQixLQUFLeXVCLE1BQU16dUIsR0FBRzs0QkFBRXVILGNBQWNBO3dCQUMxQztvQkFDSjtvQkFDQTtnQkFDSixLQUFLO29CQUNEQSxlQUFlaW1CLE9BQU90RTtvQkFDdEIsSUFBSTNoQixjQUFjO3dCQUNkdkIsY0FBY3JFLE1BQU0sQ0FBQ2drQixjQUFjLEdBQUcsSUFBSTZGLG1CQUFtQjs0QkFDekRFLElBQUk7NEJBQUkxckIsS0FBS3l1QixNQUFNenVCLEdBQUc7NEJBQUV1SCxjQUFjQTt3QkFDMUM7b0JBQ0o7b0JBQ0E7Z0JBQ0osS0FBSztvQkFDREEsZUFBZWltQixPQUFPdEUsY0FBY3RELE9BQU87b0JBQzNDLElBQUlyZSxjQUFjO3dCQUNkdkIsY0FBY3JFLE1BQU0sQ0FBQ2drQixjQUFjLEdBQUcsSUFBSTZGLG1CQUFtQjs0QkFDekRFLElBQUk7NEJBQUkxckIsS0FBS3l1QixNQUFNenVCLEdBQUc7NEJBQUV1SCxjQUFjQTt3QkFDMUM7b0JBQ0o7b0JBQ0E7WUFDUjtZQUNBMmhCLGdCQUFnQixJQUFJekQsY0FBY3pmLGVBQWUyZjtZQUNqRCxJQUFJM3NCLE1BQU1nRyxPQUFPLENBQUN1SSxpQkFBaUIsQ0FBQ0EsYUFBYWpWLE1BQU0sRUFBRTtnQkFBRTtZQUFVO1lBQ3JFaVYsZUFBZTtRQUNuQjtJQUNKO0lBQ0EsT0FBT3ZCLGNBQWMxVCxNQUFNLEdBQUcwVCxnQkFBZ0I7QUFDbEQ7QUFFQTs7O0NBR0MsR0FDRHVsQixhQUFheHpCLFNBQVMsQ0FBQ2kzQixRQUFRLEdBQUcsU0FBVVAsS0FBSztJQUM3QyxJQUFJLENBQUNBLE1BQU1ydEIsTUFBTSxFQUFFO1FBQUUsT0FBTztJQUFPO0lBQ25DLElBQUksQ0FBQ2t0QixpQkFBaUIsQ0FBQ0csTUFBTXJ0QixNQUFNO0lBQ25DLElBQUk2dEIsa0JBQWtCLElBQUksQ0FBQzFzQixRQUFRLENBQUNxbEIsY0FBYyxDQUFDNkcsTUFBTXJ0QixNQUFNO0lBQy9ELElBQUksQ0FBQ3F0QixNQUFNenVCLEdBQUcsRUFBRTtRQUFFLE9BQU9pdkI7SUFBaUI7SUFDMUMsSUFBSUMsbUJBQ0EsSUFBSSxDQUFDM3NCLFFBQVEsQ0FBQ2tzQixNQUFNcnRCLE1BQU0sQ0FBQyxDQUFDK3RCLElBQUksQ0FBQyxTQUFVanRCLE9BQU87UUFBSSxPQUFPQSxRQUFRbEMsR0FBRyxLQUFLeXVCLE1BQU16dUIsR0FBRztJQUFFO0lBRTVGLE9BQU9pdkIsbUJBQW1CQztBQUM5QjtBQUVBOzs7Q0FHQyxHQUNEM0QsYUFBYXh6QixTQUFTLENBQUMrMkIsa0JBQWtCLEdBQUcsU0FBVWpzQixXQUFXO0lBQzdELE9BQU9BLFlBQVlJLFNBQVMsSUFBSTtBQUNwQztBQUVBOzs7Q0FHQyxHQUNEc29CLGFBQWF4ekIsU0FBUyxDQUFDdTFCLGdCQUFnQixHQUFHLFNBQVU3d0IsS0FBSztJQUNyRCxJQUFJc0csVUFBVSxJQUFJLENBQUMvSSxJQUFJLENBQUNnQixNQUFNLENBQUNpekIsSUFBSSxDQUFDbHJCLE9BQU87SUFDM0MsT0FBT0EsT0FBTyxDQUFDdEcsTUFBTSxJQUFJO0FBQzdCO0FBRUE7OztDQUdDLEdBQ0Q4dUIsYUFBYXh6QixTQUFTLENBQUM4MkIsaUJBQWlCLEdBQUcsU0FBVTNzQixPQUFPO0lBQ3hELGdCQUFnQjtJQUNoQixPQUFPQSxRQUFRTyxpQkFBaUIsQ0FBQytrQixHQUFHLENBQUMsSUFBSSxDQUFDOEYsZ0JBQWdCLENBQUN4SSxJQUFJLENBQUMsSUFBSTtBQUN4RTtBQUVBOzs7Q0FHQyxHQUNEeUcsYUFBYXh6QixTQUFTLENBQUNrUSxVQUFVLEdBQUcsU0FBU0EsV0FBV3dtQixLQUFLO0lBQ3pELElBQUksQ0FBQyxJQUFJLENBQUN6MEIsSUFBSSxFQUFFO1FBQUUsT0FBTztZQUFFOHRCLE1BQU07UUFBbUI7SUFBRztJQUN2RCxJQUFJLENBQUMsSUFBSSxDQUFDdmxCLFFBQVEsQ0FBQ3FsQixjQUFjLENBQUM2RyxNQUFNcnRCLE1BQU0sR0FBRztRQUM3QyxJQUFJLENBQUNrdEIsaUJBQWlCLENBQUNHLE1BQU1ydEIsTUFBTTtJQUN2QztJQUNBLElBQUlndUIsaUJBQWlCLElBQUksQ0FBQzdzQixRQUFRLENBQUNrc0IsTUFBTXJ0QixNQUFNLENBQUM7SUFDaEQsSUFBSSxDQUFDZ3VCLGdCQUFnQjtRQUFFLE9BQ25CO1lBQUV0SCxNQUFPLDJCQUE0QjJHLE1BQU1ydEIsTUFBTTtRQUFFO0lBQ3BEO0lBQ0gsSUFBSSxDQUFDZ3VCLGVBQWVmLElBQUksQ0FBQ0ksTUFBTXp1QixHQUFHLENBQUMsRUFBRTtRQUFFLE9BQU87SUFBTTtJQUNwRCxPQUFPLElBQUksQ0FBQ3VDLFFBQVEsQ0FBQ2tzQixNQUFNcnRCLE1BQU0sQ0FBQyxDQUFDaXRCLElBQUksQ0FBQ0ksTUFBTXp1QixHQUFHLENBQUM7QUFDdEQ7QUFFQTs7Q0FFQyxHQUVELFNBQVNxdkIscUJBQXFCbkcsYUFBYTtJQUN2QyxJQUFJbEUsT0FBT2tFLGNBQWN0RCxPQUFPO0lBQ2hDLElBQUkwSixXQUFXcEcsY0FBYzd1QixHQUFHLENBQUMsQ0FBQztJQUNsQyxPQUVJLHNCQURzQjtJQUNyQmkxQixhQUFhLFFBQVFwRSxhQUFhbEcsU0FDbkMsZ0RBQWdEO0lBQy9DLENBQUNrRyxhQUFhb0UsYUFBYXBFLGFBQWFsRztBQUVqRDtBQUVBLFNBQVN1SyxtQkFBbUJyRyxhQUFhO0lBQ3JDLElBQUlzRyxXQUFXdEcsY0FBYzd1QixHQUFHLENBQUM7SUFDakMsT0FFSSxxQkFEcUI7SUFDcEJtMUIsYUFBYSxRQUNkLDRCQUE0QjtJQUMzQixDQUFDdEUsYUFBYXNFO0FBRXZCO0FBRUEsSUFBSUMsa0JBQWtCO0lBQ2xCQyxZQUFZTDtJQUNaTSxVQUFVSjtBQUNkO0FBRUE7O0NBRUMsR0FFRCxTQUFTSyx5QkFBeUIxRyxhQUFhO0lBQzNDLElBQUlsRSxPQUFPa0UsY0FBY3RELE9BQU87SUFDaEMsSUFBSTBKLFdBQVdwRyxjQUFjN3VCLEdBQUcsQ0FBQyxDQUFDO0lBQ2xDLE9BRUksbURBRG1EO0lBQ2xENndCLENBQUFBLGFBQWFsRyxTQUFTb0cscUJBQXFCcEcsS0FBSSxLQUNoRCxDQUFDa0csYUFBYW9FO0FBRXRCO0FBRUEsU0FBU08sdUJBQXVCM0csYUFBYTtJQUN6QyxJQUFJc0csV0FBV3RHLGNBQWM3dUIsR0FBRyxDQUFDO0lBQ2pDLE9BQVE7UUFDSixLQUFLbTFCLGFBQWE7WUFDZCxPQUFPO1FBQ1gsS0FBTSxDQUFDdEUsYUFBYXNFLGFBQWEsQ0FBQ3BFLHFCQUFxQm9FO1lBQ25ELElBQUlNLG1CQUFtQnhFLGFBQWFrRTtZQUNwQyxJQUFJLENBQUNNLGtCQUFrQjtnQkFBRSxPQUFPO1lBQU07WUFDdEMsSUFBSUEsa0JBQWtCO2dCQUNsQixJQUFJQyxrQkFBa0I7Z0JBQ3RCQSxrQkFDSTdHLGNBQWNwRCxTQUFTLENBQUNxSixJQUFJLENBQ3hCLFNBQVU1NEIsQ0FBQztvQkFBSSxPQUFPMjBCLGFBQWEzMEIsTUFBTTYwQixxQkFBcUI3MEI7Z0JBQUk7Z0JBRzFFLElBQUksQ0FBQ3c1QixpQkFBaUI7b0JBQUUsT0FBTztnQkFBTTtZQUN6QztZQUNBO1FBQ0o7WUFDSSxPQUFPO0lBQ2Y7QUFDSjtBQUVBLElBQUlDLHNCQUFzQjtJQUN0Qk4sWUFBWUU7SUFDWkQsVUFBVUU7QUFDZDtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0ksNEJBQTRCeEUsTUFBTSxFQUFFN0UsTUFBTSxFQUFFbnFCLEtBQUs7SUFDdERtcUIsTUFBTSxDQUFDbnFCLE1BQU0sQ0FBQ3VxQixRQUFRLENBQUN5RSxPQUFPenJCLEdBQUcsRUFBRXlyQixPQUFPbGtCLFlBQVk7QUFDMUQ7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVMyb0IsNEJBQTRCekUsTUFBTSxFQUFFN0UsTUFBTSxFQUFFbnFCLEtBQUs7SUFDdERtcUIsTUFBTSxDQUFDbnFCLE1BQU0sQ0FBQ3VxQixRQUFRLENBQUN5RSxPQUFPenJCLEdBQUcsRUFBRXlyQixPQUFPbGtCLFlBQVk7QUFDMUQ7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVM0b0IsOEJBQThCMUUsTUFBTSxFQUFFN0UsTUFBTSxFQUFFbnFCLEtBQUs7SUFDeERndkIsT0FBT2xrQixZQUFZLENBQUMrZSxPQUFPLENBQUMsU0FBVThKLEtBQUssRUFBRTduQixNQUFNO1FBQy9DLElBQUk4ZixRQUFRekIsTUFBTSxDQUFDbnFCLFFBQVE4TCxPQUFPO1FBQ2xDOGYsTUFBTXJCLFFBQVEsQ0FBQ3lFLE9BQU96ckIsR0FBRyxFQUFFb3dCO0lBQy9CO0FBQ0o7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNDLDhCQUE4QjVFLE1BQU0sRUFBRTdFLE1BQU0sRUFBRW5xQixLQUFLO0lBQ3hELElBQUk0ckIsUUFBUXpCLE1BQU0sQ0FBQ25xQixNQUFNO0lBQ3pCNHJCLE1BQU1yQixRQUFRLENBQUN5RSxPQUFPenJCLEdBQUcsRUFBRXlyQixPQUFPbGtCLFlBQVksQ0FBQ0YsUUFBUTtJQUN2RCxJQUFJaXBCLGFBQWE3RSxPQUFPbGtCLFlBQVksQ0FBQ0gsVUFBVSxDQUFDOVUsTUFBTTtJQUN0RCxJQUFLLElBQUlkLElBQUksR0FBR0EsSUFBSTgrQixZQUFZOStCLElBQUs7UUFDakM2MkIsUUFBUXpCLE1BQU0sQ0FBQ25xQixRQUFRakwsSUFBSSxFQUFFO1FBQzdCNjJCLE1BQU1yQixRQUFRLENBQUMsV0FBVztJQUM5QjtBQUNKO0FBRUE7O0NBRUMsR0FDRCxJQUFJdUosZ0JBQWdCO0lBQ2hCLElBQUlOO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlFO0FBQ1I7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNHLGtCQUFrQi9FLE1BQU0sRUFBRTdFLE1BQU0sRUFBRW5xQixLQUFLO0lBQzVDLElBQUlndkIsa0JBQWtCRCxzQkFBc0IrRSxhQUFhLENBQUM5RSxPQUFPQyxFQUFFLENBQUMsRUFBRTtRQUNsRTZFLGFBQWEsQ0FBQzlFLE9BQU9DLEVBQUUsQ0FBQyxDQUFDRCxRQUFRN0UsUUFBUW5xQjtJQUM3QztBQUNKO0FBRUE7O0NBRUMsR0FFRDs7O0NBR0MsR0FDRCxTQUFTZzBCLGdCQUFnQkMsaUJBQWlCO0lBQ3RDLElBQUk3SyxZQUFZLEVBQUUsQ0FBQzFlLE1BQU0sQ0FBQ3VwQixrQkFBa0I3SyxTQUFTO0lBQ3JELElBQUssSUFBSXIwQixJQUFJcTBCLFVBQVV2ekIsTUFBTSxHQUFHLEdBQUdkLEtBQUssR0FBR0EsSUFBSztRQUM1QyxJQUFJODlCLFdBQVd6SixTQUFTLENBQUNyMEIsRUFBRTtRQUMzQixJQUFJbS9CLFdBQVd4RixxQkFBcUJtRTtRQUNwQyxJQUFJc0IsV0FBV3hGLHFCQUFxQmtFO1FBQ3BDLElBQUksQ0FBQ3FCLFlBQVksQ0FBQ0MsVUFBVTtZQUFFLE9BQU87UUFBTTtRQUMzQyxJQUFJRCxVQUFVO1lBQUUsT0FBTztRQUFPO0lBQ2xDO0lBQ0EsT0FBTztBQUNYO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0UsZ0JBQWdCSCxpQkFBaUI7SUFDdEMsSUFBSXZGLHFCQUFxQnVGLGtCQUFrQjlLLE9BQU8sR0FBRztRQUFFLE9BQU87SUFBTztJQUNyRSxJQUFLLElBQUlwMEIsSUFBSSxHQUFHQSxJQUFJay9CLGtCQUFrQjVLLFNBQVMsQ0FBQ3h6QixNQUFNLEVBQUVkLElBQUs7UUFDekQsSUFBSWcrQixXQUFXa0Isa0JBQWtCNUssU0FBUyxDQUFDdDBCLEVBQUU7UUFDN0MsSUFBSW8vQixXQUFXeEYscUJBQXFCb0U7UUFDcEMsSUFBSSxDQUFDb0IsVUFBVTtZQUFFLE9BQU87UUFBTTtJQUNsQztJQUNBLE9BQU87QUFDWDtBQUVBOzs7Q0FHQyxHQUNELFNBQVNFLHdCQUF3QnJ3QixLQUFLO0lBQ2xDLElBQUkybEIsU0FBUyxJQUFJO0lBRWpCLElBQUlobEIsU0FBUztJQUNiLElBQUlpdEIsT0FBTyxJQUFJLENBQUMwQyxZQUFZLENBQUMzdkIsT0FBTztJQUNwQyxJQUFJd2xCLFNBQVMsSUFBSSxDQUFDb0ssU0FBUyxDQUFDcEgsY0FBYyxDQUFDbnBCO0lBQzNDLElBQUltbUIsT0FBT3QwQixNQUFNLEtBQUssR0FBRztRQUFFO0lBQVE7SUFDbkMsSUFBSTQyQixnQkFBZ0IsSUFBSXpELGNBQ3BCbUIsT0FBT1ksR0FBRyxDQUFDLFNBQVVhLEtBQUs7UUFBSSxPQUFPQSxNQUFNbkIsUUFBUSxDQUFDO0lBQWUsSUFDcEU7SUFDSCxJQUFJd0osb0JBQW9CLElBQUlqTCxjQUN4Qm1CLE9BQU9ZLEdBQUcsQ0FBQyxTQUFVYSxLQUFLO1FBQUksT0FBT0EsTUFBTXJELElBQUk7SUFBRSxJQUNsRDtJQUNINEIsT0FBT04sT0FBTyxDQUFDLFNBQVUrQixLQUFLLEVBQUU1ckIsS0FBSztRQUNqQyxJQUFJMnVCLHFCQUFxQi9DLE1BQU1yRCxJQUFJLEdBQUc7WUFBRTtRQUFRO1FBQ2hEa0UsY0FBY1EsZUFBZSxDQUFDanRCO1FBQzlCaTBCLGtCQUFrQmhILGVBQWUsQ0FBQ2p0QjtRQUNsQyxJQUFJdzBCLFVBQVUsR0FBRywwREFBMEQ7UUFDM0UsSUFBSVIsZ0JBQWdCQyxvQkFBb0I7WUFBRU8sV0FBVztRQUFHO1FBQ3hELElBQUlKLGdCQUFnQkgsb0JBQW9CO1lBQUVPLFdBQVc7UUFBRztRQUN4RCxJQUFJanhCO1FBQ0osT0FBUWl4QjtZQUNKLEtBQUs7Z0JBQUlqeEIsTUFBTTtnQkFBUztZQUN4QixLQUFLO2dCQUFJQSxNQUFNO2dCQUFTO1lBQ3hCLEtBQUs7Z0JBQUlBLE1BQU07Z0JBQVM7UUFDNUI7UUFDQSxJQUFJcXVCLEtBQUt2ekIsT0FBTyxDQUFDa0YsU0FBUyxDQUFDLEdBQUc7WUFBRTtRQUFRO1FBQ3hDLElBQUlnRyxnQkFBZ0JvZ0IsT0FBT3FJLEtBQUssQ0FBQ0QsYUFBYSxDQUFDO1lBQzNDeHVCLEtBQUtBO1lBQUtvQixRQUFRQTtZQUFROG5CLGVBQWVBO1FBQzdDO1FBQ0EsSUFBSWxqQix5QkFBeUIxUixPQUFPO1lBQUUsT0FBT3FsQixRQUFRdVgsSUFBSSxDQUFDbHJCLGNBQWNuSyxPQUFPO1FBQUc7UUFDbEZtSyxjQUFjc2dCLE9BQU8sQ0FBQyxTQUFVbUYsTUFBTSxFQUFFaHZCLEtBQUs7WUFDekMsSUFBSWd2QixrQkFBa0JELG9CQUFvQjtnQkFDdENnRixrQkFBa0IvRSxRQUFRN0UsUUFBUW5xQjtnQkFDbEN5c0IsY0FBY3hELE9BQU8sQ0FBQ2pwQixNQUFNLEdBQUdndkIsT0FBT2xrQixZQUFZO1lBQ3REO1FBQ0o7SUFDSjtBQUNKO0FBRUE7O0NBRUMsR0FFRDs7OztDQUlDLEdBQ0QsU0FBUzRwQixpQkFBaUJ2SyxNQUFNLEVBQUVucUIsS0FBSztJQUNuQyxJQUFJaXBCLFVBQVVrQixPQUFPWSxHQUFHLENBQUMsU0FBVWEsS0FBSztRQUFJLE9BQU9BLE1BQU1wRCxXQUFXLENBQUMza0IsS0FBSztJQUFFO0lBQzVFLE9BQU8sSUFBSW1sQixjQUFjQyxTQUFTanBCLFNBQVM7QUFDL0M7QUFFQTs7O0NBR0MsR0FDRCxTQUFTMjBCLHdCQUF3QjN3QixLQUFLO0lBQ2xDLElBQUkybEIsU0FBUyxJQUFJO0lBRWpCLElBQUlobEIsU0FBUztJQUNiLElBQUl3bEIsU0FBUyxJQUFJLENBQUNvSyxTQUFTLENBQUNwSCxjQUFjLENBQUNucEI7SUFDM0MsSUFBSXlvQixnQkFBZ0JpSSxpQkFBaUJ2SztJQUNyQ3NDLGNBQWN4RCxPQUFPLENBQUNZLE9BQU8sQ0FBQyxTQUFVbHJCLFVBQVUsRUFBRXFCLEtBQUs7UUFDckR5c0IsY0FBY1EsZUFBZSxDQUFDanRCO1FBQzlCLElBQUl1SixnQkFBZ0JvZ0IsT0FBT3FJLEtBQUssQ0FBQ0QsYUFBYSxDQUFDO1lBQzNDeHVCLEtBQUs7WUFBUW9CLFFBQVFBO1lBQVE4bkIsZUFBZUE7UUFDaEQ7UUFDQSxJQUFJbGpCLGNBQWMxVCxNQUFNLEVBQUU7WUFDdEIwVCxjQUFjc2dCLE9BQU8sQ0FDakIsU0FBVW1GLE1BQU07Z0JBQUksT0FBTytFLGtCQUFrQi9FLFFBQVE3RSxRQUFRbnFCO1lBQVE7WUFFekV5c0IsZ0JBQWdCaUksaUJBQWlCdks7UUFDckM7SUFDSjtBQUNKO0FBRUE7O0NBRUMsR0FFRCxTQUFTeUssb0JBQW9CbkksYUFBYTtJQUN0QyxJQUFJbEUsT0FBT2tFLGNBQWN0RCxPQUFPO0lBQ2hDLElBQUkwSixXQUFXcEcsY0FBYzd1QixHQUFHLENBQUMsQ0FBQztJQUNsQyxPQUVJLHFCQURxQjtJQUNwQmkxQixhQUFhLFFBQVFqRSxZQUFZckcsU0FDbEMsOENBQThDO0lBQzdDLENBQUNxRyxZQUFZaUUsYUFBYWpFLFlBQVlyRztBQUUvQztBQUVBLFNBQVNzTSxrQkFBa0JwSSxhQUFhO0lBQ3BDLElBQUlzRyxXQUFXdEcsY0FBYzd1QixHQUFHLENBQUM7SUFDakMsT0FFSSxvQkFEb0I7SUFDbkJtMUIsYUFBYSxRQUNkLDJCQUEyQjtJQUMxQixDQUFDbkUsWUFBWW1FO0FBRXRCO0FBRUEsSUFBSStCLGlCQUFpQjtJQUNqQjdCLFlBQVkyQjtJQUNaMUIsVUFBVTJCO0FBQ2Q7QUFFQTs7Q0FFQyxHQUVEOzs7O0NBSUMsR0FDRCxTQUFTRSxtQkFBbUI1SyxNQUFNLEVBQUVucUIsS0FBSztJQUNyQyxJQUFJaXBCLFVBQVVrQixPQUFPWSxHQUFHLENBQUMsU0FBVWEsS0FBSztRQUFJLE9BQU9BLE1BQU1wRCxXQUFXLENBQUMza0IsS0FBSztJQUFFO0lBQzVFLE9BQU8sSUFBSW1sQixjQUFjQyxTQUFTanBCLFNBQVM7QUFDL0M7QUFFQTs7O0NBR0MsR0FDRCxTQUFTZzFCLGNBQWNoeEIsS0FBSztJQUN4QixJQUFJMmxCLFNBQVMsSUFBSTtJQUVqQixJQUFJaGxCLFNBQVM7SUFDYixJQUFJd2xCLFNBQVMsSUFBSSxDQUFDb0ssU0FBUyxDQUFDcEgsY0FBYyxDQUFDbnBCO0lBQzNDLElBQUl5b0IsZ0JBQWdCc0ksbUJBQW1CNUs7SUFDdkNzQyxjQUFjeEQsT0FBTyxDQUFDWSxPQUFPLENBQUMsU0FBVWxyQixVQUFVLEVBQUVxQixLQUFLO1FBQ3JEeXNCLGNBQWNRLGVBQWUsQ0FBQ2p0QjtRQUM5QixJQUFJdUosZ0JBQWdCb2dCLE9BQU9xSSxLQUFLLENBQUNELGFBQWEsQ0FBQztZQUMzQ3h1QixLQUFLO1lBQVFvQixRQUFRQTtZQUFROG5CLGVBQWVBO1FBQ2hEO1FBQ0EsSUFBSWxqQixjQUFjMVQsTUFBTSxFQUFFO1lBQ3RCMFQsY0FBY3NnQixPQUFPLENBQ2pCLFNBQVVtRixNQUFNO2dCQUFJLE9BQU8rRSxrQkFBa0IvRSxRQUFRN0UsUUFBUW5xQjtZQUFRO1lBRXpFeXNCLGdCQUFnQnNJLG1CQUFtQjVLO1FBQ3ZDO0lBQ0o7QUFDSjtBQUVBOzs7Q0FHQyxHQUVEOzs7Q0FHQyxHQUNELFNBQVM4SyxLQUFLQyxPQUFPO0lBQ2pCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQSxXQUFXO0lBQzFCLElBQUksQ0FBQ1gsU0FBUyxHQUFHLElBQUlySztJQUNyQixJQUFJLENBQUNvSyxZQUFZLEdBQUcsQ0FBQztBQUN6QjtBQUVBOzs7Q0FHQyxHQUNEVyxLQUFLMzVCLFNBQVMsQ0FBQzY1QixPQUFPLEdBQUcsU0FBVTVHLElBQUk7SUFDbkMsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO0FBQ2hCO0FBRUE7Ozs7Q0FJQyxHQUNEMEcsS0FBSzM1QixTQUFTLENBQUM4NUIsYUFBYSxHQUFJO0lBQzVCTixnQkFBZ0JBO0lBQ2hCOUIsaUJBQWlCQTtJQUNqQk8scUJBQXFCQTtBQUN6QjtBQUVBOztDQUVDLEdBQ0QsU0FBUzVGLHVCQUF1QjBILE9BQU87SUFDbkMsSUFBSTkxQixRQUFRLElBQUksQ0FBQzYxQixhQUFhLENBQUVDLFVBQVUsUUFBUztJQUNuRCxPQUFPLElBQUksQ0FBQ2QsU0FBUyxDQUFDNUcsc0JBQXNCLENBQ3hDMEgsU0FBUzkxQixNQUFNMHpCLFVBQVUsRUFBRTF6QixNQUFNMnpCLFFBQVE7QUFFakQ7QUFFQTs7O0NBR0MsR0FDRCxTQUFTb0M7SUFDTDNILHVCQUF1QnZtQixJQUFJLENBQUMsSUFBSSxFQUFFO0lBQ2xDdW1CLHVCQUF1QnZtQixJQUFJLENBQUMsSUFBSSxFQUFFO0lBQ2xDdW1CLHVCQUF1QnZtQixJQUFJLENBQUMsSUFBSSxFQUFFO0lBQ2xDLE9BQU8sSUFBSSxDQUFDbXRCLFNBQVMsQ0FBQ2pHLFFBQVEsQ0FBQyxJQUFJLENBQUNDLElBQUk7QUFDNUM7QUFFQTs7O0NBR0MsR0FDRCxTQUFTZ0g7SUFDTCxJQUFJNUwsU0FBUyxJQUFJO0lBRWpCLElBQUk1bEIsU0FBUyxJQUFJLENBQUN3d0IsU0FBUyxDQUFDeEcsZ0JBQWdCLENBQUM7SUFDN0NocUIsT0FBTzhsQixPQUFPLENBQUMsU0FBVTdsQixLQUFLO1FBQzFCLElBQUl3eEIsY0FBYzdMLE9BQU80SyxTQUFTLENBQUNwSCxjQUFjLENBQUNucEI7UUFDbEQybEIsT0FBTzRLLFNBQVMsQ0FBQzdJLFlBQVksQ0FDekIxbkIsTUFBTTBrQixVQUFVLEVBQ2hCMWtCLE1BQU1pSixTQUFTLEVBQ2Z1b0IsWUFBWWxGLE9BQU87SUFFM0I7QUFDSjtBQUVBOzs7O0NBSUMsR0FDRDJFLEtBQUszNUIsU0FBUyxDQUFDbTZCLGdCQUFnQixHQUFHLFNBQVU5d0IsTUFBTSxFQUFFaXRCLElBQUk7SUFDcEQsSUFBSWpJLFNBQVMsSUFBSTtJQUVqQixJQUFJK0wsZ0JBQWdCOUQsS0FBS3JHLE1BQU0sQ0FDM0IsU0FBVWhvQixHQUFHO1FBQUksT0FBT29tQixPQUFPcUksS0FBSyxDQUFDTyxRQUFRLENBQUM7WUFBQzV0QixRQUFRQTtZQUFRcEIsS0FBS0E7UUFBRztJQUFJO0lBRS9FLElBQUksQ0FBQyxJQUFJLENBQUMrd0IsWUFBWSxDQUFDbkosY0FBYyxDQUFDeG1CLFNBQVM7UUFDM0MsSUFBSSxDQUFDMnZCLFlBQVksQ0FBQzN2QixPQUFPLEdBQUcrd0I7SUFDaEMsT0FBTztRQUNILElBQUksQ0FBQ3BCLFlBQVksQ0FBQzN2QixPQUFPLEdBQ3pCLElBQUksQ0FBQzJ2QixZQUFZLENBQUMzdkIsT0FBTyxDQUFDK0YsTUFBTSxDQUFDZ3JCO0lBQ3JDO0FBQ0o7QUFFQTs7Ozs7Q0FLQyxHQUNEVCxLQUFLMzVCLFNBQVMsQ0FBQ3E2QixhQUFhLEdBQUcsU0FBVXA0QixJQUFJLEVBQUV1SSxRQUFRO0lBQ25ELElBQUksQ0FBQ3ZJLE1BQU07UUFBRSxNQUFNLElBQUkxRixNQUNuQjtJQUNEO0lBQ0gsSUFBSSxDQUFDLElBQUksQ0FBQ202QixLQUFLLEVBQUU7UUFBRSxJQUFJLENBQUNBLEtBQUssR0FBRyxJQUFJbEQsYUFBYXZ4QjtJQUFPO0lBQ3hELElBQUssSUFBSWxGLElBQUksR0FBR0EsSUFBSXlOLFNBQVNqUSxNQUFNLEVBQUV3QyxJQUFLO1FBQ3RDLElBQUlvTixVQUFVSyxRQUFRLENBQUN6TixFQUFFO1FBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUMyNUIsS0FBSyxDQUFDTyxRQUFRLENBQUM7WUFBQzV0QixRQUFRYyxRQUFRZCxNQUFNO1FBQUEsSUFBSTtZQUFFO1FBQVU7UUFDaEUsSUFBSSxDQUFDOHdCLGdCQUFnQixDQUFDaHdCLFFBQVFkLE1BQU0sRUFBRWMsUUFBUW1zQixJQUFJO0lBQ3REO0FBQ0o7QUFFQTs7Ozs7Q0FLQyxHQUNEcUQsS0FBSzM1QixTQUFTLENBQUM4d0IsZ0JBQWdCLEdBQUcsU0FBVUMsVUFBVSxFQUFFQyxTQUFTLEVBQUVDLFFBQVE7SUFDdkUsSUFBSSxDQUFDZ0ksU0FBUyxDQUFDbkksZ0JBQWdCLENBQUNDLFlBQVlDLFdBQVdDO0FBQzNEO0FBRUE7O0NBRUMsR0FDRCxTQUFTcUo7SUFDTCxJQUFJLElBQUksQ0FBQ3JCLFNBQVMsQ0FBQ2pLLG1CQUFtQixDQUFDanNCLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHO1FBQ2pFLE1BQU0sSUFBSXhHLE1BQ04sOENBQ0E7SUFFUjtBQUNKO0FBRUE7O0NBRUMsR0FDRCxTQUFTZytCO0lBQ0wsSUFBSWxNLFNBQVMsSUFBSTtJQUVqQixJQUFJaGxCLFNBQVM7SUFDYixJQUFJLENBQUMsSUFBSSxDQUFDMnZCLFlBQVksQ0FBQ25KLGNBQWMsQ0FBQ3htQixTQUFTO1FBQUU7SUFBUTtJQUN6RGl4QixzQkFBc0J4dUIsSUFBSSxDQUFDLElBQUk7SUFDL0IsSUFBSXJELFNBQVMsSUFBSSxDQUFDd3dCLFNBQVMsQ0FBQ3hHLGdCQUFnQixDQUFDO0lBQzdDaHFCLE9BQU84bEIsT0FBTyxDQUFDLFNBQVU3bEIsS0FBSztRQUMxQnF3Qix3QkFBd0JqdEIsSUFBSSxDQUFDdWlCLFFBQVEzbEI7SUFDekM7QUFDSjtBQUVBOztDQUVDLEdBQ0QsU0FBUzh4QjtJQUNMLElBQUluTSxTQUFTLElBQUk7SUFFakIsSUFBSWhsQixTQUFTO0lBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQzJ2QixZQUFZLENBQUNuSixjQUFjLENBQUN4bUIsU0FBUztRQUFFO0lBQVE7SUFDekQsSUFBSWl0QixPQUFPLElBQUksQ0FBQzBDLFlBQVksQ0FBQzN2QixPQUFPO0lBQ3BDLElBQUlpdEIsS0FBS3Z6QixPQUFPLENBQUMsWUFBWSxDQUFDLEdBQUc7UUFBRTtJQUFRO0lBQzNDdTNCLHNCQUFzQnh1QixJQUFJLENBQUMsSUFBSTtJQUMvQixJQUFJckQsU0FBUyxJQUFJLENBQUN3d0IsU0FBUyxDQUFDeEcsZ0JBQWdCLENBQUM7SUFDN0NocUIsT0FBTzhsQixPQUFPLENBQUMsU0FBVTdsQixLQUFLO1FBQzFCMndCLHdCQUF3QnZ0QixJQUFJLENBQUN1aUIsUUFBUTNsQjtJQUN6QztBQUNKO0FBRUE7O0NBRUMsR0FDRCxTQUFTK3hCO0lBQ0wsSUFBSXBNLFNBQVMsSUFBSTtJQUVqQixJQUFJaGxCLFNBQVM7SUFDYixJQUFJLENBQUMsSUFBSSxDQUFDMnZCLFlBQVksQ0FBQ25KLGNBQWMsQ0FBQ3htQixTQUFTO1FBQUU7SUFBUTtJQUN6RCxJQUFJaXRCLE9BQU8sSUFBSSxDQUFDMEMsWUFBWSxDQUFDM3ZCLE9BQU87SUFDcEMsSUFBSWl0QixLQUFLdnpCLE9BQU8sQ0FBQyxZQUFZLENBQUMsR0FBRztRQUFFO0lBQVE7SUFDM0N1M0Isc0JBQXNCeHVCLElBQUksQ0FBQyxJQUFJO0lBQy9CLElBQUlyRCxTQUFTLElBQUksQ0FBQ3d3QixTQUFTLENBQUN4RyxnQkFBZ0IsQ0FBQztJQUM3Q2hxQixPQUFPOGxCLE9BQU8sQ0FBQyxTQUFVN2xCLEtBQUs7UUFDMUJneEIsY0FBYzV0QixJQUFJLENBQUN1aUIsUUFBUTNsQjtJQUMvQjtBQUNKO0FBRUE7OztDQUdDLEdBQ0RpeEIsS0FBSzM1QixTQUFTLENBQUMwNkIsaUJBQWlCLEdBQUcsU0FBVUMsU0FBUztJQUNsRCxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMxQixTQUFTLENBQUNqSCxVQUFVLENBQUMySTtBQUN2QztBQUVBOztDQUVDLEdBQ0RoQixLQUFLMzVCLFNBQVMsQ0FBQzQ2Qix1QkFBdUIsR0FBRztJQUNyQyxJQUFJLElBQUksQ0FBQ0YsaUJBQWlCLENBQUMsZUFBZTtRQUN0Q0gsNkJBQTZCenVCLElBQUksQ0FBQyxJQUFJO1FBQ3RDMHVCLDRCQUE0QjF1QixJQUFJLENBQUMsSUFBSTtJQUN6QztJQUNBLElBQUksSUFBSSxDQUFDNHVCLGlCQUFpQixDQUFDLGNBQWM7UUFDckNELG9CQUFvQjN1QixJQUFJLENBQUMsSUFBSTtJQUNqQztJQUNBLElBQUksSUFBSSxDQUFDNHVCLGlCQUFpQixDQUFDLG1CQUFtQjtRQUMxQ1QsdUJBQXVCbnVCLElBQUksQ0FBQyxJQUFJO0lBQ3BDO0FBQ0o7QUFFQTs7O0NBR0MsR0FDRDZ0QixLQUFLMzVCLFNBQVMsQ0FBQzY2QixXQUFXLEdBQUcsU0FBUzVILElBQUk7SUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQ0EsSUFBSSxJQUFJLElBQUksQ0FBQ0EsSUFBSSxLQUFLQSxNQUFNO1FBQ2xDLElBQUksQ0FBQzRHLE9BQU8sQ0FBQzVHO1FBQ2IrRyxhQUFhbHVCLElBQUksQ0FBQyxJQUFJO1FBQ3RCLElBQUksQ0FBQzh1Qix1QkFBdUI7SUFDaEM7QUFDSjtBQUVBOzs7O0NBSUMsR0FDRGpCLEtBQUszNUIsU0FBUyxDQUFDODZCLFdBQVcsR0FBRyxTQUFVN0gsSUFBSTtJQUN2QyxJQUFJLENBQUM0SCxXQUFXLENBQUM1SDtJQUNqQixPQUFPLElBQUksQ0FBQ2dHLFNBQVMsQ0FBQ2xILE9BQU87QUFDakM7QUFFQTs7O0NBR0MsR0FDRDRILEtBQUszNUIsU0FBUyxDQUFDKzZCLGFBQWEsR0FBRyxTQUFVOUgsSUFBSTtJQUN6QyxJQUFJLENBQUM0SCxXQUFXLENBQUM1SDtJQUNqQixJQUFJK0gsVUFBVSxFQUFFO0lBQ2hCLElBQUssSUFBSXZoQyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdy9CLFNBQVMsQ0FBQ3BLLE1BQU0sQ0FBQ3QwQixNQUFNLEVBQUVkLElBQUs7UUFDbkQsSUFBSTYyQixRQUFRLElBQUksQ0FBQzJJLFNBQVMsQ0FBQ3BLLE1BQU0sQ0FBQ3AxQixFQUFFO1FBQ3BDLElBQUk2MkIsTUFBTW5PLEtBQUssQ0FBQzhZLE9BQU8sRUFBRTtZQUFFO1FBQVU7UUFDckMsSUFBSXYyQixRQUFRNHJCLE1BQU1wRCxXQUFXLENBQUMza0IsS0FBSztRQUNuQ3l5QixRQUFRNzZCLElBQUksQ0FBQ2MsTUFBTWdHLE9BQU8sQ0FBQ3ZDLFNBQVNBLEtBQUssQ0FBQyxFQUFFLEdBQUdBO0lBQ25EO0lBQ0EsT0FBT3MyQjtBQUNYO0FBRUEsa0JBQWtCO0FBRWxCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBeUJDLEdBRUQ7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTRSxLQUFLMTJCLE9BQU87SUFDakJBLFVBQVVBLFdBQVcsQ0FBQztJQUN0QkEsUUFBUXZCLE1BQU0sR0FBR3VCLFFBQVF2QixNQUFNLElBQUksQ0FBQztJQUVwQyxJQUFJLENBQUN1QixRQUFRMjJCLEtBQUssRUFBRTtRQUNoQixzREFBc0Q7UUFDdEQvcUIsY0FDSTVMLFFBQVE0MkIsVUFBVSxFQUNsQjtRQUVKaHJCLGNBQ0k1TCxRQUFRNjJCLFNBQVMsRUFDakI7UUFFSmpyQixjQUNJNUwsUUFBUW9CLFVBQVUsRUFDbEI7UUFFSndLLGNBQ0k1TCxRQUFRODJCLFFBQVEsRUFDaEI7UUFFSmxyQixjQUNJNUwsUUFBUSsyQixTQUFTLElBQUksR0FDckI7UUFHSixJQUFJLENBQUMzMUIsVUFBVSxHQUFHcEIsUUFBUW9CLFVBQVUsSUFBSTtRQUN4QyxJQUFJLENBQUMwMUIsUUFBUSxHQUFHOTJCLFFBQVE4MkIsUUFBUTtRQUNoQyxJQUFJLENBQUNDLFNBQVMsR0FBRy8yQixRQUFRKzJCLFNBQVM7UUFDbEMsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR2gzQixRQUFRZzNCLGdCQUFnQjtRQUNoRCxJQUFJLENBQUN2NEIsTUFBTSxHQUFHRSxPQUFPczRCLE1BQU0sQ0FBQ2ozQixRQUFRdkIsTUFBTSxFQUFFO1lBQ3hDeTRCLEtBQUt2NEIsT0FBT3M0QixNQUFNLENBQ2Q7Z0JBQ0lFLGVBQ0luM0IsUUFBUW8zQixXQUFXLElBQUksSUFBSSxDQUFDQyxlQUFlLENBQUNDLE1BQU07Z0JBQ3REQyxjQUNJdjNCLFFBQVF3M0IsVUFBVSxJQUFJLElBQUksQ0FBQ0MsY0FBYyxDQUFDSCxNQUFNO2dCQUNwREksYUFDSTEzQixRQUFRMDNCLFdBQVcsSUFBSSxJQUFJLENBQUNDLGlCQUFpQixDQUFDQyxPQUFPO1lBQzdELEdBQ0E1M0IsUUFBUXZCLE1BQU0sQ0FBQ3k0QixHQUFHO1FBRTFCO0lBQ0o7SUFFQSxJQUFJLENBQUNXLFNBQVMsR0FBRyxNQUFNLHdFQUF3RTtJQUMvRixJQUFJLENBQUNqNkIsTUFBTSxHQUFHLElBQUkwRixTQUFTZCxRQUFRLENBQUMsSUFBSSxFQUFFeEMsUUFBUXBDLE1BQU0sSUFBSSxFQUFFO0lBQzlELElBQUksQ0FBQ1EsUUFBUSxHQUFHLElBQUlaLGdCQUFnQixJQUFJO0lBQ3hDLElBQUksQ0FBQ3lGLFFBQVEsR0FBRyxJQUFJb0UsU0FBUyxJQUFJO0lBQ2pDLElBQUksQ0FBQzJELFlBQVksR0FBRyxJQUFJaEMsYUFBYSxJQUFJO0lBQ3pDLElBQUksQ0FBQ3ZLLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sSUFBSSxDQUFDO0lBRTlCLG1DQUFtQztJQUNuQyxJQUFJLENBQUNpRSxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNFLGNBQWMsR0FBRyxDQUFDO0lBRXZCakUsT0FBTytCLGNBQWMsQ0FBQyxJQUFJLEVBQUUsV0FBVztRQUNuQzVDLEtBQUs7WUFDRCxJQUFJLElBQUksQ0FBQ2c2QixRQUFRLEVBQUU7Z0JBQUUsT0FBTyxJQUFJLENBQUNBLFFBQVE7WUFBRTtZQUMzQyxJQUFJLElBQUksQ0FBQ0MsY0FBYyxLQUFLLFlBQVk7Z0JBQ3BDLE9BQVEsSUFBSSxDQUFDRCxRQUFRLEdBQUcsSUFBSTFnQixRQUFRLElBQUk7WUFDNUM7UUFDSjtJQUNKO0FBQ0o7QUFFQTs7OztDQUlDLEdBQ0RzZixLQUFLbDdCLFNBQVMsQ0FBQ3c4QixPQUFPLEdBQUcsU0FBVWgrQixDQUFDO0lBQ2hDLE9BQU8sSUFBSSxDQUFDb0UsUUFBUSxDQUFDVixnQkFBZ0IsQ0FBQzFELE9BQU87QUFDakQ7QUFFQTs7Ozs7O0NBTUMsR0FDRDA4QixLQUFLbDdCLFNBQVMsQ0FBQ2tDLGdCQUFnQixHQUFHLFNBQVU1SCxDQUFDO0lBQ3pDLE9BQU8sSUFBSSxDQUFDc0ksUUFBUSxDQUFDVixnQkFBZ0IsQ0FBQzVIO0FBQzFDO0FBRUE7Ozs7OztDQU1DLEdBQ0Q0Z0MsS0FBS2w3QixTQUFTLENBQUN5OEIsV0FBVyxHQUFHLFNBQVVqK0IsQ0FBQztJQUNwQyxJQUFJNkUsYUFBYSxJQUFJLENBQUNuQixnQkFBZ0IsQ0FBQzFEO0lBQ3ZDLElBQUk2RCxRQUFRLElBQUksQ0FBQ0QsTUFBTSxDQUFDRSxHQUFHLENBQUNlO0lBQzVCLElBQUksQ0FBQ2hCLE9BQU87UUFDUixVQUFVO1FBQ1ZBLFFBQVEsSUFBSSxDQUFDRCxNQUFNLENBQUNFLEdBQUcsQ0FBQztJQUM1QjtJQUVBLE9BQU9EO0FBQ1g7QUFFQTs7O0NBR0MsR0FDRDY0QixLQUFLbDdCLFNBQVMsQ0FBQzA4QixjQUFjLEdBQUcsU0FBVWw0QixPQUFPO0lBQzdDLHFEQUFxRDtJQUNyRCxPQUFPLElBQUksQ0FBQ200QixvQkFBb0IsQ0FBQ255QixRQUFRLENBQUNpbEIsR0FBRyxDQUFDLFNBQVV0bEIsT0FBTztRQUMzRCxJQUFJQSxRQUFRZCxNQUFNLEtBQUssUUFBUTtZQUMzQixPQUFPO2dCQUNIQSxRQUFRO2dCQUNSaXRCLE1BQU1uc0IsUUFBUW1zQixJQUFJLENBQUNyRyxNQUFNLENBQUMsU0FBVWhvQixHQUFHO29CQUFJLE9BQU96RCxPQUFPLENBQUN5RCxJQUFJO2dCQUFFO1lBQ3BFO1FBQ0osT0FBTztZQUNILE9BQU9rQztRQUNYO0lBQ0o7QUFDSjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0Qrd0IsS0FBS2w3QixTQUFTLENBQUM0OEIsY0FBYyxHQUFHLFNBQVV0aUMsQ0FBQyxFQUFFa0ssT0FBTztJQUNoRCxJQUFJNnBCLFNBQVMsSUFBSTtJQUVqQixJQUFJd08sT0FBTyxJQUFJbEQ7SUFFZixrREFBa0Q7SUFDbEQsSUFBSW1ELHNCQUFzQixTQUFVeE0sS0FBSztRQUFJLE9BQU9qQyxPQUFPbnNCLGdCQUFnQixDQUFDb3VCLE1BQU1yRCxJQUFJO0lBQUc7SUFDekY0UCxLQUFLL0wsZ0JBQWdCLENBQUMsY0FBYyxNQUFNZ007SUFFMUMsZ0NBQWdDO0lBQ2hDLElBQUl0eUIsV0FBV2hHLFVBQ1QsSUFBSSxDQUFDazRCLGNBQWMsQ0FBQ2w0QixRQUFRZ0csUUFBUSxJQUNwQyxJQUFJLENBQUNteUIsb0JBQW9CLENBQUNueUIsUUFBUTtJQUV4Q3F5QixLQUFLeEMsYUFBYSxDQUFDLElBQUksRUFBRTd2QjtJQUV6QixJQUFJd3dCLFVBQVU2QixLQUFLOUIsYUFBYSxDQUFDemdDO0lBRWpDLElBQUlDLFNBQVN5Z0MsUUFBUXpnQyxNQUFNO0lBRTNCLHlDQUF5QztJQUN6QyxJQUFJNkgsU0FBUyxJQUFJbkIsTUFBTTFHO0lBQ3ZCLElBQUl3aUMsU0FBUyxJQUFJLENBQUMzNkIsTUFBTSxDQUFDRSxHQUFHLENBQUM7SUFDN0IsSUFBSyxJQUFJN0ksSUFBSSxHQUFHQSxJQUFJYyxRQUFRZCxLQUFLLEVBQUc7UUFDaEMySSxNQUFNLENBQUMzSSxFQUFFLEdBQUcsSUFBSSxDQUFDMkksTUFBTSxDQUFDRSxHQUFHLENBQUMwNEIsT0FBTyxDQUFDdmhDLEVBQUUsS0FBS3NqQztJQUMvQztJQUNBLE9BQU8zNkI7QUFDWDtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRDg0QixLQUFLbDdCLFNBQVMsQ0FBQ2tNLGVBQWUsR0FBRyxTQUFVOHdCLFNBQVMsRUFBRUMsVUFBVTtJQUM1REQsWUFBWUEsVUFBVXQ0QixLQUFLLElBQUlzNEI7SUFDL0JDLGFBQWFBLFdBQVd2NEIsS0FBSyxJQUFJdTRCO0lBQ2pDLElBQUlDLGNBQWMsSUFBSSxDQUFDejFCLFFBQVEsQ0FBQ3VFLG9CQUFvQjtJQUNwRCxJQUFJa3hCLGFBQWE7UUFDYixPQUFPLElBQUksQ0FBQ3oxQixRQUFRLENBQUN5RSxlQUFlLENBQ2hDZ3hCLGFBQ0FGLFdBQ0FDO0lBRVI7SUFDQSxlQUFlO0lBQ2YsT0FBTyxJQUFJLENBQUNFLFlBQVksQ0FBQ0gsWUFBWSxNQUFNQyxXQUFXLElBQUk7QUFDOUQ7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0QvQixLQUFLbDdCLFNBQVMsQ0FBQzI4QixvQkFBb0IsR0FBRztJQUNsQ1MsU0FBUztJQUNUNXlCLFVBQVU7UUFDTjs7O1NBR0MsR0FDRDtZQUFFbkIsUUFBUTtZQUFRaXRCLE1BQU07Z0JBQUM7Z0JBQVE7Z0JBQVE7Z0JBQVE7YUFBTztRQUFDO1FBQ3pEO1lBQUVqdEIsUUFBUTtZQUFRaXRCLE1BQU07Z0JBQUM7Z0JBQVE7YUFBTztRQUFDO0tBQUc7QUFDcEQ7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDRDRFLEtBQUtsN0IsU0FBUyxDQUFDcTlCLFlBQVksR0FBRyxTQUMxQnBLLElBQUksRUFDSi80QixDQUFDLEVBQ0RnRyxDQUFDLEVBQ0RrRixRQUFRLEVBQ1JaLE9BQU8sRUFDUDg0QixRQUFRO0lBRVJwakMsSUFBSUEsTUFBTW1ILFlBQVluSCxJQUFJO0lBQzFCZ0csSUFBSUEsTUFBTW1CLFlBQVluQixJQUFJO0lBQzFCa0YsV0FBV0EsYUFBYS9ELFlBQVkrRCxXQUFXO0lBQy9DWixVQUFVckIsT0FBT3M0QixNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQ2tCLG9CQUFvQixFQUFFbjRCO0lBQ3ZELElBQUkrNEIsWUFBWSxJQUFLLElBQUksQ0FBQzMzQixVQUFVLEdBQUlSO0lBQ3hDLElBQUloRCxTQUFTLElBQUksQ0FBQ3c2QixjQUFjLENBQUMzSixNQUFNenVCO0lBQ3ZDLElBQUkySDtJQUNKLElBQUkzSCxRQUFRNDRCLE9BQU8sRUFBRTtRQUNqQixJQUFJL3pCLFNBQVM3RSxRQUFRNkUsTUFBTSxJQUFJLElBQUksQ0FBQzVCLFFBQVEsQ0FBQ3dCLG9CQUFvQjtRQUNqRWtELGlCQUFpQixJQUFJLENBQUMxRSxRQUFRLENBQUN3RSxnQkFBZ0IsQ0FDM0M1QyxRQUNBN0UsUUFBUXNGLFFBQVE7SUFFeEI7SUFDQSxJQUFLLElBQUlyUSxJQUFJLEdBQUdBLElBQUkySSxPQUFPN0gsTUFBTSxFQUFFZCxLQUFLLEVBQUc7UUFDdkMsSUFBSTRJLFFBQVFELE1BQU0sQ0FBQzNJLEVBQUU7UUFDckI2akMsU0FBU3h4QixJQUFJLENBQUMsSUFBSSxFQUFFekosT0FBT25JLEdBQUdnRyxHQUFHa0YsVUFBVVo7UUFDM0MsSUFBSW5DLE1BQU00QyxZQUFZLEVBQUU7WUFDcEIvSyxLQUFLbUksTUFBTTRDLFlBQVksR0FBR3M0QjtRQUM5QjtRQUVBLElBQUkvNEIsUUFBUTQ0QixPQUFPLElBQUkzakMsSUFBSTJJLE9BQU83SCxNQUFNLEdBQUcsR0FBRztZQUMxQyxxRUFBcUU7WUFDckUsdUNBQXVDO1lBQ3ZDLElBQUlpakMsZUFBZXJ4QixpQkFDYixJQUFJLENBQUMxRSxRQUFRLENBQUN5RSxlQUFlLENBQ3pCQyxnQkFDQTlKLE1BQU1xQyxLQUFLLEVBQ1h0QyxNQUFNLENBQUMzSSxJQUFJLEVBQUUsQ0FBQ2lMLEtBQUssSUFFdkIsSUFBSSxDQUFDd0gsZUFBZSxDQUFDN0osT0FBT0QsTUFBTSxDQUFDM0ksSUFBSSxFQUFFO1lBQy9DUyxLQUFLc2pDLGVBQWVEO1FBQ3hCO1FBRUEsSUFBSS80QixRQUFRaTVCLGFBQWEsRUFBRTtZQUN2QnZqQyxLQUFLc0ssUUFBUWk1QixhQUFhLEdBQUdyNEI7UUFDakMsT0FBTyxJQUFJWixRQUFRazVCLFFBQVEsRUFBRTtZQUN6QnhqQyxLQUFLLFFBQVN3akMsUUFBUSxHQUFHLE9BQVF0NEI7UUFDckM7SUFDSjtJQUNBLE9BQU9sTDtBQUNYO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDRGdoQyxLQUFLbDdCLFNBQVMsQ0FBQ21GLE9BQU8sR0FBRyxTQUFVOHRCLElBQUksRUFBRS80QixDQUFDLEVBQUVnRyxDQUFDLEVBQUVrRixRQUFRLEVBQUVaLE9BQU87SUFDNUQsSUFBSW01QixXQUFXLElBQUloK0I7SUFDbkIsSUFBSSxDQUFDMDlCLFlBQVksQ0FDYnBLLE1BQ0EvNEIsR0FDQWdHLEdBQ0FrRixVQUNBWixTQUNBLFNBQVVuQyxLQUFLLEVBQUV1N0IsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLFNBQVM7UUFDOUIsSUFBSUMsWUFBWTE3QixNQUFNOEMsT0FBTyxDQUFDeTRCLElBQUlDLElBQUlDLFdBQVd0NUIsU0FBUyxJQUFJO1FBQzlEbTVCLFNBQVM1OEIsTUFBTSxDQUFDZzlCO0lBQ3BCO0lBRUosT0FBT0o7QUFDWDtBQUVBOzs7Ozs7OztDQVFDLEdBQ0R6QyxLQUFLbDdCLFNBQVMsQ0FBQ2crQixRQUFRLEdBQUcsU0FBVS9LLElBQUksRUFBRS80QixDQUFDLEVBQUVnRyxDQUFDLEVBQUVrRixRQUFRLEVBQUVaLE9BQU87SUFDN0QsSUFBSXk1QixhQUFhLEVBQUU7SUFDbkIsSUFBSSxDQUFDWixZQUFZLENBQ2JwSyxNQUNBLzRCLEdBQ0FnRyxHQUNBa0YsVUFDQVosU0FDQSxTQUFVbkMsS0FBSyxFQUFFdTdCLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxTQUFTO1FBQzlCLElBQUlDLFlBQVkxN0IsTUFBTThDLE9BQU8sQ0FBQ3k0QixJQUFJQyxJQUFJQyxXQUFXdDVCLFNBQVMsSUFBSTtRQUM5RHk1QixXQUFXOTlCLElBQUksQ0FBQzQ5QjtJQUNwQjtJQUdKLE9BQU9FO0FBQ1g7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNEL0MsS0FBS2w3QixTQUFTLENBQUNrK0IsZUFBZSxHQUFHLFNBQVVqTCxJQUFJLEVBQUU3dEIsUUFBUSxFQUFFWixPQUFPO0lBQzlELE9BQU8sSUFBSSxDQUFDNjRCLFlBQVksQ0FBQ3BLLE1BQU0sR0FBRyxHQUFHN3RCLFVBQVVaLFNBQVMsWUFBYTtBQUN6RTtBQUVBOztDQUVDLEdBQ0QwMkIsS0FBS2w3QixTQUFTLENBQUNtOEIsaUJBQWlCLEdBQUc7SUFDL0JnQyxRQUFRO0lBQ1JDLFlBQVk7SUFDWkMsVUFBVTtJQUNWQyxVQUFVO0lBQ1ZDLFdBQVc7SUFDWEMsTUFBTTtJQUNOcEMsU0FBUztJQUNUcUMsbUJBQW1CO0lBQ25CQyxLQUFLO0lBQ0xDLFNBQVM7QUFDYjtBQUVBOztDQUVDLEdBQ0R6RCxLQUFLbDdCLFNBQVMsQ0FBQ2k4QixjQUFjLEdBQUc7SUFDNUIyQyxpQkFBaUI7SUFDakJDLGlCQUFpQjtJQUNqQkMsV0FBVztJQUNYQyxnQkFBZ0I7SUFDaEJqRCxRQUFRO0lBQ1JrRCxlQUFlO0lBQ2ZDLFVBQVU7SUFDVkMsZ0JBQWdCO0lBQ2hCQyxnQkFBZ0I7QUFDcEI7QUFFQTs7Q0FFQyxHQUNEakUsS0FBS2w3QixTQUFTLENBQUM2N0IsZUFBZSxHQUFHO0lBQzdCdUQsTUFBTTtJQUNOQyxhQUFhO0lBQ2JDLE9BQU87SUFDUEMsUUFBUTtJQUNSekQsUUFBUTtJQUNSMEQsV0FBVztJQUNYaEIsTUFBTTtJQUNOaUIsWUFBWTtJQUNaQyxPQUFPO0FBQ1g7QUFFQSxrRUFBa0U7QUFFbEUsU0FBU0MsdUJBQXVCbDlCLElBQUksRUFBRWpILENBQUM7SUFDbkMsZ0JBQWdCO0lBQ2hCQSxFQUFFa1gsV0FBVztJQUViLHFDQUFxQztJQUNyQ2pRLEtBQUtsSSxNQUFNLEdBQUdpQixFQUFFd1gsVUFBVTtJQUMxQnZRLEtBQUtxSCxRQUFRLEdBQUd0TyxFQUFFd1gsVUFBVTtJQUU1QixJQUFJNHNCO0lBQ0puOUIsS0FBS205QixVQUFVLEdBQUdBLGFBQWFwa0MsRUFBRXdYLFVBQVU7SUFDM0N2USxLQUFLQyxhQUFhLEdBQUcsQ0FBQztJQUV0QixJQUFLLElBQUlqSixJQUFJLEdBQUdBLElBQUltbUMsWUFBWW5tQyxLQUFLLEVBQUc7UUFDcEMsSUFBSW9tQyxnQkFBZ0Jya0MsRUFBRXdYLFVBQVU7UUFDaEMsSUFBSThzQixjQUFjdGtDLEVBQUV3WCxVQUFVO1FBQzlCLElBQUkrc0IsZUFBZXZrQyxFQUFFd1gsVUFBVTtRQUUvQixJQUFLLElBQUl4VSxJQUFJcWhDLGVBQWVyaEMsS0FBS3NoQyxhQUFhdGhDLEtBQUssRUFBRztZQUNsRGlFLEtBQUtDLGFBQWEsQ0FBQ2xFLEVBQUUsR0FBR3VoQztZQUN4QkE7UUFDSjtJQUNKO0FBQ0o7QUFFQSxTQUFTQyxzQkFBc0J2OUIsSUFBSSxFQUFFakgsQ0FBQyxFQUFFNEQsSUFBSSxFQUFFN0YsS0FBSyxFQUFFaVgsTUFBTTtJQUN2RCxxQ0FBcUM7SUFDckMvTixLQUFLbEksTUFBTSxHQUFHaUIsRUFBRWtYLFdBQVc7SUFDM0JqUSxLQUFLcUgsUUFBUSxHQUFHdE8sRUFBRWtYLFdBQVc7SUFFN0IsMEJBQTBCO0lBQzFCLElBQUl1dEI7SUFDSng5QixLQUFLdzlCLFFBQVEsR0FBR0EsV0FBV3prQyxFQUFFa1gsV0FBVyxNQUFNO0lBRTlDLCtDQUErQztJQUMvQ2xYLEVBQUVtWSxJQUFJLENBQUMsVUFBVTtJQUVqQixnRUFBZ0U7SUFDaEVsUixLQUFLQyxhQUFhLEdBQUcsQ0FBQztJQUN0QixJQUFJdzlCLGlCQUFpQixJQUFJbm9CLE1BQU0xRixNQUFNLENBQUNqVCxNQUFNN0YsUUFBUWlYLFNBQVM7SUFDN0QsSUFBSTJ2QixtQkFBbUIsSUFBSXBvQixNQUFNMUYsTUFBTSxDQUNuQ2pULE1BQ0E3RixRQUFRaVgsU0FBUyxLQUFLeXZCLFdBQVc7SUFFckMsSUFBSUcsZ0JBQWdCLElBQUlyb0IsTUFBTTFGLE1BQU0sQ0FDaENqVCxNQUNBN0YsUUFBUWlYLFNBQVMsS0FBS3l2QixXQUFXO0lBRXJDLElBQUlJLHNCQUFzQixJQUFJdG9CLE1BQU0xRixNQUFNLENBQ3RDalQsTUFDQTdGLFFBQVFpWCxTQUFTLEtBQUt5dkIsV0FBVztJQUVyQyxJQUFJSyxtQkFBbUIvbUMsUUFBUWlYLFNBQVMsS0FBS3l2QixXQUFXO0lBQ3hELElBQUssSUFBSXhtQyxJQUFJLEdBQUdBLElBQUl3bUMsV0FBVyxHQUFHeG1DLEtBQUssRUFBRztRQUN0QyxJQUFJNEosYUFBYyxLQUFLO1FBQ3ZCLElBQUlrOUIsV0FBV0wsZUFBZXh0QixXQUFXO1FBQ3pDLElBQUk4dEIsYUFBYUwsaUJBQWlCenRCLFdBQVc7UUFDN0MsSUFBSSt0QixVQUFVTCxjQUFjdHRCLFVBQVU7UUFDdEMsSUFBSTR0QixnQkFBZ0JMLG9CQUFvQjN0QixXQUFXO1FBQ25ELElBQUssSUFBSWxVLElBQUlnaUMsWUFBWWhpQyxLQUFLK2hDLFVBQVUvaEMsS0FBSyxFQUFHO1lBQzVDLElBQUlraUMsa0JBQWtCLEdBQUc7Z0JBQ3JCLG9GQUFvRjtnQkFDcEYsc0RBQXNEO2dCQUN0REosbUJBQ0lELG9CQUFvQjd2QixNQUFNLEdBQzFCNnZCLG9CQUFvQi90QixjQUFjLEdBQ2xDO2dCQUVKLG9GQUFvRjtnQkFDcEZndUIsb0JBQW9CSTtnQkFFcEIsb0ZBQW9GO2dCQUNwRkosb0JBQW9CLENBQUM5aEMsSUFBSWdpQyxVQUFTLElBQUs7Z0JBQ3ZDbjlCLGFBQWEwVSxNQUFNckgsU0FBUyxDQUFDdFIsTUFBTWtoQztnQkFDbkMsSUFBSWo5QixlQUFlLEdBQUc7b0JBQ2xCQSxhQUFhLGFBQWNvOUIsVUFBVztnQkFDMUM7WUFDSixPQUFPO2dCQUNIcDlCLGFBQWEsSUFBS285QixVQUFXO1lBQ2pDO1lBRUFoK0IsS0FBS0MsYUFBYSxDQUFDbEUsRUFBRSxHQUFHNkU7UUFDNUI7SUFDSjtBQUNKO0FBRUEsb0ZBQW9GO0FBQ3BGLHFGQUFxRjtBQUNyRiwrRkFBK0Y7QUFDL0YsU0FBU3M5QixlQUFldmhDLElBQUksRUFBRTdGLEtBQUs7SUFDL0IsSUFBSWtKLE9BQU8sQ0FBQztJQUNaQSxLQUFLc0wsT0FBTyxHQUFHZ0ssTUFBTXJILFNBQVMsQ0FBQ3RSLE1BQU03RjtJQUNyQzBLLE1BQU1GLFFBQVEsQ0FBQ3RCLEtBQUtzTCxPQUFPLEtBQUssR0FBRztJQUVuQywwRUFBMEU7SUFDMUUsb0dBQW9HO0lBQ3BHdEwsS0FBS20rQixTQUFTLEdBQUc3b0IsTUFBTXJILFNBQVMsQ0FBQ3RSLE1BQU03RixRQUFRO0lBQy9DLElBQUlpWCxTQUFTLENBQUM7SUFDZCxJQUFLLElBQUkvVyxJQUFJZ0osS0FBS20rQixTQUFTLEdBQUcsR0FBR25uQyxLQUFLLEdBQUdBLEtBQUssRUFBRztRQUM3QyxJQUFJb25DLGFBQWE5b0IsTUFBTXJILFNBQVMsQ0FBQ3RSLE1BQU03RixRQUFRLElBQUlFLElBQUk7UUFDdkQsSUFBSXFuQyxhQUFhL29CLE1BQU1ySCxTQUFTLENBQUN0UixNQUFNN0YsUUFBUSxJQUFJRSxJQUFJLElBQUk7UUFDM0QsSUFDSSxlQUFnQixLQUNYcW5DLENBQUFBLGVBQWUsS0FBS0EsZUFBZSxLQUFLQSxlQUFlLEVBQUMsS0FDNURELGVBQWUsS0FDWEMsQ0FBQUEsZUFBZSxLQUNaQSxlQUFlLEtBQ2ZBLGVBQWUsS0FDZkEsZUFBZSxLQUNmQSxlQUFlLElBQ3pCO1lBQ0V0d0IsU0FBU3VILE1BQU1qSCxRQUFRLENBQUMxUixNQUFNN0YsUUFBUSxJQUFJRSxJQUFJLElBQUk7WUFDbEQ7UUFDSjtJQUNKO0lBRUEsSUFBSStXLFdBQVcsQ0FBQyxHQUFHO1FBQ2Ysc0RBQXNEO1FBQ3RELE1BQU0sSUFBSWpVLE1BQU07SUFDcEI7SUFFQSxJQUFJZixJQUFJLElBQUl1YyxNQUFNMUYsTUFBTSxDQUFDalQsTUFBTTdGLFFBQVFpWDtJQUN2Qy9OLEtBQUs2SSxNQUFNLEdBQUc5UCxFQUFFa1gsV0FBVztJQUUzQixJQUFJalEsS0FBSzZJLE1BQU0sS0FBSyxJQUFJO1FBQ3BCcTBCLHVCQUF1Qmw5QixNQUFNakg7SUFDakMsT0FBTyxJQUFJaUgsS0FBSzZJLE1BQU0sS0FBSyxHQUFHO1FBQzFCMDBCLHNCQUFzQnY5QixNQUFNakgsR0FBRzRELE1BQU03RixPQUFPaVg7SUFDaEQsT0FBTztRQUNILE1BQU0sSUFBSWpVLE1BQ04sa0VBQ0lrRyxLQUFLNkksTUFBTSxHQUNYO0lBRVo7SUFFQSxPQUFPN0k7QUFDWDtBQUVBLElBQUlBLE9BQU87SUFBRXNWLE9BQU80b0I7QUFBZTtBQUVuQyxvRUFBb0U7QUFFcEUsdUVBQXVFO0FBQ3ZFLGlEQUFpRDtBQUNqRCxTQUFTSSxzQkFBc0JDLEtBQUs7SUFDaEMsSUFBSUM7SUFDSixJQUFJRCxNQUFNem1DLE1BQU0sR0FBRyxNQUFNO1FBQ3JCMG1DLE9BQU87SUFDWCxPQUFPLElBQUlELE1BQU16bUMsTUFBTSxHQUFHLE9BQU87UUFDN0IwbUMsT0FBTztJQUNYLE9BQU87UUFDSEEsT0FBTztJQUNYO0lBRUEsT0FBT0E7QUFDWDtBQUVBLDZCQUE2QjtBQUM3Qix5RkFBeUY7QUFDekYsU0FBU0MsY0FBYzloQyxJQUFJLEVBQUU3RixLQUFLLEVBQUU0bkMsWUFBWTtJQUM1QyxJQUFJcHRCLFVBQVUsRUFBRTtJQUNoQixJQUFJcXRCLFVBQVUsRUFBRTtJQUNoQixJQUFJdHRCLFFBQVFpRSxNQUFNRSxTQUFTLENBQUM3WSxNQUFNN0Y7SUFDbEMsSUFBSThuQztJQUNKLElBQUkxdkI7SUFDSixJQUFJbUMsVUFBVSxHQUFHO1FBQ2IsSUFBSXd0QixhQUFhdnBCLE1BQU16SCxPQUFPLENBQUNsUixNQUFNN0YsUUFBUTtRQUM3QzhuQyxlQUFlOW5DLFFBQVEsQ0FBQ3VhLFFBQVEsS0FBS3d0QixhQUFhO1FBQ2xELElBQUkvakMsTUFBTWhFLFFBQVE7UUFDbEIsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlxYSxRQUFRLEdBQUdyYSxLQUFLLEVBQUc7WUFDbkNzYSxRQUFRNVQsSUFBSSxDQUFDNFgsTUFBTXhHLFNBQVMsQ0FBQ25TLE1BQU03QixLQUFLK2pDO1lBQ3hDL2pDLE9BQU8rakM7UUFDWDtRQUVBLHNGQUFzRjtRQUN0RjN2QixZQUFZMHZCLGVBQWV0dEIsT0FBTyxDQUFDRCxNQUFNO0lBQzdDLE9BQU87UUFDSG5DLFlBQVlwWSxRQUFRO0lBQ3hCO0lBRUEsSUFBSyxJQUFJeWYsTUFBTSxHQUFHQSxNQUFNakYsUUFBUXhaLE1BQU0sR0FBRyxHQUFHeWUsT0FBTyxFQUFHO1FBQ2xELElBQUl6USxRQUFRd1AsTUFBTXRHLFFBQVEsQ0FDdEJyUyxNQUNBaWlDLGVBQWV0dEIsT0FBTyxDQUFDaUYsSUFBSSxFQUMzQnFvQixlQUFldHRCLE9BQU8sQ0FBQ2lGLE1BQU0sRUFBRTtRQUVuQyxJQUFJbW9CLGNBQWM7WUFDZDU0QixRQUFRNDRCLGFBQWE1NEI7UUFDekI7UUFFQTY0QixRQUFRamhDLElBQUksQ0FBQ29JO0lBQ2pCO0lBRUEsT0FBTztRQUFFNjRCLFNBQVNBO1FBQVMxdkIsYUFBYW5ZO1FBQU9vWSxXQUFXQTtJQUFVO0FBQ3hFO0FBRUEsU0FBUzR2Qix1QkFBdUJuaUMsSUFBSSxFQUFFN0YsS0FBSztJQUN2QyxJQUFJd2EsVUFBVSxFQUFFO0lBQ2hCLElBQUlELFFBQVFpRSxNQUFNRSxTQUFTLENBQUM3WSxNQUFNN0Y7SUFDbEMsSUFBSThuQztJQUNKLElBQUkxdkI7SUFDSixJQUFJbUMsVUFBVSxHQUFHO1FBQ2IsSUFBSXd0QixhQUFhdnBCLE1BQU16SCxPQUFPLENBQUNsUixNQUFNN0YsUUFBUTtRQUM3QzhuQyxlQUFlOW5DLFFBQVEsQ0FBQ3VhLFFBQVEsS0FBS3d0QixhQUFhO1FBQ2xELElBQUkvakMsTUFBTWhFLFFBQVE7UUFDbEIsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlxYSxRQUFRLEdBQUdyYSxLQUFLLEVBQUc7WUFDbkNzYSxRQUFRNVQsSUFBSSxDQUFDNFgsTUFBTXhHLFNBQVMsQ0FBQ25TLE1BQU03QixLQUFLK2pDO1lBQ3hDL2pDLE9BQU8rakM7UUFDWDtRQUVBLHNGQUFzRjtRQUN0RjN2QixZQUFZMHZCLGVBQWV0dEIsT0FBTyxDQUFDRCxNQUFNO0lBQzdDLE9BQU87UUFDSG5DLFlBQVlwWSxRQUFRO0lBQ3hCO0lBRUEsT0FBTztRQUFFd2EsU0FBU0E7UUFBU3JDLGFBQWFuWTtRQUFPb1ksV0FBV0E7SUFBVTtBQUN4RTtBQUNBLFNBQVM2dkIsa0JBQWtCL25DLENBQUMsRUFBRXNhLE9BQU8sRUFBRTNVLElBQUksRUFBRTdGLEtBQUssRUFBRTRuQyxZQUFZO0lBQzVELElBQUlydEIsUUFBUWlFLE1BQU1FLFNBQVMsQ0FBQzdZLE1BQU03RjtJQUNsQyxJQUFJOG5DLGVBQWU7SUFDbkIsSUFBSXZ0QixVQUFVLEdBQUc7UUFDYixJQUFJd3RCLGFBQWF2cEIsTUFBTXpILE9BQU8sQ0FBQ2xSLE1BQU03RixRQUFRO1FBQzdDOG5DLGVBQWU5bkMsUUFBUSxDQUFDdWEsUUFBUSxLQUFLd3RCLGFBQWE7SUFDdEQ7SUFFQSxJQUFJLzRCLFFBQVF3UCxNQUFNdEcsUUFBUSxDQUN0QnJTLE1BQ0FpaUMsZUFBZXR0QixPQUFPLENBQUN0YSxFQUFFLEVBQ3pCNG5DLGVBQWV0dEIsT0FBTyxDQUFDdGEsSUFBSSxFQUFFO0lBRWpDLElBQUkwbkMsY0FBYztRQUNkNTRCLFFBQVE0NEIsYUFBYTU0QjtJQUN6QjtJQUNBLE9BQU9BO0FBQ1g7QUFFQSxpQ0FBaUM7QUFDakMsU0FBU2s1QixrQkFBa0JDLE1BQU07SUFDN0IsSUFBSXBuQyxJQUFJO0lBQ1IsSUFBSXFuQyxNQUFNO0lBQ1YsSUFBSWxNLFNBQVM7UUFDVDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FBSztJQUNULE1BQU8sS0FBTTtRQUNULElBQUlqOEIsSUFBSWtvQyxPQUFPbnZCLFNBQVM7UUFDeEIsSUFBSXFZLEtBQUtweEIsS0FBSztRQUNkLElBQUlteEIsS0FBS254QixJQUFJO1FBRWIsSUFBSW94QixPQUFPK1csS0FBSztZQUNaO1FBQ0o7UUFFQXJuQyxLQUFLbTdCLE1BQU0sQ0FBQzdLLEdBQUc7UUFFZixJQUFJRCxPQUFPZ1gsS0FBSztZQUNaO1FBQ0o7UUFFQXJuQyxLQUFLbTdCLE1BQU0sQ0FBQzlLLEdBQUc7SUFDbkI7SUFFQSxPQUFPaVgsV0FBV3RuQztBQUN0QjtBQUVBLDhCQUE4QjtBQUM5QixTQUFTdW5DLGFBQWFILE1BQU0sRUFBRUksRUFBRTtJQUM1QixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlKLE9BQU8sSUFBSTtRQUNYQyxLQUFLTCxPQUFPbnZCLFNBQVM7UUFDckJ5dkIsS0FBS04sT0FBT252QixTQUFTO1FBQ3JCLE9BQU8sTUFBTyxJQUFLeXZCO0lBQ3ZCO0lBRUEsSUFBSUYsT0FBTyxJQUFJO1FBQ1hDLEtBQUtMLE9BQU9udkIsU0FBUztRQUNyQnl2QixLQUFLTixPQUFPbnZCLFNBQVM7UUFDckIwdkIsS0FBS1AsT0FBT252QixTQUFTO1FBQ3JCMnZCLEtBQUtSLE9BQU9udkIsU0FBUztRQUNyQixPQUFPLE1BQU8sS0FBT3l2QixNQUFNLEtBQU9DLE1BQU0sSUFBS0M7SUFDakQ7SUFFQSxJQUFJSixPQUFPLElBQUk7UUFDWCxPQUFPTCxrQkFBa0JDO0lBQzdCO0lBRUEsSUFBSUksTUFBTSxNQUFNQSxNQUFNLEtBQUs7UUFDdkIsT0FBT0EsS0FBSztJQUNoQjtJQUVBLElBQUlBLE1BQU0sT0FBT0EsTUFBTSxLQUFLO1FBQ3hCQyxLQUFLTCxPQUFPbnZCLFNBQVM7UUFDckIsT0FBTyxDQUFDdXZCLEtBQUssR0FBRSxJQUFLLE1BQU1DLEtBQUs7SUFDbkM7SUFFQSxJQUFJRCxNQUFNLE9BQU9BLE1BQU0sS0FBSztRQUN4QkMsS0FBS0wsT0FBT252QixTQUFTO1FBQ3JCLE9BQU8sQ0FBRXV2QixDQUFBQSxLQUFLLEdBQUUsSUFBSyxNQUFNQyxLQUFLO0lBQ3BDO0lBRUEsTUFBTSxJQUFJeGxDLE1BQU0sZ0JBQWdCdWxDO0FBQ3BDO0FBRUEsc0VBQXNFO0FBQ3RFLCtDQUErQztBQUMvQyxTQUFTSyxnQkFBZ0JDLE9BQU87SUFDNUIsSUFBSTNtQyxJQUFJLENBQUM7SUFDVCxJQUFLLElBQUloQyxJQUFJLEdBQUdBLElBQUkyb0MsUUFBUTduQyxNQUFNLEVBQUVkLEtBQUssRUFBRztRQUN4QyxJQUFJeTFCLE1BQU1rVCxPQUFPLENBQUMzb0MsRUFBRSxDQUFDLEVBQUU7UUFDdkIsSUFBSXNjLFNBQVNxc0IsT0FBTyxDQUFDM29DLEVBQUUsQ0FBQyxFQUFFO1FBQzFCLElBQUk4TyxRQUFTLEtBQUs7UUFDbEIsSUFBSXdOLE9BQU94YixNQUFNLEtBQUssR0FBRztZQUNyQmdPLFFBQVF3TixNQUFNLENBQUMsRUFBRTtRQUNyQixPQUFPO1lBQ0h4TixRQUFRd047UUFDWjtRQUVBLElBQUl0YSxFQUFFbzBCLGNBQWMsQ0FBQ1gsUUFBUSxDQUFDcUIsTUFBTTkwQixDQUFDLENBQUN5ekIsSUFBSSxHQUFHO1lBQ3pDLE1BQU0sSUFBSTN5QixNQUFNLFlBQVlkLElBQUksc0JBQXNCeXpCO1FBQzFEO1FBRUF6ekIsQ0FBQyxDQUFDeXpCLElBQUksR0FBRzNtQjtJQUNiO0lBRUEsT0FBTzlNO0FBQ1g7QUFFQSw2QkFBNkI7QUFDN0IsdUVBQXVFO0FBQ3ZFLFNBQVM0bUMsYUFBYWpqQyxJQUFJLEVBQUU3RixLQUFLLEVBQUUrb0MsSUFBSTtJQUNuQy9vQyxRQUFRQSxVQUFVOEgsWUFBWTlILFFBQVE7SUFDdEMsSUFBSW1vQyxTQUFTLElBQUkzcEIsTUFBTTFGLE1BQU0sQ0FBQ2pULE1BQU03RjtJQUNwQyxJQUFJNm9DLFVBQVUsRUFBRTtJQUNoQixJQUFJRyxXQUFXLEVBQUU7SUFDakJELE9BQU9BLFNBQVNqaEMsWUFBWWloQyxPQUFPbGpDLEtBQUs3RSxNQUFNO0lBRTlDLE1BQU9tbkMsT0FBT3B2QixjQUFjLEdBQUdnd0IsS0FBTTtRQUNqQyxJQUFJblMsS0FBS3VSLE9BQU9udkIsU0FBUztRQUV6Qiw4RkFBOEY7UUFDOUYsOEJBQThCO1FBQzlCLElBQUk0ZCxNQUFNLElBQUk7WUFDVix3REFBd0Q7WUFDeEQsSUFBSUEsT0FBTyxJQUFJO2dCQUNYQSxLQUFLLE9BQU91UixPQUFPbnZCLFNBQVM7WUFDaEM7WUFFQTZ2QixRQUFRamlDLElBQUksQ0FBQztnQkFBQ2d3QjtnQkFBSW9TO2FBQVM7WUFDM0JBLFdBQVcsRUFBRTtRQUNqQixPQUFPO1lBQ0gsZ0dBQWdHO1lBQ2hHLGtDQUFrQztZQUNsQ0EsU0FBU3BpQyxJQUFJLENBQUMwaEMsYUFBYUgsUUFBUXZSO1FBQ3ZDO0lBQ0o7SUFFQSxPQUFPZ1MsZ0JBQWdCQztBQUMzQjtBQUVBLDhEQUE4RDtBQUM5RCxvRkFBb0Y7QUFDcEYsU0FBU0ksYUFBYUMsT0FBTyxFQUFFLzlCLEtBQUs7SUFDaEMsSUFBSUEsU0FBUyxLQUFLO1FBQ2RBLFFBQVE3QyxrQkFBa0IsQ0FBQzZDLE1BQU07SUFDckMsT0FBTztRQUNIQSxRQUFRKzlCLE9BQU8sQ0FBQy85QixRQUFRLElBQUk7SUFDaEM7SUFFQSxPQUFPQTtBQUNYO0FBRUEsd0dBQXdHO0FBQ3hHLG9HQUFvRztBQUNwRyxTQUFTZytCLGNBQWNDLElBQUksRUFBRUMsSUFBSSxFQUFFSCxPQUFPO0lBQ3RDLElBQUlJLFVBQVUsQ0FBQztJQUNmLElBQUl0NkI7SUFFSixrRkFBa0Y7SUFDbEYsaUNBQWlDO0lBQ2pDLElBQUssSUFBSTlPLElBQUksR0FBR0EsSUFBSW1wQyxLQUFLcm9DLE1BQU0sRUFBRWQsS0FBSyxFQUFHO1FBQ3JDLElBQUlzQixJQUFJNm5DLElBQUksQ0FBQ25wQyxFQUFFO1FBRWYsSUFBSXdILE1BQU1nRyxPQUFPLENBQUNsTSxFQUFFK0MsSUFBSSxHQUFHO1lBQ3ZCLElBQUlpWSxTQUFTLEVBQUU7WUFDZkEsT0FBT3hiLE1BQU0sR0FBR1EsRUFBRStDLElBQUksQ0FBQ3ZELE1BQU07WUFDN0IsSUFBSyxJQUFJWixJQUFJLEdBQUdBLElBQUlvQixFQUFFK0MsSUFBSSxDQUFDdkQsTUFBTSxFQUFFWixJQUFLO2dCQUNwQzRPLFFBQVFvNkIsSUFBSSxDQUFDNW5DLEVBQUVvMUIsRUFBRSxDQUFDLEtBQUs5dUIsWUFBWXNoQyxJQUFJLENBQUM1bkMsRUFBRW8xQixFQUFFLENBQUMsQ0FBQ3gyQixFQUFFLEdBQUcwSDtnQkFDbkQsSUFBSWtILFVBQVVsSCxXQUFXO29CQUNyQmtILFFBQ0l4TixFQUFFd04sS0FBSyxLQUFLbEgsYUFBYXRHLEVBQUV3TixLQUFLLENBQUM1TyxFQUFFLEtBQUswSCxZQUNsQ3RHLEVBQUV3TixLQUFLLENBQUM1TyxFQUFFLEdBQ1Y7Z0JBQ2Q7Z0JBQ0EsSUFBSW9CLEVBQUUrQyxJQUFJLENBQUNuRSxFQUFFLEtBQUssT0FBTztvQkFDckI0TyxRQUFRaTZCLGFBQWFDLFNBQVNsNkI7Z0JBQ2xDO2dCQUNBd04sTUFBTSxDQUFDcGMsRUFBRSxHQUFHNE87WUFDaEI7WUFDQXM2QixPQUFPLENBQUM5bkMsRUFBRTRKLElBQUksQ0FBQyxHQUFHb1I7UUFDdEIsT0FBTztZQUNIeE4sUUFBUW82QixJQUFJLENBQUM1bkMsRUFBRW8xQixFQUFFLENBQUM7WUFDbEIsSUFBSTVuQixVQUFVbEgsV0FBVztnQkFDckJrSCxRQUFReE4sRUFBRXdOLEtBQUssS0FBS2xILFlBQVl0RyxFQUFFd04sS0FBSyxHQUFHO1lBQzlDO1lBRUEsSUFBSXhOLEVBQUUrQyxJQUFJLEtBQUssT0FBTztnQkFDbEJ5SyxRQUFRaTZCLGFBQWFDLFNBQVNsNkI7WUFDbEM7WUFDQXM2QixPQUFPLENBQUM5bkMsRUFBRTRKLElBQUksQ0FBQyxHQUFHNEQ7UUFDdEI7SUFDSjtJQUVBLE9BQU9zNkI7QUFDWDtBQUVBLHdCQUF3QjtBQUN4QixTQUFTQyxlQUFlMWpDLElBQUksRUFBRTdGLEtBQUs7SUFDL0IsSUFBSXdwQyxTQUFTLENBQUM7SUFDZEEsT0FBT0MsV0FBVyxHQUFHanJCLE1BQU1DLFFBQVEsQ0FBQzVZLE1BQU03RjtJQUMxQ3dwQyxPQUFPRSxXQUFXLEdBQUdsckIsTUFBTUMsUUFBUSxDQUFDNVksTUFBTTdGLFFBQVE7SUFDbER3cEMsT0FBT1QsSUFBSSxHQUFHdnFCLE1BQU1DLFFBQVEsQ0FBQzVZLE1BQU03RixRQUFRO0lBQzNDd3BDLE9BQU96QixVQUFVLEdBQUd2cEIsTUFBTUMsUUFBUSxDQUFDNVksTUFBTTdGLFFBQVE7SUFDakR3cEMsT0FBT3J4QixXQUFXLEdBQUduWTtJQUNyQndwQyxPQUFPcHhCLFNBQVMsR0FBR3BZLFFBQVE7SUFDM0IsT0FBT3dwQztBQUNYO0FBRUEsSUFBSUcsZ0JBQWdCO0lBQ2hCO1FBQUV2K0IsTUFBTTtRQUFXd3JCLElBQUk7UUFBR3J5QixNQUFNO0lBQU07SUFDdEM7UUFBRTZHLE1BQU07UUFBVXdyQixJQUFJO1FBQUdyeUIsTUFBTTtJQUFNO0lBQ3JDO1FBQUU2RyxNQUFNO1FBQWF3ckIsSUFBSTtRQUFNcnlCLE1BQU07SUFBTTtJQUMzQztRQUFFNkcsTUFBTTtRQUFZd3JCLElBQUk7UUFBR3J5QixNQUFNO0lBQU07SUFDdkM7UUFBRTZHLE1BQU07UUFBY3dyQixJQUFJO1FBQUdyeUIsTUFBTTtJQUFNO0lBQ3pDO1FBQUU2RyxNQUFNO1FBQVV3ckIsSUFBSTtRQUFHcnlCLE1BQU07SUFBTTtJQUNyQztRQUFFNkcsTUFBTTtRQUFnQndyQixJQUFJO1FBQU1yeUIsTUFBTTtRQUFVeUssT0FBTztJQUFFO0lBQzNEO1FBQUU1RCxNQUFNO1FBQWV3ckIsSUFBSTtRQUFNcnlCLE1BQU07UUFBVXlLLE9BQU87SUFBRTtJQUMxRDtRQUFFNUQsTUFBTTtRQUFxQndyQixJQUFJO1FBQU1yeUIsTUFBTTtRQUFVeUssT0FBTyxDQUFDO0lBQUk7SUFDbkU7UUFBRTVELE1BQU07UUFBc0J3ckIsSUFBSTtRQUFNcnlCLE1BQU07UUFBVXlLLE9BQU87SUFBRztJQUNsRTtRQUFFNUQsTUFBTTtRQUFhd3JCLElBQUk7UUFBTXJ5QixNQUFNO1FBQVV5SyxPQUFPO0lBQUU7SUFDeEQ7UUFBRTVELE1BQU07UUFBa0J3ckIsSUFBSTtRQUFNcnlCLE1BQU07UUFBVXlLLE9BQU87SUFBRTtJQUM3RDtRQUNJNUQsTUFBTTtRQUNOd3JCLElBQUk7UUFDSnJ5QixNQUFNO1lBQUM7WUFBUTtZQUFRO1lBQVE7WUFBUTtZQUFRO1NBQU87UUFDdER5SyxPQUFPO1lBQUM7WUFBTztZQUFHO1lBQUc7WUFBTztZQUFHO1NBQUU7SUFDckM7SUFDQTtRQUFFNUQsTUFBTTtRQUFZd3JCLElBQUk7UUFBSXJ5QixNQUFNO0lBQVM7SUFDM0M7UUFDSTZHLE1BQU07UUFDTndyQixJQUFJO1FBQ0pyeUIsTUFBTTtZQUFDO1lBQVU7WUFBVTtZQUFVO1NBQVM7UUFDOUN5SyxPQUFPO1lBQUM7WUFBRztZQUFHO1lBQUc7U0FBRTtJQUN2QjtJQUNBO1FBQUU1RCxNQUFNO1FBQWV3ckIsSUFBSTtRQUFNcnlCLE1BQU07UUFBVXlLLE9BQU87SUFBRTtJQUMxRDtRQUFFNUQsTUFBTTtRQUFRd3JCLElBQUk7UUFBSXJ5QixNQUFNLEVBQUU7UUFBRXlLLE9BQU87SUFBSztJQUM5QztRQUFFNUQsTUFBTTtRQUFXd3JCLElBQUk7UUFBSXJ5QixNQUFNO1FBQVV5SyxPQUFPO0lBQUU7SUFDcEQ7UUFBRTVELE1BQU07UUFBWXdyQixJQUFJO1FBQUlyeUIsTUFBTTtRQUFVeUssT0FBTztJQUFFO0lBQ3JEO1FBQUU1RCxNQUFNO1FBQWV3ckIsSUFBSTtRQUFJcnlCLE1BQU07UUFBVXlLLE9BQU87SUFBRTtJQUN4RDtRQUFFNUQsTUFBTTtRQUFXd3JCLElBQUk7UUFBSXJ5QixNQUFNO1lBQUM7WUFBVTtTQUFTO1FBQUV5SyxPQUFPO1lBQUM7WUFBRztTQUFFO0lBQUM7SUFDckU7UUFBRTVELE1BQU07UUFBT3dyQixJQUFJO1FBQU1yeUIsTUFBTTtZQUFDO1lBQU87WUFBTztTQUFTO0lBQUM7SUFDeEQ7UUFBRTZHLE1BQU07UUFBa0J3ckIsSUFBSTtRQUFNcnlCLE1BQU07UUFBVXlLLE9BQU87SUFBRTtJQUM3RDtRQUFFNUQsTUFBTTtRQUFtQndyQixJQUFJO1FBQU1yeUIsTUFBTTtRQUFVeUssT0FBTztJQUFFO0lBQzlEO1FBQUU1RCxNQUFNO1FBQWV3ckIsSUFBSTtRQUFNcnlCLE1BQU07UUFBVXlLLE9BQU87SUFBRTtJQUMxRDtRQUFFNUQsTUFBTTtRQUFZd3JCLElBQUk7UUFBTXJ5QixNQUFNO1FBQVV5SyxPQUFPO0lBQUs7SUFDMUQ7UUFBRTVELE1BQU07UUFBV3dyQixJQUFJO1FBQU1yeUIsTUFBTTtJQUFTO0lBQzVDO1FBQUU2RyxNQUFNO1FBQVd3ckIsSUFBSTtRQUFNcnlCLE1BQU07SUFBUztJQUM1QztRQUFFNkcsTUFBTTtRQUFZd3JCLElBQUk7UUFBTXJ5QixNQUFNO0lBQVM7SUFDN0M7UUFBRTZHLE1BQU07UUFBWXdyQixJQUFJO1FBQU1yeUIsTUFBTTtJQUFNO0NBQUc7QUFFakQsSUFBSXFsQyxvQkFBb0I7SUFDcEI7UUFBRXgrQixNQUFNO1FBQVN3ckIsSUFBSTtRQUFJcnlCLE1BQU07UUFBVXlLLE9BQU87SUFBRTtJQUNsRDtRQUFFNUQsTUFBTTtRQUFpQndyQixJQUFJO1FBQUlyeUIsTUFBTTtRQUFVeUssT0FBTztJQUFFO0lBQzFEO1FBQUU1RCxNQUFNO1FBQWlCd3JCLElBQUk7UUFBSXJ5QixNQUFNO1FBQVV5SyxPQUFPO0lBQUU7Q0FBRztBQUVqRSw0R0FBNEc7QUFDNUcseUdBQXlHO0FBQ3pHLFNBQVM2NkIsZ0JBQWdCaGtDLElBQUksRUFBRXFqQyxPQUFPO0lBQ2xDLElBQUlFLE9BQU9OLGFBQWFqakMsTUFBTSxHQUFHQSxLQUFLaWtDLFVBQVU7SUFDaEQsT0FBT1gsY0FBY0MsTUFBTU8sZUFBZVQ7QUFDOUM7QUFFQSxvR0FBb0c7QUFDcEcsU0FBU2Esb0JBQW9CbGtDLElBQUksRUFBRTdGLEtBQUssRUFBRStvQyxJQUFJLEVBQUVHLE9BQU87SUFDbkQsSUFBSUUsT0FBT04sYUFBYWpqQyxNQUFNN0YsT0FBTytvQztJQUNyQyxPQUFPSSxjQUFjQyxNQUFNUSxtQkFBbUJWO0FBQ2xEO0FBRUEsMkRBQTJEO0FBQzNELHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsMkRBQTJEO0FBQzNELEVBQUU7QUFDRiwyRUFBMkU7QUFDM0UseURBQXlEO0FBQ3pELEVBQUU7QUFDRix1RUFBdUU7QUFDdkUscUVBQXFFO0FBQ3JFLDhFQUE4RTtBQUM5RSx3REFBd0Q7QUFDeEQsNEVBQTRFO0FBQzVFLEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsU0FBU2Msa0JBQWtCbmtDLElBQUksRUFBRTdGLEtBQUssRUFBRWlxQyxRQUFRLEVBQUVmLE9BQU87SUFDckQsSUFBSWdCLGVBQWUsRUFBRTtJQUNyQixJQUFLLElBQUlDLFdBQVcsR0FBR0EsV0FBV0YsU0FBU2pwQyxNQUFNLEVBQUVtcEMsWUFBWSxFQUFHO1FBQzlELElBQUlDLGNBQWMsSUFBSUMsU0FDbEIsSUFBSS9xQyxXQUFXMnFDLFFBQVEsQ0FBQ0UsU0FBUyxFQUFFRyxNQUFNO1FBRTdDLElBQUlDLFVBQVVWLGdCQUFnQk8sYUFBYWxCO1FBQzNDcUIsUUFBUUMsTUFBTSxHQUFHLEVBQUU7UUFDbkJELFFBQVFFLFVBQVUsR0FBRztRQUNyQkYsUUFBUUcsY0FBYyxHQUFHO1FBQ3pCSCxRQUFRSSxjQUFjLEdBQUc7UUFDekIsSUFBSUMsY0FBY0wsUUFBUU0sT0FBTyxDQUFDLEVBQUU7UUFDcEMsSUFBSUMsZ0JBQWdCUCxRQUFRTSxPQUFPLENBQUMsRUFBRTtRQUN0QyxJQUFJRCxnQkFBZ0IsS0FBS0Usa0JBQWtCLEdBQUc7WUFDMUMsSUFBSUMsY0FBY2hCLG9CQUNkbGtDLE1BQ0FpbEMsZ0JBQWdCOXFDLE9BQ2hCNHFDLGFBQ0ExQjtZQUVKcUIsUUFBUUcsY0FBYyxHQUFHSyxZQUFZQyxhQUFhO1lBQ2xEVCxRQUFRSSxjQUFjLEdBQUdJLFlBQVlFLGFBQWE7WUFDbEQsSUFBSUYsWUFBWXRELEtBQUssS0FBSyxHQUFHO2dCQUN6QixJQUFJeUQsYUFBYUosZ0JBQWdCQyxZQUFZdEQsS0FBSztnQkFDbEQsSUFBSTBELFlBQVl4RCxjQUFjOWhDLE1BQU1xbEMsYUFBYWxyQztnQkFDakR1cUMsUUFBUUMsTUFBTSxHQUFHVyxVQUFVdEQsT0FBTztnQkFDbEMwQyxRQUFRRSxVQUFVLEdBQUdqRCxzQkFBc0IrQyxRQUFRQyxNQUFNO1lBQzdEO1lBQ0FELFFBQVFhLFlBQVksR0FBR0w7UUFDM0I7UUFDQWIsYUFBYXRqQyxJQUFJLENBQUMyakM7SUFDdEI7SUFDQSxPQUFPTDtBQUNYO0FBRUEsaUZBQWlGO0FBQ2pGLG1EQUFtRDtBQUNuRCw2Q0FBNkM7QUFDN0MsU0FBU21CLGdCQUFnQnhsQyxJQUFJLEVBQUU3RixLQUFLLEVBQUVzckMsT0FBTyxFQUFFcEMsT0FBTztJQUNsRCxJQUFJcUM7SUFDSixJQUFJaHhCO0lBQ0osSUFBSTR0QixTQUFTLElBQUkzcEIsTUFBTTFGLE1BQU0sQ0FBQ2pULE1BQU03RjtJQUVwQyxvREFBb0Q7SUFDcERzckMsV0FBVztJQUNYLElBQUloaUMsVUFBVTtRQUFDO0tBQVU7SUFFekIsSUFBSXlJLFNBQVNvMkIsT0FBT2p2QixVQUFVO0lBQzlCLElBQUluSCxXQUFXLEdBQUc7UUFDZCxJQUFLLElBQUk3UixJQUFJLEdBQUdBLElBQUlvckMsU0FBU3ByQyxLQUFLLEVBQUc7WUFDakNxckMsTUFBTXBELE9BQU85dUIsUUFBUTtZQUNyQi9QLFFBQVExQyxJQUFJLENBQUNxaUMsYUFBYUMsU0FBU3FDO1FBQ3ZDO0lBQ0osT0FBTyxJQUFJeDVCLFdBQVcsR0FBRztRQUNyQixNQUFPekksUUFBUXRJLE1BQU0sSUFBSXNxQyxRQUFTO1lBQzlCQyxNQUFNcEQsT0FBTzl1QixRQUFRO1lBQ3JCa0IsUUFBUTR0QixPQUFPanZCLFVBQVU7WUFDekIsSUFBSyxJQUFJdUcsTUFBTSxHQUFHQSxPQUFPbEYsT0FBT2tGLE9BQU8sRUFBRztnQkFDdENuVyxRQUFRMUMsSUFBSSxDQUFDcWlDLGFBQWFDLFNBQVNxQztnQkFDbkNBLE9BQU87WUFDWDtRQUNKO0lBQ0osT0FBTyxJQUFJeDVCLFdBQVcsR0FBRztRQUNyQixNQUFPekksUUFBUXRJLE1BQU0sSUFBSXNxQyxRQUFTO1lBQzlCQyxNQUFNcEQsT0FBTzl1QixRQUFRO1lBQ3JCa0IsUUFBUTR0QixPQUFPL3VCLFdBQVc7WUFDMUIsSUFBSyxJQUFJdUcsTUFBTSxHQUFHQSxPQUFPcEYsT0FBT29GLE9BQU8sRUFBRztnQkFDdENyVyxRQUFRMUMsSUFBSSxDQUFDcWlDLGFBQWFDLFNBQVNxQztnQkFDbkNBLE9BQU87WUFDWDtRQUNKO0lBQ0osT0FBTztRQUNILE1BQU0sSUFBSXZvQyxNQUFNLDRCQUE0QitPO0lBQ2hEO0lBRUEsT0FBT3pJO0FBQ1g7QUFFQSw0RUFBNEU7QUFDNUUsOENBQThDO0FBQzlDLFNBQVNraUMsaUJBQWlCM2xDLElBQUksRUFBRTdGLEtBQUssRUFBRXNKLE9BQU87SUFDMUMsSUFBSXJHO0lBQ0osSUFBSXdvQyxNQUFNLENBQUM7SUFDWCxJQUFJdEQsU0FBUyxJQUFJM3BCLE1BQU0xRixNQUFNLENBQUNqVCxNQUFNN0Y7SUFDcEMsSUFBSStSLFNBQVNvMkIsT0FBT2p2QixVQUFVO0lBQzlCLElBQUluSCxXQUFXLEdBQUc7UUFDZCxJQUFJMjVCLFNBQVN2RCxPQUFPanZCLFVBQVU7UUFDOUIsSUFBSyxJQUFJaFosSUFBSSxHQUFHQSxJQUFJd3JDLFFBQVF4ckMsS0FBSyxFQUFHO1lBQ2hDK0MsT0FBT2tsQyxPQUFPanZCLFVBQVU7WUFDeEJ1eUIsR0FBRyxDQUFDeG9DLEtBQUssR0FBRy9DO1FBQ2hCO0lBQ0osT0FBTyxJQUFJNlIsV0FBVyxHQUFHO1FBQ3JCLElBQUk0NUIsVUFBVXhELE9BQU9qdkIsVUFBVTtRQUMvQmpXLE9BQU87UUFDUCxJQUFLLElBQUl3YyxNQUFNLEdBQUdBLE1BQU1rc0IsU0FBU2xzQixPQUFPLEVBQUc7WUFDdkMsSUFBSW1zQixRQUFRekQsT0FBT2p2QixVQUFVO1lBQzdCLElBQUkyeUIsUUFBUTFELE9BQU9qdkIsVUFBVTtZQUM3QixJQUFLLElBQUk5WSxJQUFJd3JDLE9BQU94ckMsS0FBS3dyQyxRQUFRQyxPQUFPenJDLEtBQUssRUFBRztnQkFDNUNxckMsR0FBRyxDQUFDcnJDLEVBQUUsR0FBRzZDO2dCQUNUQSxRQUFRO1lBQ1o7UUFDSjtJQUNKLE9BQU87UUFDSCxNQUFNLElBQUlELE1BQU0sNkJBQTZCK087SUFDakQ7SUFFQSxPQUFPLElBQUkzSSxZQUFZcWlDLEtBQUtuaUM7QUFDaEM7QUFFQSxxREFBcUQ7QUFDckQsNERBQTREO0FBQzVELDJEQUEyRDtBQUMzRCxTQUFTK0UsbUJBQW1CM0YsSUFBSSxFQUFFSSxLQUFLLEVBQUU3RixJQUFJO0lBQ3pDLElBQUk2b0M7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJaHFDLElBQUksSUFBSW1FO0lBQ1osSUFBSW1oQixRQUFRLEVBQUU7SUFDZCxJQUFJMmtCLFNBQVM7SUFDYixJQUFJQyxZQUFZO0lBQ2hCLElBQUlDLE9BQU87SUFDWCxJQUFJenJDLElBQUk7SUFDUixJQUFJZ0csSUFBSTtJQUNSLElBQUk4Z0M7SUFDSixJQUFJNEU7SUFDSixJQUFJckI7SUFDSixJQUFJQztJQUNKLElBQUl2aUMsS0FBSzRqQyxTQUFTLEVBQUU7UUFDaEIsSUFBSUMsVUFBVTdqQyxLQUFLZ0IsTUFBTSxDQUFDOGlDLEdBQUcsQ0FBQ2pDLE9BQU8sQ0FBQ2tDLFNBQVMsQ0FBQzNqQyxNQUFNcUMsS0FBSyxDQUFDO1FBQzVELElBQUl1aEMsU0FBU2hrQyxLQUFLZ0IsTUFBTSxDQUFDOGlDLEdBQUcsQ0FBQ2pDLE9BQU8sQ0FBQ29DLFFBQVEsQ0FBQ0osUUFBUTtRQUN0RDlFLFFBQVFpRixPQUFPbEMsTUFBTTtRQUNyQjZCLFlBQVlLLE9BQU9qQyxVQUFVO1FBQzdCTyxnQkFBZ0IwQixPQUFPaEMsY0FBYztRQUNyQ08sZ0JBQWdCeUIsT0FBTy9CLGNBQWM7SUFDekMsT0FBTztRQUNIbEQsUUFBUS8rQixLQUFLZ0IsTUFBTSxDQUFDOGlDLEdBQUcsQ0FBQ2pDLE9BQU8sQ0FBQ0MsTUFBTTtRQUN0QzZCLFlBQVkzakMsS0FBS2dCLE1BQU0sQ0FBQzhpQyxHQUFHLENBQUNqQyxPQUFPLENBQUNFLFVBQVU7UUFDOUNPLGdCQUFnQnRpQyxLQUFLZ0IsTUFBTSxDQUFDOGlDLEdBQUcsQ0FBQ2pDLE9BQU8sQ0FBQ0csY0FBYztRQUN0RE8sZ0JBQWdCdmlDLEtBQUtnQixNQUFNLENBQUM4aUMsR0FBRyxDQUFDakMsT0FBTyxDQUFDSSxjQUFjO0lBQzFEO0lBQ0EsSUFBSWlDLFFBQVE1QjtJQUVaLFNBQVM2QixXQUFXbHNDLENBQUMsRUFBRWdHLENBQUM7UUFDcEIsSUFBSXlsQyxNQUFNO1lBQ05ucUMsRUFBRXNGLFNBQVM7UUFDZjtRQUVBdEYsRUFBRXlFLE1BQU0sQ0FBQy9GLEdBQUdnRztRQUNaeWxDLE9BQU87SUFDWDtJQUVBLFNBQVNVO1FBQ0wsSUFBSUM7UUFFSiw0REFBNEQ7UUFDNUQsMkRBQTJEO1FBQzNEQSxjQUFjeGxCLE1BQU12bUIsTUFBTSxHQUFHLE1BQU07UUFDbkMsSUFBSStyQyxlQUFlLENBQUNaLFdBQVc7WUFDM0JTLFFBQVFybEIsTUFBTThULEtBQUssS0FBSzRQO1FBQzVCO1FBRUFpQixVQUFVM2tCLE1BQU12bUIsTUFBTSxJQUFJO1FBQzFCdW1CLE1BQU12bUIsTUFBTSxHQUFHO1FBQ2ZtckMsWUFBWTtJQUNoQjtJQUVBLFNBQVMzdEIsTUFBTXZiLElBQUk7UUFDZixJQUFJdWxDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSXFFO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFFSixJQUFJcnRDLElBQUk7UUFDUixNQUFPQSxJQUFJK0MsS0FBS2pDLE1BQU0sQ0FBRTtZQUNwQixJQUFJTyxJQUFJMEIsSUFBSSxDQUFDL0MsRUFBRTtZQUNmQSxLQUFLO1lBQ0wsT0FBUXFCO2dCQUNKLEtBQUs7b0JBQ0R1ckM7b0JBQ0E7Z0JBQ0osS0FBSztvQkFDREE7b0JBQ0E7Z0JBQ0osS0FBSztvQkFDRCxJQUFJdmxCLE1BQU12bUIsTUFBTSxHQUFHLEtBQUssQ0FBQ21yQyxXQUFXO3dCQUNoQ1MsUUFBUXJsQixNQUFNOFQsS0FBSyxLQUFLNFA7d0JBQ3hCa0IsWUFBWTtvQkFDaEI7b0JBRUF4bEMsS0FBSzRnQixNQUFNOEMsR0FBRztvQkFDZHdpQixXQUFXbHNDLEdBQUdnRztvQkFDZDtnQkFDSixLQUFLO29CQUNELE1BQU80Z0IsTUFBTXZtQixNQUFNLEdBQUcsRUFBRzt3QkFDckJMLEtBQUs0bUIsTUFBTThULEtBQUs7d0JBQ2hCMTBCLEtBQUs0Z0IsTUFBTThULEtBQUs7d0JBQ2hCcDVCLEVBQUU0RSxNQUFNLENBQUNsRyxHQUFHZ0c7b0JBQ2hCO29CQUVBO2dCQUNKLEtBQUs7b0JBQ0QsTUFBTzRnQixNQUFNdm1CLE1BQU0sR0FBRyxFQUFHO3dCQUNyQkwsS0FBSzRtQixNQUFNOFQsS0FBSzt3QkFDaEJwNUIsRUFBRTRFLE1BQU0sQ0FBQ2xHLEdBQUdnRzt3QkFDWixJQUFJNGdCLE1BQU12bUIsTUFBTSxLQUFLLEdBQUc7NEJBQ3BCO3dCQUNKO3dCQUVBMkYsS0FBSzRnQixNQUFNOFQsS0FBSzt3QkFDaEJwNUIsRUFBRTRFLE1BQU0sQ0FBQ2xHLEdBQUdnRztvQkFDaEI7b0JBRUE7Z0JBQ0osS0FBSztvQkFDRCxNQUFPNGdCLE1BQU12bUIsTUFBTSxHQUFHLEVBQUc7d0JBQ3JCMkYsS0FBSzRnQixNQUFNOFQsS0FBSzt3QkFDaEJwNUIsRUFBRTRFLE1BQU0sQ0FBQ2xHLEdBQUdnRzt3QkFDWixJQUFJNGdCLE1BQU12bUIsTUFBTSxLQUFLLEdBQUc7NEJBQ3BCO3dCQUNKO3dCQUVBTCxLQUFLNG1CLE1BQU04VCxLQUFLO3dCQUNoQnA1QixFQUFFNEUsTUFBTSxDQUFDbEcsR0FBR2dHO29CQUNoQjtvQkFFQTtnQkFDSixLQUFLO29CQUNELE1BQU80Z0IsTUFBTXZtQixNQUFNLEdBQUcsRUFBRzt3QkFDckI4cUMsTUFBTW5yQyxJQUFJNG1CLE1BQU04VCxLQUFLO3dCQUNyQjBRLE1BQU1wbEMsSUFBSTRnQixNQUFNOFQsS0FBSzt3QkFDckIyUSxNQUFNRixNQUFNdmtCLE1BQU04VCxLQUFLO3dCQUN2QjRRLE1BQU1GLE1BQU14a0IsTUFBTThULEtBQUs7d0JBQ3ZCMTZCLElBQUlxckMsTUFBTXprQixNQUFNOFQsS0FBSzt3QkFDckIxMEIsSUFBSXNsQyxNQUFNMWtCLE1BQU04VCxLQUFLO3dCQUNyQnA1QixFQUFFNkUsT0FBTyxDQUFDZ2xDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUt0ckMsR0FBR2dHO29CQUNyQztvQkFFQTtnQkFDSixLQUFLO29CQUNEcW1DLFlBQVl6bEIsTUFBTThDLEdBQUcsS0FBS2dpQjtvQkFDMUJZLFdBQVd4RixLQUFLLENBQUN1RixVQUFVO29CQUMzQixJQUFJQyxVQUFVO3dCQUNWenVCLE1BQU15dUI7b0JBQ1Y7b0JBRUE7Z0JBQ0osS0FBSztvQkFDRDtnQkFDSixLQUFLO29CQUNEMXJDLElBQUkwQixJQUFJLENBQUMvQyxFQUFFO29CQUNYQSxLQUFLO29CQUNMLE9BQVFxQjt3QkFDSixLQUFLOzRCQUNELHdFQUF3RTs0QkFDeEV1cUMsTUFBTW5yQyxJQUFJNG1CLE1BQU04VCxLQUFLLElBQUksTUFBTTs0QkFDL0IwUSxNQUFNcGxDLElBQUk0Z0IsTUFBTThULEtBQUssSUFBSSxNQUFNOzRCQUMvQjJRLE1BQU1GLE1BQU12a0IsTUFBTThULEtBQUssSUFBSSxNQUFNOzRCQUNqQzRRLE1BQU1GLE1BQU14a0IsTUFBTThULEtBQUssSUFBSSxNQUFNOzRCQUNqQzZSLE1BQU1sQixNQUFNemtCLE1BQU04VCxLQUFLLElBQUksTUFBTTs0QkFDakM4UixNQUFNbEIsTUFBTTFrQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDK1IsTUFBTUYsTUFBTTNsQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDZ1MsTUFBTUYsTUFBTTVsQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDaVMsTUFBTUYsTUFBTTdsQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDa1MsTUFBTUYsTUFBTTlsQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDMTZCLElBQUkyc0MsTUFBTS9sQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQy9CMTBCLElBQUk0bUMsTUFBTWhtQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQy9COVQsTUFBTThULEtBQUssSUFBSSxhQUFhOzRCQUM1QnA1QixFQUFFNkUsT0FBTyxDQUFDZ2xDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtpQixLQUFLQzs0QkFDbkNsckMsRUFBRTZFLE9BQU8sQ0FBQ3NtQyxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLNXNDLEdBQUdnRzs0QkFDakM7d0JBQ0osS0FBSzs0QkFDRCxrREFBa0Q7NEJBQ2xEbWxDLE1BQU1uckMsSUFBSTRtQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQy9CMFEsTUFBTXBsQyxHQUFHLE1BQU07NEJBQ2ZxbEMsTUFBTUYsTUFBTXZrQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDNFEsTUFBTUYsTUFBTXhrQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDNlIsTUFBTWxCLE1BQU16a0IsTUFBTThULEtBQUssSUFBSSxNQUFNOzRCQUNqQzhSLE1BQU1sQixLQUFLLE1BQU07NEJBQ2pCbUIsTUFBTUYsTUFBTTNsQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDZ1MsTUFBTXBCLEtBQUssTUFBTTs0QkFDakJxQixNQUFNRixNQUFNN2xCLE1BQU04VCxLQUFLLElBQUksTUFBTTs0QkFDakNrUyxNQUFNNW1DLEdBQUcsTUFBTTs0QkFDZmhHLElBQUkyc0MsTUFBTS9sQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQy9CcDVCLEVBQUU2RSxPQUFPLENBQUNnbEMsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS2lCLEtBQUtDOzRCQUNuQ2xyQyxFQUFFNkUsT0FBTyxDQUFDc21DLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUs1c0MsR0FBR2dHOzRCQUNqQzt3QkFDSixLQUFLOzRCQUNELDJEQUEyRDs0QkFDM0RtbEMsTUFBTW5yQyxJQUFJNG1CLE1BQU04VCxLQUFLLElBQUksTUFBTTs0QkFDL0IwUSxNQUFNcGxDLElBQUk0Z0IsTUFBTThULEtBQUssSUFBSSxNQUFNOzRCQUMvQjJRLE1BQU1GLE1BQU12a0IsTUFBTThULEtBQUssSUFBSSxNQUFNOzRCQUNqQzRRLE1BQU1GLE1BQU14a0IsTUFBTThULEtBQUssSUFBSSxNQUFNOzRCQUNqQzZSLE1BQU1sQixNQUFNemtCLE1BQU04VCxLQUFLLElBQUksTUFBTTs0QkFDakM4UixNQUFNbEIsS0FBSyxNQUFNOzRCQUNqQm1CLE1BQU1GLE1BQU0zbEIsTUFBTThULEtBQUssSUFBSSxNQUFNOzRCQUNqQ2dTLE1BQU1wQixLQUFLLE1BQU07NEJBQ2pCcUIsTUFBTUYsTUFBTTdsQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDa1MsTUFBTUYsTUFBTTlsQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDMTZCLElBQUkyc0MsTUFBTS9sQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQy9CcDVCLEVBQUU2RSxPQUFPLENBQUNnbEMsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS2lCLEtBQUtDOzRCQUNuQ2xyQyxFQUFFNkUsT0FBTyxDQUFDc21DLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUs1c0MsR0FBR2dHOzRCQUNqQzt3QkFDSixLQUFLOzRCQUNELGlFQUFpRTs0QkFDakVtbEMsTUFBTW5yQyxJQUFJNG1CLE1BQU04VCxLQUFLLElBQUksTUFBTTs0QkFDL0IwUSxNQUFNcGxDLElBQUk0Z0IsTUFBTThULEtBQUssSUFBSSxNQUFNOzRCQUMvQjJRLE1BQU1GLE1BQU12a0IsTUFBTThULEtBQUssSUFBSSxNQUFNOzRCQUNqQzRRLE1BQU1GLE1BQU14a0IsTUFBTThULEtBQUssSUFBSSxNQUFNOzRCQUNqQzZSLE1BQU1sQixNQUFNemtCLE1BQU04VCxLQUFLLElBQUksTUFBTTs0QkFDakM4UixNQUFNbEIsTUFBTTFrQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDK1IsTUFBTUYsTUFBTTNsQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDZ1MsTUFBTUYsTUFBTTVsQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDaVMsTUFBTUYsTUFBTTdsQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDa1MsTUFBTUYsTUFBTTlsQixNQUFNOFQsS0FBSyxJQUFJLE1BQU07NEJBQ2pDLElBQUl2M0IsS0FBSzhlLEdBQUcsQ0FBQzBxQixNQUFNM3NDLEtBQUttRCxLQUFLOGUsR0FBRyxDQUFDMnFCLE1BQU01bUMsSUFBSTtnQ0FDdkNoRyxJQUFJMnNDLE1BQU0vbEIsTUFBTThULEtBQUs7NEJBQ3pCLE9BQU87Z0NBQ0gxMEIsSUFBSTRtQyxNQUFNaG1CLE1BQU04VCxLQUFLOzRCQUN6Qjs0QkFFQXA1QixFQUFFNkUsT0FBTyxDQUFDZ2xDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUtpQixLQUFLQzs0QkFDbkNsckMsRUFBRTZFLE9BQU8sQ0FBQ3NtQyxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLNXNDLEdBQUdnRzs0QkFDakM7d0JBQ0o7NEJBQ0kwaEIsUUFBUUMsR0FBRyxDQUNQLFdBQ0l4ZixNQUFNcUMsS0FBSyxHQUNYLHdCQUNBLE9BQ0E1Sjs0QkFFUmdtQixNQUFNdm1CLE1BQU0sR0FBRztvQkFDdkI7b0JBQ0E7Z0JBQ0osS0FBSztvQkFDRCxJQUFJdW1CLE1BQU12bUIsTUFBTSxHQUFHLEtBQUssQ0FBQ21yQyxXQUFXO3dCQUNoQ1MsUUFBUXJsQixNQUFNOFQsS0FBSyxLQUFLNFA7d0JBQ3hCa0IsWUFBWTtvQkFDaEI7b0JBRUEsSUFBSUMsTUFBTTt3QkFDTm5xQyxFQUFFc0YsU0FBUzt3QkFDWDZrQyxPQUFPO29CQUNYO29CQUVBO2dCQUNKLEtBQUs7b0JBQ0RVO29CQUNBO2dCQUNKLEtBQUs7Z0JBQ0wsS0FBSztvQkFDREE7b0JBQ0E1c0MsS0FBSyxTQUFVLEtBQU07b0JBQ3JCO2dCQUNKLEtBQUs7b0JBQ0QsSUFBSXFuQixNQUFNdm1CLE1BQU0sR0FBRyxLQUFLLENBQUNtckMsV0FBVzt3QkFDaENTLFFBQVFybEIsTUFBTThULEtBQUssS0FBSzRQO3dCQUN4QmtCLFlBQVk7b0JBQ2hCO29CQUVBeGxDLEtBQUs0Z0IsTUFBTThDLEdBQUc7b0JBQ2QxcEIsS0FBSzRtQixNQUFNOEMsR0FBRztvQkFDZHdpQixXQUFXbHNDLEdBQUdnRztvQkFDZDtnQkFDSixLQUFLO29CQUNELElBQUk0Z0IsTUFBTXZtQixNQUFNLEdBQUcsS0FBSyxDQUFDbXJDLFdBQVc7d0JBQ2hDUyxRQUFRcmxCLE1BQU04VCxLQUFLLEtBQUs0UDt3QkFDeEJrQixZQUFZO29CQUNoQjtvQkFFQXhyQyxLQUFLNG1CLE1BQU04QyxHQUFHO29CQUNkd2lCLFdBQVdsc0MsR0FBR2dHO29CQUNkO2dCQUNKLEtBQUs7b0JBQ0RtbUM7b0JBQ0E7Z0JBQ0osS0FBSztvQkFDRCxNQUFPdmxCLE1BQU12bUIsTUFBTSxHQUFHLEVBQUc7d0JBQ3JCOHFDLE1BQU1uckMsSUFBSTRtQixNQUFNOFQsS0FBSzt3QkFDckIwUSxNQUFNcGxDLElBQUk0Z0IsTUFBTThULEtBQUs7d0JBQ3JCMlEsTUFBTUYsTUFBTXZrQixNQUFNOFQsS0FBSzt3QkFDdkI0USxNQUFNRixNQUFNeGtCLE1BQU04VCxLQUFLO3dCQUN2QjE2QixJQUFJcXJDLE1BQU16a0IsTUFBTThULEtBQUs7d0JBQ3JCMTBCLElBQUlzbEMsTUFBTTFrQixNQUFNOFQsS0FBSzt3QkFDckJwNUIsRUFBRTZFLE9BQU8sQ0FBQ2dsQyxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLdHJDLEdBQUdnRztvQkFDckM7b0JBRUFoRyxLQUFLNG1CLE1BQU04VCxLQUFLO29CQUNoQjEwQixLQUFLNGdCLE1BQU04VCxLQUFLO29CQUNoQnA1QixFQUFFNEUsTUFBTSxDQUFDbEcsR0FBR2dHO29CQUNaO2dCQUNKLEtBQUs7b0JBQ0QsTUFBTzRnQixNQUFNdm1CLE1BQU0sR0FBRyxFQUFHO3dCQUNyQkwsS0FBSzRtQixNQUFNOFQsS0FBSzt3QkFDaEIxMEIsS0FBSzRnQixNQUFNOFQsS0FBSzt3QkFDaEJwNUIsRUFBRTRFLE1BQU0sQ0FBQ2xHLEdBQUdnRztvQkFDaEI7b0JBRUFtbEMsTUFBTW5yQyxJQUFJNG1CLE1BQU04VCxLQUFLO29CQUNyQjBRLE1BQU1wbEMsSUFBSTRnQixNQUFNOFQsS0FBSztvQkFDckIyUSxNQUFNRixNQUFNdmtCLE1BQU04VCxLQUFLO29CQUN2QjRRLE1BQU1GLE1BQU14a0IsTUFBTThULEtBQUs7b0JBQ3ZCMTZCLElBQUlxckMsTUFBTXprQixNQUFNOFQsS0FBSztvQkFDckIxMEIsSUFBSXNsQyxNQUFNMWtCLE1BQU04VCxLQUFLO29CQUNyQnA1QixFQUFFNkUsT0FBTyxDQUFDZ2xDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUt0ckMsR0FBR2dHO29CQUNqQztnQkFDSixLQUFLO29CQUNELElBQUk0Z0IsTUFBTXZtQixNQUFNLEdBQUcsR0FBRzt3QkFDbEJMLEtBQUs0bUIsTUFBTThULEtBQUs7b0JBQ3BCO29CQUVBLE1BQU85VCxNQUFNdm1CLE1BQU0sR0FBRyxFQUFHO3dCQUNyQjhxQyxNQUFNbnJDO3dCQUNOb3JDLE1BQU1wbEMsSUFBSTRnQixNQUFNOFQsS0FBSzt3QkFDckIyUSxNQUFNRixNQUFNdmtCLE1BQU04VCxLQUFLO3dCQUN2QjRRLE1BQU1GLE1BQU14a0IsTUFBTThULEtBQUs7d0JBQ3ZCMTZCLElBQUlxckM7d0JBQ0pybEMsSUFBSXNsQyxNQUFNMWtCLE1BQU04VCxLQUFLO3dCQUNyQnA1QixFQUFFNkUsT0FBTyxDQUFDZ2xDLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUt0ckMsR0FBR2dHO29CQUNyQztvQkFFQTtnQkFDSixLQUFLO29CQUNELElBQUk0Z0IsTUFBTXZtQixNQUFNLEdBQUcsR0FBRzt3QkFDbEIyRixLQUFLNGdCLE1BQU04VCxLQUFLO29CQUNwQjtvQkFFQSxNQUFPOVQsTUFBTXZtQixNQUFNLEdBQUcsRUFBRzt3QkFDckI4cUMsTUFBTW5yQyxJQUFJNG1CLE1BQU04VCxLQUFLO3dCQUNyQjBRLE1BQU1wbEM7d0JBQ05xbEMsTUFBTUYsTUFBTXZrQixNQUFNOFQsS0FBSzt3QkFDdkI0USxNQUFNRixNQUFNeGtCLE1BQU04VCxLQUFLO3dCQUN2QjE2QixJQUFJcXJDLE1BQU16a0IsTUFBTThULEtBQUs7d0JBQ3JCMTBCLElBQUlzbEM7d0JBQ0pocUMsRUFBRTZFLE9BQU8sQ0FBQ2dsQyxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLdHJDLEdBQUdnRztvQkFDckM7b0JBRUE7Z0JBQ0osS0FBSztvQkFDRDZoQyxLQUFLdmxDLElBQUksQ0FBQy9DLEVBQUU7b0JBQ1p1b0MsS0FBS3hsQyxJQUFJLENBQUMvQyxJQUFJLEVBQUU7b0JBQ2hCcW5CLE1BQU0zZ0IsSUFBSSxDQUFDLENBQUMsTUFBTyxLQUFPNmhDLE1BQU0sRUFBRSxLQUFNO29CQUN4Q3ZvQyxLQUFLO29CQUNMO2dCQUNKLEtBQUs7b0JBQ0Q4c0MsWUFBWXpsQixNQUFNOEMsR0FBRyxLQUFLM2hCLEtBQUs4a0MsVUFBVTtvQkFDekNQLFdBQVd2a0MsS0FBSytrQyxNQUFNLENBQUNULFVBQVU7b0JBQ2pDLElBQUlDLFVBQVU7d0JBQ1Z6dUIsTUFBTXl1QjtvQkFDVjtvQkFFQTtnQkFDSixLQUFLO29CQUNELE1BQU8xbEIsTUFBTXZtQixNQUFNLEdBQUcsRUFBRzt3QkFDckI4cUMsTUFBTW5yQzt3QkFDTm9yQyxNQUFNcGxDLElBQUk0Z0IsTUFBTThULEtBQUs7d0JBQ3JCMlEsTUFBTUYsTUFBTXZrQixNQUFNOFQsS0FBSzt3QkFDdkI0USxNQUFNRixNQUFNeGtCLE1BQU04VCxLQUFLO3dCQUN2QjE2QixJQUFJcXJDLE1BQU16a0IsTUFBTThULEtBQUs7d0JBQ3JCMTBCLElBQUlzbEMsTUFBTzFrQixDQUFBQSxNQUFNdm1CLE1BQU0sS0FBSyxJQUFJdW1CLE1BQU04VCxLQUFLLEtBQUs7d0JBQ2hEcDVCLEVBQUU2RSxPQUFPLENBQUNnbEMsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS3RyQyxHQUFHZ0c7d0JBQ2pDLElBQUk0Z0IsTUFBTXZtQixNQUFNLEtBQUssR0FBRzs0QkFDcEI7d0JBQ0o7d0JBRUE4cUMsTUFBTW5yQyxJQUFJNG1CLE1BQU04VCxLQUFLO3dCQUNyQjBRLE1BQU1wbEM7d0JBQ05xbEMsTUFBTUYsTUFBTXZrQixNQUFNOFQsS0FBSzt3QkFDdkI0USxNQUFNRixNQUFNeGtCLE1BQU04VCxLQUFLO3dCQUN2QjEwQixJQUFJc2xDLE1BQU0xa0IsTUFBTThULEtBQUs7d0JBQ3JCMTZCLElBQUlxckMsTUFBT3prQixDQUFBQSxNQUFNdm1CLE1BQU0sS0FBSyxJQUFJdW1CLE1BQU04VCxLQUFLLEtBQUs7d0JBQ2hEcDVCLEVBQUU2RSxPQUFPLENBQUNnbEMsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS3RyQyxHQUFHZ0c7b0JBQ3JDO29CQUVBO2dCQUNKLEtBQUs7b0JBQ0QsTUFBTzRnQixNQUFNdm1CLE1BQU0sR0FBRyxFQUFHO3dCQUNyQjhxQyxNQUFNbnJDLElBQUk0bUIsTUFBTThULEtBQUs7d0JBQ3JCMFEsTUFBTXBsQzt3QkFDTnFsQyxNQUFNRixNQUFNdmtCLE1BQU04VCxLQUFLO3dCQUN2QjRRLE1BQU1GLE1BQU14a0IsTUFBTThULEtBQUs7d0JBQ3ZCMTBCLElBQUlzbEMsTUFBTTFrQixNQUFNOFQsS0FBSzt3QkFDckIxNkIsSUFBSXFyQyxNQUFPemtCLENBQUFBLE1BQU12bUIsTUFBTSxLQUFLLElBQUl1bUIsTUFBTThULEtBQUssS0FBSzt3QkFDaERwNUIsRUFBRTZFLE9BQU8sQ0FBQ2dsQyxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLdHJDLEdBQUdnRzt3QkFDakMsSUFBSTRnQixNQUFNdm1CLE1BQU0sS0FBSyxHQUFHOzRCQUNwQjt3QkFDSjt3QkFFQThxQyxNQUFNbnJDO3dCQUNOb3JDLE1BQU1wbEMsSUFBSTRnQixNQUFNOFQsS0FBSzt3QkFDckIyUSxNQUFNRixNQUFNdmtCLE1BQU04VCxLQUFLO3dCQUN2QjRRLE1BQU1GLE1BQU14a0IsTUFBTThULEtBQUs7d0JBQ3ZCMTZCLElBQUlxckMsTUFBTXprQixNQUFNOFQsS0FBSzt3QkFDckIxMEIsSUFBSXNsQyxNQUFPMWtCLENBQUFBLE1BQU12bUIsTUFBTSxLQUFLLElBQUl1bUIsTUFBTThULEtBQUssS0FBSzt3QkFDaERwNUIsRUFBRTZFLE9BQU8sQ0FBQ2dsQyxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLdHJDLEdBQUdnRztvQkFDckM7b0JBRUE7Z0JBQ0o7b0JBQ0ksSUFBSXBGLElBQUksSUFBSTt3QkFDUjhtQixRQUFRQyxHQUFHLENBQ1AsV0FBV3hmLE1BQU1xQyxLQUFLLEdBQUcsd0JBQXdCNUo7b0JBRXpELE9BQU8sSUFBSUEsSUFBSSxLQUFLO3dCQUNoQmdtQixNQUFNM2dCLElBQUksQ0FBQ3JGLElBQUk7b0JBQ25CLE9BQU8sSUFBSUEsSUFBSSxLQUFLO3dCQUNoQmluQyxLQUFLdmxDLElBQUksQ0FBQy9DLEVBQUU7d0JBQ1pBLEtBQUs7d0JBQ0xxbkIsTUFBTTNnQixJQUFJLENBQUMsQ0FBQ3JGLElBQUksR0FBRSxJQUFLLE1BQU1pbkMsS0FBSztvQkFDdEMsT0FBTyxJQUFJam5DLElBQUksS0FBSzt3QkFDaEJpbkMsS0FBS3ZsQyxJQUFJLENBQUMvQyxFQUFFO3dCQUNaQSxLQUFLO3dCQUNMcW5CLE1BQU0zZ0IsSUFBSSxDQUFDLENBQUVyRixDQUFBQSxJQUFJLEdBQUUsSUFBSyxNQUFNaW5DLEtBQUs7b0JBQ3ZDLE9BQU87d0JBQ0hBLEtBQUt2bEMsSUFBSSxDQUFDL0MsRUFBRTt3QkFDWnVvQyxLQUFLeGxDLElBQUksQ0FBQy9DLElBQUksRUFBRTt3QkFDaEJ3b0MsS0FBS3psQyxJQUFJLENBQUMvQyxJQUFJLEVBQUU7d0JBQ2hCeW9DLEtBQUsxbEMsSUFBSSxDQUFDL0MsSUFBSSxFQUFFO3dCQUNoQkEsS0FBSzt3QkFDTHFuQixNQUFNM2dCLElBQUksQ0FDTixDQUFDLE1BQU8sS0FBTzZoQyxNQUFNLEtBQU9DLE1BQU0sSUFBS0MsRUFBQyxJQUFLO29CQUVyRDtZQUNSO1FBQ0o7SUFDSjtJQUVBbnFCLE1BQU12YjtJQUVONkYsTUFBTTRDLFlBQVksR0FBR2toQztJQUNyQixPQUFPM3FDO0FBQ1g7QUFFQSxTQUFTeXJDLGlCQUFpQjduQyxJQUFJLEVBQUU3RixLQUFLLEVBQUVzckMsT0FBTyxFQUFFcUMsWUFBWTtJQUN4RCxJQUFJQyxXQUFXLEVBQUU7SUFDakIsSUFBSXJCO0lBQ0osSUFBSXBFLFNBQVMsSUFBSTNwQixNQUFNMUYsTUFBTSxDQUFDalQsTUFBTTdGO0lBQ3BDLElBQUkrUixTQUFTbzJCLE9BQU9qdkIsVUFBVTtJQUM5QixJQUFJbkgsV0FBVyxHQUFHO1FBQ2Qsa0NBQWtDO1FBQ2xDLElBQUssSUFBSTg3QixPQUFPLEdBQUdBLE9BQU92QyxTQUFTdUMsT0FBUTtZQUN2Q3RCLFVBQVVwRSxPQUFPanZCLFVBQVU7WUFDM0IsSUFBSXF6QixXQUFXb0IsY0FBYztnQkFDekIsTUFBTSxJQUFJM3FDLE1BQ04sd0RBQ0l1cEMsVUFDQSxnQkFDQW9CLGVBQ0E7WUFFWjtZQUNBQyxTQUFTaG5DLElBQUksQ0FBQzJsQztRQUNsQjtJQUNKLE9BQU8sSUFBSXg2QixXQUFXLEdBQUc7UUFDckIsU0FBUztRQUNULElBQUk0NUIsVUFBVXhELE9BQU8vdUIsV0FBVztRQUNoQyxJQUFJd3lCLFFBQVF6RCxPQUFPL3VCLFdBQVc7UUFDOUIsSUFBSXd5QixVQUFVLEdBQUc7WUFDYixNQUFNLElBQUk1b0MsTUFDTixvRUFDSTRvQztRQUVaO1FBQ0EsSUFBSXZxQjtRQUNKLElBQUssSUFBSXlzQixTQUFTLEdBQUdBLFNBQVNuQyxTQUFTbUMsU0FBVTtZQUM3Q3ZCLFVBQVVwRSxPQUFPanZCLFVBQVU7WUFDM0JtSSxPQUFPOG1CLE9BQU8vdUIsV0FBVztZQUN6QixJQUFJbXpCLFdBQVdvQixjQUFjO2dCQUN6QixNQUFNLElBQUkzcUMsTUFDTix3REFDSXVwQyxVQUNBLGdCQUNBb0IsZUFDQTtZQUVaO1lBQ0EsSUFBSXRzQixPQUFPaXFCLFNBQVM7Z0JBQ2hCLE1BQU0sSUFBSXRvQyxNQUNOLDREQUNJcWU7WUFFWjtZQUNBLE1BQU91cUIsUUFBUXZxQixNQUFNdXFCLFFBQVM7Z0JBQzFCZ0MsU0FBU2huQyxJQUFJLENBQUMybEM7WUFDbEI7WUFDQVgsUUFBUXZxQjtRQUNaO1FBQ0EsSUFBSUEsU0FBU2lxQixTQUFTO1lBQ2xCLE1BQU0sSUFBSXRvQyxNQUNOLGtFQUNJcWU7UUFFWjtJQUNKLE9BQU87UUFDSCxNQUFNLElBQUlyZSxNQUNOLDhEQUE4RCtPO0lBRXRFO0lBQ0EsT0FBTzY3QjtBQUNYO0FBRUEsaUZBQWlGO0FBQ2pGLFNBQVNHLGNBQWNsb0MsSUFBSSxFQUFFN0YsS0FBSyxFQUFFMEksSUFBSSxFQUFFMEIsR0FBRztJQUN6QzFCLEtBQUtnQixNQUFNLENBQUM4aUMsR0FBRyxHQUFHLENBQUM7SUFDbkIsSUFBSWhELFNBQVNELGVBQWUxakMsTUFBTTdGO0lBQ2xDLElBQUlndUMsWUFBWXJHLGNBQ1o5aEMsTUFDQTJqQyxPQUFPcHhCLFNBQVMsRUFDaEJvRyxNQUFNbEcsYUFBYTtJQUV2QixJQUFJMjFCLGVBQWV0RyxjQUFjOWhDLE1BQU1tb0MsVUFBVTUxQixTQUFTO0lBQzFELElBQUk4MUIsY0FBY3ZHLGNBQ2Q5aEMsTUFDQW9vQyxhQUFhNzFCLFNBQVMsRUFDdEJvRyxNQUFNbEcsYUFBYTtJQUV2QixJQUFJNjFCLGtCQUFrQnhHLGNBQWM5aEMsTUFBTXFvQyxZQUFZOTFCLFNBQVM7SUFDL0QxUCxLQUFLK2tDLE1BQU0sR0FBR1UsZ0JBQWdCdEcsT0FBTztJQUNyQ24vQixLQUFLOGtDLFVBQVUsR0FBR2hHLHNCQUFzQjkrQixLQUFLK2tDLE1BQU07SUFFbkQsSUFBSXZELGVBQWVGLGtCQUNmbmtDLE1BQ0E3RixPQUNBaXVDLGFBQWFwRyxPQUFPLEVBQ3BCcUcsWUFBWXJHLE9BQU87SUFFdkIsSUFBSXFDLGFBQWFscEMsTUFBTSxLQUFLLEdBQUc7UUFDM0IsTUFBTSxJQUFJZ0MsTUFDTixtRkFDSWtuQyxhQUFhbHBDLE1BQU07SUFFL0I7SUFFQSxJQUFJdXBDLFVBQVVMLFlBQVksQ0FBQyxFQUFFO0lBQzdCeGhDLEtBQUtnQixNQUFNLENBQUM4aUMsR0FBRyxDQUFDakMsT0FBTyxHQUFHQTtJQUUxQixJQUFJQSxRQUFRYSxZQUFZLEVBQUU7UUFDdEIxaUMsS0FBS3NpQyxhQUFhLEdBQUdULFFBQVFhLFlBQVksQ0FBQ0osYUFBYTtRQUN2RHRpQyxLQUFLdWlDLGFBQWEsR0FBR1YsUUFBUWEsWUFBWSxDQUFDSCxhQUFhO0lBQzNEO0lBRUEsSUFBSVYsUUFBUTZELEdBQUcsQ0FBQyxFQUFFLEtBQUt0bUMsYUFBYXlpQyxRQUFRNkQsR0FBRyxDQUFDLEVBQUUsS0FBS3RtQyxXQUFXO1FBQzlEWSxLQUFLNGpDLFNBQVMsR0FBRztJQUNyQjtJQUVBLElBQUk1akMsS0FBSzRqQyxTQUFTLEVBQUU7UUFDaEIsSUFBSStCLGdCQUFnQjlELFFBQVErRCxPQUFPO1FBQ25DLElBQUlDLGlCQUFpQmhFLFFBQVFxRCxRQUFRO1FBQ3JDLElBQUlTLGtCQUFrQixLQUFLRSxtQkFBbUIsR0FBRztZQUM3QyxNQUFNLElBQUl2ckMsTUFDTjtRQUVSO1FBQ0FxckMsaUJBQWlCcnVDO1FBQ2pCLElBQUl3dUMsZUFBZTdHLGNBQWM5aEMsTUFBTXdvQztRQUN2QyxJQUFJQyxVQUFVdEUsa0JBQ1Zua0MsTUFDQTdGLE9BQ0F3dUMsYUFBYTNHLE9BQU8sRUFDcEJxRyxZQUFZckcsT0FBTztRQUV2QjBDLFFBQVFvQyxRQUFRLEdBQUcyQjtRQUNuQkMsa0JBQWtCdnVDO1FBQ2xCdXFDLFFBQVFrQyxTQUFTLEdBQUdpQixpQkFDaEI3bkMsTUFDQTBvQyxnQkFDQTdsQyxLQUFLK2xDLFNBQVMsRUFDZEgsUUFBUXR0QyxNQUFNO0lBRXRCO0lBRUEsSUFBSTB0QyxvQkFBb0IxdUMsUUFBUXVxQyxRQUFRTSxPQUFPLENBQUMsRUFBRTtJQUNsRCxJQUFJRSxjQUFjaEIsb0JBQ2Rsa0MsTUFDQTZvQyxtQkFDQW5FLFFBQVFNLE9BQU8sQ0FBQyxFQUFFLEVBQ2xCcUQsWUFBWXJHLE9BQU87SUFFdkJuL0IsS0FBS3NpQyxhQUFhLEdBQUdELFlBQVlDLGFBQWE7SUFDOUN0aUMsS0FBS3VpQyxhQUFhLEdBQUdGLFlBQVlFLGFBQWE7SUFFOUMsSUFBSUYsWUFBWXRELEtBQUssS0FBSyxHQUFHO1FBQ3pCLElBQUl5RCxhQUFhd0Qsb0JBQW9CM0QsWUFBWXRELEtBQUs7UUFDdEQsSUFBSTBELFlBQVl4RCxjQUFjOWhDLE1BQU1xbEM7UUFDcEN4aUMsS0FBSysrQixLQUFLLEdBQUcwRCxVQUFVdEQsT0FBTztRQUM5Qm4vQixLQUFLMmpDLFNBQVMsR0FBRzdFLHNCQUFzQjkrQixLQUFLKytCLEtBQUs7SUFDckQsT0FBTztRQUNILytCLEtBQUsrK0IsS0FBSyxHQUFHLEVBQUU7UUFDZi8rQixLQUFLMmpDLFNBQVMsR0FBRztJQUNyQjtJQUVBLHNHQUFzRztJQUN0RyxJQUFJc0M7SUFDSixJQUFJdmtDLElBQUlDLFNBQVMsRUFBRTtRQUNmc2tDLG1CQUFtQjNHLHVCQUNmbmlDLE1BQ0E3RixRQUFRdXFDLFFBQVFxRSxXQUFXO1FBRS9CbG1DLEtBQUs0aUMsT0FBTyxHQUFHcUQsaUJBQWlCbjBCLE9BQU8sQ0FBQ3haLE1BQU07SUFDbEQsT0FBTztRQUNIMnRDLG1CQUFtQmhILGNBQWM5aEMsTUFBTTdGLFFBQVF1cUMsUUFBUXFFLFdBQVc7UUFDbEVsbUMsS0FBSzRpQyxPQUFPLEdBQUdxRCxpQkFBaUI5RyxPQUFPLENBQUM3bUMsTUFBTTtJQUNsRDtJQUVBLElBQUlzSSxVQUFVK2hDLGdCQUNWeGxDLE1BQ0E3RixRQUFRdXFDLFFBQVFqaEMsT0FBTyxFQUN2QlosS0FBSzRpQyxPQUFPLEVBQ1o0QyxZQUFZckcsT0FBTztJQUV2QixJQUFJMEMsUUFBUWxoQyxRQUFRLEtBQUssR0FBRztRQUN4QixvQkFBb0I7UUFDcEJYLEtBQUttbUMsV0FBVyxHQUFHLElBQUl6bEMsWUFBWWIscUJBQXFCZTtJQUM1RCxPQUFPLElBQUlpaEMsUUFBUWxoQyxRQUFRLEtBQUssR0FBRztRQUMvQixrQkFBa0I7UUFDbEJYLEtBQUttbUMsV0FBVyxHQUFHLElBQUl6bEMsWUFBWVosbUJBQW1CYztJQUMxRCxPQUFPO1FBQ0haLEtBQUttbUMsV0FBVyxHQUFHckQsaUJBQ2YzbEMsTUFDQTdGLFFBQVF1cUMsUUFBUWxoQyxRQUFRLEVBQ3hCQztJQUVSO0lBRUEsZ0RBQWdEO0lBQ2hEWixLQUFLVyxRQUFRLEdBQUdYLEtBQUtXLFFBQVEsSUFBSVgsS0FBS21tQyxXQUFXO0lBRWpEbm1DLEtBQUtHLE1BQU0sR0FBRyxJQUFJMEYsU0FBU2QsUUFBUSxDQUFDL0U7SUFDcEMsSUFBSTBCLElBQUlDLFNBQVMsRUFBRTtRQUNmM0IsS0FBS2lGLEtBQUssR0FBRyxTQUFVek4sQ0FBQztZQUNwQixJQUFJNHVDLGFBQWE3RyxrQkFDYi9uQyxHQUNBeXVDLGlCQUFpQm4wQixPQUFPLEVBQ3hCM1UsTUFDQTdGLFFBQVF1cUMsUUFBUXFFLFdBQVc7WUFFL0JsbUMsS0FBS0csTUFBTSxDQUFDakMsSUFBSSxDQUNaMUcsR0FDQXFPLFNBQVNILGNBQWMsQ0FBQzFGLE1BQU14SSxHQUFHbU8sb0JBQW9CeWdDO1FBRTdEO0lBQ0osT0FBTztRQUNILElBQUssSUFBSTV1QyxJQUFJLEdBQUdBLElBQUl3SSxLQUFLNGlDLE9BQU8sRUFBRXByQyxLQUFLLEVBQUc7WUFDdEMsSUFBSTR1QyxhQUFhSCxpQkFBaUI5RyxPQUFPLENBQUMzbkMsRUFBRTtZQUM1Q3dJLEtBQUtHLE1BQU0sQ0FBQ2pDLElBQUksQ0FDWjFHLEdBQ0FxTyxTQUFTSCxjQUFjLENBQUMxRixNQUFNeEksR0FBR21PLG9CQUFvQnlnQztRQUU3RDtJQUNKO0FBQ0o7QUFFQSxJQUFJdEMsTUFBTTtJQUFFaHVCLE9BQU91dkI7QUFBYztBQUVqQyw2REFBNkQ7QUFFN0QsU0FBU2dCLGNBQWNscEMsSUFBSSxFQUFFN0YsS0FBSyxFQUFFbzlCLEtBQUs7SUFDckMsSUFBSXhaLE9BQU8sQ0FBQztJQUNaLElBQUkzaEIsSUFBSSxJQUFJdWMsTUFBTTFGLE1BQU0sQ0FBQ2pULE1BQU03RjtJQUMvQjRqQixLQUFLbFYsR0FBRyxHQUFHek0sRUFBRTZYLFFBQVE7SUFDckI4SixLQUFLb3JCLFFBQVEsR0FBRy9zQyxFQUFFMFgsVUFBVTtJQUM1QmlLLEtBQUtxckIsWUFBWSxHQUFHaHRDLEVBQUUwWCxVQUFVO0lBQ2hDaUssS0FBS3NyQixRQUFRLEdBQUdqdEMsRUFBRTBYLFVBQVU7SUFDNUIxWCxFQUFFbVksSUFBSSxDQUFDLFVBQVUsSUFBSSx3Q0FBd0M7SUFDN0R3SixLQUFLeFksSUFBSSxHQUFHZ3lCLEtBQUssQ0FBQ243QixFQUFFa1gsV0FBVyxHQUFHLElBQUksQ0FBQztJQUN2QyxPQUFPeUs7QUFDWDtBQUVBLFNBQVN1ckIsa0JBQWtCdHBDLElBQUksRUFBRTdGLEtBQUssRUFBRW92QyxJQUFJLEVBQUVoUyxLQUFLO0lBQy9DLElBQUlpUyxPQUFPLENBQUM7SUFDWixJQUFJcHRDLElBQUksSUFBSXVjLE1BQU0xRixNQUFNLENBQUNqVCxNQUFNN0Y7SUFDL0JxdkMsS0FBS2prQyxJQUFJLEdBQUdneUIsS0FBSyxDQUFDbjdCLEVBQUVrWCxXQUFXLEdBQUcsSUFBSSxDQUFDO0lBQ3ZDbFgsRUFBRW1ZLElBQUksQ0FBQyxVQUFVLElBQUksd0NBQXdDO0lBRTdEaTFCLEtBQUtDLFdBQVcsR0FBRyxDQUFDO0lBQ3BCLElBQUssSUFBSXB2QyxJQUFJLEdBQUdBLElBQUlrdkMsS0FBS3B1QyxNQUFNLEVBQUUsRUFBRWQsRUFBRztRQUNsQ212QyxLQUFLQyxXQUFXLENBQUNGLElBQUksQ0FBQ2x2QyxFQUFFLENBQUN3TyxHQUFHLENBQUMsR0FBR3pNLEVBQUUwWCxVQUFVO0lBQ2hEO0lBRUEsT0FBTzAxQjtBQUNYO0FBRUEsU0FBU0UsZUFBZTFwQyxJQUFJLEVBQUU3RixLQUFLLEVBQUVvOUIsS0FBSztJQUN0QyxJQUFJbjdCLElBQUksSUFBSXVjLE1BQU0xRixNQUFNLENBQUNqVCxNQUFNN0Y7SUFDL0IsSUFBSXd2QyxlQUFldnRDLEVBQUV3WCxVQUFVO0lBQy9CL08sTUFBTUYsUUFBUSxDQUNWZ2xDLGlCQUFpQixZQUNqQjtJQUVKLElBQUlDLGVBQWV4dEMsRUFBRXFYLGFBQWE7SUFDbEMsdUJBQXVCO0lBQ3ZCclgsRUFBRW1ZLElBQUksQ0FBQyxVQUFVO0lBQ2pCLElBQUlzMUIsWUFBWXp0QyxFQUFFa1gsV0FBVztJQUM3QixJQUFJdzJCLFdBQVcxdEMsRUFBRWtYLFdBQVc7SUFDNUIsSUFBSXkyQixnQkFBZ0IzdEMsRUFBRWtYLFdBQVc7SUFDakMsSUFBSTAyQixlQUFlNXRDLEVBQUVrWCxXQUFXO0lBRWhDLElBQUlpMkIsT0FBTyxFQUFFO0lBQ2IsSUFBSyxJQUFJbHZDLElBQUksR0FBR0EsSUFBSXd2QyxXQUFXeHZDLElBQUs7UUFDaENrdkMsS0FBS3hvQyxJQUFJLENBQ0xtb0MsY0FBY2xwQyxNQUFNN0YsUUFBUXl2QyxlQUFldnZDLElBQUl5dkMsVUFBVXZTO0lBRWpFO0lBRUEsSUFBSTBTLFlBQVksRUFBRTtJQUNsQixJQUFJQyxnQkFBZ0IvdkMsUUFBUXl2QyxlQUFlQyxZQUFZQztJQUN2RCxJQUFLLElBQUl2dkMsSUFBSSxHQUFHQSxJQUFJd3ZDLGVBQWV4dkMsSUFBSztRQUNwQzB2QyxVQUFVbHBDLElBQUksQ0FDVnVvQyxrQkFDSXRwQyxNQUNBa3FDLGdCQUFnQjN2QyxJQUFJeXZDLGNBQ3BCVCxNQUNBaFM7SUFHWjtJQUVBLE9BQU87UUFBRWdTLE1BQU1BO1FBQU1VLFdBQVdBO0lBQVU7QUFDOUM7QUFFQSxJQUFJRSxPQUFPO0lBQUV4eEIsT0FBTyt3QjtBQUFlO0FBRW5DLHFEQUFxRDtBQUVyRCxJQUFJVSxhQUFhO0lBQ2IsT0FBTztRQUNIaDlCLFVBQVUsSUFBSSxDQUFDd0osWUFBWSxDQUFDM0QsT0FBTzdGLFFBQVE7UUFDM0NpOUIsY0FBYyxJQUFJLENBQUNwMUIsU0FBUyxDQUFDaEMsT0FBT3VFLE9BQU8sQ0FBQ3ZFLE9BQU8wRSxVQUFVO0lBQ2pFO0FBQ0o7QUFFQSxJQUFJMnlCLGFBQWE7SUFDYixJQUFJcCtCLFNBQVMsSUFBSSxDQUFDb0gsV0FBVztJQUM3QnpPLE1BQU1GLFFBQVEsQ0FBQ3VILFdBQVcsS0FBS0EsV0FBVyxLQUFLQSxXQUFXLEdBQ3REO0lBQ0osSUFBSUEsV0FBVyxHQUFHO1FBQ2QsT0FBTztZQUFFcStCLFlBQVksSUFBSSxDQUFDNzJCLFVBQVU7UUFBRztJQUMzQyxPQUFPLElBQUl4SCxXQUFXLEdBQUc7UUFDckIsT0FBTztZQUFFcytCLFlBQVksSUFBSSxDQUFDOTJCLFVBQVU7UUFBRztJQUMzQyxPQUFPLElBQUl4SCxXQUFXLEdBQUc7UUFDckIsOENBQThDO1FBQzlDLE9BQU87WUFBRXErQixZQUFZLElBQUksQ0FBQzcyQixVQUFVO1FBQUc7SUFDM0M7QUFDSjtBQUVBLElBQUl4RCxXQUFXO0lBQ1gsT0FBTyxJQUFJLENBQUMrRSxTQUFTLENBQUNoQyxPQUFPdUUsT0FBTyxDQUFDOHlCO0FBQ3pDO0FBRUEsSUFBSUcsZUFBZTtJQUNmLE9BQU87UUFDSHI5QixVQUFVLElBQUksQ0FBQ3dKLFlBQVksQ0FBQzNELE9BQU83RixRQUFRO1FBQzNDczlCLFdBQVcsSUFBSSxDQUFDejFCLFNBQVMsQ0FBQ2hDLE9BQU91RSxPQUFPLENBQUN0SDtJQUM3QztBQUNKO0FBRUEsSUFBSXk2QixnQkFBZ0I7SUFDaEIsSUFBSSxDQUFDcjNCLFdBQVcsSUFBSSxVQUFVO0lBQzlCLE9BQU8sSUFBSSxDQUFDMkIsU0FBUyxDQUFDaEMsT0FBT3VFLE9BQU8sQ0FBQ3ZFLE9BQU83RixRQUFRO0FBQ3hEO0FBRUEsU0FBU3c5QixlQUFlNXFDLElBQUksRUFBRTdGLEtBQUs7SUFDL0JBLFFBQVFBLFNBQVM7SUFDakIsSUFBSWlDLElBQUksSUFBSTZXLE9BQU9qVCxNQUFNN0Y7SUFDekIsSUFBSXd2QyxlQUFldnRDLEVBQUUrWCxZQUFZLENBQUM7SUFDbEN0UCxNQUFNRixRQUFRLENBQUNnbEMsaUJBQWlCLEtBQUtBLGlCQUFpQixPQUFPQSxpQkFBaUIsS0FDMUU7SUFDSixJQUFJa0IsT0FBTztRQUNQbDhCLFNBQVNnN0I7UUFDVDd4QixVQUFVMWIsRUFBRXdhLFlBQVksQ0FBQzNELE9BQU82RSxRQUFRO1FBQ3hDc3lCLFlBQVlodUMsRUFBRXdhLFlBQVksQ0FBQ3d6QjtRQUMzQkssY0FBY3J1QyxFQUFFd2EsWUFBWSxDQUFDNnpCO1FBQzdCSyxvQkFBb0IxdUMsRUFBRXdhLFlBQVksQ0FBQzNELE9BQU82RSxRQUFRO0lBQ3REO0lBQ0EsSUFBSTZ4QixnQkFBZ0IsS0FBSztRQUNyQmtCLEtBQUtGLGFBQWEsR0FBR3Z1QyxFQUFFd2EsWUFBWSxDQUFDK3pCO0lBQ3hDO0lBQ0EsT0FBT0U7QUFDWDtBQUNBLElBQUlBLE9BQU87SUFBRWx5QixPQUFPaXlCO0FBQWU7QUFFbkMsK0RBQStEO0FBRS9ELElBQUlHLGtCQUFrQixJQUFJbHBDLE1BQU0sS0FBSywrQkFBK0I7QUFFcEUsc0hBQXNIO0FBQ3RILHlCQUF5QjtBQUN6QmtwQyxlQUFlLENBQUMsRUFBRSxHQUFHLFNBQVNDO0lBQzFCLElBQUk3d0MsUUFBUSxJQUFJLENBQUNpWCxNQUFNLEdBQUcsSUFBSSxDQUFDOEIsY0FBYztJQUM3QyxJQUFJKzNCLFlBQVksSUFBSSxDQUFDMzNCLFdBQVc7SUFDaEMsSUFBSTIzQixjQUFjLEdBQUc7UUFDakIsT0FBTztZQUNINTlCLFdBQVc7WUFDWEQsVUFBVSxJQUFJLENBQUN3SixZQUFZLENBQUMzRCxPQUFPN0YsUUFBUTtZQUMzQ2pFLE9BQU8sSUFBSSxDQUFDNE0sZ0JBQWdCO1FBQ2hDO0lBQ0osT0FBTyxJQUFJazFCLGNBQWMsR0FBRztRQUN4QixPQUFPO1lBQ0g1OUIsV0FBVztZQUNYRCxVQUFVLElBQUksQ0FBQ3dKLFlBQVksQ0FBQzNELE9BQU83RixRQUFRO1lBQzNDdUosUUFBUSxJQUFJLENBQUNGLG9CQUFvQjtRQUNyQztJQUNKO0lBQ0E1UixNQUFNQyxNQUFNLENBQ1IsT0FDQSxPQUNJM0ssTUFBTWdkLFFBQVEsQ0FBQyxNQUNmO0FBRVo7QUFFQSxvSEFBb0g7QUFDcEg0ekIsZUFBZSxDQUFDLEVBQUUsR0FBRyxTQUFTRztJQUMxQixJQUFJL3dDLFFBQVEsSUFBSSxDQUFDaVgsTUFBTSxHQUFHLElBQUksQ0FBQzhCLGNBQWM7SUFDN0MsSUFBSTdGLFlBQVksSUFBSSxDQUFDaUcsV0FBVztJQUNoQ3pPLE1BQU1DLE1BQU0sQ0FDUnVJLGNBQWMsS0FBS0EsY0FBYyxHQUNqQyxPQUNJbFQsTUFBTWdkLFFBQVEsQ0FBQyxNQUNmO0lBRVIsSUFBSS9KLFdBQVcsSUFBSSxDQUFDd0osWUFBWSxDQUFDM0QsT0FBTzdGLFFBQVE7SUFDaEQsSUFBSSs5QixlQUFlLElBQUksQ0FBQzczQixXQUFXO0lBQ25DLElBQUk4M0IsZUFBZSxJQUFJLENBQUM5M0IsV0FBVztJQUNuQyxJQUFJakcsY0FBYyxHQUFHO1FBQ2pCLDhCQUE4QjtRQUM5QixPQUFPO1lBQ0hBLFdBQVdBO1lBQ1hELFVBQVVBO1lBQ1YrOUIsY0FBY0E7WUFDZEMsY0FBY0E7WUFDZDc5QixVQUFVLElBQUksQ0FBQzBILFNBQVMsQ0FDcEJoQyxPQUFPdUUsT0FBTyxDQUNWdkUsT0FBTzhCLElBQUksQ0FBQztnQkFDUixPQUFPO29CQUNILGtCQUFrQjtvQkFDbEJySCxhQUFhLElBQUksQ0FBQzRGLFdBQVc7b0JBQzdCM0YsUUFBUSxJQUFJLENBQUNvSSxnQkFBZ0IsQ0FBQ28xQjtvQkFDOUJFLFFBQVEsSUFBSSxDQUFDdDFCLGdCQUFnQixDQUFDcTFCO2dCQUNsQztZQUNKO1FBR1o7SUFDSixPQUFPLElBQUkvOUIsY0FBYyxHQUFHO1FBQ3hCLElBQUlTLFlBQVksSUFBSSxDQUFDOEksWUFBWSxDQUFDM0QsT0FBTzZFLFFBQVE7UUFDakQsSUFBSTlKLFlBQVksSUFBSSxDQUFDNEksWUFBWSxDQUFDM0QsT0FBTzZFLFFBQVE7UUFDakQsSUFBSXd6QixjQUFjLElBQUksQ0FBQ2g0QixXQUFXO1FBQ2xDLElBQUlpNEIsY0FBYyxJQUFJLENBQUNqNEIsV0FBVztRQUNsQyxPQUFPO1lBQ0gsd0JBQXdCO1lBQ3hCakcsV0FBV0E7WUFDWEQsVUFBVUE7WUFDVis5QixjQUFjQTtZQUNkQyxjQUFjQTtZQUNkdDlCLFdBQVdBO1lBQ1hFLFdBQVdBO1lBQ1hzOUIsYUFBYUE7WUFDYkMsYUFBYUE7WUFDYnI5QixjQUFjLElBQUksQ0FBQytHLFNBQVMsQ0FDeEJxMkIsYUFDQXI0QixPQUFPOEIsSUFBSSxDQUFDdzJCLGFBQWE7Z0JBQ3JCLE9BQU87b0JBQ0g1OUIsUUFBUSxJQUFJLENBQUNvSSxnQkFBZ0IsQ0FBQ28xQjtvQkFDOUJFLFFBQVEsSUFBSSxDQUFDdDFCLGdCQUFnQixDQUFDcTFCO2dCQUNsQztZQUNKO1FBRVI7SUFDSjtBQUNKO0FBRUFMLGVBQWUsQ0FBQyxFQUFFLEdBQUcsU0FBU1M7SUFDMUIsT0FBTztRQUFFQyxPQUFPO0lBQThCO0FBQ2xEO0FBQ0FWLGVBQWUsQ0FBQyxFQUFFLEdBQUcsU0FBU1c7SUFDMUIsT0FBTztRQUFFRCxPQUFPO0lBQThCO0FBQ2xEO0FBQ0FWLGVBQWUsQ0FBQyxFQUFFLEdBQUcsU0FBU1k7SUFDMUIsT0FBTztRQUFFRixPQUFPO0lBQThCO0FBQ2xEO0FBQ0FWLGVBQWUsQ0FBQyxFQUFFLEdBQUcsU0FBU2E7SUFDMUIsT0FBTztRQUFFSCxPQUFPO0lBQThCO0FBQ2xEO0FBQ0FWLGVBQWUsQ0FBQyxFQUFFLEdBQUcsU0FBU2M7SUFDMUIsT0FBTztRQUFFSixPQUFPO0lBQThCO0FBQ2xEO0FBQ0FWLGVBQWUsQ0FBQyxFQUFFLEdBQUcsU0FBU2U7SUFDMUIsT0FBTztRQUFFTCxPQUFPO0lBQThCO0FBQ2xEO0FBQ0FWLGVBQWUsQ0FBQyxFQUFFLEdBQUcsU0FBU2dCO0lBQzFCLE9BQU87UUFBRU4sT0FBTztJQUE4QjtBQUNsRDtBQUVBLGlFQUFpRTtBQUNqRSxTQUFTTyxlQUFlaHNDLElBQUksRUFBRTdGLEtBQUs7SUFDL0JBLFFBQVFBLFNBQVM7SUFDakIsSUFBSWlDLElBQUksSUFBSTZXLE9BQU9qVCxNQUFNN0Y7SUFDekIsSUFBSXd2QyxlQUFldnRDLEVBQUUrWCxZQUFZLENBQUM7SUFDbEN0UCxNQUFNRixRQUFRLENBQ1ZnbEMsaUJBQWlCLEtBQUtBLGlCQUFpQixLQUN2QyxvQ0FBb0NBO0lBR3hDLElBQUlBLGlCQUFpQixHQUFHO1FBQ3BCLE9BQU87WUFDSGg3QixTQUFTZzdCO1lBQ1Q1L0IsU0FBUzNOLEVBQUUyYixlQUFlO1lBQzFCM00sVUFBVWhQLEVBQUU0YixnQkFBZ0I7WUFDNUJwTSxTQUFTeFAsRUFBRThiLGVBQWUsQ0FBQzZ5QjtRQUMvQjtJQUNKLE9BQU87UUFDSCxPQUFPO1lBQ0hwOEIsU0FBU2c3QjtZQUNUNS9CLFNBQVMzTixFQUFFMmIsZUFBZTtZQUMxQjNNLFVBQVVoUCxFQUFFNGIsZ0JBQWdCO1lBQzVCcE0sU0FBU3hQLEVBQUU4YixlQUFlLENBQUM2eUI7WUFDM0JrQixZQUFZN3ZDLEVBQUVpYywwQkFBMEI7UUFDNUM7SUFDSjtBQUNKO0FBRUEsSUFBSWxLLE9BQU87SUFBRXdLLE9BQU9xekI7QUFBZTtBQUVuQywyREFBMkQ7QUFFM0QsSUFBSUUsb0JBQW9CLElBQUlycUMsTUFBTSxJQUFJLCtCQUErQjtBQUVyRSwwREFBMEQ7QUFDMURxcUMsaUJBQWlCLENBQUMsRUFBRSxHQUFHLFNBQVNsQjtJQUM1QixJQUFJN3dDLFFBQVEsSUFBSSxDQUFDaVgsTUFBTSxHQUFHLElBQUksQ0FBQzhCLGNBQWM7SUFDN0MsSUFBSXhFLGNBQWMsSUFBSSxDQUFDNEUsV0FBVztJQUNsQyxJQUFJNUUsZ0JBQWdCLEdBQUc7UUFDbkIsT0FBTztZQUNIQSxhQUFhO1lBQ2J0QixVQUFVLElBQUksQ0FBQ3dKLFlBQVksQ0FBQzNELE9BQU83RixRQUFRO1lBQzNDNkIsY0FBYyxJQUFJLENBQUNxRSxXQUFXO1FBQ2xDO0lBQ0osT0FBTyxJQUFJNUUsZ0JBQWdCLEdBQUc7UUFDMUIsT0FBTztZQUNIQSxhQUFhO1lBQ2J0QixVQUFVLElBQUksQ0FBQ3dKLFlBQVksQ0FBQzNELE9BQU83RixRQUFRO1lBQzNDZ0MsWUFBWSxJQUFJLENBQUN3RixpQkFBaUI7UUFDdEM7SUFDSjtJQUNBL1AsTUFBTUMsTUFBTSxDQUNSLE9BQ0EsT0FBTzNLLE1BQU1nZCxRQUFRLENBQUMsTUFBTTtBQUVwQztBQUVBLDBEQUEwRDtBQUMxRCswQixpQkFBaUIsQ0FBQyxFQUFFLEdBQUcsU0FBU2hCO0lBQzVCLElBQUl4OEIsY0FBYyxJQUFJLENBQUM0RSxXQUFXO0lBQ2xDek8sTUFBTUYsUUFBUSxDQUNWK0osZ0JBQWdCLEdBQ2hCO0lBRUosT0FBTztRQUNIQSxhQUFhQTtRQUNidEIsVUFBVSxJQUFJLENBQUN3SixZQUFZLENBQUMzRCxPQUFPN0YsUUFBUTtRQUMzQ21DLFdBQVcsSUFBSSxDQUFDd0gsZ0JBQWdCO0lBQ3BDO0FBQ0o7QUFFQSwwREFBMEQ7QUFDMURtMUIsaUJBQWlCLENBQUMsRUFBRSxHQUFHLFNBQVNWO0lBQzVCLElBQUk5OEIsY0FBYyxJQUFJLENBQUM0RSxXQUFXO0lBQ2xDek8sTUFBTUYsUUFBUSxDQUNWK0osZ0JBQWdCLEdBQ2hCO0lBRUosT0FBTztRQUNIQSxhQUFhQTtRQUNidEIsVUFBVSxJQUFJLENBQUN3SixZQUFZLENBQUMzRCxPQUFPN0YsUUFBUTtRQUMzQ3NDLGVBQWUsSUFBSSxDQUFDcUgsZ0JBQWdCO0lBQ3hDO0FBQ0o7QUFFQSwwREFBMEQ7QUFDMURtMUIsaUJBQWlCLENBQUMsRUFBRSxHQUFHLFNBQVNSO0lBQzVCLElBQUloOUIsY0FBYyxJQUFJLENBQUM0RSxXQUFXO0lBQ2xDek8sTUFBTUYsUUFBUSxDQUNWK0osZ0JBQWdCLEdBQ2hCO0lBRUosT0FBTztRQUNIQSxhQUFhQTtRQUNidEIsVUFBVSxJQUFJLENBQUN3SixZQUFZLENBQUMzRCxPQUFPN0YsUUFBUTtRQUMzQ3lDLGNBQWMsSUFBSSxDQUFDa0gsZ0JBQWdCLENBQUM7WUFDaEMsT0FBTztnQkFDSDdHLFVBQVUsSUFBSSxDQUFDb0QsV0FBVztnQkFDMUJyRCxZQUFZLElBQUksQ0FBQzRFLGVBQWUsQ0FBQyxJQUFJLENBQUN2QixXQUFXLEtBQUs7WUFDMUQ7UUFDSjtJQUNKO0FBQ0o7QUFFQSxJQUFJNjRCLG1CQUFtQjtJQUNuQkMsZUFBZW41QixPQUFPTCxNQUFNO0lBQzVCc2pCLGlCQUFpQmpqQixPQUFPTCxNQUFNO0FBQ2xDO0FBRUEsMkRBQTJEO0FBQzNEczVCLGlCQUFpQixDQUFDLEVBQUUsR0FBRyxTQUFTUDtJQUM1QixJQUFJeHhDLFFBQVEsSUFBSSxDQUFDaVgsTUFBTSxHQUFHLElBQUksQ0FBQzhCLGNBQWM7SUFDN0MsSUFBSXhFLGNBQWMsSUFBSSxDQUFDNEUsV0FBVztJQUVsQyxJQUFJNUUsZ0JBQWdCLEdBQUc7UUFDbkIsT0FBTztZQUNIQSxhQUFhQTtZQUNidEIsVUFBVSxJQUFJLENBQUN3SixZQUFZLENBQUMzRCxPQUFPN0YsUUFBUTtZQUMzQ2kvQixVQUFVLElBQUksQ0FBQ3QxQixnQkFBZ0IsQ0FBQztnQkFDNUIsSUFBSXUxQixhQUFhLElBQUksQ0FBQ2g1QixXQUFXO2dCQUNqQyxJQUFJaTVCLGFBQWEsSUFBSSxDQUFDajVCLFdBQVc7Z0JBQ2pDLE9BQU87b0JBQ0hrNUIsT0FBTyxJQUFJLENBQUMzM0IsZUFBZSxDQUFDeTNCLGFBQWE7b0JBQ3pDdFcsZUFBZSxJQUFJLENBQUM1Z0IsZUFBZSxDQUMvQm0zQixZQUNBSjtnQkFFUjtZQUNKO1FBQ0o7SUFDSixPQUFPLElBQUl6OUIsZ0JBQWdCLEdBQUc7UUFDMUIsT0FBTztZQUNIQSxhQUFhQTtZQUNidEIsVUFBVSxJQUFJLENBQUN3SixZQUFZLENBQUMzRCxPQUFPN0YsUUFBUTtZQUMzQzBLLFVBQVUsSUFBSSxDQUFDbEIsWUFBWSxDQUFDM0QsT0FBTzZFLFFBQVE7WUFDM0MyMEIsV0FBVyxJQUFJLENBQUMxMUIsZ0JBQWdCLENBQUM7Z0JBQzdCLElBQUl1MUIsYUFBYSxJQUFJLENBQUNoNUIsV0FBVztnQkFDakMsSUFBSWk1QixhQUFhLElBQUksQ0FBQ2o1QixXQUFXO2dCQUNqQyxPQUFPO29CQUNIbEgsU0FBUyxJQUFJLENBQUN5SSxlQUFlLENBQUN5M0IsYUFBYTtvQkFDM0N0VyxlQUFlLElBQUksQ0FBQzVnQixlQUFlLENBQy9CbTNCLFlBQ0FKO2dCQUVSO1lBQ0o7UUFDSjtJQUNKLE9BQU8sSUFBSXo5QixnQkFBZ0IsR0FBRztRQUMxQixJQUFJNDlCLGFBQWEsSUFBSSxDQUFDaDVCLFdBQVc7UUFDakMsSUFBSWk1QixhQUFhLElBQUksQ0FBQ2o1QixXQUFXO1FBQ2pDLE9BQU87WUFDSDVFLGFBQWFBO1lBQ2JnK0IsV0FBVyxJQUFJLENBQUN6M0IsU0FBUyxDQUNyQnEzQixZQUNBcjVCLE9BQU91RSxPQUFPLENBQUN2RSxPQUFPN0YsUUFBUTtZQUVsQzRvQixlQUFlLElBQUksQ0FBQzVnQixlQUFlLENBQUNtM0IsWUFBWUo7UUFDcEQ7SUFDSjtJQUNBdG5DLE1BQU1DLE1BQU0sQ0FDUixPQUNBLE9BQU8zSyxNQUFNZ2QsUUFBUSxDQUFDLE1BQU07QUFFcEM7QUFFQSwwREFBMEQ7QUFDMUQrMEIsaUJBQWlCLENBQUMsRUFBRSxHQUFHLFNBQVNOO0lBQzVCLElBQUl6eEMsUUFBUSxJQUFJLENBQUNpWCxNQUFNLEdBQUcsSUFBSSxDQUFDOEIsY0FBYztJQUM3QyxJQUFJeEUsY0FBYyxJQUFJLENBQUM0RSxXQUFXO0lBQ2xDLElBQUk1RSxnQkFBZ0IsR0FBRztRQUNuQixPQUFPO1lBQ0hBLGFBQWE7WUFDYnRCLFVBQVUsSUFBSSxDQUFDd0osWUFBWSxDQUFDM0QsT0FBTzdGLFFBQVE7WUFDM0N1L0IsZUFBZSxJQUFJLENBQUM1MUIsZ0JBQWdCLENBQUM7Z0JBQ2pDLE9BQU87b0JBQ0gyWCxXQUFXLElBQUksQ0FBQzdaLGVBQWU7b0JBQy9CMjNCLE9BQU8sSUFBSSxDQUFDMzNCLGVBQWUsQ0FBQyxJQUFJLENBQUNuQixVQUFVLEtBQUs7b0JBQ2hEaWIsV0FBVyxJQUFJLENBQUM5WixlQUFlO29CQUMvQm1oQixlQUFlLElBQUksQ0FBQzVnQixlQUFlLENBQUMrMkI7Z0JBQ3hDO1lBQ0o7UUFDSjtJQUNKLE9BQU8sSUFBSXo5QixnQkFBZ0IsR0FBRztRQUMxQixPQUFPO1lBQ0hBLGFBQWE7WUFDYnRCLFVBQVUsSUFBSSxDQUFDd0osWUFBWSxDQUFDM0QsT0FBTzdGLFFBQVE7WUFDM0N3L0IsbUJBQW1CLElBQUksQ0FBQ2gyQixZQUFZLENBQUMzRCxPQUFPNkUsUUFBUTtZQUNwRCswQixlQUFlLElBQUksQ0FBQ2oyQixZQUFZLENBQUMzRCxPQUFPNkUsUUFBUTtZQUNoRGcxQixtQkFBbUIsSUFBSSxDQUFDbDJCLFlBQVksQ0FBQzNELE9BQU82RSxRQUFRO1lBQ3BEaTFCLGVBQWUsSUFBSSxDQUFDaDJCLGdCQUFnQixDQUFDO2dCQUNqQyxPQUFPO29CQUNIMlgsV0FBVyxJQUFJLENBQUM3WixlQUFlO29CQUMvQjIzQixPQUFPLElBQUksQ0FBQzMzQixlQUFlLENBQUMsSUFBSSxDQUFDbkIsVUFBVSxLQUFLO29CQUNoRGliLFdBQVcsSUFBSSxDQUFDOVosZUFBZTtvQkFDL0JtaEIsZUFBZSxJQUFJLENBQUM1Z0IsZUFBZSxDQUFDKzJCO2dCQUN4QztZQUNKO1FBQ0o7SUFDSixPQUFPLElBQUl6OUIsZ0JBQWdCLEdBQUc7UUFDMUIsT0FBTztZQUNIQSxhQUFhO1lBQ2IwbUIsbUJBQW1CLElBQUksQ0FBQ25nQixTQUFTLENBQUNoQyxPQUFPdUUsT0FBTyxDQUFDdkUsT0FBTzdGLFFBQVE7WUFDaEU4bkIsZUFBZSxJQUFJLENBQUNqZ0IsU0FBUyxDQUFDaEMsT0FBT3VFLE9BQU8sQ0FBQ3ZFLE9BQU83RixRQUFRO1lBQzVEK25CLG1CQUFtQixJQUFJLENBQUNsZ0IsU0FBUyxDQUFDaEMsT0FBT3VFLE9BQU8sQ0FBQ3ZFLE9BQU83RixRQUFRO1lBQ2hFNG9CLGVBQWUsSUFBSSxDQUFDNWdCLGVBQWUsQ0FBQysyQjtRQUN4QztJQUNKO0lBQ0F0bkMsTUFBTUMsTUFBTSxDQUNSLE9BQ0EsT0FBTzNLLE1BQU1nZCxRQUFRLENBQUMsTUFBTTtBQUVwQztBQUVBLDBEQUEwRDtBQUMxRCswQixpQkFBaUIsQ0FBQyxFQUFFLEdBQUcsU0FBU0w7SUFDNUIsa0NBQWtDO0lBQ2xDLElBQUluOUIsY0FBYyxJQUFJLENBQUM0RSxXQUFXO0lBQ2xDek8sTUFBTUYsUUFBUSxDQUNWK0osZ0JBQWdCLEdBQ2hCO0lBRUosSUFBSXMrQixzQkFBc0IsSUFBSSxDQUFDMTVCLFdBQVc7SUFDMUMsSUFBSTI1QixrQkFBa0IsSUFBSWg2QixPQUN0QixJQUFJLENBQUNqVCxJQUFJLEVBQ1QsSUFBSSxDQUFDb1IsTUFBTSxHQUFHLElBQUksQ0FBQ3dDLFVBQVU7SUFFakMsT0FBTztRQUNIbEYsYUFBYTtRQUNibEQsWUFBWXdoQztRQUNaRSxXQUFXaEIsaUJBQWlCLENBQUNjLG9CQUFvQixDQUFDdGdDLElBQUksQ0FBQ3VnQztJQUMzRDtBQUNKO0FBRUEsNERBQTREO0FBQzVEZixpQkFBaUIsQ0FBQyxFQUFFLEdBQUcsU0FBU0o7SUFDNUIsSUFBSXA5QixjQUFjLElBQUksQ0FBQzRFLFdBQVc7SUFDbEN6TyxNQUFNRixRQUFRLENBQ1YrSixnQkFBZ0IsR0FDaEI7SUFFSixPQUFPO1FBQ0hBLGFBQWFBO1FBQ2J0QixVQUFVLElBQUksQ0FBQ3dKLFlBQVksQ0FBQzNELE9BQU83RixRQUFRO1FBQzNDZ29CLG1CQUFtQixJQUFJLENBQUNuZ0IsU0FBUyxDQUFDaEMsT0FBT3VFLE9BQU8sQ0FBQ3ZFLE9BQU83RixRQUFRO1FBQ2hFK25CLG1CQUFtQixJQUFJLENBQUNsZ0IsU0FBUyxDQUFDaEMsT0FBT3VFLE9BQU8sQ0FBQ3ZFLE9BQU83RixRQUFRO1FBQ2hFKy9CLGFBQWEsSUFBSSxDQUFDdDRCLGVBQWU7SUFDckM7QUFDSjtBQUVBLHVEQUF1RDtBQUN2RCxTQUFTdTRCLGVBQWVwdEMsSUFBSSxFQUFFN0YsS0FBSztJQUMvQkEsUUFBUUEsU0FBUztJQUNqQixJQUFJaUMsSUFBSSxJQUFJNlcsT0FBT2pULE1BQU03RjtJQUN6QixJQUFJd3ZDLGVBQWV2dEMsRUFBRStYLFlBQVksQ0FBQztJQUNsQ3RQLE1BQU1GLFFBQVEsQ0FDVmdsQyxpQkFBaUIsS0FBS0EsaUJBQWlCLEtBQ3ZDO0lBRUosSUFBSUEsaUJBQWlCLEdBQUc7UUFDcEIsT0FBTztZQUNIaDdCLFNBQVNnN0I7WUFDVDUvQixTQUFTM04sRUFBRTJiLGVBQWU7WUFDMUIzTSxVQUFVaFAsRUFBRTRiLGdCQUFnQjtZQUM1QnBNLFNBQVN4UCxFQUFFOGIsZUFBZSxDQUFDZzBCO1FBQy9CO0lBQ0osT0FBTztRQUNILE9BQU87WUFDSHY5QixTQUFTZzdCO1lBQ1Q1L0IsU0FBUzNOLEVBQUUyYixlQUFlO1lBQzFCM00sVUFBVWhQLEVBQUU0YixnQkFBZ0I7WUFDNUJwTSxTQUFTeFAsRUFBRThiLGVBQWUsQ0FBQ2cwQjtZQUMzQkQsWUFBWTd2QyxFQUFFaWMsMEJBQTBCO1FBQzVDO0lBQ0o7QUFDSjtBQUVBLElBQUl5ZSxPQUFPO0lBQUVuZSxPQUFPeTBCO0FBQWU7QUFFbkMsK0RBQStEO0FBRS9ELGdDQUFnQztBQUNoQyxTQUFTQyxlQUFlcnRDLElBQUksRUFBRTdGLEtBQUs7SUFDL0IsSUFBSW16QyxPQUFPLENBQUM7SUFDWixJQUFJbHhDLElBQUksSUFBSXVjLE1BQU0xRixNQUFNLENBQUNqVCxNQUFNN0Y7SUFDL0JtekMsS0FBSzMrQixPQUFPLEdBQUd2UyxFQUFFK1gsWUFBWTtJQUM3Qm01QixLQUFLQyxZQUFZLEdBQUd0dkMsS0FBS2tFLEtBQUssQ0FBQy9GLEVBQUUwWCxVQUFVLEtBQUssUUFBUTtJQUN4RHc1QixLQUFLRSxrQkFBa0IsR0FBR3B4QyxFQUFFd1gsVUFBVTtJQUN0QzA1QixLQUFLRyxXQUFXLEdBQUdyeEMsRUFBRXdYLFVBQVU7SUFDL0IvTyxNQUFNRixRQUFRLENBQ1Yyb0MsS0FBS0csV0FBVyxLQUFLLFlBQ3JCO0lBRUpILEtBQUs5ekIsS0FBSyxHQUFHcGQsRUFBRWtYLFdBQVc7SUFDMUJnNkIsS0FBSzltQyxVQUFVLEdBQUdwSyxFQUFFa1gsV0FBVztJQUMvQmc2QixLQUFLSSxPQUFPLEdBQUd0eEMsRUFBRThYLGlCQUFpQjtJQUNsQ281QixLQUFLSyxRQUFRLEdBQUd2eEMsRUFBRThYLGlCQUFpQjtJQUNuQ281QixLQUFLN25DLElBQUksR0FBR3JKLEVBQUVzWCxVQUFVO0lBQ3hCNDVCLEtBQUs1bkMsSUFBSSxHQUFHdEosRUFBRXNYLFVBQVU7SUFDeEI0NUIsS0FBSzNuQyxJQUFJLEdBQUd2SixFQUFFc1gsVUFBVTtJQUN4QjQ1QixLQUFLMW5DLElBQUksR0FBR3hKLEVBQUVzWCxVQUFVO0lBQ3hCNDVCLEtBQUtNLFFBQVEsR0FBR3h4QyxFQUFFa1gsV0FBVztJQUM3Qmc2QixLQUFLTyxhQUFhLEdBQUd6eEMsRUFBRWtYLFdBQVc7SUFDbENnNkIsS0FBS1EsaUJBQWlCLEdBQUcxeEMsRUFBRXNYLFVBQVU7SUFDckM0NUIsS0FBS1MsZ0JBQWdCLEdBQUczeEMsRUFBRXNYLFVBQVU7SUFDcEM0NUIsS0FBS1UsZUFBZSxHQUFHNXhDLEVBQUVzWCxVQUFVO0lBQ25DLE9BQU80NUI7QUFDWDtBQUVBLElBQUlBLE9BQU87SUFBRTMwQixPQUFPMDBCO0FBQWU7QUFFbkMsK0RBQStEO0FBRS9ELDJDQUEyQztBQUMzQyxTQUFTWSxlQUFlanVDLElBQUksRUFBRTdGLEtBQUs7SUFDL0IsSUFBSSt6QyxPQUFPLENBQUM7SUFDWixJQUFJOXhDLElBQUksSUFBSXVjLE1BQU0xRixNQUFNLENBQUNqVCxNQUFNN0Y7SUFDL0IrekMsS0FBS3YvQixPQUFPLEdBQUd2UyxFQUFFK1gsWUFBWTtJQUM3Qis1QixLQUFLaFMsUUFBUSxHQUFHOS9CLEVBQUVzWCxVQUFVO0lBQzVCdzZCLEtBQUsvUixTQUFTLEdBQUcvL0IsRUFBRXNYLFVBQVU7SUFDN0J3NkIsS0FBS0MsT0FBTyxHQUFHL3hDLEVBQUVzWCxVQUFVO0lBQzNCdzZCLEtBQUtFLGVBQWUsR0FBR2h5QyxFQUFFa1gsV0FBVztJQUNwQzQ2QixLQUFLRyxrQkFBa0IsR0FBR2p5QyxFQUFFc1gsVUFBVTtJQUN0Q3c2QixLQUFLSSxtQkFBbUIsR0FBR2x5QyxFQUFFc1gsVUFBVTtJQUN2Q3c2QixLQUFLSyxVQUFVLEdBQUdueUMsRUFBRXNYLFVBQVU7SUFDOUJ3NkIsS0FBS00sY0FBYyxHQUFHcHlDLEVBQUVzWCxVQUFVO0lBQ2xDdzZCLEtBQUtPLGFBQWEsR0FBR3J5QyxFQUFFc1gsVUFBVTtJQUNqQ3c2QixLQUFLUSxXQUFXLEdBQUd0eUMsRUFBRXNYLFVBQVU7SUFDL0J0WCxFQUFFOFcsY0FBYyxJQUFJO0lBQ3BCZzdCLEtBQUtTLGdCQUFnQixHQUFHdnlDLEVBQUVzWCxVQUFVO0lBQ3BDdzZCLEtBQUtVLGdCQUFnQixHQUFHeHlDLEVBQUVrWCxXQUFXO0lBQ3JDLE9BQU80NkI7QUFDWDtBQUVBLElBQUlBLE9BQU87SUFBRXYxQixPQUFPczFCO0FBQWU7QUFFbkMsbUVBQW1FO0FBRW5FLFNBQVNZLGtCQUFrQjd1QyxJQUFJLEVBQUU3RixLQUFLLEVBQUUyMEMsVUFBVSxFQUFFbEcsU0FBUyxFQUFFNWxDLE1BQU07SUFDakUsSUFBSTZDO0lBQ0osSUFBSXVCO0lBQ0osSUFBSWhMLElBQUksSUFBSXVjLE1BQU0xRixNQUFNLENBQUNqVCxNQUFNN0Y7SUFDL0IsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUl1dUMsV0FBV3Z1QyxLQUFLLEVBQUc7UUFDbkMseUdBQXlHO1FBQ3pHLElBQUlBLElBQUl5MEMsWUFBWTtZQUNoQmpwQyxlQUFlekosRUFBRWtYLFdBQVc7WUFDNUJsTSxrQkFBa0JoTCxFQUFFc1gsVUFBVTtRQUNsQztRQUVBLElBQUl6USxRQUFRRCxPQUFPRSxHQUFHLENBQUM3STtRQUN2QjRJLE1BQU00QyxZQUFZLEdBQUdBO1FBQ3JCNUMsTUFBTW1FLGVBQWUsR0FBR0E7SUFDNUI7QUFDSjtBQUVBLFNBQVMybkMsMEJBQTBCbHNDLElBQUksRUFBRTdDLElBQUksRUFBRTdGLEtBQUssRUFBRTIwQyxVQUFVLEVBQUVsRyxTQUFTO0lBQ3ZFL2xDLEtBQUttRixjQUFjLEdBQUcsQ0FBQztJQUV2QixJQUFJbkM7SUFDSixJQUFJdUI7SUFDSixJQUFJaEwsSUFBSSxJQUFJdWMsTUFBTTFGLE1BQU0sQ0FBQ2pULE1BQU03RjtJQUMvQixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSXV1QyxXQUFXdnVDLEtBQUssRUFBRztRQUNuQyx5R0FBeUc7UUFDekcsSUFBSUEsSUFBSXkwQyxZQUFZO1lBQ2hCanBDLGVBQWV6SixFQUFFa1gsV0FBVztZQUM1QmxNLGtCQUFrQmhMLEVBQUVzWCxVQUFVO1FBQ2xDO1FBRUE3USxLQUFLbUYsY0FBYyxDQUFDM04sRUFBRSxHQUFHO1lBQ3JCd0wsY0FBY0E7WUFDZHVCLGlCQUFpQkE7UUFDckI7SUFDSjtBQUNKO0FBRUEsZ0ZBQWdGO0FBQ2hGLHFHQUFxRztBQUNyRyxTQUFTNG5DLGVBQWVuc0MsSUFBSSxFQUFFN0MsSUFBSSxFQUFFN0YsS0FBSyxFQUFFMjBDLFVBQVUsRUFBRWxHLFNBQVMsRUFBRTVsQyxNQUFNLEVBQUV1QixHQUFHO0lBQ3pFLElBQUlBLElBQUlDLFNBQVMsRUFDYjtRQUFFdXFDLDBCQUEwQmxzQyxNQUFNN0MsTUFBTTdGLE9BQU8yMEMsWUFBWWxHO0lBQVksT0FDdEU7UUFBRWlHLGtCQUFrQjd1QyxNQUFNN0YsT0FBTzIwQyxZQUFZbEcsV0FBVzVsQztJQUFTO0FBQzFFO0FBRUEsSUFBSWlzQyxPQUFPO0lBQUV0MkIsT0FBT3EyQjtBQUFlO0FBRW5DLDJDQUEyQztBQUUzQyxTQUFTRSxzQkFBc0I5eUMsQ0FBQztJQUM1QixJQUFJK3lDLFFBQVEsQ0FBQztJQUNiLGdCQUFnQjtJQUNoQi95QyxFQUFFbVksSUFBSSxDQUFDO0lBQ1AsSUFBSTY2QixrQkFBa0JoekMsRUFBRWtYLFdBQVc7SUFDbkN6TyxNQUFNRixRQUFRLENBQUN5cUMsb0JBQW9CLEdBQUc7SUFDdEMsd0NBQXdDO0lBQ3hDaHpDLEVBQUVtWSxJQUFJLENBQUMsVUFBVTtJQUNqQixJQUFJODZCLFNBQVNqekMsRUFBRWtYLFdBQVc7SUFDMUIsK0NBQStDO0lBQy9DbFgsRUFBRW1ZLElBQUksQ0FBQyxVQUFVO0lBQ2pCLElBQUssSUFBSWxhLElBQUksR0FBR0EsSUFBSWcxQyxRQUFRaDFDLEtBQUssRUFBRztRQUNoQyxJQUFJMlMsWUFBWTVRLEVBQUVrWCxXQUFXO1FBQzdCLElBQUlyRyxhQUFhN1EsRUFBRWtYLFdBQVc7UUFDOUIsSUFBSW5LLFFBQVEvTSxFQUFFc1gsVUFBVTtRQUN4Qnk3QixLQUFLLENBQUNuaUMsWUFBWSxNQUFNQyxXQUFXLEdBQUc5RDtJQUMxQztJQUNBLE9BQU9nbUM7QUFDWDtBQUVBLFNBQVNHLGtCQUFrQmx6QyxDQUFDO0lBQ3hCLElBQUkreUMsUUFBUSxDQUFDO0lBQ2IsbUdBQW1HO0lBQ25HLGlCQUFpQjtJQUNqQi95QyxFQUFFbVksSUFBSSxDQUFDO0lBQ1AsSUFBSWc3QixVQUFVbnpDLEVBQUV3WCxVQUFVO0lBQzFCLHVGQUF1RjtJQUN2RixJQUFJMjdCLFVBQVUsR0FBRztRQUNiL3NCLFFBQVFndEIsSUFBSSxDQUFDO0lBQ2pCO0lBQ0FwekMsRUFBRW1ZLElBQUksQ0FBQztJQUNQLElBQUluSCxXQUFXaFIsRUFBRWtYLFdBQVc7SUFDNUIsSUFBSTg3QixrQkFBa0JoaUMsV0FBVztJQUNqQ2hSLEVBQUVtWSxJQUFJLENBQUM7SUFDUCxJQUFJNjZCLG9CQUFvQixHQUFHO1FBQ3ZCLElBQUlDLFNBQVNqekMsRUFBRWtYLFdBQVc7UUFDMUIsK0NBQStDO1FBQy9DbFgsRUFBRW1ZLElBQUksQ0FBQyxVQUFVO1FBQ2pCLElBQUssSUFBSWxhLElBQUksR0FBR0EsSUFBSWcxQyxRQUFRaDFDLEtBQUssRUFBRztZQUNoQyxJQUFJMlMsWUFBWTVRLEVBQUVrWCxXQUFXO1lBQzdCLElBQUlyRyxhQUFhN1EsRUFBRWtYLFdBQVc7WUFDOUIsSUFBSW5LLFFBQVEvTSxFQUFFc1gsVUFBVTtZQUN4Qnk3QixLQUFLLENBQUNuaUMsWUFBWSxNQUFNQyxXQUFXLEdBQUc5RDtRQUMxQztJQUNKO0lBQ0EsT0FBT2dtQztBQUNYO0FBRUEsdURBQXVEO0FBQ3ZELFNBQVNNLGVBQWV6dkMsSUFBSSxFQUFFN0YsS0FBSztJQUMvQixJQUFJaUMsSUFBSSxJQUFJdWMsTUFBTTFGLE1BQU0sQ0FBQ2pULE1BQU03RjtJQUMvQixJQUFJd3ZDLGVBQWV2dEMsRUFBRWtYLFdBQVc7SUFDaEMsSUFBSXEyQixpQkFBaUIsR0FBRztRQUNwQixPQUFPdUYsc0JBQXNCOXlDO0lBQ2pDLE9BQU8sSUFBSXV0QyxpQkFBaUIsR0FBRztRQUMzQixPQUFPMkYsa0JBQWtCbHpDO0lBQzdCLE9BQU87UUFDSCxNQUFNLElBQUllLE1BQU0scUNBQXFDd3NDLGVBQWU7SUFDeEU7QUFDSjtBQUVBLElBQUkrRixPQUFPO0lBQUUvMkIsT0FBTzgyQjtBQUFlO0FBRW5DLDBFQUEwRTtBQUUxRSxTQUFTRSxlQUFlM3ZDLElBQUksRUFBRTdGLEtBQUs7SUFDL0IsSUFBSWlDLElBQUksSUFBSXVjLE1BQU0xRixNQUFNLENBQUNqVCxNQUFNN0Y7SUFDL0IsSUFBSXd2QyxlQUFldnRDLEVBQUV3WCxVQUFVO0lBQy9CL08sTUFBTUYsUUFBUSxDQUFDZ2xDLGlCQUFpQixHQUFHO0lBQ25DLHNFQUFzRTtJQUN0RXZ0QyxFQUFFbVksSUFBSSxDQUFDLFNBQVM7SUFDaEIsSUFBSXE3QixVQUFVeHpDLEVBQUV3WCxVQUFVO0lBRTFCLElBQUlzakIsT0FBTyxFQUFFO0lBQ2IsSUFBSyxJQUFJNzhCLElBQUksR0FBR0EsSUFBSXUxQyxTQUFTdjFDLElBQUs7UUFDOUIsSUFBSXdPLE1BQU07UUFDVixJQUFJdUksU0FBU2pYLFFBQVFpQyxFQUFFa1gsV0FBVztRQUNsQyxJQUFJblksU0FBU2lCLEVBQUVrWCxXQUFXO1FBQzFCLElBQUssSUFBSS9ZLElBQUk2VyxRQUFRN1csSUFBSTZXLFNBQVNqVyxRQUFRLEVBQUVaLEVBQUc7WUFDM0NzTyxPQUFPbUosT0FBT0MsWUFBWSxDQUFDalMsS0FBS2tTLE9BQU8sQ0FBQzNYO1FBQzVDO1FBRUEyOEIsS0FBS24yQixJQUFJLENBQUM4SDtJQUNkO0lBRUEsT0FBT3F1QjtBQUNYO0FBRUEsSUFBSTJZLE9BQU87SUFBRWwzQixPQUFPZzNCO0FBQWU7QUFFbkMsa0ZBQWtGO0FBRWxGLG9HQUFvRztBQUNwRyxvREFBb0Q7QUFDcEQscUdBQXFHO0FBQ3JHLG1HQUFtRztBQUNuRyw4RkFBOEY7QUFDOUYsNEJBQTRCO0FBQzVCLFNBQVNHLGVBQWU5dkMsSUFBSSxFQUFFN0YsS0FBSyxFQUFFeXVDLFNBQVMsRUFBRW1ILFlBQVk7SUFDeEQsSUFBSTN6QyxJQUFJLElBQUl1YyxNQUFNMUYsTUFBTSxDQUFDalQsTUFBTTdGO0lBQy9CLElBQUk2MUMsVUFBVUQsZUFBZTN6QyxFQUFFa1gsV0FBVyxHQUFHbFgsRUFBRXdYLFVBQVU7SUFDekQsZ0dBQWdHO0lBQ2hHLG1DQUFtQztJQUNuQyxJQUFJcThCLGVBQWUsRUFBRTtJQUNyQixJQUFLLElBQUk1MUMsSUFBSSxHQUFHQSxJQUFJdXVDLFlBQVksR0FBR3Z1QyxLQUFLLEVBQUc7UUFDdkMsSUFBSTYxQyxjQUFjRixRQUFRdGpDLElBQUksQ0FBQ3RRO1FBQy9CLElBQUkyekMsY0FBYztZQUNkLGlFQUFpRTtZQUNqRUcsZUFBZTtRQUNuQjtRQUVBRCxhQUFhbHZDLElBQUksQ0FBQ212QztJQUN0QjtJQUVBLE9BQU9EO0FBQ1g7QUFFQSxJQUFJajBCLE9BQU87SUFBRXJELE9BQU9tM0I7QUFBZTtBQUVuQyxxRUFBcUU7QUFFckUsMENBQTBDO0FBQzFDLFNBQVNLLGVBQWVud0MsSUFBSSxFQUFFN0YsS0FBSztJQUMvQixJQUFJaTJDLE9BQU8sQ0FBQztJQUNaLElBQUloMEMsSUFBSSxJQUFJdWMsTUFBTTFGLE1BQU0sQ0FBQ2pULE1BQU03RjtJQUMvQmkyQyxLQUFLemhDLE9BQU8sR0FBR3ZTLEVBQUUrWCxZQUFZO0lBQzdCaThCLEtBQUt4SCxTQUFTLEdBQUd4c0MsRUFBRWtYLFdBQVc7SUFDOUIsSUFBSTg4QixLQUFLemhDLE9BQU8sS0FBSyxLQUFLO1FBQ3RCeWhDLEtBQUtDLFNBQVMsR0FBR2owQyxFQUFFa1gsV0FBVztRQUM5Qjg4QixLQUFLRSxXQUFXLEdBQUdsMEMsRUFBRWtYLFdBQVc7UUFDaEM4OEIsS0FBS0csa0JBQWtCLEdBQUduMEMsRUFBRWtYLFdBQVc7UUFDdkM4OEIsS0FBS0ksb0JBQW9CLEdBQUdwMEMsRUFBRWtYLFdBQVc7UUFDekM4OEIsS0FBS0ssUUFBUSxHQUFHcjBDLEVBQUVrWCxXQUFXO1FBQzdCODhCLEtBQUtNLGlCQUFpQixHQUFHdDBDLEVBQUVrWCxXQUFXO1FBQ3RDODhCLEtBQUtPLFVBQVUsR0FBR3YwQyxFQUFFa1gsV0FBVztRQUMvQjg4QixLQUFLUSxlQUFlLEdBQUd4MEMsRUFBRWtYLFdBQVc7UUFDcEM4OEIsS0FBS1Msa0JBQWtCLEdBQUd6MEMsRUFBRWtYLFdBQVc7UUFDdkM4OEIsS0FBS1UsZ0JBQWdCLEdBQUcxMEMsRUFBRWtYLFdBQVc7UUFDckM4OEIsS0FBS1cscUJBQXFCLEdBQUczMEMsRUFBRWtYLFdBQVc7UUFDMUM4OEIsS0FBS1ksb0JBQW9CLEdBQUc1MEMsRUFBRWtYLFdBQVc7UUFDekM4OEIsS0FBS2EsaUJBQWlCLEdBQUc3MEMsRUFBRWtYLFdBQVc7SUFDMUM7SUFFQSxPQUFPODhCO0FBQ1g7QUFFQSxJQUFJQSxPQUFPO0lBQUV6M0IsT0FBT3czQjtBQUFlO0FBRW5DLGdFQUFnRTtBQUVoRSxrREFBa0Q7QUFDbEQsU0FBU2UsY0FBY2x4QyxJQUFJLEVBQUU3RixLQUFLO0lBQzlCLElBQUltaUMsTUFBTSxDQUFDO0lBQ1gsSUFBSWxnQyxJQUFJLElBQUl1YyxNQUFNMUYsTUFBTSxDQUFDalQsTUFBTTdGO0lBQy9CbWlDLElBQUkzdEIsT0FBTyxHQUFHdlMsRUFBRWtYLFdBQVc7SUFDM0JncEIsSUFBSTZVLGFBQWEsR0FBRy8wQyxFQUFFc1gsVUFBVTtJQUNoQzRvQixJQUFJQyxhQUFhLEdBQUduZ0MsRUFBRWtYLFdBQVc7SUFDakNncEIsSUFBSUssWUFBWSxHQUFHdmdDLEVBQUVrWCxXQUFXO0lBQ2hDZ3BCLElBQUk4VSxNQUFNLEdBQUdoMUMsRUFBRWtYLFdBQVc7SUFDMUJncEIsSUFBSStVLGVBQWUsR0FBR2oxQyxFQUFFc1gsVUFBVTtJQUNsQzRvQixJQUFJZ1YsZUFBZSxHQUFHbDFDLEVBQUVzWCxVQUFVO0lBQ2xDNG9CLElBQUlpVixpQkFBaUIsR0FBR24xQyxFQUFFc1gsVUFBVTtJQUNwQzRvQixJQUFJa1YsaUJBQWlCLEdBQUdwMUMsRUFBRXNYLFVBQVU7SUFDcEM0b0IsSUFBSW1WLGlCQUFpQixHQUFHcjFDLEVBQUVzWCxVQUFVO0lBQ3BDNG9CLElBQUlvVixpQkFBaUIsR0FBR3QxQyxFQUFFc1gsVUFBVTtJQUNwQzRvQixJQUFJcVYsbUJBQW1CLEdBQUd2MUMsRUFBRXNYLFVBQVU7SUFDdEM0b0IsSUFBSXNWLG1CQUFtQixHQUFHeDFDLEVBQUVzWCxVQUFVO0lBQ3RDNG9CLElBQUl1VixjQUFjLEdBQUd6MUMsRUFBRXNYLFVBQVU7SUFDakM0b0IsSUFBSXdWLGtCQUFrQixHQUFHMTFDLEVBQUVzWCxVQUFVO0lBQ3JDNG9CLElBQUl5VixZQUFZLEdBQUczMUMsRUFBRXNYLFVBQVU7SUFDL0I0b0IsSUFBSTBWLE1BQU0sR0FBRyxFQUFFO0lBQ2YsSUFBSyxJQUFJMzNDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1FBQ3pCaWlDLElBQUkwVixNQUFNLENBQUMzM0MsRUFBRSxHQUFHK0IsRUFBRStXLFNBQVM7SUFDL0I7SUFFQW1wQixJQUFJMlYsZUFBZSxHQUFHNzFDLEVBQUV3WCxVQUFVO0lBQ2xDMG9CLElBQUk0VixlQUFlLEdBQUc5MUMsRUFBRXdYLFVBQVU7SUFDbEMwb0IsSUFBSTZWLGVBQWUsR0FBRy8xQyxFQUFFd1gsVUFBVTtJQUNsQzBvQixJQUFJOFYsZUFBZSxHQUFHaDJDLEVBQUV3WCxVQUFVO0lBQ2xDMG9CLElBQUkrVixTQUFTLEdBQUdyZ0MsT0FBT0MsWUFBWSxDQUMvQjdWLEVBQUUrVyxTQUFTLElBQ1gvVyxFQUFFK1csU0FBUyxJQUNYL1csRUFBRStXLFNBQVMsSUFDWC9XLEVBQUUrVyxTQUFTO0lBRWZtcEIsSUFBSVEsV0FBVyxHQUFHMWdDLEVBQUVrWCxXQUFXO0lBQy9CZ3BCLElBQUlnVyxnQkFBZ0IsR0FBR2wyQyxFQUFFa1gsV0FBVztJQUNwQ2dwQixJQUFJaVcsZUFBZSxHQUFHbjJDLEVBQUVrWCxXQUFXO0lBQ25DZ3BCLElBQUlrVyxhQUFhLEdBQUdwMkMsRUFBRXNYLFVBQVU7SUFDaEM0b0IsSUFBSW1XLGNBQWMsR0FBR3IyQyxFQUFFc1gsVUFBVTtJQUNqQzRvQixJQUFJb1csWUFBWSxHQUFHdDJDLEVBQUVzWCxVQUFVO0lBQy9CNG9CLElBQUlxVyxXQUFXLEdBQUd2MkMsRUFBRWtYLFdBQVc7SUFDL0JncEIsSUFBSXNXLFlBQVksR0FBR3gyQyxFQUFFa1gsV0FBVztJQUNoQyxJQUFJZ3BCLElBQUkzdEIsT0FBTyxJQUFJLEdBQUc7UUFDbEIydEIsSUFBSXVXLGdCQUFnQixHQUFHejJDLEVBQUV3WCxVQUFVO1FBQ25DMG9CLElBQUl3VyxnQkFBZ0IsR0FBRzEyQyxFQUFFd1gsVUFBVTtJQUN2QztJQUVBLElBQUkwb0IsSUFBSTN0QixPQUFPLElBQUksR0FBRztRQUNsQjJ0QixJQUFJeVcsUUFBUSxHQUFHMzJDLEVBQUVzWCxVQUFVO1FBQzNCNG9CLElBQUkwVyxVQUFVLEdBQUc1MkMsRUFBRXNYLFVBQVU7UUFDN0I0b0IsSUFBSTJXLGFBQWEsR0FBRzcyQyxFQUFFa1gsV0FBVztRQUNqQ2dwQixJQUFJNFcsV0FBVyxHQUFHOTJDLEVBQUVrWCxXQUFXO1FBQy9CZ3BCLElBQUk2VyxZQUFZLEdBQUcvMkMsRUFBRWtYLFdBQVc7SUFDcEM7SUFFQSxPQUFPZ3BCO0FBQ1g7QUFFQSxJQUFJQSxNQUFNO0lBQUUzakIsT0FBT3U0QjtBQUFjO0FBRWpDLGtGQUFrRjtBQUVsRixvQ0FBb0M7QUFDcEMsU0FBU2tDLGVBQWVwekMsSUFBSSxFQUFFN0YsS0FBSztJQUMvQixJQUFJazVDLE9BQU8sQ0FBQztJQUNaLElBQUlqM0MsSUFBSSxJQUFJdWMsTUFBTTFGLE1BQU0sQ0FBQ2pULE1BQU03RjtJQUMvQms1QyxLQUFLMWtDLE9BQU8sR0FBR3ZTLEVBQUUrWCxZQUFZO0lBQzdCay9CLEtBQUtDLFdBQVcsR0FBR2wzQyxFQUFFMFgsVUFBVTtJQUMvQnUvQixLQUFLRSxpQkFBaUIsR0FBR24zQyxFQUFFc1gsVUFBVTtJQUNyQzIvQixLQUFLRyxrQkFBa0IsR0FBR3AzQyxFQUFFc1gsVUFBVTtJQUN0QzIvQixLQUFLSSxZQUFZLEdBQUdyM0MsRUFBRXdYLFVBQVU7SUFDaEN5L0IsS0FBS0ssWUFBWSxHQUFHdDNDLEVBQUV3WCxVQUFVO0lBQ2hDeS9CLEtBQUtNLFlBQVksR0FBR3YzQyxFQUFFd1gsVUFBVTtJQUNoQ3kvQixLQUFLTyxXQUFXLEdBQUd4M0MsRUFBRXdYLFVBQVU7SUFDL0J5L0IsS0FBS1EsV0FBVyxHQUFHejNDLEVBQUV3WCxVQUFVO0lBQy9CeS9CLEtBQUs5YixLQUFLLEdBQUcsRUFBRTtJQUNmLE9BQVE4YixLQUFLMWtDLE9BQU87UUFDaEIsS0FBSztZQUNEO1FBQ0osS0FBSztZQUNEMGtDLEtBQUtTLGNBQWMsR0FBRzEzQyxFQUFFa1gsV0FBVztZQUNuQysvQixLQUFLVSxjQUFjLEdBQUcsSUFBSWx5QyxNQUFNd3hDLEtBQUtTLGNBQWM7WUFDbkQsSUFBSyxJQUFJejVDLElBQUksR0FBR0EsSUFBSWc1QyxLQUFLUyxjQUFjLEVBQUV6NUMsSUFBSztnQkFDMUNnNUMsS0FBS1UsY0FBYyxDQUFDMTVDLEVBQUUsR0FBRytCLEVBQUVrWCxXQUFXO1lBQzFDO1lBQ0E7UUFDSixLQUFLO1lBQ0QrL0IsS0FBS1MsY0FBYyxHQUFHMTNDLEVBQUVrWCxXQUFXO1lBQ25DKy9CLEtBQUtqaUMsTUFBTSxHQUFHLElBQUl2UCxNQUFNd3hDLEtBQUtTLGNBQWM7WUFDM0MsSUFBSyxJQUFJbDZCLE1BQU0sR0FBR0EsTUFBTXk1QixLQUFLUyxjQUFjLEVBQUVsNkIsTUFBTztnQkFDaER5NUIsS0FBS2ppQyxNQUFNLENBQUN3SSxJQUFJLEdBQUd4ZCxFQUFFZ1gsU0FBUztZQUNsQztZQUNBO0lBQ1I7SUFDQSxPQUFPaWdDO0FBQ1g7QUFFQSxJQUFJQSxPQUFPO0lBQUUxNkIsT0FBT3k2QjtBQUFlO0FBRW5DLDZDQUE2QztBQUU3Qzs7O0NBR0MsR0FDRCxJQUFJL3lDLFNBQVMsQ0FBQztBQUVkOzs7OztDQUtDLEdBQ0RBLE9BQU8yekMsSUFBSSxHQUFHLFNBQVNoMEMsSUFBSSxFQUFFb1IsTUFBTSxFQUFFNmlDLFFBQVE7SUFDekMsSUFBSUMsYUFBYSxFQUFFO0lBQ25CLElBQUlDLFdBQVdGO0lBQ2YsSUFBSyxJQUFJMTVDLElBQUksR0FBR0EsSUFBSTQ1QyxVQUFVNTVDLEtBQUs2VyxVQUFVLEVBQUc7UUFDNUM4aUMsVUFBVSxDQUFDMzVDLEVBQUUsR0FBR3lGLEtBQUtxUixRQUFRLENBQUNEO0lBQ2xDO0lBRUEsT0FBT1ksT0FBT0MsWUFBWSxDQUFDblEsS0FBSyxDQUFDLE1BQU1veUM7QUFDM0M7QUFFQTs7Ozs7Q0FLQyxHQUNEN3pDLE9BQU8rekMsS0FBSyxHQUFHLFNBQVNwMEMsSUFBSSxFQUFFb1IsTUFBTSxFQUFFNmlDLFFBQVE7SUFDMUMsSUFBSUMsYUFBYSxFQUFFO0lBQ25CLElBQUlDLFdBQVdGLFdBQVc7SUFDMUIsSUFBSyxJQUFJMTVDLElBQUksR0FBR0EsSUFBSTQ1QyxVQUFVNTVDLEtBQUs2VyxVQUFVLEVBQUc7UUFDNUM4aUMsVUFBVSxDQUFDMzVDLEVBQUUsR0FBR3lGLEtBQUt1UixTQUFTLENBQUNIO0lBQ25DO0lBRUEsT0FBT1ksT0FBT0MsWUFBWSxDQUFDblEsS0FBSyxDQUFDLE1BQU1veUM7QUFDM0M7QUFFQSxvRUFBb0U7QUFDcEUsb0VBQW9FO0FBQ3BFLHNFQUFzRTtBQUN0RSxtRUFBbUU7QUFDbkUsaUVBQWlFO0FBQ2pFLEVBQUU7QUFDRiw4Q0FBOEM7QUFDOUMsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSwrQkFBK0I7QUFDL0I7O0NBRUMsR0FDRCxJQUFJRyx1QkFBdUI7SUFDdkIsa0JBQ0Esa05BQ0E7SUFDQSxrQkFDQSw2RkFDQTtJQUNBLGdCQUNBLGtOQUNBO0lBQ0EsZUFDQSwyS0FDQTtJQUNBLG1CQUNBLGlPQUNBO0lBQ0EsZUFDQSxpRkFDQTtJQUNBLFlBQ0EsdUlBQ0E7SUFDQUMsV0FDQSw4TkFDQTtJQUNBLGtCQUNBLGtOQUNBO0lBQ0EsaUJBQ0EsOE5BQ0E7QUFDSjtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRGowQyxPQUFPazBDLFNBQVMsR0FBRyxTQUFTcGpDLFFBQVEsRUFBRUMsTUFBTSxFQUFFb2pDLFVBQVUsRUFBRWh4QyxRQUFRO0lBQzlELElBQUlpeEMsUUFBUUosb0JBQW9CLENBQUM3d0MsU0FBUztJQUMxQyxJQUFJaXhDLFVBQVV4eUMsV0FBVztRQUNyQixPQUFPQTtJQUNYO0lBRUEsSUFBSXl5QyxTQUFTO0lBQ2IsSUFBSyxJQUFJcjZDLElBQUksR0FBR0EsSUFBSW02QyxZQUFZbjZDLElBQUs7UUFDakMsSUFBSStFLElBQUkrUixTQUFTRSxRQUFRLENBQUNELFNBQVMvVztRQUNuQyxnRUFBZ0U7UUFDaEUsZ0VBQWdFO1FBQ2hFLElBQUkrRSxLQUFLLE1BQU07WUFDWHMxQyxVQUFVMWlDLE9BQU9DLFlBQVksQ0FBQzdTO1FBQ2xDLE9BQU87WUFDSHMxQyxVQUFVRCxLQUFLLENBQUNyMUMsSUFBSSxLQUFLO1FBQzdCO0lBQ0o7SUFFQSxPQUFPczFDO0FBQ1g7QUFFQSwrREFBK0Q7QUFFL0QsbUNBQW1DO0FBQ25DLGtGQUFrRjtBQUNsRixTQUFTQyxlQUFlMzBDLElBQUksRUFBRTdGLEtBQUs7SUFDL0IsSUFBSWlDLElBQUksSUFBSXVjLE1BQU0xRixNQUFNLENBQUNqVCxNQUFNN0Y7SUFDL0IsSUFBSXd2QyxlQUFldnRDLEVBQUV3WCxVQUFVO0lBQy9CL08sTUFBTUYsUUFBUSxDQUFDZ2xDLGlCQUFpQixHQUFHO0lBQ25DdnRDLEVBQUV3WCxVQUFVLElBQUksd0NBQXdDO0lBQ3hEeFgsRUFBRXdYLFVBQVUsSUFBSSxjQUFjO0lBQzlCLElBQUlnaEMsY0FBY3g0QyxFQUFFd1gsVUFBVTtJQUU5QixJQUFJc2pCLE9BQU8sQ0FBQztJQUNaLElBQUssSUFBSTc4QixJQUFJLEdBQUdBLElBQUl1NkMsYUFBYXY2QyxJQUFLO1FBQ2xDLElBQUl3TyxNQUFNek0sRUFBRTZYLFFBQVE7UUFDcEIsSUFBSTRnQyxhQUFhejRDLEVBQUV3WCxVQUFVO1FBQzdCLElBQUk0Z0MsYUFBYXA0QyxFQUFFd1gsVUFBVTtRQUM3QixJQUFJaWdCLE9BQU94ekIsT0FBTzJ6QyxJQUFJLENBQUNoMEMsTUFBTTdGLFFBQVEwNkMsWUFBWUw7UUFFakR0ZCxJQUFJLENBQUNydUIsSUFBSSxHQUFHZ3JCO0lBQ2hCO0lBQ0EsT0FBT3FEO0FBQ1g7QUFFQSxJQUFJc00sT0FBTztJQUFFN3FCLE9BQU9nOEI7QUFBZTtBQUVuQyxjQUFjO0FBRWQ7OztDQUdDLEdBRUQseUVBQXlFO0FBQ3pFOzs7OztDQUtDLEdBQ0QsU0FBU0csMEJBQTBCOTBDLElBQUksRUFBRXdoQyxTQUFTO0lBQzlDLElBQUl1VCxlQUFlLEVBQUU7SUFDckIsSUFBSTM0QyxJQUFJO0lBQ1IsSUFBSyxJQUFJL0IsSUFBSSxHQUFHQSxJQUFJbW5DLFdBQVdubkMsS0FBSyxFQUFHO1FBQ25DLElBQUl3TyxNQUFNOFAsTUFBTTVHLE1BQU0sQ0FBQy9SLE1BQU01RDtRQUM3QixJQUFJNDRDLFdBQVdyOEIsTUFBTWpILFFBQVEsQ0FBQzFSLE1BQU01RCxJQUFJO1FBQ3hDLElBQUlnVixTQUFTdUgsTUFBTWpILFFBQVEsQ0FBQzFSLE1BQU01RCxJQUFJO1FBQ3RDLElBQUlqQixTQUFTd2QsTUFBTWpILFFBQVEsQ0FBQzFSLE1BQU01RCxJQUFJO1FBQ3RDMjRDLGFBQWFoMEMsSUFBSSxDQUFDO1lBQ2Q4SCxLQUFLQTtZQUNMbXNDLFVBQVVBO1lBQ1Y1akMsUUFBUUE7WUFDUmpXLFFBQVFBO1lBQ1I4NUMsYUFBYTtRQUNqQjtRQUNBNzRDLEtBQUs7SUFDVDtJQUVBLE9BQU8yNEM7QUFDWDtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0csc0JBQXNCbDFDLElBQUksRUFBRXdoQyxTQUFTO0lBQzFDLElBQUl1VCxlQUFlLEVBQUU7SUFDckIsSUFBSTM0QyxJQUFJLElBQUksNkNBQTZDO0lBQ3pELElBQUssSUFBSS9CLElBQUksR0FBR0EsSUFBSW1uQyxXQUFXbm5DLEtBQUssRUFBRztRQUNuQyxJQUFJd08sTUFBTThQLE1BQU01RyxNQUFNLENBQUMvUixNQUFNNUQ7UUFDN0IsSUFBSWdWLFNBQVN1SCxNQUFNakgsUUFBUSxDQUFDMVIsTUFBTTVELElBQUk7UUFDdEMsSUFBSSs0QyxhQUFheDhCLE1BQU1qSCxRQUFRLENBQUMxUixNQUFNNUQsSUFBSTtRQUMxQyxJQUFJZzVDLGFBQWF6OEIsTUFBTWpILFFBQVEsQ0FBQzFSLE1BQU01RCxJQUFJO1FBQzFDLElBQUk2NEMsY0FBZSxLQUFLO1FBQ3hCLElBQUlFLGFBQWFDLFlBQVk7WUFDekJILGNBQWM7UUFDbEIsT0FBTztZQUNIQSxjQUFjO1FBQ2xCO1FBRUFGLGFBQWFoMEMsSUFBSSxDQUFDO1lBQ2Q4SCxLQUFLQTtZQUNMdUksUUFBUUE7WUFDUjZqQyxhQUFhQTtZQUNiSSxrQkFBa0JGO1lBQ2xCaDZDLFFBQVFpNkM7UUFDWjtRQUNBaDVDLEtBQUs7SUFDVDtJQUVBLE9BQU8yNEM7QUFDWDtBQUVBOzs7OztDQUtDLEdBRUQ7Ozs7Q0FJQyxHQUNELFNBQVNPLGdCQUFnQnQxQyxJQUFJLEVBQUV1MUMsVUFBVTtJQUNyQyxJQUFJQSxXQUFXTixXQUFXLEtBQUssUUFBUTtRQUNuQyxJQUFJTyxXQUFXLElBQUkvN0MsV0FDZnVHLEtBQUt5a0MsTUFBTSxFQUNYOFEsV0FBV25rQyxNQUFNLEdBQUcsR0FDcEJta0MsV0FBV0YsZ0JBQWdCLEdBQUc7UUFFbEMsSUFBSUksWUFBWSxJQUFJaDhDLFdBQVc4N0MsV0FBV3A2QyxNQUFNO1FBQ2hENEUsWUFBWXkxQyxVQUFVQztRQUN0QixJQUFJQSxVQUFVeFIsVUFBVSxLQUFLc1IsV0FBV3A2QyxNQUFNLEVBQUU7WUFDNUMsTUFBTSxJQUFJZ0MsTUFDTiwwQkFDSW80QyxXQUFXMXNDLEdBQUcsR0FDZDtRQUVaO1FBRUEsSUFBSTZzQyxPQUFPLElBQUlsUixTQUFTaVIsVUFBVWhSLE1BQU0sRUFBRTtRQUMxQyxPQUFPO1lBQUV6a0MsTUFBTTAxQztZQUFNdGtDLFFBQVE7UUFBRTtJQUNuQyxPQUFPO1FBQ0gsT0FBTztZQUFFcFIsTUFBTUE7WUFBTW9SLFFBQVFta0MsV0FBV25rQyxNQUFNO1FBQUM7SUFDbkQ7QUFDSjtBQUVBLHlFQUF5RTtBQUV6RTs7Ozs7O0NBTUMsR0FDRCxTQUFTdWtDLFlBQVlsUixNQUFNLEVBQUVsZ0MsR0FBRztJQUM1QkEsTUFBTUEsUUFBUXRDLGFBQWFzQyxRQUFRLE9BQU8sQ0FBQyxJQUFJQTtJQUUvQyxJQUFJd3BDO0lBRUosOEZBQThGO0lBQzlGLDZEQUE2RDtJQUM3RCxJQUFJbHJDLE9BQU8sSUFBSWk1QixLQUFLO1FBQUVDLE9BQU87SUFBSztJQUVsQywrQ0FBK0M7SUFDL0MsMEdBQTBHO0lBQzFHLDREQUE0RDtJQUM1RCxJQUFJLzdCLE9BQU8sSUFBSXdrQyxTQUFTQyxRQUFRO0lBQ2hDLElBQUlqRDtJQUNKLElBQUl1VCxlQUFlLEVBQUU7SUFDckIsSUFBSWEsWUFBWWo5QixNQUFNNUcsTUFBTSxDQUFDL1IsTUFBTTtJQUNuQyxJQUNJNDFDLGNBQWM1akMsT0FBT0MsWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQzNDMmpDLGNBQWMsVUFDZEEsY0FBYyxRQUNoQjtRQUNFL3lDLEtBQUtzNkIsY0FBYyxHQUFHO1FBQ3RCcUUsWUFBWTdvQixNQUFNckgsU0FBUyxDQUFDdFIsTUFBTTtRQUNsQyswQyxlQUFlRCwwQkFBMEI5MEMsTUFBTXdoQztJQUNuRCxPQUFPLElBQUlvVSxjQUFjLFFBQVE7UUFDN0IveUMsS0FBS3M2QixjQUFjLEdBQUc7UUFDdEJxRSxZQUFZN29CLE1BQU1ySCxTQUFTLENBQUN0UixNQUFNO1FBQ2xDKzBDLGVBQWVELDBCQUEwQjkwQyxNQUFNd2hDO0lBQ25ELE9BQU8sSUFBSW9VLGNBQWMsUUFBUTtRQUM3QixJQUFJQyxTQUFTbDlCLE1BQU01RyxNQUFNLENBQUMvUixNQUFNO1FBQ2hDLElBQUk2MUMsV0FBVzdqQyxPQUFPQyxZQUFZLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSTtZQUM1Q3BQLEtBQUtzNkIsY0FBYyxHQUFHO1FBQzFCLE9BQU8sSUFBSTBZLFdBQVcsUUFBUTtZQUMxQmh6QyxLQUFLczZCLGNBQWMsR0FBRztRQUMxQixPQUFPO1lBQ0gsTUFBTSxJQUFJaGdDLE1BQU0saUNBQWlDeTRDO1FBQ3JEO1FBRUFwVSxZQUFZN29CLE1BQU1ySCxTQUFTLENBQUN0UixNQUFNO1FBQ2xDKzBDLGVBQWVHLHNCQUFzQmwxQyxNQUFNd2hDO0lBQy9DLE9BQU87UUFDSCxNQUFNLElBQUlya0MsTUFBTSxvQ0FBb0N5NEM7SUFDeEQ7SUFFQSxJQUFJRTtJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUluNkM7SUFFSixJQUFLLElBQUkvQixJQUFJLEdBQUdBLElBQUltbkMsV0FBV25uQyxLQUFLLEVBQUc7UUFDbkMsSUFBSWs3QyxhQUFhUixZQUFZLENBQUMxNkMsRUFBRTtRQUNoQyxJQUFJbzZDLFFBQVMsS0FBSztRQUNsQixPQUFRYyxXQUFXMXNDLEdBQUc7WUFDbEIsS0FBSztnQkFDRDRyQyxRQUFRYSxnQkFBZ0J0MUMsTUFBTXUxQztnQkFDOUIxeUMsS0FBS2dCLE1BQU0sQ0FBQ1IsSUFBSSxHQUFHQSxLQUFLc1YsS0FBSyxDQUFDODdCLE1BQU16MEMsSUFBSSxFQUFFeTBDLE1BQU1yakMsTUFBTTtnQkFDdER2TyxLQUFLVyxRQUFRLEdBQUcsSUFBSUosYUFBYVAsS0FBS2dCLE1BQU0sQ0FBQ1IsSUFBSTtnQkFDakQ7WUFDSixLQUFLO2dCQUNEb3hDLFFBQVFhLGdCQUFnQnQxQyxNQUFNdTFDO2dCQUM5Qm41QyxJQUFJLElBQUl1YyxNQUFNMUYsTUFBTSxDQUFDd2hDLE1BQU16MEMsSUFBSSxFQUFFeTBDLE1BQU1yakMsTUFBTTtnQkFDN0N2TyxLQUFLZ0IsTUFBTSxDQUFDZ2YsR0FBRyxHQUFHem1CLEVBQUUwWSxjQUFjLENBQUN5Z0MsV0FBV3A2QyxNQUFNLEdBQUc7Z0JBQ3ZEO1lBQ0osS0FBSztnQkFDRDQ2QyxpQkFBaUJSO2dCQUNqQjtZQUNKLEtBQUs7Z0JBQ0RkLFFBQVFhLGdCQUFnQnQxQyxNQUFNdTFDO2dCQUM5Qm41QyxJQUFJLElBQUl1YyxNQUFNMUYsTUFBTSxDQUFDd2hDLE1BQU16MEMsSUFBSSxFQUFFeTBDLE1BQU1yakMsTUFBTTtnQkFDN0N2TyxLQUFLZ0IsTUFBTSxDQUFDdWUsSUFBSSxHQUFHaG1CLEVBQUU0WSxhQUFhLENBQUN1Z0MsV0FBV3A2QyxNQUFNO2dCQUNwRDtZQUNKLEtBQUs7Z0JBQ0RzNUMsUUFBUWEsZ0JBQWdCdDFDLE1BQU11MUM7Z0JBQzlCMXlDLEtBQUtnQixNQUFNLENBQUN5cEMsSUFBSSxHQUFHQSxLQUFLMzBCLEtBQUssQ0FBQzg3QixNQUFNejBDLElBQUksRUFBRXkwQyxNQUFNcmpDLE1BQU07Z0JBQ3REdk8sS0FBSzJELFVBQVUsR0FBRzNELEtBQUtnQixNQUFNLENBQUN5cEMsSUFBSSxDQUFDOW1DLFVBQVU7Z0JBQzdDdW5DLG1CQUFtQmxyQyxLQUFLZ0IsTUFBTSxDQUFDeXBDLElBQUksQ0FBQ1MsZ0JBQWdCO2dCQUNwRDtZQUNKLEtBQUs7Z0JBQ0QwRyxRQUFRYSxnQkFBZ0J0MUMsTUFBTXUxQztnQkFDOUIxeUMsS0FBS2dCLE1BQU0sQ0FBQ3FxQyxJQUFJLEdBQUdBLEtBQUt2MUIsS0FBSyxDQUFDODdCLE1BQU16MEMsSUFBSSxFQUFFeTBDLE1BQU1yakMsTUFBTTtnQkFDdER2TyxLQUFLcTVCLFFBQVEsR0FBR3I1QixLQUFLZ0IsTUFBTSxDQUFDcXFDLElBQUksQ0FBQ2hTLFFBQVE7Z0JBQ3pDcjVCLEtBQUtzNUIsU0FBUyxHQUFHdDVCLEtBQUtnQixNQUFNLENBQUNxcUMsSUFBSSxDQUFDL1IsU0FBUztnQkFDM0N0NUIsS0FBSytyQyxnQkFBZ0IsR0FBRy9yQyxLQUFLZ0IsTUFBTSxDQUFDcXFDLElBQUksQ0FBQ1UsZ0JBQWdCO2dCQUN6RDtZQUNKLEtBQUs7Z0JBQ0R3SCxpQkFBaUJiO2dCQUNqQjtZQUNKLEtBQUs7Z0JBQ0RkLFFBQVFhLGdCQUFnQnQxQyxNQUFNdTFDO2dCQUM5QmlCLFlBQVkzRyxLQUFLbDNCLEtBQUssQ0FBQzg3QixNQUFNejBDLElBQUksRUFBRXkwQyxNQUFNcmpDLE1BQU07Z0JBQy9DO1lBQ0osS0FBSztnQkFDRHFqQyxRQUFRYSxnQkFBZ0J0MUMsTUFBTXUxQztnQkFDOUIxeUMsS0FBS2dCLE1BQU0sQ0FBQ3VzQyxJQUFJLEdBQUdBLEtBQUt6M0IsS0FBSyxDQUFDODdCLE1BQU16MEMsSUFBSSxFQUFFeTBDLE1BQU1yakMsTUFBTTtnQkFDdER2TyxLQUFLK2xDLFNBQVMsR0FBRy9sQyxLQUFLZ0IsTUFBTSxDQUFDdXNDLElBQUksQ0FBQ3hILFNBQVM7Z0JBQzNDO1lBQ0osS0FBSztnQkFDRDZMLFFBQVFhLGdCQUFnQnQxQyxNQUFNdTFDO2dCQUM5QjF5QyxLQUFLZ0IsTUFBTSxDQUFDeTRCLEdBQUcsR0FBR0EsSUFBSTNqQixLQUFLLENBQUM4N0IsTUFBTXowQyxJQUFJLEVBQUV5MEMsTUFBTXJqQyxNQUFNO2dCQUNwRDtZQUNKLEtBQUs7Z0JBQ0RxakMsUUFBUWEsZ0JBQWdCdDFDLE1BQU11MUM7Z0JBQzlCMXlDLEtBQUtnQixNQUFNLENBQUN3dkMsSUFBSSxHQUFHQSxLQUFLMTZCLEtBQUssQ0FBQzg3QixNQUFNejBDLElBQUksRUFBRXkwQyxNQUFNcmpDLE1BQU07Z0JBQ3REO1lBQ0osS0FBSztnQkFDRHFqQyxRQUFRYSxnQkFBZ0J0MUMsTUFBTXUxQztnQkFDOUJuNUMsSUFBSSxJQUFJdWMsTUFBTTFGLE1BQU0sQ0FBQ3doQyxNQUFNejBDLElBQUksRUFBRXkwQyxNQUFNcmpDLE1BQU07Z0JBQzdDdk8sS0FBS2dCLE1BQU0sQ0FBQzhlLElBQUksR0FBR3ZtQixFQUFFNFksYUFBYSxDQUFDdWdDLFdBQVdwNkMsTUFBTTtnQkFDcEQ7WUFDSixLQUFLO2dCQUNENjZDLGlCQUFpQlQ7Z0JBQ2pCO1lBQ0osS0FBSztnQkFDRGUsaUJBQWlCZjtnQkFDakI7WUFDSixLQUFLO2dCQUNETyxnQkFBZ0JQO2dCQUNoQjtZQUNKLEtBQUs7Z0JBQ0RjLGlCQUFpQmQ7Z0JBQ2pCO1lBQ0osS0FBSztnQkFDRFUsaUJBQWlCVjtnQkFDakI7WUFDSixLQUFLO2dCQUNEVyxpQkFBaUJYO2dCQUNqQjtZQUNKLEtBQUs7Z0JBQ0RZLGlCQUFpQlo7Z0JBQ2pCO1lBQ0osS0FBSztnQkFDRGdCLGlCQUFpQmhCO2dCQUNqQjtRQUNSO0lBQ0o7SUFFQSxJQUFJUyxrQkFBa0JNLGdCQUFnQjtRQUNsQyxJQUFJdkcsZUFBZWhDLHFCQUFxQjtRQUN4QyxJQUFJMEksWUFBWW5CLGdCQUFnQnQxQyxNQUFNczJDO1FBQ3RDLElBQUlJLGNBQWMxNkIsS0FBS3JELEtBQUssQ0FDeEI4OUIsVUFBVXoyQyxJQUFJLEVBQ2R5MkMsVUFBVXJsQyxNQUFNLEVBQ2hCdk8sS0FBSytsQyxTQUFTLEVBQ2RtSDtRQUVKLElBQUk0RyxZQUFZckIsZ0JBQWdCdDFDLE1BQU1nMkM7UUFDdENuekMsS0FBS0csTUFBTSxHQUFHb1osS0FBS3pELEtBQUssQ0FDcEJnK0IsVUFBVTMyQyxJQUFJLEVBQ2QyMkMsVUFBVXZsQyxNQUFNLEVBQ2hCc2xDLGFBQ0E3ekMsTUFDQTBCO0lBRVIsT0FBTyxJQUFJdXhDLGVBQWU7UUFDdEIsSUFBSWMsV0FBV3RCLGdCQUFnQnQxQyxNQUFNODFDO1FBQ3JDblAsSUFBSWh1QixLQUFLLENBQUNpK0IsU0FBUzUyQyxJQUFJLEVBQUU0MkMsU0FBU3hsQyxNQUFNLEVBQUV2TyxNQUFNMEI7SUFDcEQsT0FBTztRQUNILE1BQU0sSUFBSXBILE1BQU07SUFDcEI7SUFFQSxJQUFJMDVDLFlBQVl2QixnQkFBZ0J0MUMsTUFBTW8yQztJQUN0Q25ILEtBQUt0MkIsS0FBSyxDQUNOOVYsTUFDQWcwQyxVQUFVNzJDLElBQUksRUFDZDYyQyxVQUFVemxDLE1BQU0sRUFDaEJ2TyxLQUFLK3JDLGdCQUFnQixFQUNyQi9yQyxLQUFLK2xDLFNBQVMsRUFDZC9sQyxLQUFLRyxNQUFNLEVBQ1h1QjtJQUVKRCxjQUFjekIsTUFBTTBCO0lBRXBCLElBQUk4eEMsZ0JBQWdCO1FBQ2hCLElBQUlTLFlBQVl4QixnQkFBZ0J0MUMsTUFBTXEyQztRQUN0Q3h6QyxLQUFLazdCLFlBQVksR0FBRzJSLEtBQUsvMkIsS0FBSyxDQUFDbStCLFVBQVU5MkMsSUFBSSxFQUFFODJDLFVBQVUxbEMsTUFBTTtJQUNuRSxPQUFPO1FBQ0h2TyxLQUFLazdCLFlBQVksR0FBRyxDQUFDO0lBQ3pCO0lBRUEsSUFBSWtZLGdCQUFnQjtRQUNoQixJQUFJYyxZQUFZekIsZ0JBQWdCdDFDLE1BQU1pMkM7UUFDdENwekMsS0FBS2dCLE1BQU0sQ0FBQ2duQyxJQUFJLEdBQUdBLEtBQUtseUIsS0FBSyxDQUFDbytCLFVBQVUvMkMsSUFBSSxFQUFFKzJDLFVBQVUzbEMsTUFBTTtJQUNsRTtJQUVBLElBQUk4a0MsZ0JBQWdCO1FBQ2hCLElBQUljLFlBQVkxQixnQkFBZ0J0MUMsTUFBTWsyQztRQUN0Q3J6QyxLQUFLZ0IsTUFBTSxDQUFDc0ssSUFBSSxHQUFHQSxLQUFLd0ssS0FBSyxDQUFDcStCLFVBQVVoM0MsSUFBSSxFQUFFZzNDLFVBQVU1bEMsTUFBTTtRQUM5RHZPLEtBQUt3RixRQUFRLENBQUNzRSxJQUFJO0lBQ3RCO0lBRUEsSUFBSXdwQyxnQkFBZ0I7UUFDaEIsSUFBSWMsWUFBWTNCLGdCQUFnQnQxQyxNQUFNbTJDO1FBQ3RDdHpDLEtBQUtnQixNQUFNLENBQUNpekIsSUFBSSxHQUFHQSxLQUFLbmUsS0FBSyxDQUFDcytCLFVBQVVqM0MsSUFBSSxFQUFFaTNDLFVBQVU3bEMsTUFBTTtJQUNsRTtJQUVBLElBQUkya0MsZ0JBQWdCO1FBQ2hCLElBQUltQixZQUFZNUIsZ0JBQWdCdDFDLE1BQU0rMUM7UUFDdENsekMsS0FBS2dCLE1BQU0sQ0FBQ3NtQyxJQUFJLEdBQUdBLEtBQUt4eEIsS0FBSyxDQUN6QnUrQixVQUFVbDNDLElBQUksRUFDZGszQyxVQUFVOWxDLE1BQU0sRUFDaEJ2TyxLQUFLMDBCLEtBQUs7SUFFbEI7SUFFQSxJQUFJZ2YsZ0JBQWdCO1FBQ2hCLElBQUlZLFlBQVk3QixnQkFBZ0J0MUMsTUFBTXUyQztRQUN0QzF6QyxLQUFLZ0IsTUFBTSxDQUFDMi9CLElBQUksR0FBR0EsS0FBSzdxQixLQUFLLENBQUN3K0IsVUFBVW4zQyxJQUFJLEVBQUVtM0MsVUFBVS9sQyxNQUFNO1FBQzlEdk8sS0FBS3UwQyxLQUFLLEdBQUd2MEMsS0FBS2dCLE1BQU0sQ0FBQzIvQixJQUFJO0lBQ2pDO0lBRUEsT0FBTzNnQztBQUNYO0FBRUEsU0FBU3cwQyxRQUFRO0FBQ2pCLFNBQVNDLFlBQVk7QUFFckIsSUFBSUMsV0FBVyxXQUFXLEdBQUV4ekMsT0FBT29jLE1BQU0sQ0FBQztJQUN2Q3EzQixXQUFXO0lBQ1gxYixNQUFNQTtJQUNOMzJCLE9BQU9BO0lBQ1A1RSxNQUFNQTtJQUNOazNDLFFBQVE5K0I7SUFDUkEsT0FBT2c5QjtJQUNQMEIsTUFBTUE7SUFDTkMsVUFBVUE7QUFDYjtBQUVBLGlFQUFlQyxRQUFRQSxFQUFDO0FBQzRELENBQ3BGLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3J1bWJsZS1yYWZmbGUtZnJhbWUvLi9ub2RlX21vZHVsZXMvQHNodWRpbmcvb3BlbnR5cGUuanMvZGlzdC9vcGVudHlwZS5tb2R1bGUuanM/NDk4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGh0dHBzOi8vb3BlbnR5cGUuanMub3JnIHYxLjMuNSB8IChjKSBGcmVkZXJpayBEZSBCbGVzZXIgYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyB8IE1JVCBMaWNlbnNlIHwgVXNlcyBmZmxhdGUgYnkgMTAxYXJyb3d6IGFuZCBzdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0IHBvbHlmaWxsIGJ5IE1hdGhpYXMgQnluZW5zXG4gKi9cblxuLy8gREVGTEFURSBpcyBhIGNvbXBsZXggZm9ybWF0OyB0byByZWFkIHRoaXMgY29kZSwgeW91IHNob3VsZCBwcm9iYWJseSBjaGVjayB0aGUgUkZDIGZpcnN0OlxuXG4vLyBhbGlhc2VzIGZvciBzaG9ydGVyIGNvbXByZXNzZWQgY29kZSAobW9zdCBtaW5pZmVycyBkb24ndCBkbyB0aGlzKVxudmFyIHU4ID0gVWludDhBcnJheSwgdTE2ID0gVWludDE2QXJyYXksIHUzMiA9IFVpbnQzMkFycmF5O1xuLy8gZml4ZWQgbGVuZ3RoIGV4dHJhIGJpdHNcbnZhciBmbGViID0gbmV3IHU4KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwLCAvKiB1bnVzZWQgKi8gMCwgMCwgLyogaW1wb3NzaWJsZSAqLyAwXSk7XG4vLyBmaXhlZCBkaXN0YW5jZSBleHRyYSBiaXRzXG4vLyBzZWUgZmxlYiBub3RlXG52YXIgZmRlYiA9IG5ldyB1OChbMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzLCAvKiB1bnVzZWQgKi8gMCwgMF0pO1xuLy8gY29kZSBsZW5ndGggaW5kZXggbWFwXG52YXIgY2xpbSA9IG5ldyB1OChbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV0pO1xuLy8gZ2V0IGJhc2UsIHJldmVyc2UgaW5kZXggbWFwIGZyb20gZXh0cmEgYml0c1xudmFyIGZyZWIgPSBmdW5jdGlvbiAoZWIsIHN0YXJ0KSB7XG4gICAgdmFyIGIgPSBuZXcgdTE2KDMxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMxOyArK2kpIHtcbiAgICAgICAgYltpXSA9IHN0YXJ0ICs9IDEgPDwgZWJbaSAtIDFdO1xuICAgIH1cbiAgICAvLyBudW1iZXJzIGhlcmUgYXJlIGF0IG1heCAxOCBiaXRzXG4gICAgdmFyIHIgPSBuZXcgdTMyKGJbMzBdKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDMwOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGJbaV07IGogPCBiW2kgKyAxXTsgKytqKSB7XG4gICAgICAgICAgICByW2pdID0gKChqIC0gYltpXSkgPDwgNSkgfCBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbYiwgcl07XG59O1xudmFyIF9hID0gZnJlYihmbGViLCAyKSwgZmwgPSBfYVswXSwgcmV2ZmwgPSBfYVsxXTtcbi8vIHdlIGNhbiBpZ25vcmUgdGhlIGZhY3QgdGhhdCB0aGUgb3RoZXIgbnVtYmVycyBhcmUgd3Jvbmc7IHRoZXkgbmV2ZXIgaGFwcGVuIGFueXdheVxuZmxbMjhdID0gMjU4LCByZXZmbFsyNThdID0gMjg7XG52YXIgX2IgPSBmcmViKGZkZWIsIDApLCBmZCA9IF9iWzBdO1xuLy8gbWFwIG9mIHZhbHVlIHRvIHJldmVyc2UgKGFzc3VtaW5nIDE2IGJpdHMpXG52YXIgcmV2ID0gbmV3IHUxNigzMjc2OCk7XG5mb3IgKHZhciBpID0gMDsgaSA8IDMyNzY4OyArK2kpIHtcbiAgICAvLyByZXZlcnNlIHRhYmxlIGFsZ29yaXRobSBmcm9tIFNPXG4gICAgdmFyIHggPSAoKGkgJiAweEFBQUEpID4+PiAxKSB8ICgoaSAmIDB4NTU1NSkgPDwgMSk7XG4gICAgeCA9ICgoeCAmIDB4Q0NDQykgPj4+IDIpIHwgKCh4ICYgMHgzMzMzKSA8PCAyKTtcbiAgICB4ID0gKCh4ICYgMHhGMEYwKSA+Pj4gNCkgfCAoKHggJiAweDBGMEYpIDw8IDQpO1xuICAgIHJldltpXSA9ICgoKHggJiAweEZGMDApID4+PiA4KSB8ICgoeCAmIDB4MDBGRikgPDwgOCkpID4+PiAxO1xufVxuLy8gY3JlYXRlIGh1ZmZtYW4gdHJlZSBmcm9tIHU4IFwibWFwXCI6IGluZGV4IC0+IGNvZGUgbGVuZ3RoIGZvciBjb2RlIGluZGV4XG4vLyBtYiAobWF4IGJpdHMpIG11c3QgYmUgYXQgbW9zdCAxNVxuLy8gVE9ETzogb3B0aW1pemUvc3BsaXQgdXA/XG52YXIgaE1hcCA9IChmdW5jdGlvbiAoY2QsIG1iLCByKSB7XG4gICAgdmFyIHMgPSBjZC5sZW5ndGg7XG4gICAgLy8gaW5kZXhcbiAgICB2YXIgaSA9IDA7XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+ICMgb2YgY29kZXMgd2l0aCBiaXQgbGVuZ3RoID0gaW5kZXhcbiAgICB2YXIgbCA9IG5ldyB1MTYobWIpO1xuICAgIC8vIGxlbmd0aCBvZiBjZCBtdXN0IGJlIDI4OCAodG90YWwgIyBvZiBjb2RlcylcbiAgICBmb3IgKDsgaSA8IHM7ICsraSkge1xuICAgICAgICBpZiAoY2RbaV0pXG4gICAgICAgICAgICB7ICsrbFtjZFtpXSAtIDFdOyB9XG4gICAgfVxuICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiBtaW5pbXVtIGNvZGUgZm9yIGJpdCBsZW5ndGggPSBpbmRleFxuICAgIHZhciBsZSA9IG5ldyB1MTYobWIpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtYjsgKytpKSB7XG4gICAgICAgIGxlW2ldID0gKGxlW2kgLSAxXSArIGxbaSAtIDFdKSA8PCAxO1xuICAgIH1cbiAgICB2YXIgY287XG4gICAgaWYgKHIpIHtcbiAgICAgICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+IG51bWJlciBvZiBhY3R1YWwgYml0cywgc3ltYm9sIGZvciBjb2RlXG4gICAgICAgIGNvID0gbmV3IHUxNigxIDw8IG1iKTtcbiAgICAgICAgLy8gYml0cyB0byByZW1vdmUgZm9yIHJldmVyc2VyXG4gICAgICAgIHZhciBydmIgPSAxNSAtIG1iO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgMCBsZW5ndGhzXG4gICAgICAgICAgICBpZiAoY2RbaV0pIHtcbiAgICAgICAgICAgICAgICAvLyBudW0gZW5jb2RpbmcgYm90aCBzeW1ib2wgYW5kIGJpdHMgcmVhZFxuICAgICAgICAgICAgICAgIHZhciBzdiA9IChpIDw8IDQpIHwgY2RbaV07XG4gICAgICAgICAgICAgICAgLy8gZnJlZSBiaXRzXG4gICAgICAgICAgICAgICAgdmFyIHJfMSA9IG1iIC0gY2RbaV07XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGxlW2NkW2ldIC0gMV0rKyA8PCByXzE7XG4gICAgICAgICAgICAgICAgLy8gbSBpcyBlbmQgdmFsdWVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gdiB8ICgoMSA8PCByXzEpIC0gMSk7IHYgPD0gbTsgKyt2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZXJ5IDE2IGJpdCB2YWx1ZSBzdGFydGluZyB3aXRoIHRoZSBjb2RlIHlpZWxkcyB0aGUgc2FtZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgY29bcmV2W3ZdID4+PiBydmJdID0gc3Y7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjbyA9IG5ldyB1MTYocyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChjZFtpXSkge1xuICAgICAgICAgICAgICAgIGNvW2ldID0gcmV2W2xlW2NkW2ldIC0gMV0rK10gPj4+ICgxNSAtIGNkW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY287XG59KTtcbi8vIGZpeGVkIGxlbmd0aCB0cmVlXG52YXIgZmx0ID0gbmV3IHU4KDI4OCk7XG5mb3IgKHZhciBpID0gMDsgaSA8IDE0NDsgKytpKVxuICAgIHsgZmx0W2ldID0gODsgfVxuZm9yICh2YXIgaSA9IDE0NDsgaSA8IDI1NjsgKytpKVxuICAgIHsgZmx0W2ldID0gOTsgfVxuZm9yICh2YXIgaSA9IDI1NjsgaSA8IDI4MDsgKytpKVxuICAgIHsgZmx0W2ldID0gNzsgfVxuZm9yICh2YXIgaSA9IDI4MDsgaSA8IDI4ODsgKytpKVxuICAgIHsgZmx0W2ldID0gODsgfVxuLy8gZml4ZWQgZGlzdGFuY2UgdHJlZVxudmFyIGZkdCA9IG5ldyB1OCgzMik7XG5mb3IgKHZhciBpID0gMDsgaSA8IDMyOyArK2kpXG4gICAgeyBmZHRbaV0gPSA1OyB9XG4vLyBmaXhlZCBsZW5ndGggbWFwXG52YXIgZmxybSA9IC8qI19fUFVSRV9fKi8gaE1hcChmbHQsIDksIDEpO1xuLy8gZml4ZWQgZGlzdGFuY2UgbWFwXG52YXIgZmRybSA9IC8qI19fUFVSRV9fKi8gaE1hcChmZHQsIDUsIDEpO1xuLy8gZmluZCBtYXggb2YgYXJyYXlcbnZhciBtYXggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBtID0gYVswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFbaV0gPiBtKVxuICAgICAgICAgICAgeyBtID0gYVtpXTsgfVxuICAgIH1cbiAgICByZXR1cm4gbTtcbn07XG4vLyByZWFkIGQsIHN0YXJ0aW5nIGF0IGJpdCBwIGFuZCBtYXNrIHdpdGggbVxudmFyIGJpdHMgPSBmdW5jdGlvbiAoZCwgcCwgbSkge1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgcmV0dXJuICgoZFtvXSB8IChkW28gKyAxXSA8PCA4KSkgPj4gKHAgJiA3KSkgJiBtO1xufTtcbi8vIHJlYWQgZCwgc3RhcnRpbmcgYXQgYml0IHAgY29udGludWluZyBmb3IgYXQgbGVhc3QgMTYgYml0c1xudmFyIGJpdHMxNiA9IGZ1bmN0aW9uIChkLCBwKSB7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICByZXR1cm4gKChkW29dIHwgKGRbbyArIDFdIDw8IDgpIHwgKGRbbyArIDJdIDw8IDE2KSkgPj4gKHAgJiA3KSk7XG59O1xuLy8gZ2V0IGVuZCBvZiBieXRlXG52YXIgc2hmdCA9IGZ1bmN0aW9uIChwKSB7IHJldHVybiAoKHAgKyA3KSAvIDgpIHwgMDsgfTtcbi8vIHR5cGVkIGFycmF5IHNsaWNlIC0gYWxsb3dzIGdhcmJhZ2UgY29sbGVjdG9yIHRvIGZyZWUgb3JpZ2luYWwgcmVmZXJlbmNlLFxuLy8gd2hpbGUgYmVpbmcgbW9yZSBjb21wYXRpYmxlIHRoYW4gLnNsaWNlXG52YXIgc2xjID0gZnVuY3Rpb24gKHYsIHMsIGUpIHtcbiAgICBpZiAocyA9PSBudWxsIHx8IHMgPCAwKVxuICAgICAgICB7IHMgPSAwOyB9XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID4gdi5sZW5ndGgpXG4gICAgICAgIHsgZSA9IHYubGVuZ3RoOyB9XG4gICAgLy8gY2FuJ3QgdXNlIC5jb25zdHJ1Y3RvciBpbiBjYXNlIHVzZXItc3VwcGxpZWRcbiAgICB2YXIgbiA9IG5ldyAodi5CWVRFU19QRVJfRUxFTUVOVCA9PSAyID8gdTE2IDogdi5CWVRFU19QRVJfRUxFTUVOVCA9PSA0ID8gdTMyIDogdTgpKGUgLSBzKTtcbiAgICBuLnNldCh2LnN1YmFycmF5KHMsIGUpKTtcbiAgICByZXR1cm4gbjtcbn07XG4vLyBlcnJvciBjb2Rlc1xudmFyIGVjID0gW1xuICAgICd1bmV4cGVjdGVkIEVPRicsXG4gICAgJ2ludmFsaWQgYmxvY2sgdHlwZScsXG4gICAgJ2ludmFsaWQgbGVuZ3RoL2xpdGVyYWwnLFxuICAgICdpbnZhbGlkIGRpc3RhbmNlJyxcbiAgICAnc3RyZWFtIGZpbmlzaGVkJyxcbiAgICAnbm8gc3RyZWFtIGhhbmRsZXInLFxuICAgICxcbiAgICAnbm8gY2FsbGJhY2snLFxuICAgICdpbnZhbGlkIFVURi04IGRhdGEnLFxuICAgICdleHRyYSBmaWVsZCB0b28gbG9uZycsXG4gICAgJ2RhdGUgbm90IGluIHJhbmdlIDE5ODAtMjA5OScsXG4gICAgJ2ZpbGVuYW1lIHRvbyBsb25nJyxcbiAgICAnc3RyZWFtIGZpbmlzaGluZycsXG4gICAgJ2ludmFsaWQgemlwIGRhdGEnXG4gICAgLy8gZGV0ZXJtaW5lZCBieSB1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZFxuXTtcbnZhciBlcnIgPSBmdW5jdGlvbiAoaW5kLCBtc2csIG50KSB7XG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobXNnIHx8IGVjW2luZF0pO1xuICAgIGUuY29kZSA9IGluZDtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgICAgIHsgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZSwgZXJyKTsgfVxuICAgIGlmICghbnQpXG4gICAgICAgIHsgdGhyb3cgZTsgfVxuICAgIHJldHVybiBlO1xufTtcbi8vIGV4cGFuZHMgcmF3IERFRkxBVEUgZGF0YVxudmFyIGluZmx0ID0gZnVuY3Rpb24gKGRhdCwgYnVmLCBzdCkge1xuICAgIC8vIHNvdXJjZSBsZW5ndGhcbiAgICB2YXIgc2wgPSBkYXQubGVuZ3RoO1xuICAgIGlmICghc2wgfHwgKHN0ICYmIHN0LmYgJiYgIXN0LmwpKVxuICAgICAgICB7IHJldHVybiBidWYgfHwgbmV3IHU4KDApOyB9XG4gICAgLy8gaGF2ZSB0byBlc3RpbWF0ZSBzaXplXG4gICAgdmFyIG5vQnVmID0gIWJ1ZiB8fCBzdDtcbiAgICAvLyBubyBzdGF0ZVxuICAgIHZhciBub1N0ID0gIXN0IHx8IHN0Lmk7XG4gICAgaWYgKCFzdClcbiAgICAgICAgeyBzdCA9IHt9OyB9XG4gICAgLy8gQXNzdW1lcyByb3VnaGx5IDMzJSBjb21wcmVzc2lvbiByYXRpbyBhdmVyYWdlXG4gICAgaWYgKCFidWYpXG4gICAgICAgIHsgYnVmID0gbmV3IHU4KHNsICogMyk7IH1cbiAgICAvLyBlbnN1cmUgYnVmZmVyIGNhbiBmaXQgYXQgbGVhc3QgbCBlbGVtZW50c1xuICAgIHZhciBjYnVmID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgdmFyIGJsID0gYnVmLmxlbmd0aDtcbiAgICAgICAgLy8gbmVlZCB0byBpbmNyZWFzZSBzaXplIHRvIGZpdFxuICAgICAgICBpZiAobCA+IGJsKSB7XG4gICAgICAgICAgICAvLyBEb3VibGUgb3Igc2V0IHRvIG5lY2Vzc2FyeSwgd2hpY2hldmVyIGlzIGdyZWF0ZXJcbiAgICAgICAgICAgIHZhciBuYnVmID0gbmV3IHU4KE1hdGgubWF4KGJsICogMiwgbCkpO1xuICAgICAgICAgICAgbmJ1Zi5zZXQoYnVmKTtcbiAgICAgICAgICAgIGJ1ZiA9IG5idWY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vICBsYXN0IGNodW5rICAgICAgICAgYml0cG9zICAgICAgICAgICBieXRlc1xuICAgIHZhciBmaW5hbCA9IHN0LmYgfHwgMCwgcG9zID0gc3QucCB8fCAwLCBidCA9IHN0LmIgfHwgMCwgbG0gPSBzdC5sLCBkbSA9IHN0LmQsIGxidCA9IHN0Lm0sIGRidCA9IHN0Lm47XG4gICAgLy8gdG90YWwgYml0c1xuICAgIHZhciB0YnRzID0gc2wgKiA4O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCFsbSkge1xuICAgICAgICAgICAgLy8gQkZJTkFMIC0gdGhpcyBpcyBvbmx5IDEgd2hlbiBsYXN0IGNodW5rIGlzIG5leHRcbiAgICAgICAgICAgIGZpbmFsID0gYml0cyhkYXQsIHBvcywgMSk7XG4gICAgICAgICAgICAvLyB0eXBlOiAwID0gbm8gY29tcHJlc3Npb24sIDEgPSBmaXhlZCBodWZmbWFuLCAyID0gZHluYW1pYyBodWZmbWFuXG4gICAgICAgICAgICB2YXIgdHlwZSA9IGJpdHMoZGF0LCBwb3MgKyAxLCAzKTtcbiAgICAgICAgICAgIHBvcyArPSAzO1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gZ28gdG8gZW5kIG9mIGJ5dGUgYm91bmRhcnlcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHNoZnQocG9zKSArIDQsIGwgPSBkYXRbcyAtIDRdIHwgKGRhdFtzIC0gM10gPDwgOCksIHQgPSBzICsgbDtcbiAgICAgICAgICAgICAgICBpZiAodCA+IHNsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICAgICAgeyBlcnIoMCk7IH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzaXplXG4gICAgICAgICAgICAgICAgaWYgKG5vQnVmKVxuICAgICAgICAgICAgICAgICAgICB7IGNidWYoYnQgKyBsKTsgfVxuICAgICAgICAgICAgICAgIC8vIENvcHkgb3ZlciB1bmNvbXByZXNzZWQgZGF0YVxuICAgICAgICAgICAgICAgIGJ1Zi5zZXQoZGF0LnN1YmFycmF5KHMsIHQpLCBidCk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IG5ldyBiaXRwb3MsIHVwZGF0ZSBieXRlIGNvdW50XG4gICAgICAgICAgICAgICAgc3QuYiA9IGJ0ICs9IGwsIHN0LnAgPSBwb3MgPSB0ICogOCwgc3QuZiA9IGZpbmFsO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHsgbG0gPSBmbHJtLCBkbSA9IGZkcm0sIGxidCA9IDksIGRidCA9IDU7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMikge1xuICAgICAgICAgICAgICAgIC8vICBsaXRlcmFsICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aHNcbiAgICAgICAgICAgICAgICB2YXIgaExpdCA9IGJpdHMoZGF0LCBwb3MsIDMxKSArIDI1NywgaGNMZW4gPSBiaXRzKGRhdCwgcG9zICsgMTAsIDE1KSArIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHRsID0gaExpdCArIGJpdHMoZGF0LCBwb3MgKyA1LCAzMSkgKyAxO1xuICAgICAgICAgICAgICAgIHBvcyArPSAxNDtcbiAgICAgICAgICAgICAgICAvLyBsZW5ndGgrZGlzdGFuY2UgdHJlZVxuICAgICAgICAgICAgICAgIHZhciBsZHQgPSBuZXcgdTgodGwpO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RoIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgY2x0ID0gbmV3IHU4KDE5KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhjTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGluZGV4IG1hcCB0byBnZXQgcmVhbCBjb2RlXG4gICAgICAgICAgICAgICAgICAgIGNsdFtjbGltW2ldXSA9IGJpdHMoZGF0LCBwb3MgKyBpICogMywgNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBoY0xlbiAqIDM7XG4gICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGhzIGJpdHNcbiAgICAgICAgICAgICAgICB2YXIgY2xiID0gbWF4KGNsdCksIGNsYm1zayA9ICgxIDw8IGNsYikgLSAxO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RocyBtYXBcbiAgICAgICAgICAgICAgICB2YXIgY2xtID0gaE1hcChjbHQsIGNsYiwgMSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBjbG1bYml0cyhkYXQsIHBvcywgY2xibXNrKV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgcmVhZFxuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gciAmIDE1O1xuICAgICAgICAgICAgICAgICAgICAvLyBzeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSByID4+PiA0O1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0byBjb3B5XG4gICAgICAgICAgICAgICAgICAgIGlmIChzIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxkdFtpKytdID0gcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBjb3B5ICAgY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gMCwgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PSAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG4gPSAzICsgYml0cyhkYXQsIHBvcywgMyksIHBvcyArPSAyLCBjID0gbGR0W2kgLSAxXTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAxNylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG4gPSAzICsgYml0cyhkYXQsIHBvcywgNyksIHBvcyArPSAzOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzID09IDE4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbiA9IDExICsgYml0cyhkYXQsIHBvcywgMTI3KSwgcG9zICs9IDc7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBsZHRbaSsrXSA9IGM7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgICBsZW5ndGggdHJlZSAgICAgICAgICAgICAgICAgZGlzdGFuY2UgdHJlZVxuICAgICAgICAgICAgICAgIHZhciBsdCA9IGxkdC5zdWJhcnJheSgwLCBoTGl0KSwgZHQgPSBsZHQuc3ViYXJyYXkoaExpdCk7XG4gICAgICAgICAgICAgICAgLy8gbWF4IGxlbmd0aCBiaXRzXG4gICAgICAgICAgICAgICAgbGJ0ID0gbWF4KGx0KTtcbiAgICAgICAgICAgICAgICAvLyBtYXggZGlzdCBiaXRzXG4gICAgICAgICAgICAgICAgZGJ0ID0gbWF4KGR0KTtcbiAgICAgICAgICAgICAgICBsbSA9IGhNYXAobHQsIGxidCwgMSk7XG4gICAgICAgICAgICAgICAgZG0gPSBoTWFwKGR0LCBkYnQsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHsgZXJyKDEpOyB9XG4gICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICB7IGVycigwKTsgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgYnVmZmVyIGNhbiBob2xkIHRoaXMgKyB0aGUgbGFyZ2VzdCBwb3NzaWJsZSBhZGRpdGlvblxuICAgICAgICAvLyBNYXhpbXVtIGNodW5rIHNpemUgKHByYWN0aWNhbGx5LCB0aGVvcmV0aWNhbGx5IGluZmluaXRlKSBpcyAyXjE3O1xuICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgICB7IGNidWYoYnQgKyAxMzEwNzIpOyB9XG4gICAgICAgIHZhciBsbXMgPSAoMSA8PCBsYnQpIC0gMSwgZG1zID0gKDEgPDwgZGJ0KSAtIDE7XG4gICAgICAgIHZhciBscG9zID0gcG9zO1xuICAgICAgICBmb3IgKDs7IGxwb3MgPSBwb3MpIHtcbiAgICAgICAgICAgIC8vIGJpdHMgcmVhZCwgY29kZVxuICAgICAgICAgICAgdmFyIGMgPSBsbVtiaXRzMTYoZGF0LCBwb3MpICYgbG1zXSwgc3ltID0gYyA+Pj4gNDtcbiAgICAgICAgICAgIHBvcyArPSBjICYgMTU7XG4gICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICB7IGVycigwKTsgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjKVxuICAgICAgICAgICAgICAgIHsgZXJyKDIpOyB9XG4gICAgICAgICAgICBpZiAoc3ltIDwgMjU2KVxuICAgICAgICAgICAgICAgIHsgYnVmW2J0KytdID0gc3ltOyB9XG4gICAgICAgICAgICBlbHNlIGlmIChzeW0gPT0gMjU2KSB7XG4gICAgICAgICAgICAgICAgbHBvcyA9IHBvcywgbG0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkZCA9IHN5bSAtIDI1NDtcbiAgICAgICAgICAgICAgICAvLyBubyBleHRyYSBiaXRzIG5lZWRlZCBpZiBsZXNzXG4gICAgICAgICAgICAgICAgaWYgKHN5bSA+IDI2NCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmRleFxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHN5bSAtIDI1NywgYiA9IGZsZWJbaV07XG4gICAgICAgICAgICAgICAgICAgIGFkZCA9IGJpdHMoZGF0LCBwb3MsICgxIDw8IGIpIC0gMSkgKyBmbFtpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRpc3RcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRtW2JpdHMxNihkYXQsIHBvcykgJiBkbXNdLCBkc3ltID0gZCA+Pj4gNDtcbiAgICAgICAgICAgICAgICBpZiAoIWQpXG4gICAgICAgICAgICAgICAgICAgIHsgZXJyKDMpOyB9XG4gICAgICAgICAgICAgICAgcG9zICs9IGQgJiAxNTtcbiAgICAgICAgICAgICAgICB2YXIgZHQgPSBmZFtkc3ltXTtcbiAgICAgICAgICAgICAgICBpZiAoZHN5bSA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBmZGViW2RzeW1dO1xuICAgICAgICAgICAgICAgICAgICBkdCArPSBiaXRzMTYoZGF0LCBwb3MpICYgKCgxIDw8IGIpIC0gMSksIHBvcyArPSBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgZXJyKDApOyB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgICAgICAgICAgIHsgY2J1ZihidCArIDEzMTA3Mik7IH1cbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gYnQgKyBhZGQ7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJ0IDwgZW5kOyBidCArPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidF0gPSBidWZbYnQgLSBkdF07XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidCArIDFdID0gYnVmW2J0ICsgMSAtIGR0XTtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0ICsgMl0gPSBidWZbYnQgKyAyIC0gZHRdO1xuICAgICAgICAgICAgICAgICAgICBidWZbYnQgKyAzXSA9IGJ1ZltidCArIDMgLSBkdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ0ID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0LmwgPSBsbSwgc3QucCA9IGxwb3MsIHN0LmIgPSBidCwgc3QuZiA9IGZpbmFsO1xuICAgICAgICBpZiAobG0pXG4gICAgICAgICAgICB7IGZpbmFsID0gMSwgc3QubSA9IGxidCwgc3QuZCA9IGRtLCBzdC5uID0gZGJ0OyB9XG4gICAgfSB3aGlsZSAoIWZpbmFsKTtcbiAgICByZXR1cm4gYnQgPT0gYnVmLmxlbmd0aCA/IGJ1ZiA6IHNsYyhidWYsIDAsIGJ0KTtcbn07XG4vLyBlbXB0eVxudmFyIGV0ID0gLyojX19QVVJFX18qLyBuZXcgdTgoMCk7XG4vKipcbiAqIEV4cGFuZHMgREVGTEFURSBkYXRhIHdpdGggbm8gd3JhcHBlclxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb21wcmVzc1xuICogQHBhcmFtIG91dCBXaGVyZSB0byB3cml0ZSB0aGUgZGF0YS4gU2F2ZXMgbWVtb3J5IGlmIHlvdSBrbm93IHRoZSBkZWNvbXByZXNzZWQgc2l6ZSBhbmQgcHJvdmlkZSBhbiBvdXRwdXQgYnVmZmVyIG9mIHRoYXQgbGVuZ3RoLlxuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVTeW5jKGRhdGEsIG91dCkge1xuICAgIHJldHVybiBpbmZsdChkYXRhLCBvdXQpO1xufVxuLy8gdGV4dCBkZWNvZGVyXG52YXIgdGQgPSB0eXBlb2YgVGV4dERlY29kZXIgIT0gJ3VuZGVmaW5lZCcgJiYgLyojX19QVVJFX18qLyBuZXcgVGV4dERlY29kZXIoKTtcbi8vIHRleHQgZGVjb2RlciBzdHJlYW1cbnZhciB0ZHMgPSAwO1xudHJ5IHtcbiAgICB0ZC5kZWNvZGUoZXQsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIHRkcyA9IDE7XG59XG5jYXRjaCAoZSkgeyB9XG5cbi8vIEdlb21ldHJpYyBvYmplY3RzXG5cbi8vIGltcG9ydCBCb3VuZGluZ0JveCBmcm9tICcuL2Jib3gnO1xuXG4vKipcbiAqIEEgYsOpemllciBwYXRoIGNvbnRhaW5pbmcgYSBzZXQgb2YgcGF0aCBjb21tYW5kcyBzaW1pbGFyIHRvIGEgU1ZHIHBhdGguXG4gKiBQYXRocyBjYW4gYmUgZHJhd24gb24gYSBjb250ZXh0IHVzaW5nIGBkcmF3YC5cbiAqIEBleHBvcnRzIG9wZW50eXBlLlBhdGhcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBhdGgoKSB7XG4gICAgdGhpcy5jb21tYW5kcyA9IFtdO1xuICAgIHRoaXMuZmlsbCA9ICdibGFjayc7XG4gICAgdGhpcy5zdHJva2UgPSBudWxsO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0geFxuICogQHBhcmFtICB7bnVtYmVyfSB5XG4gKi9cblBhdGgucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ00nLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSAge251bWJlcn0geVxuICovXG5QYXRoLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdMJyxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRHJhd3MgY3ViaWMgY3VydmVcbiAqIEBmdW5jdGlvblxuICogY3VydmVUb1xuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sIDFcbiAqIEBwYXJhbSAge251bWJlcn0geTEgLSB5IG9mIGNvbnRyb2wgMVxuICogQHBhcmFtICB7bnVtYmVyfSB4MiAtIHggb2YgY29udHJvbCAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkyIC0geSBvZiBjb250cm9sIDJcbiAqIEBwYXJhbSAge251bWJlcn0geCAtIHggb2YgcGF0aCBwb2ludFxuICogQHBhcmFtICB7bnVtYmVyfSB5IC0geSBvZiBwYXRoIHBvaW50XG4gKi9cblxuLyoqXG4gKiBEcmF3cyBjdWJpYyBjdXJ2ZVxuICogQGZ1bmN0aW9uXG4gKiBiZXppZXJDdXJ2ZVRvXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqIEBwYXJhbSAge251bWJlcn0geDEgLSB4IG9mIGNvbnRyb2wgMVxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbCAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgyIC0geCBvZiBjb250cm9sIDJcbiAqIEBwYXJhbSAge251bWJlcn0geTIgLSB5IG9mIGNvbnRyb2wgMlxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqIEBzZWUgY3VydmVUb1xuICovXG5QYXRoLnByb3RvdHlwZS5jdXJ2ZVRvID0gUGF0aC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uIChcbiAgICB4MSxcbiAgICB5MSxcbiAgICB4MixcbiAgICB5MixcbiAgICB4LFxuICAgIHlcbikge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdDJyxcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB5MTogeTEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgeTI6IHkyLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEcmF3cyBxdWFkcmF0aWMgY3VydmVcbiAqIEBmdW5jdGlvblxuICogcXVhZHJhdGljQ3VydmVUb1xuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkxIC0geSBvZiBjb250cm9sXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcbiAqIEBwYXJhbSAge251bWJlcn0geSAtIHkgb2YgcGF0aCBwb2ludFxuICovXG5cbi8qKlxuICogRHJhd3MgcXVhZHJhdGljIGN1cnZlXG4gKiBAZnVuY3Rpb25cbiAqIHF1YWRUb1xuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkxIC0geSBvZiBjb250cm9sXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcbiAqIEBwYXJhbSAge251bWJlcn0geSAtIHkgb2YgcGF0aCBwb2ludFxuICovXG5QYXRoLnByb3RvdHlwZS5xdWFkVG8gPSBQYXRoLnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24gKFxuICAgIHgxLFxuICAgIHkxLFxuICAgIHgsXG4gICAgeVxuKSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ1EnLFxuICAgICAgICB4MTogeDEsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBwYXRoXG4gKiBAZnVuY3Rpb24gY2xvc2VQYXRoXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqL1xuXG4vKipcbiAqIENsb3NlIHRoZSBwYXRoXG4gKiBAZnVuY3Rpb24gY2xvc2VcbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICovXG5QYXRoLnByb3RvdHlwZS5jbG9zZSA9IFBhdGgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnWicsXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gcGF0aCBvciBsaXN0IG9mIGNvbW1hbmRzIHRvIHRoZSBjb21tYW5kcyBvZiB0aGlzIHBhdGguXG4gKiBAcGFyYW0gIHtBcnJheX0gcGF0aE9yQ29tbWFuZHMgLSBhbm90aGVyIG9wZW50eXBlLlBhdGgsIGFuIG9wZW50eXBlLkJvdW5kaW5nQm94LCBvciBhbiBhcnJheSBvZiBjb21tYW5kcy5cbiAqL1xuUGF0aC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKHBhdGhPckNvbW1hbmRzKSB7XG4gICAgaWYgKHBhdGhPckNvbW1hbmRzLmNvbW1hbmRzKSB7XG4gICAgICAgIHBhdGhPckNvbW1hbmRzID0gcGF0aE9yQ29tbWFuZHMuY29tbWFuZHM7XG4gICAgfVxuICAgIC8vIGVsc2UgaWYgKHBhdGhPckNvbW1hbmRzIGluc3RhbmNlb2YgQm91bmRpbmdCb3gpIHtcbiAgICAvLyAgICAgY29uc3QgYm94ID0gcGF0aE9yQ29tbWFuZHM7XG4gICAgLy8gICAgIHRoaXMubW92ZVRvKGJveC54MSwgYm94LnkxKTtcbiAgICAvLyAgICAgdGhpcy5saW5lVG8oYm94LngyLCBib3gueTEpO1xuICAgIC8vICAgICB0aGlzLmxpbmVUbyhib3gueDIsIGJveC55Mik7XG4gICAgLy8gICAgIHRoaXMubGluZVRvKGJveC54MSwgYm94LnkyKTtcbiAgICAvLyAgICAgdGhpcy5jbG9zZSgpO1xuICAgIC8vICAgICByZXR1cm47XG4gICAgLy8gfVxuXG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5jb21tYW5kcywgcGF0aE9yQ29tbWFuZHMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBQYXRoIHRvIGEgc3RyaW5nIG9mIHBhdGggZGF0YSBpbnN0cnVjdGlvbnNcbiAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVxuICogQHBhcmFtICB7bnVtYmVyfSBbZGVjaW1hbFBsYWNlcz0yXSAtIFRoZSBhbW91bnQgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGZsb2F0aW5nLXBvaW50IHZhbHVlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5QYXRoLnByb3RvdHlwZS50b1BhdGhEYXRhID0gZnVuY3Rpb24gKGRlY2ltYWxQbGFjZXMpIHtcbiAgICBkZWNpbWFsUGxhY2VzID0gZGVjaW1hbFBsYWNlcyAhPT0gdW5kZWZpbmVkID8gZGVjaW1hbFBsYWNlcyA6IDI7XG5cbiAgICBmdW5jdGlvbiBmbG9hdFRvU3RyaW5nKHYpIHtcbiAgICAgICAgaWYgKE1hdGgucm91bmQodikgPT09IHYpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIE1hdGgucm91bmQodik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b0ZpeGVkKGRlY2ltYWxQbGFjZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFja1ZhbHVlcygpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGFyZ3VtZW50cyQxW2ldO1xuICAgICAgICAgICAgaWYgKHYgPj0gMCAmJiBpID4gMCkge1xuICAgICAgICAgICAgICAgIHMgKz0gJyAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzICs9IGZsb2F0VG9TdHJpbmcodik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICB2YXIgZCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gdGhpcy5jb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIGQgKz0gJ00nICsgcGFja1ZhbHVlcyhjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcbiAgICAgICAgICAgIGQgKz0gJ0wnICsgcGFja1ZhbHVlcyhjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIGQgKz0gJ0MnICsgcGFja1ZhbHVlcyhjbWQueDEsIGNtZC55MSwgY21kLngyLCBjbWQueTIsIGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgZCArPSAnUScgKyBwYWNrVmFsdWVzKGNtZC54MSwgY21kLnkxLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIGQgKz0gJ1onO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG4vLyBHbHlwaCBlbmNvZGluZ1xuXG52YXIgY2ZmU3RhbmRhcmRTdHJpbmdzID0gW1xuICAgICcubm90ZGVmJyxcbiAgICAnc3BhY2UnLFxuICAgICdleGNsYW0nLFxuICAgICdxdW90ZWRibCcsXG4gICAgJ251bWJlcnNpZ24nLFxuICAgICdkb2xsYXInLFxuICAgICdwZXJjZW50JyxcbiAgICAnYW1wZXJzYW5kJyxcbiAgICAncXVvdGVyaWdodCcsXG4gICAgJ3BhcmVubGVmdCcsXG4gICAgJ3BhcmVucmlnaHQnLFxuICAgICdhc3RlcmlzaycsXG4gICAgJ3BsdXMnLFxuICAgICdjb21tYScsXG4gICAgJ2h5cGhlbicsXG4gICAgJ3BlcmlvZCcsXG4gICAgJ3NsYXNoJyxcbiAgICAnemVybycsXG4gICAgJ29uZScsXG4gICAgJ3R3bycsXG4gICAgJ3RocmVlJyxcbiAgICAnZm91cicsXG4gICAgJ2ZpdmUnLFxuICAgICdzaXgnLFxuICAgICdzZXZlbicsXG4gICAgJ2VpZ2h0JyxcbiAgICAnbmluZScsXG4gICAgJ2NvbG9uJyxcbiAgICAnc2VtaWNvbG9uJyxcbiAgICAnbGVzcycsXG4gICAgJ2VxdWFsJyxcbiAgICAnZ3JlYXRlcicsXG4gICAgJ3F1ZXN0aW9uJyxcbiAgICAnYXQnLFxuICAgICdBJyxcbiAgICAnQicsXG4gICAgJ0MnLFxuICAgICdEJyxcbiAgICAnRScsXG4gICAgJ0YnLFxuICAgICdHJyxcbiAgICAnSCcsXG4gICAgJ0knLFxuICAgICdKJyxcbiAgICAnSycsXG4gICAgJ0wnLFxuICAgICdNJyxcbiAgICAnTicsXG4gICAgJ08nLFxuICAgICdQJyxcbiAgICAnUScsXG4gICAgJ1InLFxuICAgICdTJyxcbiAgICAnVCcsXG4gICAgJ1UnLFxuICAgICdWJyxcbiAgICAnVycsXG4gICAgJ1gnLFxuICAgICdZJyxcbiAgICAnWicsXG4gICAgJ2JyYWNrZXRsZWZ0JyxcbiAgICAnYmFja3NsYXNoJyxcbiAgICAnYnJhY2tldHJpZ2h0JyxcbiAgICAnYXNjaWljaXJjdW0nLFxuICAgICd1bmRlcnNjb3JlJyxcbiAgICAncXVvdGVsZWZ0JyxcbiAgICAnYScsXG4gICAgJ2InLFxuICAgICdjJyxcbiAgICAnZCcsXG4gICAgJ2UnLFxuICAgICdmJyxcbiAgICAnZycsXG4gICAgJ2gnLFxuICAgICdpJyxcbiAgICAnaicsXG4gICAgJ2snLFxuICAgICdsJyxcbiAgICAnbScsXG4gICAgJ24nLFxuICAgICdvJyxcbiAgICAncCcsXG4gICAgJ3EnLFxuICAgICdyJyxcbiAgICAncycsXG4gICAgJ3QnLFxuICAgICd1JyxcbiAgICAndicsXG4gICAgJ3cnLFxuICAgICd4JyxcbiAgICAneScsXG4gICAgJ3onLFxuICAgICdicmFjZWxlZnQnLFxuICAgICdiYXInLFxuICAgICdicmFjZXJpZ2h0JyxcbiAgICAnYXNjaWl0aWxkZScsXG4gICAgJ2V4Y2xhbWRvd24nLFxuICAgICdjZW50JyxcbiAgICAnc3RlcmxpbmcnLFxuICAgICdmcmFjdGlvbicsXG4gICAgJ3llbicsXG4gICAgJ2Zsb3JpbicsXG4gICAgJ3NlY3Rpb24nLFxuICAgICdjdXJyZW5jeScsXG4gICAgJ3F1b3Rlc2luZ2xlJyxcbiAgICAncXVvdGVkYmxsZWZ0JyxcbiAgICAnZ3VpbGxlbW90bGVmdCcsXG4gICAgJ2d1aWxzaW5nbGxlZnQnLFxuICAgICdndWlsc2luZ2xyaWdodCcsXG4gICAgJ2ZpJyxcbiAgICAnZmwnLFxuICAgICdlbmRhc2gnLFxuICAgICdkYWdnZXInLFxuICAgICdkYWdnZXJkYmwnLFxuICAgICdwZXJpb2RjZW50ZXJlZCcsXG4gICAgJ3BhcmFncmFwaCcsXG4gICAgJ2J1bGxldCcsXG4gICAgJ3F1b3Rlc2luZ2xiYXNlJyxcbiAgICAncXVvdGVkYmxiYXNlJyxcbiAgICAncXVvdGVkYmxyaWdodCcsXG4gICAgJ2d1aWxsZW1vdHJpZ2h0JyxcbiAgICAnZWxsaXBzaXMnLFxuICAgICdwZXJ0aG91c2FuZCcsXG4gICAgJ3F1ZXN0aW9uZG93bicsXG4gICAgJ2dyYXZlJyxcbiAgICAnYWN1dGUnLFxuICAgICdjaXJjdW1mbGV4JyxcbiAgICAndGlsZGUnLFxuICAgICdtYWNyb24nLFxuICAgICdicmV2ZScsXG4gICAgJ2RvdGFjY2VudCcsXG4gICAgJ2RpZXJlc2lzJyxcbiAgICAncmluZycsXG4gICAgJ2NlZGlsbGEnLFxuICAgICdodW5nYXJ1bWxhdXQnLFxuICAgICdvZ29uZWsnLFxuICAgICdjYXJvbicsXG4gICAgJ2VtZGFzaCcsXG4gICAgJ0FFJyxcbiAgICAnb3JkZmVtaW5pbmUnLFxuICAgICdMc2xhc2gnLFxuICAgICdPc2xhc2gnLFxuICAgICdPRScsXG4gICAgJ29yZG1hc2N1bGluZScsXG4gICAgJ2FlJyxcbiAgICAnZG90bGVzc2knLFxuICAgICdsc2xhc2gnLFxuICAgICdvc2xhc2gnLFxuICAgICdvZScsXG4gICAgJ2dlcm1hbmRibHMnLFxuICAgICdvbmVzdXBlcmlvcicsXG4gICAgJ2xvZ2ljYWxub3QnLFxuICAgICdtdScsXG4gICAgJ3RyYWRlbWFyaycsXG4gICAgJ0V0aCcsXG4gICAgJ29uZWhhbGYnLFxuICAgICdwbHVzbWludXMnLFxuICAgICdUaG9ybicsXG4gICAgJ29uZXF1YXJ0ZXInLFxuICAgICdkaXZpZGUnLFxuICAgICdicm9rZW5iYXInLFxuICAgICdkZWdyZWUnLFxuICAgICd0aG9ybicsXG4gICAgJ3RocmVlcXVhcnRlcnMnLFxuICAgICd0d29zdXBlcmlvcicsXG4gICAgJ3JlZ2lzdGVyZWQnLFxuICAgICdtaW51cycsXG4gICAgJ2V0aCcsXG4gICAgJ211bHRpcGx5JyxcbiAgICAndGhyZWVzdXBlcmlvcicsXG4gICAgJ2NvcHlyaWdodCcsXG4gICAgJ0FhY3V0ZScsXG4gICAgJ0FjaXJjdW1mbGV4JyxcbiAgICAnQWRpZXJlc2lzJyxcbiAgICAnQWdyYXZlJyxcbiAgICAnQXJpbmcnLFxuICAgICdBdGlsZGUnLFxuICAgICdDY2VkaWxsYScsXG4gICAgJ0VhY3V0ZScsXG4gICAgJ0VjaXJjdW1mbGV4JyxcbiAgICAnRWRpZXJlc2lzJyxcbiAgICAnRWdyYXZlJyxcbiAgICAnSWFjdXRlJyxcbiAgICAnSWNpcmN1bWZsZXgnLFxuICAgICdJZGllcmVzaXMnLFxuICAgICdJZ3JhdmUnLFxuICAgICdOdGlsZGUnLFxuICAgICdPYWN1dGUnLFxuICAgICdPY2lyY3VtZmxleCcsXG4gICAgJ09kaWVyZXNpcycsXG4gICAgJ09ncmF2ZScsXG4gICAgJ090aWxkZScsXG4gICAgJ1NjYXJvbicsXG4gICAgJ1VhY3V0ZScsXG4gICAgJ1VjaXJjdW1mbGV4JyxcbiAgICAnVWRpZXJlc2lzJyxcbiAgICAnVWdyYXZlJyxcbiAgICAnWWFjdXRlJyxcbiAgICAnWWRpZXJlc2lzJyxcbiAgICAnWmNhcm9uJyxcbiAgICAnYWFjdXRlJyxcbiAgICAnYWNpcmN1bWZsZXgnLFxuICAgICdhZGllcmVzaXMnLFxuICAgICdhZ3JhdmUnLFxuICAgICdhcmluZycsXG4gICAgJ2F0aWxkZScsXG4gICAgJ2NjZWRpbGxhJyxcbiAgICAnZWFjdXRlJyxcbiAgICAnZWNpcmN1bWZsZXgnLFxuICAgICdlZGllcmVzaXMnLFxuICAgICdlZ3JhdmUnLFxuICAgICdpYWN1dGUnLFxuICAgICdpY2lyY3VtZmxleCcsXG4gICAgJ2lkaWVyZXNpcycsXG4gICAgJ2lncmF2ZScsXG4gICAgJ250aWxkZScsXG4gICAgJ29hY3V0ZScsXG4gICAgJ29jaXJjdW1mbGV4JyxcbiAgICAnb2RpZXJlc2lzJyxcbiAgICAnb2dyYXZlJyxcbiAgICAnb3RpbGRlJyxcbiAgICAnc2Nhcm9uJyxcbiAgICAndWFjdXRlJyxcbiAgICAndWNpcmN1bWZsZXgnLFxuICAgICd1ZGllcmVzaXMnLFxuICAgICd1Z3JhdmUnLFxuICAgICd5YWN1dGUnLFxuICAgICd5ZGllcmVzaXMnLFxuICAgICd6Y2Fyb24nLFxuICAgICdleGNsYW1zbWFsbCcsXG4gICAgJ0h1bmdhcnVtbGF1dHNtYWxsJyxcbiAgICAnZG9sbGFyb2xkc3R5bGUnLFxuICAgICdkb2xsYXJzdXBlcmlvcicsXG4gICAgJ2FtcGVyc2FuZHNtYWxsJyxcbiAgICAnQWN1dGVzbWFsbCcsXG4gICAgJ3BhcmVubGVmdHN1cGVyaW9yJyxcbiAgICAncGFyZW5yaWdodHN1cGVyaW9yJyxcbiAgICAnMjY2IGZmJyxcbiAgICAnb25lZG90ZW5sZWFkZXInLFxuICAgICd6ZXJvb2xkc3R5bGUnLFxuICAgICdvbmVvbGRzdHlsZScsXG4gICAgJ3R3b29sZHN0eWxlJyxcbiAgICAndGhyZWVvbGRzdHlsZScsXG4gICAgJ2ZvdXJvbGRzdHlsZScsXG4gICAgJ2ZpdmVvbGRzdHlsZScsXG4gICAgJ3NpeG9sZHN0eWxlJyxcbiAgICAnc2V2ZW5vbGRzdHlsZScsXG4gICAgJ2VpZ2h0b2xkc3R5bGUnLFxuICAgICduaW5lb2xkc3R5bGUnLFxuICAgICdjb21tYXN1cGVyaW9yJyxcbiAgICAndGhyZWVxdWFydGVyc2VtZGFzaCcsXG4gICAgJ3BlcmlvZHN1cGVyaW9yJyxcbiAgICAncXVlc3Rpb25zbWFsbCcsXG4gICAgJ2FzdXBlcmlvcicsXG4gICAgJ2JzdXBlcmlvcicsXG4gICAgJ2NlbnRzdXBlcmlvcicsXG4gICAgJ2RzdXBlcmlvcicsXG4gICAgJ2VzdXBlcmlvcicsXG4gICAgJ2lzdXBlcmlvcicsXG4gICAgJ2xzdXBlcmlvcicsXG4gICAgJ21zdXBlcmlvcicsXG4gICAgJ25zdXBlcmlvcicsXG4gICAgJ29zdXBlcmlvcicsXG4gICAgJ3JzdXBlcmlvcicsXG4gICAgJ3NzdXBlcmlvcicsXG4gICAgJ3RzdXBlcmlvcicsXG4gICAgJ2ZmJyxcbiAgICAnZmZpJyxcbiAgICAnZmZsJyxcbiAgICAncGFyZW5sZWZ0aW5mZXJpb3InLFxuICAgICdwYXJlbnJpZ2h0aW5mZXJpb3InLFxuICAgICdDaXJjdW1mbGV4c21hbGwnLFxuICAgICdoeXBoZW5zdXBlcmlvcicsXG4gICAgJ0dyYXZlc21hbGwnLFxuICAgICdBc21hbGwnLFxuICAgICdCc21hbGwnLFxuICAgICdDc21hbGwnLFxuICAgICdEc21hbGwnLFxuICAgICdFc21hbGwnLFxuICAgICdGc21hbGwnLFxuICAgICdHc21hbGwnLFxuICAgICdIc21hbGwnLFxuICAgICdJc21hbGwnLFxuICAgICdKc21hbGwnLFxuICAgICdLc21hbGwnLFxuICAgICdMc21hbGwnLFxuICAgICdNc21hbGwnLFxuICAgICdOc21hbGwnLFxuICAgICdPc21hbGwnLFxuICAgICdQc21hbGwnLFxuICAgICdRc21hbGwnLFxuICAgICdSc21hbGwnLFxuICAgICdTc21hbGwnLFxuICAgICdUc21hbGwnLFxuICAgICdVc21hbGwnLFxuICAgICdWc21hbGwnLFxuICAgICdXc21hbGwnLFxuICAgICdYc21hbGwnLFxuICAgICdZc21hbGwnLFxuICAgICdac21hbGwnLFxuICAgICdjb2xvbm1vbmV0YXJ5JyxcbiAgICAnb25lZml0dGVkJyxcbiAgICAncnVwaWFoJyxcbiAgICAnVGlsZGVzbWFsbCcsXG4gICAgJ2V4Y2xhbWRvd25zbWFsbCcsXG4gICAgJ2NlbnRvbGRzdHlsZScsXG4gICAgJ0xzbGFzaHNtYWxsJyxcbiAgICAnU2Nhcm9uc21hbGwnLFxuICAgICdaY2Fyb25zbWFsbCcsXG4gICAgJ0RpZXJlc2lzc21hbGwnLFxuICAgICdCcmV2ZXNtYWxsJyxcbiAgICAnQ2Fyb25zbWFsbCcsXG4gICAgJ0RvdGFjY2VudHNtYWxsJyxcbiAgICAnTWFjcm9uc21hbGwnLFxuICAgICdmaWd1cmVkYXNoJyxcbiAgICAnaHlwaGVuaW5mZXJpb3InLFxuICAgICdPZ29uZWtzbWFsbCcsXG4gICAgJ1JpbmdzbWFsbCcsXG4gICAgJ0NlZGlsbGFzbWFsbCcsXG4gICAgJ3F1ZXN0aW9uZG93bnNtYWxsJyxcbiAgICAnb25lZWlnaHRoJyxcbiAgICAndGhyZWVlaWdodGhzJyxcbiAgICAnZml2ZWVpZ2h0aHMnLFxuICAgICdzZXZlbmVpZ2h0aHMnLFxuICAgICdvbmV0aGlyZCcsXG4gICAgJ3R3b3RoaXJkcycsXG4gICAgJ3plcm9zdXBlcmlvcicsXG4gICAgJ2ZvdXJzdXBlcmlvcicsXG4gICAgJ2ZpdmVzdXBlcmlvcicsXG4gICAgJ3NpeHN1cGVyaW9yJyxcbiAgICAnc2V2ZW5zdXBlcmlvcicsXG4gICAgJ2VpZ2h0c3VwZXJpb3InLFxuICAgICduaW5lc3VwZXJpb3InLFxuICAgICd6ZXJvaW5mZXJpb3InLFxuICAgICdvbmVpbmZlcmlvcicsXG4gICAgJ3R3b2luZmVyaW9yJyxcbiAgICAndGhyZWVpbmZlcmlvcicsXG4gICAgJ2ZvdXJpbmZlcmlvcicsXG4gICAgJ2ZpdmVpbmZlcmlvcicsXG4gICAgJ3NpeGluZmVyaW9yJyxcbiAgICAnc2V2ZW5pbmZlcmlvcicsXG4gICAgJ2VpZ2h0aW5mZXJpb3InLFxuICAgICduaW5laW5mZXJpb3InLFxuICAgICdjZW50aW5mZXJpb3InLFxuICAgICdkb2xsYXJpbmZlcmlvcicsXG4gICAgJ3BlcmlvZGluZmVyaW9yJyxcbiAgICAnY29tbWFpbmZlcmlvcicsXG4gICAgJ0FncmF2ZXNtYWxsJyxcbiAgICAnQWFjdXRlc21hbGwnLFxuICAgICdBY2lyY3VtZmxleHNtYWxsJyxcbiAgICAnQXRpbGRlc21hbGwnLFxuICAgICdBZGllcmVzaXNzbWFsbCcsXG4gICAgJ0FyaW5nc21hbGwnLFxuICAgICdBRXNtYWxsJyxcbiAgICAnQ2NlZGlsbGFzbWFsbCcsXG4gICAgJ0VncmF2ZXNtYWxsJyxcbiAgICAnRWFjdXRlc21hbGwnLFxuICAgICdFY2lyY3VtZmxleHNtYWxsJyxcbiAgICAnRWRpZXJlc2lzc21hbGwnLFxuICAgICdJZ3JhdmVzbWFsbCcsXG4gICAgJ0lhY3V0ZXNtYWxsJyxcbiAgICAnSWNpcmN1bWZsZXhzbWFsbCcsXG4gICAgJ0lkaWVyZXNpc3NtYWxsJyxcbiAgICAnRXRoc21hbGwnLFxuICAgICdOdGlsZGVzbWFsbCcsXG4gICAgJ09ncmF2ZXNtYWxsJyxcbiAgICAnT2FjdXRlc21hbGwnLFxuICAgICdPY2lyY3VtZmxleHNtYWxsJyxcbiAgICAnT3RpbGRlc21hbGwnLFxuICAgICdPZGllcmVzaXNzbWFsbCcsXG4gICAgJ09Fc21hbGwnLFxuICAgICdPc2xhc2hzbWFsbCcsXG4gICAgJ1VncmF2ZXNtYWxsJyxcbiAgICAnVWFjdXRlc21hbGwnLFxuICAgICdVY2lyY3VtZmxleHNtYWxsJyxcbiAgICAnVWRpZXJlc2lzc21hbGwnLFxuICAgICdZYWN1dGVzbWFsbCcsXG4gICAgJ1Rob3Juc21hbGwnLFxuICAgICdZZGllcmVzaXNzbWFsbCcsXG4gICAgJzAwMS4wMDAnLFxuICAgICcwMDEuMDAxJyxcbiAgICAnMDAxLjAwMicsXG4gICAgJzAwMS4wMDMnLFxuICAgICdCbGFjaycsXG4gICAgJ0JvbGQnLFxuICAgICdCb29rJyxcbiAgICAnTGlnaHQnLFxuICAgICdNZWRpdW0nLFxuICAgICdSZWd1bGFyJyxcbiAgICAnUm9tYW4nLFxuICAgICdTZW1pYm9sZCcgXTtcblxudmFyIGNmZlN0YW5kYXJkRW5jb2RpbmcgPSBbXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ3NwYWNlJyxcbiAgICAnZXhjbGFtJyxcbiAgICAncXVvdGVkYmwnLFxuICAgICdudW1iZXJzaWduJyxcbiAgICAnZG9sbGFyJyxcbiAgICAncGVyY2VudCcsXG4gICAgJ2FtcGVyc2FuZCcsXG4gICAgJ3F1b3RlcmlnaHQnLFxuICAgICdwYXJlbmxlZnQnLFxuICAgICdwYXJlbnJpZ2h0JyxcbiAgICAnYXN0ZXJpc2snLFxuICAgICdwbHVzJyxcbiAgICAnY29tbWEnLFxuICAgICdoeXBoZW4nLFxuICAgICdwZXJpb2QnLFxuICAgICdzbGFzaCcsXG4gICAgJ3plcm8nLFxuICAgICdvbmUnLFxuICAgICd0d28nLFxuICAgICd0aHJlZScsXG4gICAgJ2ZvdXInLFxuICAgICdmaXZlJyxcbiAgICAnc2l4JyxcbiAgICAnc2V2ZW4nLFxuICAgICdlaWdodCcsXG4gICAgJ25pbmUnLFxuICAgICdjb2xvbicsXG4gICAgJ3NlbWljb2xvbicsXG4gICAgJ2xlc3MnLFxuICAgICdlcXVhbCcsXG4gICAgJ2dyZWF0ZXInLFxuICAgICdxdWVzdGlvbicsXG4gICAgJ2F0JyxcbiAgICAnQScsXG4gICAgJ0InLFxuICAgICdDJyxcbiAgICAnRCcsXG4gICAgJ0UnLFxuICAgICdGJyxcbiAgICAnRycsXG4gICAgJ0gnLFxuICAgICdJJyxcbiAgICAnSicsXG4gICAgJ0snLFxuICAgICdMJyxcbiAgICAnTScsXG4gICAgJ04nLFxuICAgICdPJyxcbiAgICAnUCcsXG4gICAgJ1EnLFxuICAgICdSJyxcbiAgICAnUycsXG4gICAgJ1QnLFxuICAgICdVJyxcbiAgICAnVicsXG4gICAgJ1cnLFxuICAgICdYJyxcbiAgICAnWScsXG4gICAgJ1onLFxuICAgICdicmFja2V0bGVmdCcsXG4gICAgJ2JhY2tzbGFzaCcsXG4gICAgJ2JyYWNrZXRyaWdodCcsXG4gICAgJ2FzY2lpY2lyY3VtJyxcbiAgICAndW5kZXJzY29yZScsXG4gICAgJ3F1b3RlbGVmdCcsXG4gICAgJ2EnLFxuICAgICdiJyxcbiAgICAnYycsXG4gICAgJ2QnLFxuICAgICdlJyxcbiAgICAnZicsXG4gICAgJ2cnLFxuICAgICdoJyxcbiAgICAnaScsXG4gICAgJ2onLFxuICAgICdrJyxcbiAgICAnbCcsXG4gICAgJ20nLFxuICAgICduJyxcbiAgICAnbycsXG4gICAgJ3AnLFxuICAgICdxJyxcbiAgICAncicsXG4gICAgJ3MnLFxuICAgICd0JyxcbiAgICAndScsXG4gICAgJ3YnLFxuICAgICd3JyxcbiAgICAneCcsXG4gICAgJ3knLFxuICAgICd6JyxcbiAgICAnYnJhY2VsZWZ0JyxcbiAgICAnYmFyJyxcbiAgICAnYnJhY2VyaWdodCcsXG4gICAgJ2FzY2lpdGlsZGUnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICdleGNsYW1kb3duJyxcbiAgICAnY2VudCcsXG4gICAgJ3N0ZXJsaW5nJyxcbiAgICAnZnJhY3Rpb24nLFxuICAgICd5ZW4nLFxuICAgICdmbG9yaW4nLFxuICAgICdzZWN0aW9uJyxcbiAgICAnY3VycmVuY3knLFxuICAgICdxdW90ZXNpbmdsZScsXG4gICAgJ3F1b3RlZGJsbGVmdCcsXG4gICAgJ2d1aWxsZW1vdGxlZnQnLFxuICAgICdndWlsc2luZ2xsZWZ0JyxcbiAgICAnZ3VpbHNpbmdscmlnaHQnLFxuICAgICdmaScsXG4gICAgJ2ZsJyxcbiAgICAnJyxcbiAgICAnZW5kYXNoJyxcbiAgICAnZGFnZ2VyJyxcbiAgICAnZGFnZ2VyZGJsJyxcbiAgICAncGVyaW9kY2VudGVyZWQnLFxuICAgICcnLFxuICAgICdwYXJhZ3JhcGgnLFxuICAgICdidWxsZXQnLFxuICAgICdxdW90ZXNpbmdsYmFzZScsXG4gICAgJ3F1b3RlZGJsYmFzZScsXG4gICAgJ3F1b3RlZGJscmlnaHQnLFxuICAgICdndWlsbGVtb3RyaWdodCcsXG4gICAgJ2VsbGlwc2lzJyxcbiAgICAncGVydGhvdXNhbmQnLFxuICAgICcnLFxuICAgICdxdWVzdGlvbmRvd24nLFxuICAgICcnLFxuICAgICdncmF2ZScsXG4gICAgJ2FjdXRlJyxcbiAgICAnY2lyY3VtZmxleCcsXG4gICAgJ3RpbGRlJyxcbiAgICAnbWFjcm9uJyxcbiAgICAnYnJldmUnLFxuICAgICdkb3RhY2NlbnQnLFxuICAgICdkaWVyZXNpcycsXG4gICAgJycsXG4gICAgJ3JpbmcnLFxuICAgICdjZWRpbGxhJyxcbiAgICAnJyxcbiAgICAnaHVuZ2FydW1sYXV0JyxcbiAgICAnb2dvbmVrJyxcbiAgICAnY2Fyb24nLFxuICAgICdlbWRhc2gnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICdBRScsXG4gICAgJycsXG4gICAgJ29yZGZlbWluaW5lJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnTHNsYXNoJyxcbiAgICAnT3NsYXNoJyxcbiAgICAnT0UnLFxuICAgICdvcmRtYXNjdWxpbmUnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICdhZScsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ2RvdGxlc3NpJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnbHNsYXNoJyxcbiAgICAnb3NsYXNoJyxcbiAgICAnb2UnLFxuICAgICdnZXJtYW5kYmxzJyBdO1xuXG52YXIgY2ZmRXhwZXJ0RW5jb2RpbmcgPSBbXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ3NwYWNlJyxcbiAgICAnZXhjbGFtc21hbGwnLFxuICAgICdIdW5nYXJ1bWxhdXRzbWFsbCcsXG4gICAgJycsXG4gICAgJ2RvbGxhcm9sZHN0eWxlJyxcbiAgICAnZG9sbGFyc3VwZXJpb3InLFxuICAgICdhbXBlcnNhbmRzbWFsbCcsXG4gICAgJ0FjdXRlc21hbGwnLFxuICAgICdwYXJlbmxlZnRzdXBlcmlvcicsXG4gICAgJ3BhcmVucmlnaHRzdXBlcmlvcicsXG4gICAgJ3R3b2RvdGVubGVhZGVyJyxcbiAgICAnb25lZG90ZW5sZWFkZXInLFxuICAgICdjb21tYScsXG4gICAgJ2h5cGhlbicsXG4gICAgJ3BlcmlvZCcsXG4gICAgJ2ZyYWN0aW9uJyxcbiAgICAnemVyb29sZHN0eWxlJyxcbiAgICAnb25lb2xkc3R5bGUnLFxuICAgICd0d29vbGRzdHlsZScsXG4gICAgJ3RocmVlb2xkc3R5bGUnLFxuICAgICdmb3Vyb2xkc3R5bGUnLFxuICAgICdmaXZlb2xkc3R5bGUnLFxuICAgICdzaXhvbGRzdHlsZScsXG4gICAgJ3NldmVub2xkc3R5bGUnLFxuICAgICdlaWdodG9sZHN0eWxlJyxcbiAgICAnbmluZW9sZHN0eWxlJyxcbiAgICAnY29sb24nLFxuICAgICdzZW1pY29sb24nLFxuICAgICdjb21tYXN1cGVyaW9yJyxcbiAgICAndGhyZWVxdWFydGVyc2VtZGFzaCcsXG4gICAgJ3BlcmlvZHN1cGVyaW9yJyxcbiAgICAncXVlc3Rpb25zbWFsbCcsXG4gICAgJycsXG4gICAgJ2FzdXBlcmlvcicsXG4gICAgJ2JzdXBlcmlvcicsXG4gICAgJ2NlbnRzdXBlcmlvcicsXG4gICAgJ2RzdXBlcmlvcicsXG4gICAgJ2VzdXBlcmlvcicsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ2lzdXBlcmlvcicsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ2xzdXBlcmlvcicsXG4gICAgJ21zdXBlcmlvcicsXG4gICAgJ25zdXBlcmlvcicsXG4gICAgJ29zdXBlcmlvcicsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ3JzdXBlcmlvcicsXG4gICAgJ3NzdXBlcmlvcicsXG4gICAgJ3RzdXBlcmlvcicsXG4gICAgJycsXG4gICAgJ2ZmJyxcbiAgICAnZmknLFxuICAgICdmbCcsXG4gICAgJ2ZmaScsXG4gICAgJ2ZmbCcsXG4gICAgJ3BhcmVubGVmdGluZmVyaW9yJyxcbiAgICAnJyxcbiAgICAncGFyZW5yaWdodGluZmVyaW9yJyxcbiAgICAnQ2lyY3VtZmxleHNtYWxsJyxcbiAgICAnaHlwaGVuc3VwZXJpb3InLFxuICAgICdHcmF2ZXNtYWxsJyxcbiAgICAnQXNtYWxsJyxcbiAgICAnQnNtYWxsJyxcbiAgICAnQ3NtYWxsJyxcbiAgICAnRHNtYWxsJyxcbiAgICAnRXNtYWxsJyxcbiAgICAnRnNtYWxsJyxcbiAgICAnR3NtYWxsJyxcbiAgICAnSHNtYWxsJyxcbiAgICAnSXNtYWxsJyxcbiAgICAnSnNtYWxsJyxcbiAgICAnS3NtYWxsJyxcbiAgICAnTHNtYWxsJyxcbiAgICAnTXNtYWxsJyxcbiAgICAnTnNtYWxsJyxcbiAgICAnT3NtYWxsJyxcbiAgICAnUHNtYWxsJyxcbiAgICAnUXNtYWxsJyxcbiAgICAnUnNtYWxsJyxcbiAgICAnU3NtYWxsJyxcbiAgICAnVHNtYWxsJyxcbiAgICAnVXNtYWxsJyxcbiAgICAnVnNtYWxsJyxcbiAgICAnV3NtYWxsJyxcbiAgICAnWHNtYWxsJyxcbiAgICAnWXNtYWxsJyxcbiAgICAnWnNtYWxsJyxcbiAgICAnY29sb25tb25ldGFyeScsXG4gICAgJ29uZWZpdHRlZCcsXG4gICAgJ3J1cGlhaCcsXG4gICAgJ1RpbGRlc21hbGwnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICdleGNsYW1kb3duc21hbGwnLFxuICAgICdjZW50b2xkc3R5bGUnLFxuICAgICdMc2xhc2hzbWFsbCcsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ1NjYXJvbnNtYWxsJyxcbiAgICAnWmNhcm9uc21hbGwnLFxuICAgICdEaWVyZXNpc3NtYWxsJyxcbiAgICAnQnJldmVzbWFsbCcsXG4gICAgJ0Nhcm9uc21hbGwnLFxuICAgICcnLFxuICAgICdEb3RhY2NlbnRzbWFsbCcsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ01hY3JvbnNtYWxsJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnZmlndXJlZGFzaCcsXG4gICAgJ2h5cGhlbmluZmVyaW9yJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnT2dvbmVrc21hbGwnLFxuICAgICdSaW5nc21hbGwnLFxuICAgICdDZWRpbGxhc21hbGwnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICdvbmVxdWFydGVyJyxcbiAgICAnb25laGFsZicsXG4gICAgJ3RocmVlcXVhcnRlcnMnLFxuICAgICdxdWVzdGlvbmRvd25zbWFsbCcsXG4gICAgJ29uZWVpZ2h0aCcsXG4gICAgJ3RocmVlZWlnaHRocycsXG4gICAgJ2ZpdmVlaWdodGhzJyxcbiAgICAnc2V2ZW5laWdodGhzJyxcbiAgICAnb25ldGhpcmQnLFxuICAgICd0d290aGlyZHMnLFxuICAgICcnLFxuICAgICcnLFxuICAgICd6ZXJvc3VwZXJpb3InLFxuICAgICdvbmVzdXBlcmlvcicsXG4gICAgJ3R3b3N1cGVyaW9yJyxcbiAgICAndGhyZWVzdXBlcmlvcicsXG4gICAgJ2ZvdXJzdXBlcmlvcicsXG4gICAgJ2ZpdmVzdXBlcmlvcicsXG4gICAgJ3NpeHN1cGVyaW9yJyxcbiAgICAnc2V2ZW5zdXBlcmlvcicsXG4gICAgJ2VpZ2h0c3VwZXJpb3InLFxuICAgICduaW5lc3VwZXJpb3InLFxuICAgICd6ZXJvaW5mZXJpb3InLFxuICAgICdvbmVpbmZlcmlvcicsXG4gICAgJ3R3b2luZmVyaW9yJyxcbiAgICAndGhyZWVpbmZlcmlvcicsXG4gICAgJ2ZvdXJpbmZlcmlvcicsXG4gICAgJ2ZpdmVpbmZlcmlvcicsXG4gICAgJ3NpeGluZmVyaW9yJyxcbiAgICAnc2V2ZW5pbmZlcmlvcicsXG4gICAgJ2VpZ2h0aW5mZXJpb3InLFxuICAgICduaW5laW5mZXJpb3InLFxuICAgICdjZW50aW5mZXJpb3InLFxuICAgICdkb2xsYXJpbmZlcmlvcicsXG4gICAgJ3BlcmlvZGluZmVyaW9yJyxcbiAgICAnY29tbWFpbmZlcmlvcicsXG4gICAgJ0FncmF2ZXNtYWxsJyxcbiAgICAnQWFjdXRlc21hbGwnLFxuICAgICdBY2lyY3VtZmxleHNtYWxsJyxcbiAgICAnQXRpbGRlc21hbGwnLFxuICAgICdBZGllcmVzaXNzbWFsbCcsXG4gICAgJ0FyaW5nc21hbGwnLFxuICAgICdBRXNtYWxsJyxcbiAgICAnQ2NlZGlsbGFzbWFsbCcsXG4gICAgJ0VncmF2ZXNtYWxsJyxcbiAgICAnRWFjdXRlc21hbGwnLFxuICAgICdFY2lyY3VtZmxleHNtYWxsJyxcbiAgICAnRWRpZXJlc2lzc21hbGwnLFxuICAgICdJZ3JhdmVzbWFsbCcsXG4gICAgJ0lhY3V0ZXNtYWxsJyxcbiAgICAnSWNpcmN1bWZsZXhzbWFsbCcsXG4gICAgJ0lkaWVyZXNpc3NtYWxsJyxcbiAgICAnRXRoc21hbGwnLFxuICAgICdOdGlsZGVzbWFsbCcsXG4gICAgJ09ncmF2ZXNtYWxsJyxcbiAgICAnT2FjdXRlc21hbGwnLFxuICAgICdPY2lyY3VtZmxleHNtYWxsJyxcbiAgICAnT3RpbGRlc21hbGwnLFxuICAgICdPZGllcmVzaXNzbWFsbCcsXG4gICAgJ09Fc21hbGwnLFxuICAgICdPc2xhc2hzbWFsbCcsXG4gICAgJ1VncmF2ZXNtYWxsJyxcbiAgICAnVWFjdXRlc21hbGwnLFxuICAgICdVY2lyY3VtZmxleHNtYWxsJyxcbiAgICAnVWRpZXJlc2lzc21hbGwnLFxuICAgICdZYWN1dGVzbWFsbCcsXG4gICAgJ1Rob3Juc21hbGwnLFxuICAgICdZZGllcmVzaXNzbWFsbCcgXTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBlbmNvZGluZyB1c2VkIGZvciBmb250cyBjcmVhdGVkIGZyb20gc2NyYXRjaC5cbiAqIEl0IGxvb3BzIHRocm91Z2ggYWxsIGdseXBocyBhbmQgZmluZHMgdGhlIGFwcHJvcHJpYXRlIHVuaWNvZGUgdmFsdWUuXG4gKiBTaW5jZSBpdCdzIGxpbmVhciB0aW1lLCBvdGhlciBlbmNvZGluZ3Mgd2lsbCBiZSBmYXN0ZXIuXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5EZWZhdWx0RW5jb2RpbmdcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKi9cbmZ1bmN0aW9uIERlZmF1bHRFbmNvZGluZyhmb250KSB7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbn1cblxuRGVmYXVsdEVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgY29kZSA9IGMuY29kZVBvaW50QXQoMCk7XG4gICAgdmFyIGdseXBocyA9IHRoaXMuZm9udC5nbHlwaHM7XG4gICAgaWYgKGdseXBocykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzLmdldChpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGgudW5pY29kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGgudW5pY29kZXNbal0gPT09IGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5DbWFwRW5jb2RpbmdcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY21hcCAtIGEgb2JqZWN0IHdpdGggdGhlIGNtYXAgZW5jb2RlZCBkYXRhXG4gKi9cbmZ1bmN0aW9uIENtYXBFbmNvZGluZyhjbWFwKSB7XG4gICAgdGhpcy5jbWFwID0gY21hcDtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGMgLSB0aGUgY2hhcmFjdGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBnbHlwaCBpbmRleC5cbiAqL1xuQ21hcEVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gdGhpcy5jbWFwLmdseXBoSW5kZXhNYXBbYy5jb2RlUG9pbnRBdCgwKV0gfHwgMDtcbn07XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuQ2ZmRW5jb2RpbmdcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgLSBUaGUgZW5jb2RpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IGNoYXJzZXQgLSBUaGUgY2hhcmFjdGVyIHNldC5cbiAqL1xuZnVuY3Rpb24gQ2ZmRW5jb2RpbmcoZW5jb2RpbmcsIGNoYXJzZXQpIHtcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgdGhpcy5jaGFyc2V0ID0gY2hhcnNldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHMgLSBUaGUgY2hhcmFjdGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleC5cbiAqL1xuQ2ZmRW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbiAocykge1xuICAgIHZhciBjb2RlID0gcy5jb2RlUG9pbnRBdCgwKTtcbiAgICB2YXIgY2hhck5hbWUgPSB0aGlzLmVuY29kaW5nW2NvZGVdO1xuICAgIHJldHVybiB0aGlzLmNoYXJzZXQuaW5kZXhPZihjaGFyTmFtZSk7XG59O1xuXG5mdW5jdGlvbiBhZGRHbHlwaE5hbWVzQWxsKGZvbnQpIHtcbiAgICB2YXIgZ2x5cGg7XG4gICAgdmFyIGdseXBoSW5kZXhNYXAgPSBmb250LnRhYmxlcy5jbWFwLmdseXBoSW5kZXhNYXA7XG4gICAgdmFyIGNoYXJDb2RlcyA9IE9iamVjdC5rZXlzKGdseXBoSW5kZXhNYXApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyQ29kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBjaGFyQ29kZXNbaV07XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gZ2x5cGhJbmRleE1hcFtjXTtcbiAgICAgICAgZ2x5cGggPSBmb250LmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG4gICAgICAgIGdseXBoLmFkZFVuaWNvZGUocGFyc2VJbnQoYykpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkR2x5cGhOYW1lc1RvVW5pY29kZU1hcChmb250KSB7XG4gICAgZm9udC5fSW5kZXhUb1VuaWNvZGVNYXAgPSB7fTtcblxuICAgIHZhciBnbHlwaEluZGV4TWFwID0gZm9udC50YWJsZXMuY21hcC5nbHlwaEluZGV4TWFwO1xuICAgIHZhciBjaGFyQ29kZXMgPSBPYmplY3Qua2V5cyhnbHlwaEluZGV4TWFwKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhckNvZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjID0gY2hhckNvZGVzW2ldO1xuICAgICAgICB2YXIgZ2x5cGhJbmRleCA9IGdseXBoSW5kZXhNYXBbY107XG4gICAgICAgIGlmIChmb250Ll9JbmRleFRvVW5pY29kZU1hcFtnbHlwaEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb250Ll9JbmRleFRvVW5pY29kZU1hcFtnbHlwaEluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICB1bmljb2RlczogW3BhcnNlSW50KGMpXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb250Ll9JbmRleFRvVW5pY29kZU1hcFtnbHlwaEluZGV4XS51bmljb2Rlcy5wdXNoKHBhcnNlSW50KGMpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAYWxpYXMgb3BlbnR5cGUuYWRkR2x5cGhOYW1lc1xuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICogQHBhcmFtIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGFkZEdseXBoTmFtZXMoZm9udCwgb3B0KSB7XG4gICAgaWYgKG9wdC5sb3dNZW1vcnkpIHtcbiAgICAgICAgYWRkR2x5cGhOYW1lc1RvVW5pY29kZU1hcChmb250KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhZGRHbHlwaE5hbWVzQWxsKGZvbnQpO1xuICAgIH1cbn1cblxuLy8gUnVuLXRpbWUgY2hlY2tpbmcgb2YgcHJlY29uZGl0aW9ucy5cblxuZnVuY3Rpb24gZmFpbChtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vLyBQcmVjb25kaXRpb24gZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIGdpdmVuIHByZWRpY2F0ZSBpcyB0cnVlLlxuLy8gSWYgbm90LCBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuZnVuY3Rpb24gYXJndW1lbnQocHJlZGljYXRlLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFwcmVkaWNhdGUpIHtcbiAgICAgICAgZmFpbChtZXNzYWdlKTtcbiAgICB9XG59XG52YXIgY2hlY2sgPSB7IGZhaWw6IGZhaWwsIGFyZ3VtZW50OiBhcmd1bWVudCwgYXNzZXJ0OiBhcmd1bWVudCB9O1xuXG4vLyBUaGUgR2x5cGggb2JqZWN0XG4vLyBpbXBvcnQgZ2x5ZiBmcm9tICcuL3RhYmxlcy9nbHlmJyBDYW4ndCBiZSBpbXBvcnRlZCBoZXJlLCBiZWNhdXNlIGl0J3MgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG5cbmZ1bmN0aW9uIGdldFBhdGhEZWZpbml0aW9uKGdseXBoLCBwYXRoKSB7XG4gICAgdmFyIF9wYXRoID0gcGF0aCB8fCBuZXcgUGF0aCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgX3BhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBfcGF0aCA9IF9wYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfcGF0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICBfcGF0aCA9IHA7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQHR5cGVkZWYgR2x5cGhPcHRpb25zXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gLSBUaGUgZ2x5cGggbmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt1bmljb2RlXVxuICogQHByb3BlcnR5IHtBcnJheX0gW3VuaWNvZGVzXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt4TWluXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt5TWluXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt4TWF4XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt5TWF4XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFthZHZhbmNlV2lkdGhdXG4gKi9cblxuLy8gQSBHbHlwaCBpcyBhbiBpbmRpdmlkdWFsIG1hcmsgdGhhdCBvZnRlbiBjb3JyZXNwb25kcyB0byBhIGNoYXJhY3Rlci5cbi8vIFNvbWUgZ2x5cGhzLCBzdWNoIGFzIGxpZ2F0dXJlcywgYXJlIGEgY29tYmluYXRpb24gb2YgbWFueSBjaGFyYWN0ZXJzLlxuLy8gR2x5cGhzIGFyZSB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2tzIG9mIGEgZm9udC5cbi8vXG4vLyBUaGUgYEdseXBoYCBjbGFzcyBjb250YWlucyB1dGlsaXR5IG1ldGhvZHMgZm9yIGRyYXdpbmcgdGhlIHBhdGggYW5kIGl0cyBwb2ludHMuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkdseXBoXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7R2x5cGhPcHRpb25zfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEdseXBoKG9wdGlvbnMpIHtcbiAgICAvLyBCeSBwdXR0aW5nIGFsbCB0aGUgY29kZSBvbiBhIHByb3RvdHlwZSBmdW5jdGlvbiAod2hpY2ggaXMgb25seSBkZWNsYXJlZCBvbmNlKVxuICAgIC8vIHdlIHJlZHVjZSB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBmb3IgbGFyZ2VyIGZvbnRzIGJ5IHNvbWUgMiVcbiAgICB0aGlzLmJpbmRDb25zdHJ1Y3RvclZhbHVlcyhvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtHbHlwaE9wdGlvbnN9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5iaW5kQ29uc3RydWN0b3JWYWx1ZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4IHx8IDA7XG5cbiAgICAvLyBUaGVzZSB0aHJlZSB2YWx1ZXMgY2Fubm90IGJlIGRlZmVycmVkIGZvciBtZW1vcnkgb3B0aW1pemF0aW9uOlxuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBudWxsO1xuICAgIHRoaXMudW5pY29kZSA9IG9wdGlvbnMudW5pY29kZSB8fCB1bmRlZmluZWQ7XG4gICAgdGhpcy51bmljb2RlcyA9XG4gICAgICAgIG9wdGlvbnMudW5pY29kZXMgfHwgb3B0aW9ucy51bmljb2RlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gW29wdGlvbnMudW5pY29kZV1cbiAgICAgICAgICAgIDogW107XG5cbiAgICAvLyBCdXQgYnkgYmluZGluZyB0aGVzZSB2YWx1ZXMgb25seSB3aGVuIG5lY2Vzc2FyeSwgd2UgcmVkdWNlIGNhblxuICAgIC8vIHRoZSBtZW1vcnkgcmVxdWlyZW1lbnRzIGJ5IGFsbW9zdCAzJSBmb3IgbGFyZ2VyIGZvbnRzLlxuICAgIGlmICgneE1pbicgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnhNaW4gPSBvcHRpb25zLnhNaW47XG4gICAgfVxuXG4gICAgaWYgKCd5TWluJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMueU1pbiA9IG9wdGlvbnMueU1pbjtcbiAgICB9XG5cbiAgICBpZiAoJ3hNYXgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy54TWF4ID0gb3B0aW9ucy54TWF4O1xuICAgIH1cblxuICAgIGlmICgneU1heCcgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnlNYXggPSBvcHRpb25zLnlNYXg7XG4gICAgfVxuXG4gICAgaWYgKCdhZHZhbmNlV2lkdGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlV2lkdGggPSBvcHRpb25zLmFkdmFuY2VXaWR0aDtcbiAgICB9XG5cbiAgICAvLyBUaGUgcGF0aCBmb3IgYSBnbHlwaCBpcyB0aGUgbW9zdCBtZW1vcnkgaW50ZW5zaXZlLCBhbmQgaXMgYm91bmQgYXMgYSB2YWx1ZVxuICAgIC8vIHdpdGggYSBnZXR0ZXIvc2V0dGVyIHRvIGVuc3VyZSB3ZSBhY3R1YWxseSBkbyBwYXRoIHBhcnNpbmcgb25seSBvbmNlIHRoZVxuICAgIC8vIHBhdGggaXMgYWN0dWFsbHkgbmVlZGVkIGJ5IGFueXRoaW5nLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGF0aCcsIGdldFBhdGhEZWZpbml0aW9uKHRoaXMsIG9wdGlvbnMucGF0aCkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqL1xuR2x5cGgucHJvdG90eXBlLmFkZFVuaWNvZGUgPSBmdW5jdGlvbiAodW5pY29kZSkge1xuICAgIGlmICh0aGlzLnVuaWNvZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnVuaWNvZGUgPSB1bmljb2RlO1xuICAgIH1cblxuICAgIHRoaXMudW5pY29kZXMucHVzaCh1bmljb2RlKTtcbn07XG5cbi8vIC8qKlxuLy8gICogQ2FsY3VsYXRlIHRoZSBtaW5pbXVtIGJvdW5kaW5nIGJveCBmb3IgdGhpcyBnbHlwaC5cbi8vICAqIEByZXR1cm4ge29wZW50eXBlLkJvdW5kaW5nQm94fVxuLy8gICovXG4vLyBHbHlwaC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcbi8vICAgICByZXR1cm4gdGhpcy5wYXRoLmdldEJvdW5kaW5nQm94KCk7XG4vLyB9O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdseXBoIHRvIGEgUGF0aCB3ZSBjYW4gZHJhdyBvbiBhIGRyYXdpbmcgY29udGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9ucyAtIHhTY2FsZSwgeVNjYWxlIHRvIHN0cmV0Y2ggdGhlIGdseXBoLlxuICogQHBhcmFtICB7b3BlbnR5cGUuRm9udH0gaWYgaGludGluZyBpcyB0byBiZSB1c2VkLCB0aGUgZm9udFxuICogQHJldHVybiB7b3BlbnR5cGUuUGF0aH1cbiAqL1xuR2x5cGgucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAoeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZvbnQpIHtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG4gICAgdmFyIGNvbW1hbmRzO1xuICAgIHZhciBoUG9pbnRzO1xuICAgIGlmICghb3B0aW9ucykgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgeFNjYWxlID0gb3B0aW9ucy54U2NhbGU7XG4gICAgdmFyIHlTY2FsZSA9IG9wdGlvbnMueVNjYWxlO1xuXG4gICAgaWYgKG9wdGlvbnMuaGludGluZyAmJiBmb250ICYmIGZvbnQuaGludGluZykge1xuICAgICAgICAvLyBpbiBjYXNlIG9mIGhpbnRpbmcsIHRoZSBoaW50aW5nIGVuZ2luZSB0YWtlcyBjYXJlXG4gICAgICAgIC8vIG9mIHNjYWxpbmcgdGhlIHBvaW50cyAobm90IHRoZSBwYXRoKSBiZWZvcmUgaGludGluZy5cbiAgICAgICAgaFBvaW50cyA9IHRoaXMucGF0aCAmJiBmb250LmhpbnRpbmcuZXhlYyh0aGlzLCBmb250U2l6ZSk7XG4gICAgICAgIC8vIGluIGNhc2UgdGhlIGhpbnRpbmcgZW5naW5lIGZhaWxlZCBoUG9pbnRzIGlzIHVuZGVmaW5lZFxuICAgICAgICAvLyBhbmQgdGh1cyByZXZlcnRzIHRvIHBsYWluIHJlbmRpbmdcbiAgICB9XG5cbiAgICBpZiAoaFBvaW50cykge1xuICAgICAgICAvLyBDYWxsIGZvbnQuaGludGluZy5nZXRDb21tYW5kcyBpbnN0ZWFkIG9mIGBnbHlmLmdldFBhdGgoaFBvaW50cykuY29tbWFuZHNgIHRvIGF2b2lkIGEgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICAgICAgICBjb21tYW5kcyA9IGZvbnQuaGludGluZy5nZXRDb21tYW5kcyhoUG9pbnRzKTtcbiAgICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xuICAgICAgICAvLyBUT0RPIGluIGNhc2Ugb2YgaGludGluZyB4eVNjYWxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRcbiAgICAgICAgeFNjYWxlID0geVNjYWxlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb21tYW5kcyA9IHRoaXMucGF0aC5jb21tYW5kcztcbiAgICAgICAgdmFyIHNjYWxlID0gKDEgLyAodGhpcy5wYXRoLnVuaXRzUGVyRW0gfHwgMTAwMCkpICogZm9udFNpemU7XG4gICAgICAgIGlmICh4U2NhbGUgPT09IHVuZGVmaW5lZCkgeyB4U2NhbGUgPSBzY2FsZTsgfVxuICAgICAgICBpZiAoeVNjYWxlID09PSB1bmRlZmluZWQpIHsgeVNjYWxlID0gc2NhbGU7IH1cbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBQYXRoKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBwLm1vdmVUbyh4ICsgY21kLnggKiB4U2NhbGUsIHkgKyAtY21kLnkgKiB5U2NhbGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcbiAgICAgICAgICAgIHAubGluZVRvKHggKyBjbWQueCAqIHhTY2FsZSwgeSArIC1jbWQueSAqIHlTY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHggKyBjbWQueDEgKiB4U2NhbGUsXG4gICAgICAgICAgICAgICAgeSArIC1jbWQueTEgKiB5U2NhbGUsXG4gICAgICAgICAgICAgICAgeCArIGNtZC54ICogeFNjYWxlLFxuICAgICAgICAgICAgICAgIHkgKyAtY21kLnkgKiB5U2NhbGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgcC5jdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHggKyBjbWQueDEgKiB4U2NhbGUsXG4gICAgICAgICAgICAgICAgeSArIC1jbWQueTEgKiB5U2NhbGUsXG4gICAgICAgICAgICAgICAgeCArIGNtZC54MiAqIHhTY2FsZSxcbiAgICAgICAgICAgICAgICB5ICsgLWNtZC55MiAqIHlTY2FsZSxcbiAgICAgICAgICAgICAgICB4ICsgY21kLnggKiB4U2NhbGUsXG4gICAgICAgICAgICAgICAgeSArIC1jbWQueSAqIHlTY2FsZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG59O1xuXG4vKipcbiAqIFNwbGl0IHRoZSBnbHlwaCBpbnRvIGNvbnRvdXJzLlxuICogVGhpcyBmdW5jdGlvbiBpcyBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYW5kIHRvXG4gKiBwcm92aWRlIHJhdyBhY2Nlc3MgdG8gdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmVzLlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRDb250b3VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wb2ludHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbnRvdXJzID0gW107XG4gICAgdmFyIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHQgPSB0aGlzLnBvaW50c1tpXTtcbiAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG4gICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrLmFyZ3VtZW50KFxuICAgICAgICBjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsXG4gICAgICAgICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nXG4gICAgKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgeE1pbi95TWluL3hNYXgveU1heC9sc2IvcnNiIGZvciBhIEdseXBoLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5HbHlwaC5wcm90b3R5cGUuZ2V0TWV0cmljcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29tbWFuZHMgPSB0aGlzLnBhdGguY29tbWFuZHM7XG4gICAgdmFyIHhDb29yZHMgPSBbXTtcbiAgICB2YXIgeUNvb3JkcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNtZCA9IGNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgIT09ICdaJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54KTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdRJyB8fCBjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngxKTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIHhDb29yZHMucHVzaChjbWQueDIpO1xuICAgICAgICAgICAgeUNvb3Jkcy5wdXNoKGNtZC55Mik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWV0cmljcyA9IHtcbiAgICAgICAgeE1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeENvb3JkcyksXG4gICAgICAgIHlNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHlDb29yZHMpLFxuICAgICAgICB4TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB4Q29vcmRzKSxcbiAgICAgICAgeU1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeUNvb3JkcyksXG4gICAgICAgIGxlZnRTaWRlQmVhcmluZzogdGhpcy5sZWZ0U2lkZUJlYXJpbmcsXG4gICAgfTtcblxuICAgIGlmICghaXNGaW5pdGUobWV0cmljcy54TWluKSkge1xuICAgICAgICBtZXRyaWNzLnhNaW4gPSAwO1xuICAgIH1cblxuICAgIGlmICghaXNGaW5pdGUobWV0cmljcy54TWF4KSkge1xuICAgICAgICBtZXRyaWNzLnhNYXggPSB0aGlzLmFkdmFuY2VXaWR0aDtcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueU1pbikpIHtcbiAgICAgICAgbWV0cmljcy55TWluID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueU1heCkpIHtcbiAgICAgICAgbWV0cmljcy55TWF4ID0gMDtcbiAgICB9XG5cbiAgICBtZXRyaWNzLnJpZ2h0U2lkZUJlYXJpbmcgPVxuICAgICAgICB0aGlzLmFkdmFuY2VXaWR0aCAtXG4gICAgICAgIG1ldHJpY3MubGVmdFNpZGVCZWFyaW5nIC1cbiAgICAgICAgKG1ldHJpY3MueE1heCAtIG1ldHJpY3MueE1pbik7XG4gICAgcmV0dXJuIG1ldHJpY3M7XG59O1xuXG4vLyBUaGUgR2x5cGhTZXQgb2JqZWN0XG5cbi8vIERlZmluZSBhIHByb3BlcnR5IG9uIHRoZSBnbHlwaCB0aGF0IGRlcGVuZHMgb24gdGhlIHBhdGggYmVpbmcgbG9hZGVkLlxuZnVuY3Rpb24gZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsIGV4dGVybmFsTmFtZSwgaW50ZXJuYWxOYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdseXBoLCBleHRlcm5hbE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IHRoZSBwYXRoIHByb3BlcnR5IHRvIG1ha2Ugc3VyZSB0aGUgcGF0aCBpcyBsb2FkZWQuXG4gICAgICAgICAgICBnbHlwaC5wYXRoOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIHJldHVybiBnbHlwaFtpbnRlcm5hbE5hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZ2x5cGhbaW50ZXJuYWxOYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSk7XG59XG5cbi8qKlxuICogQSBHbHlwaFNldCByZXByZXNlbnRzIGFsbCBnbHlwaHMgYXZhaWxhYmxlIGluIHRoZSBmb250LCBidXQgbW9kZWxsZWQgdXNpbmdcbiAqIGEgZGVmZXJyZWQgZ2x5cGggbG9hZGVyLCBmb3IgcmV0cmlldmluZyBnbHlwaHMgb25seSBvbmNlIHRoZXkgYXJlIGFic29sdXRlbHlcbiAqIG5lY2Vzc2FyeSwgdG8ga2VlcCB0aGUgbWVtb3J5IGZvb3RwcmludCBkb3duLlxuICogQGV4cG9ydHMgb3BlbnR5cGUuR2x5cGhTZXRcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICogQHBhcmFtIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gR2x5cGhTZXQoZm9udCwgZ2x5cGhzKSB7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbiAgICB0aGlzLmdseXBocyA9IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGdseXBocykpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgICAgIGdseXBoLnBhdGgudW5pdHNQZXJFbSA9IGZvbnQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2ldID0gZ2x5cGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IChnbHlwaHMgJiYgZ2x5cGhzLmxlbmd0aCkgfHwgMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAqL1xuR2x5cGhTZXQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIC8vIHRoaXMuZ2x5cGhzW2luZGV4XSBpcyAndW5kZWZpbmVkJyB3aGVuIGxvdyBtZW1vcnkgbW9kZSBpcyBvbi4gZ2x5cGggaXMgcHVzaGVkIG9uIHJlcXVlc3Qgb25seS5cbiAgICBpZiAodGhpcy5nbHlwaHNbaW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5mb250Ll9wdXNoKGluZGV4KTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdseXBoc1tpbmRleF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2luZGV4XSA9IHRoaXMuZ2x5cGhzW2luZGV4XSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdseXBoID0gdGhpcy5nbHlwaHNbaW5kZXhdO1xuICAgICAgICB2YXIgdW5pY29kZU9iaiA9IHRoaXMuZm9udC5fSW5kZXhUb1VuaWNvZGVNYXBbaW5kZXhdO1xuXG4gICAgICAgIGlmICh1bmljb2RlT2JqKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHVuaWNvZGVPYmoudW5pY29kZXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgeyBnbHlwaC5hZGRVbmljb2RlKHVuaWNvZGVPYmoudW5pY29kZXNbal0pOyB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdseXBoc1tpbmRleF0uYWR2YW5jZVdpZHRoID1cbiAgICAgICAgICAgIHRoaXMuZm9udC5faG10eFRhYmxlRGF0YVtpbmRleF0uYWR2YW5jZVdpZHRoO1xuICAgICAgICB0aGlzLmdseXBoc1tpbmRleF0ubGVmdFNpZGVCZWFyaW5nID1cbiAgICAgICAgICAgIHRoaXMuZm9udC5faG10eFRhYmxlRGF0YVtpbmRleF0ubGVmdFNpZGVCZWFyaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5nbHlwaHNbaW5kZXhdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmdseXBoc1tpbmRleF0gPSB0aGlzLmdseXBoc1tpbmRleF0oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdseXBoc1tpbmRleF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSAge09iamVjdH1cbiAqL1xuR2x5cGhTZXQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoaW5kZXgsIGxvYWRlcikge1xuICAgIHRoaXMuZ2x5cGhzW2luZGV4XSA9IGxvYWRlcjtcbiAgICB0aGlzLmxlbmd0aCsrO1xufTtcblxuLyoqXG4gKiBAYWxpYXMgb3BlbnR5cGUuZ2x5cGhMb2FkZXJcbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5mdW5jdGlvbiBnbHlwaExvYWRlcihmb250LCBpbmRleCkge1xuICAgIHJldHVybiBuZXcgR2x5cGgoeyBpbmRleDogaW5kZXgsIGZvbnQ6IGZvbnQgfSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdHViIGdseXBoIHRoYXQgY2FuIGJlIGZpbGxlZCB3aXRoIGFsbCBtZXRhZGF0YSAqZXhjZXB0KlxuICogdGhlIFwicG9pbnRzXCIgYW5kIFwicGF0aFwiIHByb3BlcnRpZXMsIHdoaWNoIG11c3QgYmUgbG9hZGVkIG9ubHkgb25jZVxuICogdGhlIGdseXBoJ3MgcGF0aCBpcyBhY3R1YWxseSByZXF1ZXN0ZWQgZm9yIHRleHQgc2hhcGluZy5cbiAqIEBhbGlhcyBvcGVudHlwZS50dGZHbHlwaExvYWRlclxuICogQHBhcmFtICB7b3BlbnR5cGUuRm9udH0gZm9udFxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtICB7RnVuY3Rpb259IHBhcnNlR2x5cGhcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICogQHBhcmFtICB7bnVtYmVyfSBwb3NpdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb259IGJ1aWxkUGF0aFxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbmZ1bmN0aW9uIHR0ZkdseXBoTG9hZGVyKGZvbnQsIGluZGV4LCBwYXJzZUdseXBoLCBkYXRhLCBwb3NpdGlvbiwgYnVpbGRQYXRoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdseXBoID0gbmV3IEdseXBoKHsgaW5kZXg6IGluZGV4LCBmb250OiBmb250IH0pO1xuXG4gICAgICAgIGdseXBoLnBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwYXJzZUdseXBoKGdseXBoLCBkYXRhLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGJ1aWxkUGF0aChmb250LmdseXBocywgZ2x5cGgpO1xuICAgICAgICAgICAgcGF0aC51bml0c1BlckVtID0gZm9udC51bml0c1BlckVtO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd4TWluJywgJ194TWluJyk7XG4gICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneE1heCcsICdfeE1heCcpO1xuICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3lNaW4nLCAnX3lNaW4nKTtcbiAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd5TWF4JywgJ195TWF4Jyk7XG5cbiAgICAgICAgcmV0dXJuIGdseXBoO1xuICAgIH07XG59XG4vKipcbiAqIEBhbGlhcyBvcGVudHlwZS5jZmZHbHlwaExvYWRlclxuICogQHBhcmFtICB7b3BlbnR5cGUuRm9udH0gZm9udFxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtICB7RnVuY3Rpb259IHBhcnNlQ0ZGQ2hhcnN0cmluZ1xuICogQHBhcmFtICB7c3RyaW5nfSBjaGFyc3RyaW5nXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAqL1xuZnVuY3Rpb24gY2ZmR2x5cGhMb2FkZXIoZm9udCwgaW5kZXgsIHBhcnNlQ0ZGQ2hhcnN0cmluZywgY2hhcnN0cmluZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IG5ldyBHbHlwaCh7IGluZGV4OiBpbmRleCwgZm9udDogZm9udCB9KTtcblxuICAgICAgICBnbHlwaC5wYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBwYXJzZUNGRkNoYXJzdHJpbmcoZm9udCwgZ2x5cGgsIGNoYXJzdHJpbmcpO1xuICAgICAgICAgICAgcGF0aC51bml0c1BlckVtID0gZm9udC51bml0c1BlckVtO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGdseXBoO1xuICAgIH07XG59XG5cbnZhciBnbHlwaHNldCA9IHsgR2x5cGhTZXQ6IEdseXBoU2V0LCBnbHlwaExvYWRlcjogZ2x5cGhMb2FkZXIsIHR0ZkdseXBoTG9hZGVyOiB0dGZHbHlwaExvYWRlciwgY2ZmR2x5cGhMb2FkZXI6IGNmZkdseXBoTG9hZGVyIH07XG5cbi8vIFRoZSBMYXlvdXQgb2JqZWN0IGlzIHRoZSBwcm90b3R5cGUgb2YgU3Vic3RpdHV0aW9uIG9iamVjdHMsIGFuZCBwcm92aWRlc1xuXG5mdW5jdGlvbiBzZWFyY2hUYWcoYXJyLCB0YWcpIHtcbiAgICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cbiAgICB2YXIgaW1pbiA9IDA7XG4gICAgdmFyIGltYXggPSBhcnIubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaW1pbiA8PSBpbWF4KSB7XG4gICAgICAgIHZhciBpbWlkID0gKGltaW4gKyBpbWF4KSA+Pj4gMTtcbiAgICAgICAgdmFyIHZhbCA9IGFycltpbWlkXS50YWc7XG4gICAgICAgIGlmICh2YWwgPT09IHRhZykge1xuICAgICAgICAgICAgcmV0dXJuIGltaWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDwgdGFnKSB7XG4gICAgICAgICAgICBpbWluID0gaW1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbWF4ID0gaW1pZCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm90IGZvdW5kOiByZXR1cm4gLTEtaW5zZXJ0aW9uIHBvaW50XG4gICAgcmV0dXJuIC1pbWluIC0gMTtcbn1cblxuZnVuY3Rpb24gYmluU2VhcmNoKGFyciwgdmFsdWUpIHtcbiAgICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cbiAgICB2YXIgaW1pbiA9IDA7XG4gICAgdmFyIGltYXggPSBhcnIubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaW1pbiA8PSBpbWF4KSB7XG4gICAgICAgIHZhciBpbWlkID0gKGltaW4gKyBpbWF4KSA+Pj4gMTtcbiAgICAgICAgdmFyIHZhbCA9IGFycltpbWlkXTtcbiAgICAgICAgaWYgKHZhbCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWlkO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8IHZhbHVlKSB7XG4gICAgICAgICAgICBpbWluID0gaW1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbWF4ID0gaW1pZCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm90IGZvdW5kOiByZXR1cm4gLTEtaW5zZXJ0aW9uIHBvaW50XG4gICAgcmV0dXJuIC1pbWluIC0gMTtcbn1cblxuLy8gYmluYXJ5IHNlYXJjaCBpbiBhIGxpc3Qgb2YgcmFuZ2VzIChjb3ZlcmFnZSwgY2xhc3MgZGVmaW5pdGlvbilcbmZ1bmN0aW9uIHNlYXJjaFJhbmdlKHJhbmdlcywgdmFsdWUpIHtcbiAgICAvLyBqc2hpbnQgYml0d2lzZTogZmFsc2VcbiAgICB2YXIgcmFuZ2U7XG4gICAgdmFyIGltaW4gPSAwO1xuICAgIHZhciBpbWF4ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGltaW4gPD0gaW1heCkge1xuICAgICAgICB2YXIgaW1pZCA9IChpbWluICsgaW1heCkgPj4+IDE7XG4gICAgICAgIHJhbmdlID0gcmFuZ2VzW2ltaWRdO1xuICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0IDwgdmFsdWUpIHtcbiAgICAgICAgICAgIGltaW4gPSBpbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGltYXggPSBpbWlkIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW1pbiA+IDApIHtcbiAgICAgICAgcmFuZ2UgPSByYW5nZXNbaW1pbiAtIDFdO1xuICAgICAgICBpZiAodmFsdWUgPiByYW5nZS5lbmQpIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5MYXlvdXRcbiAqIEBjbGFzc1xuICovXG5mdW5jdGlvbiBMYXlvdXQoZm9udCwgdGFibGVOYW1lKSB7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbiAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbn1cblxuTGF5b3V0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBCaW5hcnkgc2VhcmNoIGFuIG9iamVjdCBieSBcInRhZ1wiIHByb3BlcnR5XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQGZ1bmN0aW9uIHNlYXJjaFRhZ1xuICAgICAqIEBtZW1iZXJvZiBvcGVudHlwZS5MYXlvdXRcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0YWdcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2VhcmNoVGFnOiBzZWFyY2hUYWcsXG5cbiAgICAvKipcbiAgICAgKiBCaW5hcnkgc2VhcmNoIGluIGEgbGlzdCBvZiBudW1iZXJzXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQGZ1bmN0aW9uIGJpblNlYXJjaFxuICAgICAqIEBtZW1iZXJvZiBvcGVudHlwZS5MYXlvdXRcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBiaW5TZWFyY2g6IGJpblNlYXJjaCxcblxuICAgIC8qKlxuICAgICAqIEdldCBvciBjcmVhdGUgdGhlIExheW91dCB0YWJsZSAoR1NVQiwgR1BPUyBldGMpLlxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGNyZWF0ZSAtIFdoZXRoZXIgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBHU1VCIG9yIEdQT1MgdGFibGUuXG4gICAgICovXG4gICAgZ2V0VGFibGU6IGZ1bmN0aW9uIChjcmVhdGUpIHtcbiAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdO1xuICAgICAgICBpZiAoIWxheW91dCAmJiBjcmVhdGUpIHtcbiAgICAgICAgICAgIGxheW91dCA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdID1cbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZURlZmF1bHRUYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJlc3QgYmV0IGZvciBhIHNjcmlwdCBuYW1lLlxuICAgICAqIFJldHVybnMgJ0RGTFQnIGlmIGl0IGV4aXN0cy5cbiAgICAgKiBJZiBub3QsIHJldHVybnMgJ2xhdG4nIGlmIGl0IGV4aXN0cy5cbiAgICAgKiBJZiBuZWl0aGVyIGV4aXN0LCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0U2NyaXB0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXRUYWJsZSgpO1xuICAgICAgICBpZiAoIWxheW91dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNMYXRuID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0LnNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbGF5b3V0LnNjcmlwdHNbaV0udGFnO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdERkxUJykgeyByZXR1cm4gbmFtZTsgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdsYXRuJykgeyBoYXNMYXRuID0gdHJ1ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNMYXRuKSB7IHJldHVybiAnbGF0bic7IH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgTGFuZ1N5c1JlY29yZHMgaW4gdGhlIGdpdmVuIHNjcmlwdC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGUgLSBmb3JjZXMgdGhlIGNyZWF0aW9uIG9mIHRoaXMgc2NyaXB0IHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0YWcgYW5kIHNjcmlwdCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdldFNjcmlwdFRhYmxlOiBmdW5jdGlvbiAoc2NyaXB0LCBjcmVhdGUpIHtcbiAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0VGFibGUoY3JlYXRlKTtcbiAgICAgICAgaWYgKGxheW91dCkge1xuICAgICAgICAgICAgc2NyaXB0ID0gc2NyaXB0IHx8ICdERkxUJztcbiAgICAgICAgICAgIHZhciBzY3JpcHRzID0gbGF5b3V0LnNjcmlwdHM7XG4gICAgICAgICAgICB2YXIgcG9zID0gc2VhcmNoVGFnKGxheW91dC5zY3JpcHRzLCBzY3JpcHQpO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdHNbcG9zXS5zY3JpcHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzY3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogc2NyaXB0LFxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMYW5nU3lzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXJ2ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxRmVhdHVyZUluZGV4OiAweGZmZmYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUluZGV4ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmdTeXNSZWNvcmRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNjcmlwdHMuc3BsaWNlKC0xIC0gcG9zLCAwLCBzY3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3Iuc2NyaXB0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsYW5ndWFnZSBzeXN0ZW0gdGFibGVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGxmdCddXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGUgLSBmb3JjZXMgdGhlIGNyZWF0aW9uIG9mIHRoaXMgbGFuZ1N5c1RhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldExhbmdTeXNUYWJsZTogZnVuY3Rpb24gKHNjcmlwdCwgbGFuZ3VhZ2UsIGNyZWF0ZSkge1xuICAgICAgICB2YXIgc2NyaXB0VGFibGUgPSB0aGlzLmdldFNjcmlwdFRhYmxlKHNjcmlwdCwgY3JlYXRlKTtcbiAgICAgICAgaWYgKHNjcmlwdFRhYmxlKSB7XG4gICAgICAgICAgICBpZiAoIWxhbmd1YWdlIHx8IGxhbmd1YWdlID09PSAnZGZsdCcgfHwgbGFuZ3VhZ2UgPT09ICdERkxUJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRUYWJsZS5kZWZhdWx0TGFuZ1N5cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwb3MgPSBzZWFyY2hUYWcoc2NyaXB0VGFibGUubGFuZ1N5c1JlY29yZHMsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRUYWJsZS5sYW5nU3lzUmVjb3Jkc1twb3NdLmxhbmdTeXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBsYW5nU3lzUmVjb3JkID0ge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IGxhbmd1YWdlLFxuICAgICAgICAgICAgICAgICAgICBsYW5nU3lzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNlcnZlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcUZlYXR1cmVJbmRleDogMHhmZmZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUluZGV4ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NyaXB0VGFibGUubGFuZ1N5c1JlY29yZHMuc3BsaWNlKC0xIC0gcG9zLCAwLCBsYW5nU3lzUmVjb3JkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ1N5c1JlY29yZC5sYW5nU3lzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHNwZWNpZmljIGZlYXR1cmUgdGFibGUuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RsZnQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gT25lIG9mIHRoZSBjb2RlcyBsaXN0ZWQgYXQgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9mZWF0dXJlbGlzdC5odG1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhlIGZlYXR1cmUgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RmVhdHVyZVRhYmxlOiBmdW5jdGlvbiAoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgY3JlYXRlKSB7XG4gICAgICAgIHZhciBsYW5nU3lzVGFibGUgPSB0aGlzLmdldExhbmdTeXNUYWJsZShzY3JpcHQsIGxhbmd1YWdlLCBjcmVhdGUpO1xuICAgICAgICBpZiAobGFuZ1N5c1RhYmxlKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZVJlY29yZDtcbiAgICAgICAgICAgIHZhciBmZWF0SW5kZXhlcyA9IGxhbmdTeXNUYWJsZS5mZWF0dXJlSW5kZXhlcztcbiAgICAgICAgICAgIHZhciBhbGxGZWF0dXJlcyA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdLmZlYXR1cmVzO1xuICAgICAgICAgICAgLy8gVGhlIEZlYXR1cmVJbmRleCBhcnJheSBvZiBpbmRpY2VzIGlzIGluIGFyYml0cmFyeSBvcmRlcixcbiAgICAgICAgICAgIC8vIGV2ZW4gaWYgYWxsRmVhdHVyZXMgaXMgc29ydGVkIGFscGhhYmV0aWNhbGx5IGJ5IGZlYXR1cmUgdGFnLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVSZWNvcmQgPSBhbGxGZWF0dXJlc1tmZWF0SW5kZXhlc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVSZWNvcmQudGFnID09PSBmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlUmVjb3JkLmZlYXR1cmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFsbEZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBBdXRvbWF0aWMgb3JkZXJpbmcgb2YgZmVhdHVyZXMgd291bGQgcmVxdWlyZSB0byBzaGlmdCBmZWF0dXJlIGluZGV4ZXMgaW4gdGhlIHNjcmlwdCBsaXN0LlxuICAgICAgICAgICAgICAgIGNoZWNrLmFzc2VydChcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPT09IDAgfHwgZmVhdHVyZSA+PSBhbGxGZWF0dXJlc1tpbmRleCAtIDFdLnRhZyxcbiAgICAgICAgICAgICAgICAgICAgJ0ZlYXR1cmVzIG11c3QgYmUgYWRkZWQgaW4gYWxwaGFiZXRpY2FsIG9yZGVyLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGZlYXR1cmVSZWNvcmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogZmVhdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZTogeyBwYXJhbXM6IDAsIGxvb2t1cExpc3RJbmRleGVzOiBbXSB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMucHVzaChmZWF0dXJlUmVjb3JkKTtcbiAgICAgICAgICAgICAgICBmZWF0SW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZVJlY29yZC5mZWF0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbG9va3VwIHRhYmxlcyBvZiBhIGdpdmVuIHR5cGUgZm9yIGEgc2NyaXB0L2xhbmd1YWdlL2ZlYXR1cmUuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RsZnQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBjb2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvb2t1cFR5cGUgLSAxIHRvIDlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhlIGxvb2t1cCB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LCB3aXRoIG5vIHN1YnRhYmxlcy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRMb29rdXBUYWJsZXM6IGZ1bmN0aW9uIChzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCBsb29rdXBUeXBlLCBjcmVhdGUpIHtcbiAgICAgICAgdmFyIGZlYXR1cmVUYWJsZSA9IHRoaXMuZ2V0RmVhdHVyZVRhYmxlKFxuICAgICAgICAgICAgc2NyaXB0LFxuICAgICAgICAgICAgbGFuZ3VhZ2UsXG4gICAgICAgICAgICBmZWF0dXJlLFxuICAgICAgICAgICAgY3JlYXRlXG4gICAgICAgICk7XG4gICAgICAgIHZhciB0YWJsZXMgPSBbXTtcbiAgICAgICAgaWYgKGZlYXR1cmVUYWJsZSkge1xuICAgICAgICAgICAgdmFyIGxvb2t1cFRhYmxlO1xuICAgICAgICAgICAgdmFyIGxvb2t1cExpc3RJbmRleGVzID0gZmVhdHVyZVRhYmxlLmxvb2t1cExpc3RJbmRleGVzO1xuICAgICAgICAgICAgdmFyIGFsbExvb2t1cHMgPSB0aGlzLmZvbnQudGFibGVzW3RoaXMudGFibGVOYW1lXS5sb29rdXBzO1xuICAgICAgICAgICAgLy8gbG9va3VwTGlzdEluZGV4ZXMgYXJlIGluIG5vIHBhcnRpY3VsYXIgb3JkZXIsIHNvIHVzZSBuYWl2ZSBzZWFyY2guXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvb2t1cExpc3RJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9va3VwVGFibGUgPSBhbGxMb29rdXBzW2xvb2t1cExpc3RJbmRleGVzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAobG9va3VwVGFibGUubG9va3VwVHlwZSA9PT0gbG9va3VwVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZXMucHVzaChsb29rdXBUYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhYmxlcy5sZW5ndGggPT09IDAgJiYgY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgbG9va3VwVGFibGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFR5cGU6IGxvb2t1cFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cEZsYWc6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN1YnRhYmxlczogW10sXG4gICAgICAgICAgICAgICAgICAgIG1hcmtGaWx0ZXJpbmdTZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFsbExvb2t1cHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGFsbExvb2t1cHMucHVzaChsb29rdXBUYWJsZSk7XG4gICAgICAgICAgICAgICAgbG9va3VwTGlzdEluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsb29rdXBUYWJsZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhYmxlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIGdseXBoIGluIGEgY2xhc3MgZGVmaW5pdGlvbiB0YWJsZVxuICAgICAqIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9jaGFwdGVyMiNjbGFzcy1kZWZpbml0aW9uLXRhYmxlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNsYXNzRGVmVGFibGUgLSBhbiBPcGVuVHlwZSBMYXlvdXQgY2xhc3MgZGVmaW5pdGlvbiB0YWJsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnbHlwaEluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBnbHlwaCB0byBmaW5kXG4gICAgICogQHJldHVybnMge251bWJlcn0gLTEgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0R2x5cGhDbGFzczogZnVuY3Rpb24gKGNsYXNzRGVmVGFibGUsIGdseXBoSW5kZXgpIHtcbiAgICAgICAgc3dpdGNoIChjbGFzc0RlZlRhYmxlLmZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NEZWZUYWJsZS5zdGFydEdseXBoIDw9IGdseXBoSW5kZXggJiZcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA8XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc0RlZlRhYmxlLnN0YXJ0R2x5cGggKyBjbGFzc0RlZlRhYmxlLmNsYXNzZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc0RlZlRhYmxlLmNsYXNzZXNbXG4gICAgICAgICAgICAgICAgICAgICAgICBnbHlwaEluZGV4IC0gY2xhc3NEZWZUYWJsZS5zdGFydEdseXBoXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHNlYXJjaFJhbmdlKGNsYXNzRGVmVGFibGUucmFuZ2VzLCBnbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UgPyByYW5nZS5jbGFzc0lkIDogMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgZ2x5cGggaW4gYSBjb3ZlcmFnZSB0YWJsZVxuICAgICAqIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9jaGFwdGVyMiNjb3ZlcmFnZS10YWJsZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb3ZlcmFnZVRhYmxlIC0gYW4gT3BlblR5cGUgTGF5b3V0IGNvdmVyYWdlIHRhYmxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdseXBoSW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGdseXBoIHRvIGZpbmRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtMSBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBnZXRDb3ZlcmFnZUluZGV4OiBmdW5jdGlvbiAoY292ZXJhZ2VUYWJsZSwgZ2x5cGhJbmRleCkge1xuICAgICAgICBzd2l0Y2ggKGNvdmVyYWdlVGFibGUuZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYmluU2VhcmNoKGNvdmVyYWdlVGFibGUuZ2x5cGhzLCBnbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPj0gMCA/IGluZGV4IDogLTE7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VhcmNoUmFuZ2UoY292ZXJhZ2VUYWJsZS5yYW5nZXMsIGdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZSA/IHJhbmdlLmluZGV4ICsgZ2x5cGhJbmRleCAtIHJhbmdlLnN0YXJ0IDogLTE7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBnbHlwaCBpbmRleGVzIG9mIGEgY292ZXJhZ2UgdGFibGUuXG4gICAgICogRm9ybWF0IDE6IHRoZSBsaXN0IGlzIHN0b3JlZCByYXdcbiAgICAgKiBGb3JtYXQgMjogY29tcGFjdCBsaXN0IGFzIHJhbmdlIHJlY29yZHMuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjb3ZlcmFnZVRhYmxlXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZXhwYW5kQ292ZXJhZ2U6IGZ1bmN0aW9uIChjb3ZlcmFnZVRhYmxlKSB7XG4gICAgICAgIGlmIChjb3ZlcmFnZVRhYmxlLmZvcm1hdCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvdmVyYWdlVGFibGUuZ2x5cGhzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGdseXBocyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IGNvdmVyYWdlVGFibGUucmFuZ2VzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPD0gZW5kOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhzLnB1c2goaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdseXBocztcbiAgICAgICAgfVxuICAgIH0sXG59O1xuXG4vLyBUaGUgUG9zaXRpb24gb2JqZWN0IHByb3ZpZGVzIHV0aWxpdHkgbWV0aG9kcyB0byBtYW5pcHVsYXRlXG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuUG9zaXRpb25cbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgb3BlbnR5cGUuTGF5b3V0XG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUG9zaXRpb24oZm9udCkge1xuICAgIExheW91dC5jYWxsKHRoaXMsIGZvbnQsICdncG9zJyk7XG59XG5cblBvc2l0aW9uLnByb3RvdHlwZSA9IExheW91dC5wcm90b3R5cGU7XG5cbi8qKlxuICogSW5pdCBzb21lIGRhdGEgZm9yIGZhc3RlciBhbmQgZWFzaWVyIGFjY2VzcyBsYXRlci5cbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NyaXB0ID0gdGhpcy5nZXREZWZhdWx0U2NyaXB0TmFtZSgpO1xuICAgIHRoaXMuZGVmYXVsdEtlcm5pbmdUYWJsZXMgPSB0aGlzLmdldEtlcm5pbmdUYWJsZXMoc2NyaXB0KTtcbn07XG5cbi8qKlxuICogRmluZCBhIGdseXBoIHBhaXIgaW4gYSBsaXN0IG9mIGxvb2t1cCB0YWJsZXMgb2YgdHlwZSAyIGFuZCByZXRyaWV2ZSB0aGUgeEFkdmFuY2Uga2VybmluZyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlZnRJbmRleCAtIGxlZnQgZ2x5cGggaW5kZXhcbiAqIEBwYXJhbSB7aW50ZWdlcn0gcmlnaHRJbmRleCAtIHJpZ2h0IGdseXBoIGluZGV4XG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLmdldEtlcm5pbmdWYWx1ZSA9IGZ1bmN0aW9uKGtlcm5pbmdMb29rdXBzLCBsZWZ0SW5kZXgsIHJpZ2h0SW5kZXgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtlcm5pbmdMb29rdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSBrZXJuaW5nTG9va3Vwc1tpXS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3VidGFibGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbal07XG4gICAgICAgICAgICB2YXIgY292SW5kZXggPSB0aGlzLmdldENvdmVyYWdlSW5kZXgoc3VidGFibGUuY292ZXJhZ2UsIGxlZnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoY292SW5kZXggPCAwKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICBzd2l0Y2ggKHN1YnRhYmxlLnBvc0Zvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIFBhaXIgQWRqdXN0bWVudCBQb3NpdGlvbmluZyBGb3JtYXQgMVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFpclNldCA9IHN1YnRhYmxlLnBhaXJTZXRzW2NvdkluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwYWlyU2V0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJTZXRba107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFpci5zZWNvbmRHbHlwaCA9PT0gcmlnaHRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyLnZhbHVlMSAmJiBwYWlyLnZhbHVlMS54QWR2YW5jZSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgIC8vIGxlZnQgZ2x5cGggZm91bmQsIG5vdCByaWdodCBnbHlwaCAtIHRyeSBuZXh0IHN1YnRhYmxlXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWFyY2ggUGFpciBBZGp1c3RtZW50IFBvc2l0aW9uaW5nIEZvcm1hdCAyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzczEgPSB0aGlzLmdldEdseXBoQ2xhc3Moc3VidGFibGUuY2xhc3NEZWYxLCBsZWZ0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3MyID0gdGhpcy5nZXRHbHlwaENsYXNzKHN1YnRhYmxlLmNsYXNzRGVmMiwgcmlnaHRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWlyJDEgPSBzdWJ0YWJsZS5jbGFzc1JlY29yZHNbY2xhc3MxXVtjbGFzczJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpciQxLnZhbHVlMSAmJiBwYWlyJDEudmFsdWUxLnhBZHZhbmNlIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGtlcm5pbmcgbG9va3VwIHRhYmxlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddIC0gdXNlIGZvbnQucG9zaXRpb24uZ2V0RGVmYXVsdFNjcmlwdE5hbWUoKSBmb3IgYSBiZXR0ZXIgZGVmYXVsdCB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcmV0dXJuIHtvYmplY3RbXX0gVGhlIGxpc3Qgb2Yga2VybmluZyBsb29rdXAgdGFibGVzIChtYXkgYmUgZW1wdHkpLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gR1BPUyB0YWJsZSAoYW5kIHdlIHNob3VsZCB1c2UgdGhlIGtlcm4gdGFibGUpXG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5nZXRLZXJuaW5nVGFibGVzID0gZnVuY3Rpb24oc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGlmICh0aGlzLmZvbnQudGFibGVzLmdwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsICdrZXJuJywgMik7XG4gICAgfVxufTtcblxuLy8gVGhlIFN1YnN0aXR1dGlvbiBvYmplY3QgcHJvdmlkZXMgdXRpbGl0eSBtZXRob2RzIHRvIG1hbmlwdWxhdGVcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5TdWJzdGl0dXRpb25cbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgb3BlbnR5cGUuTGF5b3V0XG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3Vic3RpdHV0aW9uKGZvbnQpIHtcbiAgICBMYXlvdXQuY2FsbCh0aGlzLCBmb250LCAnZ3N1YicpO1xufVxuXG4vLyBDaGVjayBpZiAyIGFycmF5cyBvZiBwcmltaXRpdmVzIGFyZSBlcXVhbC5cbmZ1bmN0aW9uIGFycmF5c0VxdWFsKGFyMSwgYXIyKSB7XG4gICAgdmFyIG4gPSBhcjEubGVuZ3RoO1xuICAgIGlmIChuICE9PSBhcjIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKGFyMVtpXSAhPT0gYXIyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEZpbmQgdGhlIGZpcnN0IHN1YnRhYmxlIG9mIGEgbG9va3VwIHRhYmxlIGluIGEgcGFydGljdWxhciBmb3JtYXQuXG5mdW5jdGlvbiBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgZm9ybWF0LCBkZWZhdWx0U3VidGFibGUpIHtcbiAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGUuc3VidGFibGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcbiAgICAgICAgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSBmb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJ0YWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFN1YnRhYmxlKSB7XG4gICAgICAgIHN1YnRhYmxlcy5wdXNoKGRlZmF1bHRTdWJ0YWJsZSk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0U3VidGFibGU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUgPSBMYXlvdXQucHJvdG90eXBlO1xuXG4vKipcbiAqIENyZWF0ZSBhIGRlZmF1bHQgR1NVQiB0YWJsZS5cbiAqIEByZXR1cm4ge09iamVjdH0gZ3N1YiAtIFRoZSBHU1VCIHRhYmxlLlxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmNyZWF0ZURlZmF1bHRUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBHZW5lcmF0ZSBhIGRlZmF1bHQgZW1wdHkgR1NVQiB0YWJsZSB3aXRoIGp1c3QgYSBERkxUIHNjcmlwdCBhbmQgZGZsdCBsYW5nIHN5cy5cbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICBzY3JpcHRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnREZMVCcsXG4gICAgICAgICAgICAgICAgc2NyaXB0OiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMYW5nU3lzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNlcnZlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcUZlYXR1cmVJbmRleDogMHhmZmZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUluZGV4ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsYW5nU3lzUmVjb3JkczogW10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0gXSxcbiAgICAgICAgZmVhdHVyZXM6IFtdLFxuICAgICAgICBsb29rdXBzOiBbXSxcbiAgICB9O1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBzaW5nbGUgc3Vic3RpdHV0aW9ucyAobG9va3VwIHR5cGUgMSkgZm9yIGEgZ2l2ZW4gc2NyaXB0LCBsYW5ndWFnZSwgYW5kIGZlYXR1cmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1jaGFyYWN0ZXIgZmVhdHVyZSBuYW1lICgnYWFsdCcsICdzYWx0JywgJ3NzMDEnLi4uKVxuICogQHJldHVybiB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgLSBUaGUgbGlzdCBvZiBzdWJzdGl0dXRpb25zLlxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldFNpbmdsZSA9IGZ1bmN0aW9uIChmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIHN1YnN0aXR1dGlvbnMgPSBbXTtcbiAgICB2YXIgbG9va3VwVGFibGVzID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMSk7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbG9va3VwVGFibGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgdmFyIHN1YnRhYmxlcyA9IGxvb2t1cFRhYmxlc1tpZHhdLnN1YnRhYmxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcbiAgICAgICAgICAgIHZhciBnbHlwaHMgPSB0aGlzLmV4cGFuZENvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICAgICAgICAgIHZhciBqID0gKHZvaWQgMCk7XG4gICAgICAgICAgICBpZiAoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBzdWJ0YWJsZS5kZWx0YUdseXBoSWQ7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbal07XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7IHN1YjogZ2x5cGgsIGJ5OiBnbHlwaCArIGRlbHRhIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0aXR1dGUgPSBzdWJ0YWJsZS5zdWJzdGl0dXRlO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsgc3ViOiBnbHlwaHNbal0sIGJ5OiBzdWJzdGl0dXRlW2pdIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3Vic3RpdHV0aW9ucztcbn07XG5cbi8qKlxuICogTGlzdCBhbGwgbXVsdGlwbGUgc3Vic3RpdHV0aW9ucyAobG9va3VwIHR5cGUgMikgZm9yIGEgZ2l2ZW4gc2NyaXB0LCBsYW5ndWFnZSwgYW5kIGZlYXR1cmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1jaGFyYWN0ZXIgZmVhdHVyZSBuYW1lICgnY2NtcCcsICdzdGNoJylcbiAqIEByZXR1cm4ge0FycmF5fSBzdWJzdGl0dXRpb25zIC0gVGhlIGxpc3Qgb2Ygc3Vic3RpdHV0aW9ucy5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRNdWx0aXBsZSA9IGZ1bmN0aW9uIChmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIHN1YnN0aXR1dGlvbnMgPSBbXTtcbiAgICB2YXIgbG9va3VwVGFibGVzID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMik7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbG9va3VwVGFibGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgdmFyIHN1YnRhYmxlcyA9IGxvb2t1cFRhYmxlc1tpZHhdLnN1YnRhYmxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcbiAgICAgICAgICAgIHZhciBnbHlwaHMgPSB0aGlzLmV4cGFuZENvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICAgICAgICAgIHZhciBqID0gKHZvaWQgMCk7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbal07XG4gICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50cyA9IHN1YnRhYmxlLnNlcXVlbmNlc1tqXTtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goeyBzdWI6IGdseXBoLCBieTogcmVwbGFjZW1lbnRzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJzdGl0dXRpb25zO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBhbHRlcm5hdGVzIChsb29rdXAgdHlwZSAzKSBmb3IgYSBnaXZlbiBzY3JpcHQsIGxhbmd1YWdlLCBhbmQgZmVhdHVyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWNoYXJhY3RlciBmZWF0dXJlIG5hbWUgKCdhYWx0JywgJ3NhbHQnLi4uKVxuICogQHJldHVybiB7QXJyYXl9IGFsdGVybmF0ZXMgLSBUaGUgbGlzdCBvZiBhbHRlcm5hdGVzXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0QWx0ZXJuYXRlcyA9IGZ1bmN0aW9uIChmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIGFsdGVybmF0ZXMgPSBbXTtcbiAgICB2YXIgbG9va3VwVGFibGVzID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMyk7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbG9va3VwVGFibGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgdmFyIHN1YnRhYmxlcyA9IGxvb2t1cFRhYmxlc1tpZHhdLnN1YnRhYmxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcbiAgICAgICAgICAgIHZhciBnbHlwaHMgPSB0aGlzLmV4cGFuZENvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICAgICAgICAgIHZhciBhbHRlcm5hdGVTZXRzID0gc3VidGFibGUuYWx0ZXJuYXRlU2V0cztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRlcy5wdXNoKHsgc3ViOiBnbHlwaHNbal0sIGJ5OiBhbHRlcm5hdGVTZXRzW2pdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbHRlcm5hdGVzO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBsaWdhdHVyZXMgKGxvb2t1cCB0eXBlIDQpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuICogVGhlIHJlc3VsdCBpcyBhbiBhcnJheSBvZiBsaWdhdHVyZSBvYmplY3RzIGxpa2UgeyBzdWI6IFtpZHNdLCBieTogaWQgfVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqIEByZXR1cm4ge0FycmF5fSBsaWdhdHVyZXMgLSBUaGUgbGlzdCBvZiBsaWdhdHVyZXMuXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0TGlnYXR1cmVzID0gZnVuY3Rpb24gKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgbGlnYXR1cmVzID0gW107XG4gICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDQpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cFRhYmxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgICAgICAgICB2YXIgbGlnYXR1cmVTZXRzID0gc3VidGFibGUubGlnYXR1cmVTZXRzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRHbHlwaCA9IGdseXBoc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgbGlnU2V0ID0gbGlnYXR1cmVTZXRzW2pdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGlnU2V0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaWcgPSBsaWdTZXRba107XG4gICAgICAgICAgICAgICAgICAgIGxpZ2F0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YjogW3N0YXJ0R2x5cGhdLmNvbmNhdChsaWcuY29tcG9uZW50cyksXG4gICAgICAgICAgICAgICAgICAgICAgICBieTogbGlnLmxpZ0dseXBoLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpZ2F0dXJlcztcbn07XG5cbi8qKlxuICogQWRkIG9yIG1vZGlmeSBhIHNpbmdsZSBzdWJzdGl0dXRpb24gKGxvb2t1cCB0eXBlIDEpXG4gKiBGb3JtYXQgMiwgbW9yZSBmbGV4aWJsZSwgaXMgYWx3YXlzIHVzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2xpZ2EnLCAncmxpZycsICdkbGlnJy4uLilcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJzdGl0dXRpb24gLSB7IHN1YjogaWQsIGJ5OiBpZCB9IChmb3JtYXQgMSBpcyBub3Qgc3VwcG9ydGVkKVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkU2luZ2xlID0gZnVuY3Rpb24gKFxuICAgIGZlYXR1cmUsXG4gICAgc3Vic3RpdHV0aW9uLFxuICAgIHNjcmlwdCxcbiAgICBsYW5ndWFnZVxuKSB7XG4gICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoXG4gICAgICAgIHNjcmlwdCxcbiAgICAgICAgbGFuZ3VhZ2UsXG4gICAgICAgIGZlYXR1cmUsXG4gICAgICAgIDEsXG4gICAgICAgIHRydWVcbiAgICApWzBdO1xuICAgIHZhciBzdWJ0YWJsZSA9IGdldFN1YnN0Rm9ybWF0KGxvb2t1cFRhYmxlLCAyLCB7XG4gICAgICAgIC8vIGxvb2t1cCB0eXBlIDEgc3VidGFibGUsIGZvcm1hdCAyLCBjb3ZlcmFnZSBmb3JtYXQgMVxuICAgICAgICBzdWJzdEZvcm1hdDogMixcbiAgICAgICAgY292ZXJhZ2U6IHsgZm9ybWF0OiAxLCBnbHlwaHM6IFtdIH0sXG4gICAgICAgIHN1YnN0aXR1dGU6IFtdLFxuICAgIH0pO1xuICAgIGNoZWNrLmFzc2VydChcbiAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLFxuICAgICAgICAnU2luZ2xlOiB1bmFibGUgdG8gbW9kaWZ5IGNvdmVyYWdlIHRhYmxlIGZvcm1hdCAnICtcbiAgICAgICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdFxuICAgICk7XG4gICAgdmFyIGNvdmVyYWdlR2x5cGggPSBzdWJzdGl0dXRpb24uc3ViO1xuICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHBvcyA9IC0xIC0gcG9zO1xuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG4gICAgICAgIHN1YnRhYmxlLnN1YnN0aXR1dGUuc3BsaWNlKHBvcywgMCwgMCk7XG4gICAgfVxuICAgIHN1YnRhYmxlLnN1YnN0aXR1dGVbcG9zXSA9IHN1YnN0aXR1dGlvbi5ieTtcbn07XG5cbi8qKlxuICogQWRkIG9yIG1vZGlmeSBhIG11bHRpcGxlIHN1YnN0aXR1dGlvbiAobG9va3VwIHR5cGUgMilcbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnY2NtcCcsICdzdGNoJylcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJzdGl0dXRpb24gLSB7IHN1YjogaWQsIGJ5OiBbaWRdIH0gZm9yIGZvcm1hdCAyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkTXVsdGlwbGUgPSBmdW5jdGlvbiAoXG4gICAgZmVhdHVyZSxcbiAgICBzdWJzdGl0dXRpb24sXG4gICAgc2NyaXB0LFxuICAgIGxhbmd1YWdlXG4pIHtcbiAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgIHN1YnN0aXR1dGlvbi5ieSBpbnN0YW5jZW9mIEFycmF5ICYmIHN1YnN0aXR1dGlvbi5ieS5sZW5ndGggPiAxLFxuICAgICAgICAnTXVsdGlwbGU6IFwiYnlcIiBtdXN0IGJlIGFuIGFycmF5IG9mIHR3byBvciBtb3JlIGlkcydcbiAgICApO1xuICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKFxuICAgICAgICBzY3JpcHQsXG4gICAgICAgIGxhbmd1YWdlLFxuICAgICAgICBmZWF0dXJlLFxuICAgICAgICAyLFxuICAgICAgICB0cnVlXG4gICAgKVswXTtcbiAgICB2YXIgc3VidGFibGUgPSBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgMSwge1xuICAgICAgICAvLyBsb29rdXAgdHlwZSAyIHN1YnRhYmxlLCBmb3JtYXQgMSwgY292ZXJhZ2UgZm9ybWF0IDFcbiAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgIGNvdmVyYWdlOiB7IGZvcm1hdDogMSwgZ2x5cGhzOiBbXSB9LFxuICAgICAgICBzZXF1ZW5jZXM6IFtdLFxuICAgIH0pO1xuICAgIGNoZWNrLmFzc2VydChcbiAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLFxuICAgICAgICAnTXVsdGlwbGU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0ICcgK1xuICAgICAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0XG4gICAgKTtcbiAgICB2YXIgY292ZXJhZ2VHbHlwaCA9IHN1YnN0aXR1dGlvbi5zdWI7XG4gICAgdmFyIHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcG9zID0gLTEgLSBwb3M7XG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICAgc3VidGFibGUuc2VxdWVuY2VzLnNwbGljZShwb3MsIDAsIDApO1xuICAgIH1cbiAgICBzdWJ0YWJsZS5zZXF1ZW5jZXNbcG9zXSA9IHN1YnN0aXR1dGlvbi5ieTtcbn07XG5cbi8qKlxuICogQWRkIG9yIG1vZGlmeSBhbiBhbHRlcm5hdGUgc3Vic3RpdHV0aW9uIChsb29rdXAgdHlwZSAzKVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG4gKiBAcGFyYW0ge09iamVjdH0gc3Vic3RpdHV0aW9uIC0geyBzdWI6IGlkLCBieTogW2lkc10gfVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkQWx0ZXJuYXRlID0gZnVuY3Rpb24gKFxuICAgIGZlYXR1cmUsXG4gICAgc3Vic3RpdHV0aW9uLFxuICAgIHNjcmlwdCxcbiAgICBsYW5ndWFnZVxuKSB7XG4gICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoXG4gICAgICAgIHNjcmlwdCxcbiAgICAgICAgbGFuZ3VhZ2UsXG4gICAgICAgIGZlYXR1cmUsXG4gICAgICAgIDMsXG4gICAgICAgIHRydWVcbiAgICApWzBdO1xuICAgIHZhciBzdWJ0YWJsZSA9IGdldFN1YnN0Rm9ybWF0KGxvb2t1cFRhYmxlLCAxLCB7XG4gICAgICAgIC8vIGxvb2t1cCB0eXBlIDMgc3VidGFibGUsIGZvcm1hdCAxLCBjb3ZlcmFnZSBmb3JtYXQgMVxuICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgY292ZXJhZ2U6IHsgZm9ybWF0OiAxLCBnbHlwaHM6IFtdIH0sXG4gICAgICAgIGFsdGVybmF0ZVNldHM6IFtdLFxuICAgIH0pO1xuICAgIGNoZWNrLmFzc2VydChcbiAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLFxuICAgICAgICAnQWx0ZXJuYXRlOiB1bmFibGUgdG8gbW9kaWZ5IGNvdmVyYWdlIHRhYmxlIGZvcm1hdCAnICtcbiAgICAgICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdFxuICAgICk7XG4gICAgdmFyIGNvdmVyYWdlR2x5cGggPSBzdWJzdGl0dXRpb24uc3ViO1xuICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHBvcyA9IC0xIC0gcG9zO1xuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG4gICAgICAgIHN1YnRhYmxlLmFsdGVybmF0ZVNldHMuc3BsaWNlKHBvcywgMCwgMCk7XG4gICAgfVxuICAgIHN1YnRhYmxlLmFsdGVybmF0ZVNldHNbcG9zXSA9IHN1YnN0aXR1dGlvbi5ieTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlnYXR1cmUgKGxvb2t1cCB0eXBlIDQpXG4gKiBMaWdhdHVyZXMgd2l0aCBtb3JlIGNvbXBvbmVudHMgbXVzdCBiZSBzdG9yZWQgYWhlYWQgb2YgdGhvc2Ugd2l0aCBmZXdlciBjb21wb25lbnRzIGluIG9yZGVyIHRvIGJlIGZvdW5kXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2xpZ2EnLCAncmxpZycsICdkbGlnJy4uLilcbiAqIEBwYXJhbSB7T2JqZWN0fSBsaWdhdHVyZSAtIHsgc3ViOiBbaWRzXSwgYnk6IGlkIH1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZExpZ2F0dXJlID0gZnVuY3Rpb24gKFxuICAgIGZlYXR1cmUsXG4gICAgbGlnYXR1cmUsXG4gICAgc2NyaXB0LFxuICAgIGxhbmd1YWdlXG4pIHtcbiAgICB2YXIgbG9va3VwVGFibGUgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhcbiAgICAgICAgc2NyaXB0LFxuICAgICAgICBsYW5ndWFnZSxcbiAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgNCxcbiAgICAgICAgdHJ1ZVxuICAgIClbMF07XG4gICAgdmFyIHN1YnRhYmxlID0gbG9va3VwVGFibGUuc3VidGFibGVzWzBdO1xuICAgIGlmICghc3VidGFibGUpIHtcbiAgICAgICAgc3VidGFibGUgPSB7XG4gICAgICAgICAgICAvLyBsb29rdXAgdHlwZSA0IHN1YnRhYmxlLCBmb3JtYXQgMSwgY292ZXJhZ2UgZm9ybWF0IDFcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHsgZm9ybWF0OiAxLCBnbHlwaHM6IFtdIH0sXG4gICAgICAgICAgICBsaWdhdHVyZVNldHM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBsb29rdXBUYWJsZS5zdWJ0YWJsZXNbMF0gPSBzdWJ0YWJsZTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KFxuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsXG4gICAgICAgICdMaWdhdHVyZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArXG4gICAgICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXRcbiAgICApO1xuICAgIHZhciBjb3ZlcmFnZUdseXBoID0gbGlnYXR1cmUuc3ViWzBdO1xuICAgIHZhciBsaWdDb21wb25lbnRzID0gbGlnYXR1cmUuc3ViLnNsaWNlKDEpO1xuICAgIHZhciBsaWdhdHVyZVRhYmxlID0ge1xuICAgICAgICBsaWdHbHlwaDogbGlnYXR1cmUuYnksXG4gICAgICAgIGNvbXBvbmVudHM6IGxpZ0NvbXBvbmVudHMsXG4gICAgfTtcbiAgICB2YXIgcG9zID0gdGhpcy5iaW5TZWFyY2goc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLCBjb3ZlcmFnZUdseXBoKTtcbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgLy8gbGlnYXR1cmVTZXQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgdmFyIGxpZ2F0dXJlU2V0ID0gc3VidGFibGUubGlnYXR1cmVTZXRzW3Bvc107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlnYXR1cmVTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIElmIGxpZ2F0dXJlIGFscmVhZHkgZXhpc3RzLCByZXR1cm4uXG4gICAgICAgICAgICBpZiAoYXJyYXlzRXF1YWwobGlnYXR1cmVTZXRbaV0uY29tcG9uZW50cywgbGlnQ29tcG9uZW50cykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGlnYXR1cmUgZG9lcyBub3QgZXhpc3Q6IGFkZCBpdC5cbiAgICAgICAgbGlnYXR1cmVTZXQucHVzaChsaWdhdHVyZVRhYmxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbGlnYXR1cmVTZXQgYW5kIGFkZCBjb3ZlcmFnZSBmb3IgdGhlIGZpcnN0IGdseXBoLlxuICAgICAgICBwb3MgPSAtMSAtIHBvcztcbiAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLnNwbGljZShwb3MsIDAsIGNvdmVyYWdlR2x5cGgpO1xuICAgICAgICBzdWJ0YWJsZS5saWdhdHVyZVNldHMuc3BsaWNlKHBvcywgMCwgW2xpZ2F0dXJlVGFibGVdKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGZlYXR1cmUgZGF0YSBmb3IgYSBnaXZlbiBzY3JpcHQgYW5kIGxhbmd1YWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHJldHVybiB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgLSBUaGUgbGlzdCBvZiBzdWJzdGl0dXRpb25zLlxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldEZlYXR1cmUgPSBmdW5jdGlvbiAoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGlmICgvc3NcXGRcXGQvLnRlc3QoZmVhdHVyZSkpIHtcbiAgICAgICAgLy8gc3MwMSAtIHNzMjBcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2luZ2xlKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZlYXR1cmUpIHtcbiAgICAgICAgY2FzZSAnYWFsdCc6XG4gICAgICAgIGNhc2UgJ3NhbHQnOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2luZ2xlKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpLmNvbmNhdChcbiAgICAgICAgICAgICAgICB0aGlzLmdldEFsdGVybmF0ZXMoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgJ2RsaWcnOlxuICAgICAgICBjYXNlICdsaWdhJzpcbiAgICAgICAgY2FzZSAncmxpZyc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMaWdhdHVyZXMoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgICAgIGNhc2UgJ2NjbXAnOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TXVsdGlwbGUoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkuY29uY2F0KFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGlnYXR1cmVzKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpXG4gICAgICAgICAgICApO1xuICAgICAgICBjYXNlICdzdGNoJzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE11bHRpcGxlKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBBZGQgYSBzdWJzdGl0dXRpb24gdG8gYSBmZWF0dXJlIGZvciBhIGdpdmVuIHNjcmlwdCBhbmQgbGFuZ3VhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IHN1YiAtIHRoZSBzdWJzdGl0dXRpb24gdG8gYWRkIChhbiBvYmplY3QgbGlrZSB7IHN1YjogaWQgb3IgW2lkc10sIGJ5OiBpZCBvciBbaWRzXSB9KVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGlmICgvc3NcXGRcXGQvLnRlc3QoZmVhdHVyZSkpIHtcbiAgICAgICAgLy8gc3MwMSAtIHNzMjBcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU2luZ2xlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgfVxuICAgIHN3aXRjaCAoZmVhdHVyZSkge1xuICAgICAgICBjYXNlICdhYWx0JzpcbiAgICAgICAgY2FzZSAnc2FsdCc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1Yi5ieSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRTaW5nbGUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEFsdGVybmF0ZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgICAgICBjYXNlICdkbGlnJzpcbiAgICAgICAgY2FzZSAnbGlnYSc6XG4gICAgICAgIGNhc2UgJ3JsaWcnOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGlnYXR1cmUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICAgICAgY2FzZSAnY2NtcCc6XG4gICAgICAgICAgICBpZiAoc3ViLmJ5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRNdWx0aXBsZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGlnYXR1cmUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmZ1bmN0aW9uIGNoZWNrQXJndW1lbnQoZXhwcmVzc2lvbiwgbWVzc2FnZSkge1xuICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH1cbn1cblxuLy8gUGFyc2luZyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4vLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCBieXRlIGZyb20gdGhlIERhdGFWaWV3LlxuZnVuY3Rpb24gZ2V0Qnl0ZShkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCk7XG59XG5cbi8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIDE2LWJpdCBzaG9ydCBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmZ1bmN0aW9uIGdldFVTaG9ydChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQsIGZhbHNlKTtcbn1cblxuLy8gUmV0cmlldmUgYSBzaWduZWQgMTYtYml0IHNob3J0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZnVuY3Rpb24gZ2V0U2hvcnQoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGZhbHNlKTtcbn1cblxuLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgMzItYml0IGxvbmcgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5mdW5jdGlvbiBnZXRVTG9uZyhkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbn1cblxuLy8gUmV0cmlldmUgYSAzMi1iaXQgc2lnbmVkIGZpeGVkLXBvaW50IG51bWJlciAoMTYuMTYpIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZnVuY3Rpb24gZ2V0Rml4ZWQoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHZhciBkZWNpbWFsID0gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBmYWxzZSk7XG4gICAgdmFyIGZyYWN0aW9uID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDIsIGZhbHNlKTtcbiAgICByZXR1cm4gZGVjaW1hbCArIGZyYWN0aW9uIC8gNjU1MzU7XG59XG5cbi8vIFJldHJpZXZlIGEgNC1jaGFyYWN0ZXIgdGFnIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGFncyBhcmUgdXNlZCB0byBpZGVudGlmeSB0YWJsZXMuXG5mdW5jdGlvbiBnZXRUYWcoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHZhciB0YWcgPSAnJztcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNDsgaSArPSAxKSB7XG4gICAgICAgIHRhZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldEludDgoaSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0YWc7XG59XG5cbi8vIFJldHJpZXZlIGFuIG9mZnNldCBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIE9mZnNldHMgYXJlIDEgdG8gNCBieXRlcyBpbiBsZW5ndGgsIGRlcGVuZGluZyBvbiB0aGUgb2ZmU2l6ZSBhcmd1bWVudC5cbmZ1bmN0aW9uIGdldE9mZnNldChkYXRhVmlldywgb2Zmc2V0LCBvZmZTaXplKSB7XG4gICAgdmFyIHYgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2ZmU2l6ZTsgaSArPSAxKSB7XG4gICAgICAgIHYgPDw9IDg7XG4gICAgICAgIHYgKz0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG59XG5cbi8vIFJldHJpZXZlIGEgbnVtYmVyIG9mIGJ5dGVzIGZyb20gc3RhcnQgb2Zmc2V0IHRvIHRoZSBlbmQgb2Zmc2V0IGZyb20gdGhlIERhdGFWaWV3LlxuZnVuY3Rpb24gZ2V0Qnl0ZXMoZGF0YVZpZXcsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRPZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMSkge1xuICAgICAgICBieXRlcy5wdXNoKGRhdGFWaWV3LmdldFVpbnQ4KGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5cbi8vIENvbnZlcnQgdGhlIGxpc3Qgb2YgYnl0ZXMgdG8gYSBzdHJpbmcuXG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gICAgdmFyIHMgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHM7XG59XG5cbnZhciB0eXBlT2Zmc2V0cyA9IHtcbiAgICBieXRlOiAxLFxuICAgIHVTaG9ydDogMixcbiAgICBzaG9ydDogMixcbiAgICB1TG9uZzogNCxcbiAgICBmaXhlZDogNCxcbiAgICBsb25nRGF0ZVRpbWU6IDgsXG4gICAgdGFnOiA0XG59O1xuXG4vLyBBIHN0YXRlZnVsIHBhcnNlciB0aGF0IGNoYW5nZXMgdGhlIG9mZnNldCB3aGVuZXZlciBhIHZhbHVlIGlzIHJldHJpZXZlZC5cbi8vIFRoZSBkYXRhIGlzIGEgRGF0YVZpZXcuXG5mdW5jdGlvbiBQYXJzZXIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gMDtcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRVaW50OCh0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMTtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VDaGFyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMTtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VDYXJkOCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlO1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhcmQxNiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU0lEID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblBhcnNlci5wcm90b3R5cGUucGFyc2VPZmZzZXQxNiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTaG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUYyRG90MTQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpIC8gMTYzODQ7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBnZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDMyID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nO1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRml4ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IGdldEZpeGVkKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHN0cmluZyA9ICcnO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gbGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVGFnID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdHJpbmcoNCk7XG59O1xuXG4vLyBMT05HREFURVRJTUUgaXMgYSA2NC1iaXQgaW50ZWdlci5cbi8vIEphdmFTY3JpcHQgYW5kIHVuaXggdGltZXN0YW1wcyB0cmFkaXRpb25hbGx5IHVzZSAzMiBiaXRzLCBzbyB3ZVxuLy8gb25seSB0YWtlIHRoZSBsYXN0IDMyIGJpdHMuXG4vLyArIFNpbmNlIHVudGlsIDIwMzggdGhvc2UgYml0cyB3aWxsIGJlIGZpbGxlZCBieSB6ZXJvcyB3ZSBjYW4gaWdub3JlIHRoZW0uXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTG9uZ0RhdGVUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBnZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCArIDQpO1xuICAgIC8vIFN1YnRyYWN0IHNlY29uZHMgYmV0d2VlbiAwMS8wMS8xOTA0IGFuZCAwMS8wMS8xOTcwXG4gICAgLy8gdG8gY29udmVydCBBcHBsZSBNYWMgdGltZXN0YW1wIHRvIFN0YW5kYXJkIFVuaXggdGltZXN0YW1wXG4gICAgdiAtPSAyMDgyODQ0ODAwO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gODtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VWZXJzaW9uID0gZnVuY3Rpb24obWlub3JCYXNlKSB7XG4gICAgdmFyIG1ham9yID0gZ2V0VVNob3J0KHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcblxuICAgIC8vIEhvdyB0byBpbnRlcnByZXQgdGhlIG1pbm9yIHZlcnNpb24gaXMgdmVyeSB2YWd1ZSBpbiB0aGUgc3BlYy4gMHg1MDAwIGlzIDUsIDB4MTAwMCBpcyAxXG4gICAgLy8gRGVmYXVsdCByZXR1cm5zIHRoZSBjb3JyZWN0IG51bWJlciBpZiBtaW5vciA9IDB4TjAwMCB3aGVyZSBOIGlzIDAtOVxuICAgIC8vIFNldCBtaW5vckJhc2UgdG8gMSBmb3IgdGFibGVzIHRoYXQgdXNlIG1pbm9yID0gTiB3aGVyZSBOIGlzIDAtOVxuICAgIHZhciBtaW5vciA9IGdldFVTaG9ydCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCArIDIpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcbiAgICBpZiAobWlub3JCYXNlID09PSB1bmRlZmluZWQpIHsgbWlub3JCYXNlID0gMHgxMDAwOyB9XG4gICAgcmV0dXJuIG1ham9yICsgbWlub3IgLyBtaW5vckJhc2UgLyAxMDtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uKHR5cGUsIGFtb3VudCkge1xuICAgIGlmIChhbW91bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbW91bnQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gdHlwZU9mZnNldHNbdHlwZV0gKiBhbW91bnQ7XG59O1xuXG4vLy8vLyBQYXJzaW5nIGxpc3RzIGFuZCByZWNvcmRzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUGFyc2UgYSBsaXN0IG9mIDMyIGJpdCB1bnNpZ25lZCBpbnRlZ2Vycy5cblBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZ0xpc3QgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7IGNvdW50ID0gdGhpcy5wYXJzZVVMb25nKCk7IH1cbiAgICB2YXIgb2Zmc2V0cyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIG9mZnNldHNbaV0gPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuXG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudCAqIDQ7XG4gICAgcmV0dXJuIG9mZnNldHM7XG59O1xuXG4vLyBQYXJzZSBhIGxpc3Qgb2YgMTYgYml0IHVuc2lnbmVkIGludGVnZXJzLiBUaGUgbGVuZ3RoIG9mIHRoZSBsaXN0IGNhbiBiZSByZWFkIG9uIHRoZSBzdHJlYW1cbi8vIG9yIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50LlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDE2TGlzdCA9XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0TGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHsgY291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7IH1cbiAgICB2YXIgb2Zmc2V0cyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIG9mZnNldHNbaV0gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgfVxuXG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudCAqIDI7XG4gICAgcmV0dXJuIG9mZnNldHM7XG59O1xuXG4vLyBQYXJzZXMgYSBsaXN0IG9mIDE2IGJpdCBzaWduZWQgaW50ZWdlcnMuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU2hvcnRMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGxpc3RbaV0gPSBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50ICogMjtcbiAgICByZXR1cm4gbGlzdDtcbn07XG5cbi8vIFBhcnNlcyBhIGxpc3Qgb2YgYnl0ZXMuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZUxpc3QgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgbGlzdFtpXSA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCsrKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50O1xuICAgIHJldHVybiBsaXN0O1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGxpc3Qgb2YgaXRlbXMuXG4gKiBSZWNvcmQgY291bnQgaXMgb3B0aW9uYWwsIGlmIG9taXR0ZWQgaXQgaXMgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gKiBpdGVtQ2FsbGJhY2sgaXMgb25lIG9mIHRoZSBQYXJzZXIgbWV0aG9kcy5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpc3QgPSBmdW5jdGlvbihjb3VudCwgaXRlbUNhbGxiYWNrKSB7XG4gICAgaWYgKCFpdGVtQ2FsbGJhY2spIHtcbiAgICAgICAgaXRlbUNhbGxiYWNrID0gY291bnQ7XG4gICAgICAgIGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGxpc3RbaV0gPSBpdGVtQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTGlzdDMyID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuICAgIGlmICghaXRlbUNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZW1DYWxsYmFjayA9IGNvdW50O1xuICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVTG9uZygpO1xuICAgIH1cbiAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGxpc3RbaV0gPSBpdGVtQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiByZWNvcmRzLlxuICogUmVjb3JkIGNvdW50IGlzIG9wdGlvbmFsLCBpZiBvbWl0dGVkIGl0IGlzIHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICogRXhhbXBsZSBvZiByZWNvcmREZXNjcmlwdGlvbjogeyBzZXF1ZW5jZUluZGV4OiBQYXJzZXIudVNob3J0LCBsb29rdXBMaXN0SW5kZXg6IFBhcnNlci51U2hvcnQgfVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlUmVjb3JkTGlzdCA9IGZ1bmN0aW9uKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbikge1xuICAgIC8vIElmIHRoZSBjb3VudCBhcmd1bWVudCBpcyBhYnNlbnQsIHJlYWQgaXQgaW4gdGhlIHN0cmVhbS5cbiAgICBpZiAoIXJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJlY29yZERlc2NyaXB0aW9uID0gY291bnQ7XG4gICAgICAgIGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICB2YXIgcmVjb3JkcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKHJlY29yZERlc2NyaXB0aW9uKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHJlYyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcbiAgICAgICAgICAgIHZhciBmaWVsZFR5cGUgPSByZWNvcmREZXNjcmlwdGlvbltmaWVsZE5hbWVdO1xuICAgICAgICAgICAgcmVjW2ZpZWxkTmFtZV0gPSBmaWVsZFR5cGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZWNvcmRzW2ldID0gcmVjO1xuICAgIH1cbiAgICByZXR1cm4gcmVjb3Jkcztcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VSZWNvcmRMaXN0MzIgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICAvLyBJZiB0aGUgY291bnQgYXJndW1lbnQgaXMgYWJzZW50LCByZWFkIGl0IGluIHRoZSBzdHJlYW0uXG4gICAgaWYgKCFyZWNvcmREZXNjcmlwdGlvbikge1xuICAgICAgICByZWNvcmREZXNjcmlwdGlvbiA9IGNvdW50O1xuICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVTG9uZygpO1xuICAgIH1cbiAgICB2YXIgcmVjb3JkcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKHJlY29yZERlc2NyaXB0aW9uKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHJlYyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcbiAgICAgICAgICAgIHZhciBmaWVsZFR5cGUgPSByZWNvcmREZXNjcmlwdGlvbltmaWVsZE5hbWVdO1xuICAgICAgICAgICAgcmVjW2ZpZWxkTmFtZV0gPSBmaWVsZFR5cGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZWNvcmRzW2ldID0gcmVjO1xuICAgIH1cbiAgICByZXR1cm4gcmVjb3Jkcztcbn07XG5cbi8vIFBhcnNlIGEgZGF0YSBzdHJ1Y3R1cmUgaW50byBhbiBvYmplY3Rcbi8vIEV4YW1wbGUgb2YgZGVzY3JpcHRpb246IHsgc2VxdWVuY2VJbmRleDogUGFyc2VyLnVTaG9ydCwgbG9va3VwTGlzdEluZGV4OiBQYXJzZXIudVNob3J0IH1cblBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJ1Y3QgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uLmNhbGwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgdmFyIHN0cnVjdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcbiAgICAgICAgICAgIHZhciBmaWVsZFR5cGUgPSBkZXNjcmlwdGlvbltmaWVsZE5hbWVdO1xuICAgICAgICAgICAgc3RydWN0W2ZpZWxkTmFtZV0gPSBmaWVsZFR5cGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RydWN0O1xuICAgIH1cbn07XG5cbi8qKlxuICogUGFyc2UgYSBHUE9TIHZhbHVlUmVjb3JkXG4gKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3BvcyN2YWx1ZS1yZWNvcmRcbiAqIHZhbHVlRm9ybWF0IGlzIG9wdGlvbmFsLCBpZiBvbWl0dGVkIGl0IGlzIHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVmFsdWVSZWNvcmQgPSBmdW5jdGlvbih2YWx1ZUZvcm1hdCkge1xuICAgIGlmICh2YWx1ZUZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlRm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICBpZiAodmFsdWVGb3JtYXQgPT09IDApIHtcbiAgICAgICAgLy8gdmFsdWVGb3JtYXQyIGluIGtlcm5pbmcgcGFpcnMgaXMgbW9zdCBvZnRlbiAwXG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSByZXR1cm4gdW5kZWZpbmVkIGluc3RlYWQgb2YgYW4gZW1wdHkgb2JqZWN0LCB0byBzYXZlIHNwYWNlXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHZhbHVlUmVjb3JkID0ge307XG5cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMDEpIHsgdmFsdWVSZWNvcmQueFBsYWNlbWVudCA9IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDAyKSB7IHZhbHVlUmVjb3JkLnlQbGFjZW1lbnQgPSB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwNCkgeyB2YWx1ZVJlY29yZC54QWR2YW5jZSA9IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDA4KSB7IHZhbHVlUmVjb3JkLnlBZHZhbmNlID0gdGhpcy5wYXJzZVNob3J0KCk7IH1cblxuICAgIC8vIERldmljZSB0YWJsZSAobm9uLXZhcmlhYmxlIGZvbnQpIC8gVmFyaWF0aW9uSW5kZXggdGFibGUgKHZhcmlhYmxlIGZvbnQpIG5vdCBzdXBwb3J0ZWRcbiAgICAvLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9mci1mci90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvY2hhcHRlcjIjZGV2VmFySWR4VGJsc1xuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAxMCkgeyB2YWx1ZVJlY29yZC54UGxhRGV2aWNlID0gdW5kZWZpbmVkOyB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAyMCkgeyB2YWx1ZVJlY29yZC55UGxhRGV2aWNlID0gdW5kZWZpbmVkOyB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDA0MCkgeyB2YWx1ZVJlY29yZC54QWR2RGV2aWNlID0gdW5kZWZpbmVkOyB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDA4MCkgeyB2YWx1ZVJlY29yZC55QWR2RGV2aWNlID0gdW5kZWZpbmVkOyB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuXG4gICAgcmV0dXJuIHZhbHVlUmVjb3JkO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGxpc3Qgb2YgR1BPUyB2YWx1ZVJlY29yZHNcbiAqIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zI3ZhbHVlLXJlY29yZFxuICogdmFsdWVGb3JtYXQgYW5kIHZhbHVlQ291bnQgYXJlIHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVmFsdWVSZWNvcmRMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlRm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciB2YWx1ZUNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVDb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICAgICAgdmFsdWVzW2ldID0gdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VQb2ludGVyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgc3RydWN0T2Zmc2V0ID0gdGhpcy5wYXJzZU9mZnNldDE2KCk7XG4gICAgaWYgKHN0cnVjdE9mZnNldCA+IDApIHtcbiAgICAgICAgLy8gTlVMTCBvZmZzZXQgPT4gcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcih0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgc3RydWN0T2Zmc2V0KS5wYXJzZVN0cnVjdChkZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlUG9pbnRlcjMyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgc3RydWN0T2Zmc2V0ID0gdGhpcy5wYXJzZU9mZnNldDMyKCk7XG4gICAgaWYgKHN0cnVjdE9mZnNldCA+IDApIHtcbiAgICAgICAgLy8gTlVMTCBvZmZzZXQgPT4gcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcih0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgc3RydWN0T2Zmc2V0KS5wYXJzZVN0cnVjdChkZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBvZmZzZXRzIHRvIGxpc3RzIG9mIDE2LWJpdCBpbnRlZ2VycyxcbiAqIG9yIGEgbGlzdCBvZiBvZmZzZXRzIHRvIGxpc3RzIG9mIG9mZnNldHMgdG8gYW55IGtpbmQgb2YgaXRlbXMuXG4gKiBJZiBpdGVtQ2FsbGJhY2sgaXMgbm90IHByb3ZpZGVkLCBhIGxpc3Qgb2YgbGlzdCBvZiBVU2hvcnQgaXMgYXNzdW1lZC5cbiAqIElmIHByb3ZpZGVkLCBpdGVtQ2FsbGJhY2sgaXMgY2FsbGVkIG9uIGVhY2ggaXRlbSBhbmQgbXVzdCBwYXJzZSB0aGUgaXRlbS5cbiAqIFNlZSBleGFtcGxlcyBpbiB0YWJsZXMvZ3N1Yi5qc1xuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTGlzdE9mTGlzdHMgPSBmdW5jdGlvbihpdGVtQ2FsbGJhY2spIHtcbiAgICB2YXIgb2Zmc2V0cyA9IHRoaXMucGFyc2VPZmZzZXQxNkxpc3QoKTtcbiAgICB2YXIgY291bnQgPSBvZmZzZXRzLmxlbmd0aDtcbiAgICB2YXIgcmVsYXRpdmVPZmZzZXQgPSB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0c1tpXTtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBOVUxMIG9mZnNldFxuICAgICAgICAgICAgLy8gQWRkIGkgYXMgb3duZWQgcHJvcGVydHkgdG8gbGlzdC4gQ29udmVuaWVudCB3aXRoIGFzc2VydC5cbiAgICAgICAgICAgIGxpc3RbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGlmIChpdGVtQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBzdWJPZmZzZXRzID0gdGhpcy5wYXJzZU9mZnNldDE2TGlzdCgpO1xuICAgICAgICAgICAgdmFyIHN1Ykxpc3QgPSBuZXcgQXJyYXkoc3ViT2Zmc2V0cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWJPZmZzZXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IHN0YXJ0ICsgc3ViT2Zmc2V0c1tqXTtcbiAgICAgICAgICAgICAgICBzdWJMaXN0W2pdID0gaXRlbUNhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0W2ldID0gc3ViTGlzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RbaV0gPSB0aGlzLnBhcnNlVVNob3J0TGlzdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSByZWxhdGl2ZU9mZnNldDtcbiAgICByZXR1cm4gbGlzdDtcbn07XG5cbi8vLy8vIENvbXBsZXggdGFibGVzIHBhcnNpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBQYXJzZSBhIGNvdmVyYWdlIHRhYmxlIGluIGEgR1NVQiwgR1BPUyBvciBHREVGIHRhYmxlLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFwdGVyMi5odG1cbi8vIHBhcnNlci5vZmZzZXQgbXVzdCBwb2ludCB0byB0aGUgc3RhcnQgb2YgdGhlIHRhYmxlIGNvbnRhaW5pbmcgdGhlIGNvdmVyYWdlLlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvdmVyYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogMSxcbiAgICAgICAgICAgIGdseXBoczogdGhpcy5wYXJzZVVTaG9ydExpc3QoY291bnQpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgcmFuZ2VzW2ldID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgZW5kOiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMucGFyc2VVU2hvcnQoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAyLFxuICAgICAgICAgICAgcmFuZ2VzOiByYW5nZXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCcweCcgKyBzdGFydE9mZnNldC50b1N0cmluZygxNikgKyAnOiBDb3ZlcmFnZSBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG59O1xuXG4vLyBQYXJzZSBhIENsYXNzIERlZmluaXRpb24gVGFibGUgaW4gYSBHU1VCLCBHUE9TIG9yIEdERUYgdGFibGUuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXB0ZXIyLmh0bVxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRGVmID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAxLFxuICAgICAgICAgICAgc3RhcnRHbHlwaDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgY2xhc3NlczogdGhpcy5wYXJzZVVTaG9ydExpc3QoKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6IDIsXG4gICAgICAgICAgICByYW5nZXM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KHtcbiAgICAgICAgICAgICAgICBzdGFydDogUGFyc2VyLnVTaG9ydCxcbiAgICAgICAgICAgICAgICBlbmQ6IFBhcnNlci51U2hvcnQsXG4gICAgICAgICAgICAgICAgY2xhc3NJZDogUGFyc2VyLnVTaG9ydFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCcweCcgKyBzdGFydE9mZnNldC50b1N0cmluZygxNikgKyAnOiBDbGFzc0RlZiBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG59O1xuXG4vLy8vLyBTdGF0aWMgbWV0aG9kcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVGhlc2UgY29udmVuaWVuY2UgbWV0aG9kcyBjYW4gYmUgdXNlZCBhcyBjYWxsYmFja3MgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBcInRoaXNcIiBjb250ZXh0IHNldCB0byBhIFBhcnNlciBpbnN0YW5jZS5cblxuUGFyc2VyLmxpc3QgPSBmdW5jdGlvbihjb3VudCwgaXRlbUNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QoY291bnQsIGl0ZW1DYWxsYmFjayk7XG4gICAgfTtcbn07XG5cblBhcnNlci5saXN0MzIgPSBmdW5jdGlvbihjb3VudCwgaXRlbUNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QzMihjb3VudCwgaXRlbUNhbGxiYWNrKTtcbiAgICB9O1xufTtcblxuUGFyc2VyLnJlY29yZExpc3QgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmVjb3JkTGlzdChjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pO1xuICAgIH07XG59O1xuXG5QYXJzZXIucmVjb3JkTGlzdDMyID0gZnVuY3Rpb24oY291bnQsIHJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJlY29yZExpc3QzMihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pO1xuICAgIH07XG59O1xuXG5QYXJzZXIucG9pbnRlciA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoZGVzY3JpcHRpb24pO1xuICAgIH07XG59O1xuXG5QYXJzZXIucG9pbnRlcjMyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcjMyKGRlc2NyaXB0aW9uKTtcbiAgICB9O1xufTtcblxuUGFyc2VyLnRhZyA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VUYWc7XG5QYXJzZXIuYnl0ZSA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlO1xuUGFyc2VyLnVTaG9ydCA9IFBhcnNlci5vZmZzZXQxNiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5QYXJzZXIudVNob3J0TGlzdCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnRMaXN0O1xuUGFyc2VyLnVMb25nID0gUGFyc2VyLm9mZnNldDMyID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nO1xuUGFyc2VyLnVMb25nTGlzdCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZ0xpc3Q7XG5QYXJzZXIuc3RydWN0ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cnVjdDtcblBhcnNlci5jb3ZlcmFnZSA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VDb3ZlcmFnZTtcblBhcnNlci5jbGFzc0RlZiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0RlZjtcblxuLy8vLy8gU2NyaXB0LCBGZWF0dXJlLCBMb29rdXAgbGlzdHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcHRlcjIuaHRtXG5cbnZhciBsYW5nU3lzVGFibGUgPSB7XG4gICAgcmVzZXJ2ZWQ6IFBhcnNlci51U2hvcnQsXG4gICAgcmVxRmVhdHVyZUluZGV4OiBQYXJzZXIudVNob3J0LFxuICAgIGZlYXR1cmVJbmRleGVzOiBQYXJzZXIudVNob3J0TGlzdFxufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNjcmlwdExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLnJlY29yZExpc3Qoe1xuICAgICAgICB0YWc6IFBhcnNlci50YWcsXG4gICAgICAgIHNjcmlwdDogUGFyc2VyLnBvaW50ZXIoe1xuICAgICAgICAgICAgZGVmYXVsdExhbmdTeXM6IFBhcnNlci5wb2ludGVyKGxhbmdTeXNUYWJsZSksXG4gICAgICAgICAgICBsYW5nU3lzUmVjb3JkczogUGFyc2VyLnJlY29yZExpc3Qoe1xuICAgICAgICAgICAgICAgIHRhZzogUGFyc2VyLnRhZyxcbiAgICAgICAgICAgICAgICBsYW5nU3lzOiBQYXJzZXIucG9pbnRlcihsYW5nU3lzVGFibGUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH0pKSB8fCBbXTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGZWF0dXJlTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIucmVjb3JkTGlzdCh7XG4gICAgICAgIHRhZzogUGFyc2VyLnRhZyxcbiAgICAgICAgZmVhdHVyZTogUGFyc2VyLnBvaW50ZXIoe1xuICAgICAgICAgICAgZmVhdHVyZVBhcmFtczogUGFyc2VyLm9mZnNldDE2LFxuICAgICAgICAgICAgbG9va3VwTGlzdEluZGV4ZXM6IFBhcnNlci51U2hvcnRMaXN0XG4gICAgICAgIH0pXG4gICAgfSkpIHx8IFtdO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxvb2t1cExpc3QgPSBmdW5jdGlvbihsb29rdXBUYWJsZVBhcnNlcnMpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmxpc3QoUGFyc2VyLnBvaW50ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsb29rdXBUeXBlID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBjaGVjay5hcmd1bWVudCgxIDw9IGxvb2t1cFR5cGUgJiYgbG9va3VwVHlwZSA8PSA5LCAnR1BPUy9HU1VCIGxvb2t1cCB0eXBlICcgKyBsb29rdXBUeXBlICsgJyB1bmtub3duLicpO1xuICAgICAgICB2YXIgbG9va3VwRmxhZyA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHVzZU1hcmtGaWx0ZXJpbmdTZXQgPSBsb29rdXBGbGFnICYgMHgxMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvb2t1cFR5cGU6IGxvb2t1cFR5cGUsXG4gICAgICAgICAgICBsb29rdXBGbGFnOiBsb29rdXBGbGFnLFxuICAgICAgICAgICAgc3VidGFibGVzOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihsb29rdXBUYWJsZVBhcnNlcnNbbG9va3VwVHlwZV0pKSxcbiAgICAgICAgICAgIG1hcmtGaWx0ZXJpbmdTZXQ6IHVzZU1hcmtGaWx0ZXJpbmdTZXQgPyB0aGlzLnBhcnNlVVNob3J0KCkgOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9KSkpIHx8IFtdO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZlYXR1cmVWYXJpYXRpb25zTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcjMyKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWFqb3JWZXJzaW9uID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgbWlub3JWZXJzaW9uID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBjaGVjay5hcmd1bWVudChtYWpvclZlcnNpb24gPT09IDEgJiYgbWlub3JWZXJzaW9uIDwgMSwgJ0dQT1MvR1NVQiBmZWF0dXJlIHZhcmlhdGlvbnMgdGFibGUgdW5rbm93bi4nKTtcbiAgICAgICAgdmFyIGZlYXR1cmVWYXJpYXRpb25zID0gdGhpcy5wYXJzZVJlY29yZExpc3QzMih7XG4gICAgICAgICAgICBjb25kaXRpb25TZXRPZmZzZXQ6IFBhcnNlci5vZmZzZXQzMixcbiAgICAgICAgICAgIGZlYXR1cmVUYWJsZVN1YnN0aXR1dGlvbk9mZnNldDogUGFyc2VyLm9mZnNldDMyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmVhdHVyZVZhcmlhdGlvbnM7XG4gICAgfSkgfHwgW107XG59O1xuXG52YXIgcGFyc2UgPSB7XG4gICAgZ2V0Qnl0ZTogZ2V0Qnl0ZSxcbiAgICBnZXRDYXJkODogZ2V0Qnl0ZSxcbiAgICBnZXRVU2hvcnQ6IGdldFVTaG9ydCxcbiAgICBnZXRDYXJkMTY6IGdldFVTaG9ydCxcbiAgICBnZXRTaG9ydDogZ2V0U2hvcnQsXG4gICAgZ2V0VUxvbmc6IGdldFVMb25nLFxuICAgIGdldEZpeGVkOiBnZXRGaXhlZCxcbiAgICBnZXRUYWc6IGdldFRhZyxcbiAgICBnZXRPZmZzZXQ6IGdldE9mZnNldCxcbiAgICBnZXRCeXRlczogZ2V0Qnl0ZXMsXG4gICAgYnl0ZXNUb1N0cmluZzogYnl0ZXNUb1N0cmluZyxcbiAgICBQYXJzZXI6IFBhcnNlcixcbn07XG5cbi8vIFRoZSBgZ2x5ZmAgdGFibGUgZGVzY3JpYmVzIHRoZSBnbHlwaHMgaW4gVHJ1ZVR5cGUgb3V0bGluZSBmb3JtYXQuXG5cbi8vIFBhcnNlIHRoZSBjb29yZGluYXRlIGRhdGEgZm9yIGEgZ2x5cGguXG5mdW5jdGlvbiBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBwcmV2aW91c1ZhbHVlLCBzaG9ydFZlY3RvckJpdE1hc2ssIHNhbWVCaXRNYXNrKSB7XG4gICAgdmFyIHY7XG4gICAgaWYgKChmbGFnICYgc2hvcnRWZWN0b3JCaXRNYXNrKSA+IDApIHtcbiAgICAgICAgLy8gVGhlIGNvb3JkaW5hdGUgaXMgMSBieXRlIGxvbmcuXG4gICAgICAgIHYgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAvLyBUaGUgYHNhbWVgIGJpdCBpcyByZS11c2VkIGZvciBzaG9ydCB2YWx1ZXMgdG8gc2lnbmlmeSB0aGUgc2lnbiBvZiB0aGUgdmFsdWUuXG4gICAgICAgIGlmICgoZmxhZyAmIHNhbWVCaXRNYXNrKSA9PT0gMCkge1xuICAgICAgICAgICAgdiA9IC12O1xuICAgICAgICB9XG5cbiAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyB2O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICBUaGUgY29vcmRpbmF0ZSBpcyAyIGJ5dGVzIGxvbmcuXG4gICAgICAgIC8vIElmIHRoZSBgc2FtZWAgYml0IGlzIHNldCwgdGhlIGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIGNvb3JkaW5hdGUuXG4gICAgICAgIGlmICgoZmxhZyAmIHNhbWVCaXRNYXNrKSA+IDApIHtcbiAgICAgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgYXMgYSBzaWduZWQgMTYtYml0IGRlbHRhIHZhbHVlLlxuICAgICAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2O1xufVxuXG4vLyBQYXJzZSBhIFRydWVUeXBlIGdseXBoLlxuZnVuY3Rpb24gcGFyc2VHbHlwaChnbHlwaCwgZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGdseXBoLm51bWJlck9mQ29udG91cnMgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC5feE1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLl95TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGguX3hNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC5feU1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHZhciBmbGFncztcbiAgICB2YXIgZmxhZztcblxuICAgIGlmIChnbHlwaC5udW1iZXJPZkNvbnRvdXJzID4gMCkge1xuICAgICAgICAvLyBUaGlzIGdseXBoIGlzIG5vdCBhIGNvbXBvc2l0ZS5cbiAgICAgICAgdmFyIGVuZFBvaW50SW5kaWNlcyA9IGdseXBoLmVuZFBvaW50SW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBoLm51bWJlck9mQ29udG91cnM7IGkgKz0gMSkge1xuICAgICAgICAgICAgZW5kUG9pbnRJbmRpY2VzLnB1c2gocC5wYXJzZVVTaG9ydCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBoLmluc3RydWN0aW9uTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgZ2x5cGguaW5zdHJ1Y3Rpb25MZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMucHVzaChwLnBhcnNlQnl0ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBudW1iZXJPZkNvb3JkaW5hdGVzID0gZW5kUG9pbnRJbmRpY2VzW2VuZFBvaW50SW5kaWNlcy5sZW5ndGggLSAxXSArIDE7XG4gICAgICAgIGZsYWdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkkMiArPSAxKSB7XG4gICAgICAgICAgICBmbGFnID0gcC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICAgICAgICAvLyBJZiBiaXQgMyBpcyBzZXQsIHdlIHJlcGVhdCB0aGlzIGZsYWcgbiB0aW1lcywgd2hlcmUgbiBpcyB0aGUgbmV4dCBieXRlLlxuICAgICAgICAgICAgaWYgKChmbGFnICYgOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcGVhdENvdW50ID0gcC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcGVhdENvdW50OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MucHVzaChmbGFnKTtcbiAgICAgICAgICAgICAgICAgICAgaSQyICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2suYXJndW1lbnQoZmxhZ3MubGVuZ3RoID09PSBudW1iZXJPZkNvb3JkaW5hdGVzLCAnQmFkIGZsYWdzLicpO1xuXG4gICAgICAgIGlmIChlbmRQb2ludEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIHBvaW50O1xuICAgICAgICAgICAgLy8gWC9ZIGNvb3JkaW5hdGVzIGFyZSByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgcG9pbnQsIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IHBvaW50IHdoaWNoIGlzIHJlbGF0aXZlIHRvIDAsMC5cbiAgICAgICAgICAgIGlmIChudW1iZXJPZkNvb3JkaW5hdGVzID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkkMyArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpJDNdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBwb2ludC5vbkN1cnZlID0gISEoZmxhZyAmIDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludC5sYXN0UG9pbnRPZkNvbnRvdXIgPSBlbmRQb2ludEluZGljZXMuaW5kZXhPZihpJDMpID49IDA7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkNCA9IDA7IGkkNCA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkkNCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpJDRdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHBvaW50c1tpJDRdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludC54ID0gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHgsIDIsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgcHggPSBwb2ludC54O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBweSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQ1ID0gMDsgaSQ1IDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSQ1ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2kkNV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2kkNV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnkgPSBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBweSwgNCwgMzIpO1xuICAgICAgICAgICAgICAgICAgICBweSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBbXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ2x5cGgubnVtYmVyT2ZDb250b3VycyA9PT0gMCkge1xuICAgICAgICBnbHlwaC5wb2ludHMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbHlwaC5pc0NvbXBvc2l0ZSA9IHRydWU7XG4gICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgICAgICBnbHlwaC5jb21wb25lbnRzID0gW107XG4gICAgICAgIHZhciBtb3JlQ29tcG9uZW50cyA9IHRydWU7XG4gICAgICAgIHdoaWxlIChtb3JlQ29tcG9uZW50cykge1xuICAgICAgICAgICAgZmxhZ3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0ge1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXg6IHAucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICB4U2NhbGU6IDEsXG4gICAgICAgICAgICAgICAgc2NhbGUwMTogMCxcbiAgICAgICAgICAgICAgICBzY2FsZTEwOiAwLFxuICAgICAgICAgICAgICAgIHlTY2FsZTogMSxcbiAgICAgICAgICAgICAgICBkeDogMCxcbiAgICAgICAgICAgICAgICBkeTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYXJndW1lbnRzIGFyZSB3b3Jkc1xuICAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAyKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgbWF0Y2hlZCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm1hdGNoZWRQb2ludHMgPSBbcC5wYXJzZVVTaG9ydCgpLCBwLnBhcnNlVVNob3J0KCldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYXJndW1lbnRzIGFyZSBieXRlc1xuICAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAyKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR4ID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR5ID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG1hdGNoZWQgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzID0gW3AucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChmbGFncyAmIDgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBzY2FsZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgNjQpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYW4gWCAvIFkgc2NhbGVcbiAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgMTI4KSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgMngyIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnNjYWxlMDEgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zY2FsZTEwID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2x5cGguY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICBtb3JlQ29tcG9uZW50cyA9ICEhKGZsYWdzICYgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncyAmIDB4MTAwKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGluc3RydWN0aW9uc1xuICAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25MZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkNiA9IDA7IGkkNiA8IGdseXBoLmluc3RydWN0aW9uTGVuZ3RoOyBpJDYgKz0gMSkge1xuICAgICAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucy5wdXNoKHAucGFyc2VCeXRlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBUcmFuc2Zvcm0gYW4gYXJyYXkgb2YgcG9pbnRzIGFuZCByZXR1cm4gYSBuZXcgYXJyYXkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludHMocG9pbnRzLCB0cmFuc2Zvcm0pIHtcbiAgICB2YXIgbmV3UG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgICAgICB2YXIgbmV3UHQgPSB7XG4gICAgICAgICAgICB4OiB0cmFuc2Zvcm0ueFNjYWxlICogcHQueCArIHRyYW5zZm9ybS5zY2FsZTAxICogcHQueSArIHRyYW5zZm9ybS5keCxcbiAgICAgICAgICAgIHk6IHRyYW5zZm9ybS5zY2FsZTEwICogcHQueCArIHRyYW5zZm9ybS55U2NhbGUgKiBwdC55ICsgdHJhbnNmb3JtLmR5LFxuICAgICAgICAgICAgb25DdXJ2ZTogcHQub25DdXJ2ZSxcbiAgICAgICAgICAgIGxhc3RQb2ludE9mQ29udG91cjogcHQubGFzdFBvaW50T2ZDb250b3VyXG4gICAgICAgIH07XG4gICAgICAgIG5ld1BvaW50cy5wdXNoKG5ld1B0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuXG5mdW5jdGlvbiBnZXRDb250b3Vycyhwb2ludHMpIHtcbiAgICB2YXIgY29udG91cnMgPSBbXTtcbiAgICB2YXIgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgICAgIGN1cnJlbnRDb250b3VyLnB1c2gocHQpO1xuICAgICAgICBpZiAocHQubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICBjb250b3Vycy5wdXNoKGN1cnJlbnRDb250b3VyKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59XG5cbi8vIENvbnZlcnQgdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmUgdG8gYSBQYXRoLlxuZnVuY3Rpb24gZ2V0UGF0aChwb2ludHMpIHtcbiAgICB2YXIgcCA9IG5ldyBQYXRoKCk7XG4gICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRvdXJzID0gZ2V0Q29udG91cnMocG9pbnRzKTtcblxuICAgIGZvciAodmFyIGNvbnRvdXJJbmRleCA9IDA7IGNvbnRvdXJJbmRleCA8IGNvbnRvdXJzLmxlbmd0aDsgKytjb250b3VySW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbnRvdXIgPSBjb250b3Vyc1tjb250b3VySW5kZXhdO1xuXG4gICAgICAgIHZhciBwcmV2ID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnIgPSBjb250b3VyW2NvbnRvdXIubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBuZXh0ID0gY29udG91clswXTtcblxuICAgICAgICBpZiAoY3Vyci5vbkN1cnZlKSB7XG4gICAgICAgICAgICBwLm1vdmVUbyhjdXJyLngsIGN1cnIueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobmV4dC5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgcC5tb3ZlVG8obmV4dC54LCBuZXh0LnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBib3RoIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgb2ZmLWN1cnZlLCBzdGFydCBhdCB0aGVpciBtaWRkbGUuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0ge3g6IChjdXJyLnggKyBuZXh0LngpICogMC41LCB5OiAoY3Vyci55ICsgbmV4dC55KSAqIDAuNX07XG4gICAgICAgICAgICAgICAgcC5tb3ZlVG8oc3RhcnQueCwgc3RhcnQueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRvdXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHByZXYgPSBjdXJyO1xuICAgICAgICAgICAgY3VyciA9IG5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gY29udG91clsoaSArIDEpICUgY29udG91ci5sZW5ndGhdO1xuXG4gICAgICAgICAgICBpZiAoY3Vyci5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHN0cmFpZ2h0IGxpbmUuXG4gICAgICAgICAgICAgICAgcC5saW5lVG8oY3Vyci54LCBjdXJyLnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldjIgPSBwcmV2O1xuICAgICAgICAgICAgICAgIHZhciBuZXh0MiA9IG5leHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXByZXYub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2MiA9IHsgeDogKGN1cnIueCArIHByZXYueCkgKiAwLjUsIHk6IChjdXJyLnkgKyBwcmV2LnkpICogMC41IH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dDIgPSB7IHg6IChjdXJyLnggKyBuZXh0LngpICogMC41LCB5OiAoY3Vyci55ICsgbmV4dC55KSAqIDAuNSB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyhjdXJyLngsIGN1cnIueSwgbmV4dDIueCwgbmV4dDIueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gYnVpbGRQYXRoKGdseXBocywgZ2x5cGgpIHtcbiAgICBpZiAoZ2x5cGguaXNDb21wb3NpdGUpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaC5jb21wb25lbnRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gZ2x5cGguY29tcG9uZW50c1tqXTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRHbHlwaCA9IGdseXBocy5nZXQoY29tcG9uZW50LmdseXBoSW5kZXgpO1xuICAgICAgICAgICAgLy8gRm9yY2UgdGhlIHR0ZkdseXBoTG9hZGVyIHRvIHBhcnNlIHRoZSBnbHlwaC5cbiAgICAgICAgICAgIGNvbXBvbmVudEdseXBoLmdldFBhdGgoKTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRHbHlwaC5wb2ludHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSAodm9pZCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50Lm1hdGNoZWRQb2ludHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgcG9zaXRpb25lZCBieSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQb2ludHMgPSB0cmFuc2Zvcm1Qb2ludHMoY29tcG9uZW50R2x5cGgucG9pbnRzLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBwb3NpdGlvbmVkIGJ5IG1hdGNoZWQgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmICgoY29tcG9uZW50Lm1hdGNoZWRQb2ludHNbMF0gPiBnbHlwaC5wb2ludHMubGVuZ3RoIC0gMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb21wb25lbnQubWF0Y2hlZFBvaW50c1sxXSA+IGNvbXBvbmVudEdseXBoLnBvaW50cy5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ01hdGNoZWQgcG9pbnRzIG91dCBvZiByYW5nZSBpbiAnICsgZ2x5cGgubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0UHQgPSBnbHlwaC5wb2ludHNbY29tcG9uZW50Lm1hdGNoZWRQb2ludHNbMF1dO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kUHQgPSBjb21wb25lbnRHbHlwaC5wb2ludHNbY29tcG9uZW50Lm1hdGNoZWRQb2ludHNbMV1dO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeFNjYWxlOiBjb21wb25lbnQueFNjYWxlLCBzY2FsZTAxOiBjb21wb25lbnQuc2NhbGUwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlMTA6IGNvbXBvbmVudC5zY2FsZTEwLCB5U2NhbGU6IGNvbXBvbmVudC55U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkeDogMCwgZHk6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kUHQgPSB0cmFuc2Zvcm1Qb2ludHMoW3NlY29uZFB0XSwgdHJhbnNmb3JtKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmR4ID0gZmlyc3RQdC54IC0gc2Vjb25kUHQueDtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmR5ID0gZmlyc3RQdC55IC0gc2Vjb25kUHQueTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQb2ludHMgPSB0cmFuc2Zvcm1Qb2ludHMoY29tcG9uZW50R2x5cGgucG9pbnRzLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBnbHlwaC5wb2ludHMuY29uY2F0KHRyYW5zZm9ybWVkUG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnZXRQYXRoKGdseXBoLnBvaW50cyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlR2x5ZlRhYmxlQWxsKGRhdGEsIHN0YXJ0LCBsb2NhLCBmb250KSB7XG4gICAgdmFyIGdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldChmb250KTtcblxuICAgIC8vIFRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxvY2EgdGFibGUgaXMgaW52YWxpZC5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY2EubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBsb2NhW2ldO1xuICAgICAgICB2YXIgbmV4dE9mZnNldCA9IGxvY2FbaSArIDFdO1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSBuZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChpLCBnbHlwaHNldC50dGZHbHlwaExvYWRlcihmb250LCBpLCBwYXJzZUdseXBoLCBkYXRhLCBzdGFydCArIG9mZnNldCwgYnVpbGRQYXRoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChpLCBnbHlwaHNldC5nbHlwaExvYWRlcihmb250LCBpKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGhzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUdseWZUYWJsZU9uTG93TWVtb3J5KGRhdGEsIHN0YXJ0LCBsb2NhLCBmb250KSB7XG4gICAgdmFyIGdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldChmb250KTtcblxuICAgIGZvbnQuX3B1c2ggPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBsb2NhW2ldO1xuICAgICAgICB2YXIgbmV4dE9mZnNldCA9IGxvY2FbaSArIDFdO1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSBuZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChpLCBnbHlwaHNldC50dGZHbHlwaExvYWRlcihmb250LCBpLCBwYXJzZUdseXBoLCBkYXRhLCBzdGFydCArIG9mZnNldCwgYnVpbGRQYXRoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChpLCBnbHlwaHNldC5nbHlwaExvYWRlcihmb250LCBpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGdseXBocztcbn1cblxuLy8gUGFyc2UgYWxsIHRoZSBnbHlwaHMgYWNjb3JkaW5nIHRvIHRoZSBvZmZzZXRzIGZyb20gdGhlIGBsb2NhYCB0YWJsZS5cbmZ1bmN0aW9uIHBhcnNlR2x5ZlRhYmxlKGRhdGEsIHN0YXJ0LCBsb2NhLCBmb250LCBvcHQpIHtcbiAgICBpZiAob3B0Lmxvd01lbW9yeSlcbiAgICAgICAgeyByZXR1cm4gcGFyc2VHbHlmVGFibGVPbkxvd01lbW9yeShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCk7IH1cbiAgICBlbHNlXG4gICAgICAgIHsgcmV0dXJuIHBhcnNlR2x5ZlRhYmxlQWxsKGRhdGEsIHN0YXJ0LCBsb2NhLCBmb250KTsgfVxufVxuXG52YXIgZ2x5ZiA9IHsgZ2V0UGF0aDogZ2V0UGF0aCwgcGFyc2U6IHBhcnNlR2x5ZlRhYmxlfTtcblxuLyogQSBUcnVlVHlwZSBmb250IGhpbnRpbmcgaW50ZXJwcmV0ZXIuXG4qXG4qIChjKSAyMDE3IEF4ZWwgS2l0dGVuYmVyZ2VyXG4qXG4qIFRoaXMgaW50ZXJwcmV0ZXIgaGFzIGJlZW4gaW1wbGVtZW50ZWQgYWNjb3JkaW5nIHRvIHRoaXMgZG9jdW1lbnRhdGlvbjpcbiogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvbnRzL1RydWVUeXBlLVJlZmVyZW5jZS1NYW51YWwvUk0wNS9DaGFwNS5odG1sXG4qXG4qIEFjY29yZGluZyB0byB0aGUgZG9jdW1lbnRhdGlvbiBGMjRET1Q2IHZhbHVlcyBhcmUgdXNlZCBmb3IgcGl4ZWxzLlxuKiBUaGF0IG1lYW5zIGNhbGN1bGF0aW9uIGlzIDEvNjQgcGl4ZWwgYWNjdXJhdGUgYW5kIHVzZXMgaW50ZWdlciBvcGVyYXRpb25zLlxuKiBIb3dldmVyLCBKYXZhc2NyaXB0IGhhcyBmbG9hdGluZyBwb2ludCBvcGVyYXRpb25zIGJ5IGRlZmF1bHQgYW5kIG9ubHlcbiogdGhvc2UgYXJlIGF2YWlsYWJsZS4gT25lIGNvdWxkIG1ha2UgYSBjYXNlIHRvIHNpbXVsYXRlIHRoZSAxLzY0IGFjY3VyYWN5XG4qIGV4YWN0bHkgYnkgdHJ1bmNhdGluZyBhZnRlciBldmVyeSBkaXZpc2lvbiBvcGVyYXRpb25cbiogKGZvciBleGFtcGxlIHdpdGggPDwgMCkgdG8gZ2V0IHBpeGVsIGV4YWN0bHkgcmVzdWx0cyBhcyBvdGhlciBUcnVlVHlwZVxuKiBpbXBsZW1lbnRhdGlvbnMuIEl0IG1heSBtYWtlIHNlbnNlIHNpbmNlIHNvbWUgZm9udHMgYXJlIHBpeGVsIG9wdGltaXplZFxuKiBieSBoYW5kIHVzaW5nIERFTFRBUCBpbnN0cnVjdGlvbnMuIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIGRvZXNuJ3RcbiogYW5kIHJhdGhlciB1c2VzIGZ1bGwgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uLlxuKlxuKiB4U2NhbGUsIHlTY2FsZSBhbmQgcm90YXRpb24gaXMgY3VycmVudGx5IGlnbm9yZWQuXG4qXG4qIEEgZmV3IG5vbi10cml2aWFsIGluc3RydWN0aW9ucyBhcmUgbWlzc2luZyBhcyBJIGRpZG4ndCBlbmNvdW50ZXIgeWV0XG4qIGEgZm9udCB0aGF0IHVzZWQgdGhlbSB0byB0ZXN0IGEgcG9zc2libGUgaW1wbGVtZW50YXRpb24uXG4qXG4qIFNvbWUgZm9udHMgc2VlbSB0byB1c2UgdW5kb2N1bWVudGVkIGZlYXR1cmVzIHJlZ2FyZGluZyB0aGUgdHdpbGlnaHQgem9uZS5cbiogT25seSBzb21lIG9mIHRoZW0gYXJlIGltcGxlbWVudGVkIGFzIHRoZXkgd2VyZSBlbmNvdW50ZXJlZC5cbipcbiogVGhlIGV4cG9ydHMuREVCVUcgc3RhdGVtZW50cyBhcmUgcmVtb3ZlZCBvbiB0aGUgbWluaWZpZWQgZGlzdHJpYnV0aW9uIGZpbGUuXG4qL1xuXG52YXIgaW5zdHJ1Y3Rpb25UYWJsZTtcbnZhciBleGVjO1xudmFyIGV4ZWNHbHlwaDtcbnZhciBleGVjQ29tcG9uZW50O1xuXG4vKlxuKiBDcmVhdGVzIGEgaGludGluZyBvYmplY3QuXG4qXG4qIFRoZXJlIG91Z2h0IHRvIGJlIGV4YWN0bHkgb25lXG4qIGZvciBlYWNoIHRydWV0eXBlIGZvbnQgdGhhdCBpcyB1c2VkIGZvciBoaW50aW5nLlxuKi9cbmZ1bmN0aW9uIEhpbnRpbmcoZm9udCkge1xuICAgIC8vIHRoZSBmb250IHRoaXMgaGludGluZyBvYmplY3QgaXMgZm9yXG4gICAgdGhpcy5mb250ID0gZm9udDtcblxuICAgIHRoaXMuZ2V0Q29tbWFuZHMgPSBmdW5jdGlvbiAoaFBvaW50cykge1xuICAgICAgICByZXR1cm4gZ2x5Zi5nZXRQYXRoKGhQb2ludHMpLmNvbW1hbmRzO1xuICAgIH07XG5cbiAgICAvLyBjYWNoZWQgc3RhdGVzXG4gICAgdGhpcy5fZnBnbVN0YXRlICA9XG4gICAgdGhpcy5fcHJlcFN0YXRlICA9XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgIC8vIGVycm9yU3RhdGVcbiAgICAvLyAwIC4uLiBhbGwgb2theVxuICAgIC8vIDEgLi4uIGhhZCBhbiBlcnJvciBpbiBhIGdseWYsXG4gICAgLy8gICAgICAgY29udGludWUgd29ya2luZyBidXQgc3RvcCBzcGFtbWluZ1xuICAgIC8vICAgICAgIHRoZSBjb25zb2xlXG4gICAgLy8gMiAuLi4gZXJyb3IgYXQgcHJlcCwgc3RvcCBoaW50aW5nIGF0IHRoaXMgcHBlbVxuICAgIC8vIDMgLi4uIGVycm9yIGF0IGZwZWcsIHN0b3AgaGludGluZyBmb3IgdGhpcyBmb250IGF0IGFsbFxuICAgIHRoaXMuX2Vycm9yU3RhdGUgPSAwO1xufVxuXG4vKlxuKiBOb3Qgcm91bmRpbmcuXG4qL1xuZnVuY3Rpb24gcm91bmRPZmYodikge1xuICAgIHJldHVybiB2O1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byBncmlkLlxuKi9cbmZ1bmN0aW9uIHJvdW5kVG9HcmlkKHYpIHtcbiAgICAvL1JvdW5kaW5nIGluIFRUIGlzIHN1cHBvc2VkIHRvIFwic3ltbWV0cmljYWwgYXJvdW5kIHplcm9cIlxuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLnJvdW5kKE1hdGguYWJzKHYpKTtcbn1cblxuLypcbiogUm91bmRpbmcgdG8gZG91YmxlIGdyaWQuXG4qL1xuZnVuY3Rpb24gcm91bmRUb0RvdWJsZUdyaWQodikge1xuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLnJvdW5kKE1hdGguYWJzKHYgKiAyKSkgLyAyO1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byBoYWxmIGdyaWQuXG4qL1xuZnVuY3Rpb24gcm91bmRUb0hhbGZHcmlkKHYpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHYpICogKE1hdGgucm91bmQoTWF0aC5hYnModikgKyAwLjUpIC0gMC41KTtcbn1cblxuLypcbiogUm91bmRpbmcgdG8gdXAgdG8gZ3JpZC5cbiovXG5mdW5jdGlvbiByb3VuZFVwVG9HcmlkKHYpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5jZWlsKE1hdGguYWJzKHYpKTtcbn1cblxuLypcbiogUm91bmRpbmcgdG8gZG93biB0byBncmlkLlxuKi9cbmZ1bmN0aW9uIHJvdW5kRG93blRvR3JpZCh2KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGguZmxvb3IoTWF0aC5hYnModikpO1xufVxuXG4vKlxuKiBTdXBlciByb3VuZGluZy5cbiovXG52YXIgcm91bmRTdXBlciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIHBlcmlvZCA9IHRoaXMuc3JQZXJpb2Q7XG4gICAgdmFyIHBoYXNlID0gdGhpcy5zclBoYXNlO1xuICAgIHZhciB0aHJlc2hvbGQgPSB0aGlzLnNyVGhyZXNob2xkO1xuICAgIHZhciBzaWduID0gMTtcblxuICAgIGlmICh2IDwgMCkge1xuICAgICAgICB2ID0gLXY7XG4gICAgICAgIHNpZ24gPSAtMTtcbiAgICB9XG5cbiAgICB2ICs9IHRocmVzaG9sZCAtIHBoYXNlO1xuXG4gICAgdiA9IE1hdGgudHJ1bmModiAvIHBlcmlvZCkgKiBwZXJpb2Q7XG5cbiAgICB2ICs9IHBoYXNlO1xuXG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly94Z3JpZGZpdC5zb3VyY2Vmb3JnZS5uZXQvcm91bmQuaHRtbFxuICAgIGlmICh2IDwgMCkgeyByZXR1cm4gcGhhc2UgKiBzaWduOyB9XG5cbiAgICByZXR1cm4gdiAqIHNpZ247XG59O1xuXG4vKlxuKiBVbml0IHZlY3RvciBvZiB4LWF4aXMuXG4qL1xudmFyIHhVbml0VmVjdG9yID0ge1xuICAgIHg6IDEsXG5cbiAgICB5OiAwLFxuXG4gICAgYXhpczogJ3gnLFxuXG4gICAgLy8gR2V0cyB0aGUgcHJvamVjdGVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAvLyBvMS9vMiAuLi4gaWYgdHJ1ZSwgcmVzcGVjdGl2ZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyB1c2VkLlxuICAgIGRpc3RhbmNlOiBmdW5jdGlvbiAocDEsIHAyLCBvMSwgbzIpIHtcbiAgICAgICAgcmV0dXJuIChvMSA/IHAxLnhvIDogcDEueCkgLSAobzIgPyBwMi54byA6IHAyLngpO1xuICAgIH0sXG5cbiAgICAvLyBNb3ZlcyBwb2ludCBwIHNvIHRoZSBtb3ZlZCBwb3NpdGlvbiBoYXMgdGhlIHNhbWUgcmVsYXRpdmVcbiAgICAvLyBwb3NpdGlvbiB0byB0aGUgbW92ZWQgcG9zaXRpb25zIG9mIHJwMSBhbmQgcnAyIHRoYW4gdGhlXG4gICAgLy8gb3JpZ2luYWwgcG9zaXRpb25zIGhhZC5cbiAgICAvL1xuICAgIC8vIFNlZSBBUFBFTkRJWCBvbiBJTlRFUlBPTEFURSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbiAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gKHAsIHJwMSwgcnAyLCBwdikge1xuICAgICAgICB2YXIgZG8xO1xuICAgICAgICB2YXIgZG8yO1xuICAgICAgICB2YXIgZG9hMTtcbiAgICAgICAgdmFyIGRvYTI7XG4gICAgICAgIHZhciBkbTE7XG4gICAgICAgIHZhciBkbTI7XG4gICAgICAgIHZhciBkdDtcblxuICAgICAgICBpZiAoIXB2IHx8IHB2ID09PSB0aGlzKSB7XG4gICAgICAgICAgICBkbzEgPSBwLnhvIC0gcnAxLnhvO1xuICAgICAgICAgICAgZG8yID0gcC54byAtIHJwMi54bztcbiAgICAgICAgICAgIGRtMSA9IHJwMS54IC0gcnAxLnhvO1xuICAgICAgICAgICAgZG0yID0gcnAyLnggLSBycDIueG87XG4gICAgICAgICAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcbiAgICAgICAgICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgICAgICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuICAgICAgICAgICAgaWYgKGR0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcC54ID0gcC54byArIChkbTEgKyBkbTIpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAueCA9IHAueG8gKyAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkbzEgPSBwdi5kaXN0YW5jZShwLCBycDEsIHRydWUsIHRydWUpO1xuICAgICAgICBkbzIgPSBwdi5kaXN0YW5jZShwLCBycDIsIHRydWUsIHRydWUpO1xuICAgICAgICBkbTEgPSBwdi5kaXN0YW5jZShycDEsIHJwMSwgZmFsc2UsIHRydWUpO1xuICAgICAgICBkbTIgPSBwdi5kaXN0YW5jZShycDIsIHJwMiwgZmFsc2UsIHRydWUpO1xuICAgICAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcbiAgICAgICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG4gICAgICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICAgICAgaWYgKGR0ID09PSAwKSB7XG4gICAgICAgICAgICB4VW5pdFZlY3Rvci5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICsgZG0yKSAvIDIsIHB2LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHhVbml0VmVjdG9yLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdCwgcHYsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvLyBTbG9wZSBvZiBsaW5lIG5vcm1hbCB0byB0aGlzXG4gICAgbm9ybWFsU2xvcGU6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcblxuICAgIC8vIFNldHMgdGhlIHBvaW50ICdwJyByZWxhdGl2ZSB0byBwb2ludCAncnAnXG4gICAgLy8gYnkgdGhlIGRpc3RhbmNlICdkJy5cbiAgICAvL1xuICAgIC8vIFNlZSBBUFBFTkRJWCBvbiBTRVRSRUxBVElWRSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbiAgICAvL1xuICAgIC8vIHAgICAuLi4gcG9pbnQgdG8gc2V0XG4gICAgLy8gcnAgIC4uLiByZWZlcmVuY2UgcG9pbnRcbiAgICAvLyBkICAgLi4uIGRpc3RhbmNlIG9uIHByb2plY3Rpb24gdmVjdG9yXG4gICAgLy8gcHYgIC4uLiBwcm9qZWN0aW9uIHZlY3RvciAodW5kZWZpbmVkID0gdGhpcylcbiAgICAvLyBvcmcgLi4uIGlmIHRydWUsIHVzZXMgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIG9mIHJwIGFzIHJlZmVyZW5jZS5cbiAgICBzZXRSZWxhdGl2ZTogZnVuY3Rpb24gKHAsIHJwLCBkLCBwdiwgb3JnKSB7XG4gICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHAueCA9IChvcmcgPyBycC54byA6IHJwLngpICsgZDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBycHggPSBvcmcgPyBycC54byA6IHJwLng7XG4gICAgICAgIHZhciBycHkgPSBvcmcgPyBycC55byA6IHJwLnk7XG4gICAgICAgIHZhciBycGR4ID0gcnB4ICsgZCAqIHB2Lng7XG4gICAgICAgIHZhciBycGR5ID0gcnB5ICsgZCAqIHB2Lnk7XG5cbiAgICAgICAgcC54ID0gcnBkeCArIChwLnkgLSBycGR5KSAvIHB2Lm5vcm1hbFNsb3BlO1xuICAgIH0sXG5cbiAgICAvLyBTbG9wZSBvZiB2ZWN0b3IgbGluZS5cbiAgICBzbG9wZTogMCxcblxuICAgIC8vIFRvdWNoZXMgdGhlIHBvaW50IHAuXG4gICAgdG91Y2g6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAueFRvdWNoZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBUZXN0cyBpZiBhIHBvaW50IHAgaXMgdG91Y2hlZC5cbiAgICB0b3VjaGVkOiBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC54VG91Y2hlZDtcbiAgICB9LFxuXG4gICAgLy8gVW50b3VjaGVzIHRoZSBwb2ludCBwLlxuICAgIHVudG91Y2g6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAueFRvdWNoZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG4vKlxuKiBVbml0IHZlY3RvciBvZiB5LWF4aXMuXG4qL1xudmFyIHlVbml0VmVjdG9yID0ge1xuICAgIHg6IDAsXG5cbiAgICB5OiAxLFxuXG4gICAgYXhpczogJ3knLFxuXG4gICAgLy8gR2V0cyB0aGUgcHJvamVjdGVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAvLyBvMS9vMiAuLi4gaWYgdHJ1ZSwgcmVzcGVjdGl2ZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyB1c2VkLlxuICAgIGRpc3RhbmNlOiBmdW5jdGlvbiAocDEsIHAyLCBvMSwgbzIpIHtcbiAgICAgICAgcmV0dXJuIChvMSA/IHAxLnlvIDogcDEueSkgLSAobzIgPyBwMi55byA6IHAyLnkpO1xuICAgIH0sXG5cbiAgICAvLyBNb3ZlcyBwb2ludCBwIHNvIHRoZSBtb3ZlZCBwb3NpdGlvbiBoYXMgdGhlIHNhbWUgcmVsYXRpdmVcbiAgICAvLyBwb3NpdGlvbiB0byB0aGUgbW92ZWQgcG9zaXRpb25zIG9mIHJwMSBhbmQgcnAyIHRoYW4gdGhlXG4gICAgLy8gb3JpZ2luYWwgcG9zaXRpb25zIGhhZC5cbiAgICAvL1xuICAgIC8vIFNlZSBBUFBFTkRJWCBvbiBJTlRFUlBPTEFURSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbiAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gKHAsIHJwMSwgcnAyLCBwdikge1xuICAgICAgICB2YXIgZG8xO1xuICAgICAgICB2YXIgZG8yO1xuICAgICAgICB2YXIgZG9hMTtcbiAgICAgICAgdmFyIGRvYTI7XG4gICAgICAgIHZhciBkbTE7XG4gICAgICAgIHZhciBkbTI7XG4gICAgICAgIHZhciBkdDtcblxuICAgICAgICBpZiAoIXB2IHx8IHB2ID09PSB0aGlzKSB7XG4gICAgICAgICAgICBkbzEgPSBwLnlvIC0gcnAxLnlvO1xuICAgICAgICAgICAgZG8yID0gcC55byAtIHJwMi55bztcbiAgICAgICAgICAgIGRtMSA9IHJwMS55IC0gcnAxLnlvO1xuICAgICAgICAgICAgZG0yID0gcnAyLnkgLSBycDIueW87XG4gICAgICAgICAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcbiAgICAgICAgICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgICAgICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuICAgICAgICAgICAgaWYgKGR0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcC55ID0gcC55byArIChkbTEgKyBkbTIpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAueSA9IHAueW8gKyAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkbzEgPSBwdi5kaXN0YW5jZShwLCBycDEsIHRydWUsIHRydWUpO1xuICAgICAgICBkbzIgPSBwdi5kaXN0YW5jZShwLCBycDIsIHRydWUsIHRydWUpO1xuICAgICAgICBkbTEgPSBwdi5kaXN0YW5jZShycDEsIHJwMSwgZmFsc2UsIHRydWUpO1xuICAgICAgICBkbTIgPSBwdi5kaXN0YW5jZShycDIsIHJwMiwgZmFsc2UsIHRydWUpO1xuICAgICAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcbiAgICAgICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG4gICAgICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICAgICAgaWYgKGR0ID09PSAwKSB7XG4gICAgICAgICAgICB5VW5pdFZlY3Rvci5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICsgZG0yKSAvIDIsIHB2LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHlVbml0VmVjdG9yLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdCwgcHYsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvLyBTbG9wZSBvZiBsaW5lIG5vcm1hbCB0byB0aGlzLlxuICAgIG5vcm1hbFNsb3BlOiAwLFxuXG4gICAgLy8gU2V0cyB0aGUgcG9pbnQgJ3AnIHJlbGF0aXZlIHRvIHBvaW50ICdycCdcbiAgICAvLyBieSB0aGUgZGlzdGFuY2UgJ2QnXG4gICAgLy9cbiAgICAvLyBTZWUgQVBQRU5ESVggb24gU0VUUkVMQVRJVkUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4gICAgLy9cbiAgICAvLyBwICAgLi4uIHBvaW50IHRvIHNldFxuICAgIC8vIHJwICAuLi4gcmVmZXJlbmNlIHBvaW50XG4gICAgLy8gZCAgIC4uLiBkaXN0YW5jZSBvbiBwcm9qZWN0aW9uIHZlY3RvclxuICAgIC8vIHB2ICAuLi4gcHJvamVjdGlvbiB2ZWN0b3IgKHVuZGVmaW5lZCA9IHRoaXMpXG4gICAgLy8gb3JnIC4uLiBpZiB0cnVlLCB1c2VzIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBvZiBycCBhcyByZWZlcmVuY2UuXG4gICAgc2V0UmVsYXRpdmU6IGZ1bmN0aW9uIChwLCBycCwgZCwgcHYsIG9yZykge1xuICAgICAgICBpZiAoIXB2IHx8IHB2ID09PSB0aGlzKSB7XG4gICAgICAgICAgICBwLnkgPSAob3JnID8gcnAueW8gOiBycC55KSArIGQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcnB4ID0gb3JnID8gcnAueG8gOiBycC54O1xuICAgICAgICB2YXIgcnB5ID0gb3JnID8gcnAueW8gOiBycC55O1xuICAgICAgICB2YXIgcnBkeCA9IHJweCArIGQgKiBwdi54O1xuICAgICAgICB2YXIgcnBkeSA9IHJweSArIGQgKiBwdi55O1xuXG4gICAgICAgIHAueSA9IHJwZHkgKyBwdi5ub3JtYWxTbG9wZSAqIChwLnggLSBycGR4KTtcbiAgICB9LFxuXG4gICAgLy8gU2xvcGUgb2YgdmVjdG9yIGxpbmUuXG4gICAgc2xvcGU6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcblxuICAgIC8vIFRvdWNoZXMgdGhlIHBvaW50IHAuXG4gICAgdG91Y2g6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAueVRvdWNoZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBUZXN0cyBpZiBhIHBvaW50IHAgaXMgdG91Y2hlZC5cbiAgICB0b3VjaGVkOiBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC55VG91Y2hlZDtcbiAgICB9LFxuXG4gICAgLy8gVW50b3VjaGVzIHRoZSBwb2ludCBwLlxuICAgIHVudG91Y2g6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAueVRvdWNoZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5PYmplY3QuZnJlZXplKHhVbml0VmVjdG9yKTtcbk9iamVjdC5mcmVlemUoeVVuaXRWZWN0b3IpO1xuXG4vKlxuKiBDcmVhdGVzIGEgdW5pdCB2ZWN0b3IgdGhhdCBpcyBub3QgeC0gb3IgeS1heGlzLlxuKi9cbmZ1bmN0aW9uIFVuaXRWZWN0b3IoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmF4aXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zbG9wZSA9IHkgLyB4O1xuICAgIHRoaXMubm9ybWFsU2xvcGUgPSAteCAvIHk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbn1cblxuLypcbiogR2V0cyB0aGUgcHJvamVjdGVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiogbzEvbzIgLi4uIGlmIHRydWUsIHJlc3BlY3RpdmUgb3JpZ2luYWwgcG9zaXRpb24gaXMgdXNlZC5cbiovXG5Vbml0VmVjdG9yLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uKHAxLCBwMiwgbzEsIG8yKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy54ICogeFVuaXRWZWN0b3IuZGlzdGFuY2UocDEsIHAyLCBvMSwgbzIpICtcbiAgICAgICAgdGhpcy55ICogeVVuaXRWZWN0b3IuZGlzdGFuY2UocDEsIHAyLCBvMSwgbzIpXG4gICAgKTtcbn07XG5cbi8qXG4qIE1vdmVzIHBvaW50IHAgc28gdGhlIG1vdmVkIHBvc2l0aW9uIGhhcyB0aGUgc2FtZSByZWxhdGl2ZVxuKiBwb3NpdGlvbiB0byB0aGUgbW92ZWQgcG9zaXRpb25zIG9mIHJwMSBhbmQgcnAyIHRoYW4gdGhlXG4qIG9yaWdpbmFsIHBvc2l0aW9ucyBoYWQuXG4qXG4qIFNlZSBBUFBFTkRJWCBvbiBJTlRFUlBPTEFURSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbiovXG5Vbml0VmVjdG9yLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKHAsIHJwMSwgcnAyLCBwdikge1xuICAgIHZhciBkbTE7XG4gICAgdmFyIGRtMjtcbiAgICB2YXIgZG8xO1xuICAgIHZhciBkbzI7XG4gICAgdmFyIGRvYTE7XG4gICAgdmFyIGRvYTI7XG4gICAgdmFyIGR0O1xuXG4gICAgZG8xID0gcHYuZGlzdGFuY2UocCwgcnAxLCB0cnVlLCB0cnVlKTtcbiAgICBkbzIgPSBwdi5kaXN0YW5jZShwLCBycDIsIHRydWUsIHRydWUpO1xuICAgIGRtMSA9IHB2LmRpc3RhbmNlKHJwMSwgcnAxLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZG0yID0gcHYuZGlzdGFuY2UocnAyLCBycDIsIGZhbHNlLCB0cnVlKTtcbiAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcbiAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgaWYgKGR0ID09PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSArIGRtMikgLyAyLCBwdiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdCwgcHYsIHRydWUpO1xufTtcblxuLypcbiogU2V0cyB0aGUgcG9pbnQgJ3AnIHJlbGF0aXZlIHRvIHBvaW50ICdycCdcbiogYnkgdGhlIGRpc3RhbmNlICdkJ1xuKlxuKiBTZWUgQVBQRU5ESVggb24gU0VUUkVMQVRJVkUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4qXG4qIHAgICAuLi4gIHBvaW50IHRvIHNldFxuKiBycCAgLi4uIHJlZmVyZW5jZSBwb2ludFxuKiBkICAgLi4uIGRpc3RhbmNlIG9uIHByb2plY3Rpb24gdmVjdG9yXG4qIHB2ICAuLi4gcHJvamVjdGlvbiB2ZWN0b3IgKHVuZGVmaW5lZCA9IHRoaXMpXG4qIG9yZyAuLi4gaWYgdHJ1ZSwgdXNlcyB0aGUgb3JpZ2luYWwgcG9zaXRpb24gb2YgcnAgYXMgcmVmZXJlbmNlLlxuKi9cblVuaXRWZWN0b3IucHJvdG90eXBlLnNldFJlbGF0aXZlID0gZnVuY3Rpb24ocCwgcnAsIGQsIHB2LCBvcmcpIHtcbiAgICBwdiA9IHB2IHx8IHRoaXM7XG5cbiAgICB2YXIgcnB4ID0gb3JnID8gcnAueG8gOiBycC54O1xuICAgIHZhciBycHkgPSBvcmcgPyBycC55byA6IHJwLnk7XG4gICAgdmFyIHJwZHggPSBycHggKyBkICogcHYueDtcbiAgICB2YXIgcnBkeSA9IHJweSArIGQgKiBwdi55O1xuXG4gICAgdmFyIHB2bnMgPSBwdi5ub3JtYWxTbG9wZTtcbiAgICB2YXIgZnZzID0gdGhpcy5zbG9wZTtcblxuICAgIHZhciBweCA9IHAueDtcbiAgICB2YXIgcHkgPSBwLnk7XG5cbiAgICBwLnggPSAoZnZzICogcHggLSBwdm5zICogcnBkeCArIHJwZHkgLSBweSkgLyAoZnZzIC0gcHZucyk7XG4gICAgcC55ID0gZnZzICogKHAueCAtIHB4KSArIHB5O1xufTtcblxuLypcbiogVG91Y2hlcyB0aGUgcG9pbnQgcC5cbiovXG5Vbml0VmVjdG9yLnByb3RvdHlwZS50b3VjaCA9IGZ1bmN0aW9uKHApIHtcbiAgICBwLnhUb3VjaGVkID0gdHJ1ZTtcbiAgICBwLnlUb3VjaGVkID0gdHJ1ZTtcbn07XG5cbi8qXG4qIFJldHVybnMgYSB1bml0IHZlY3RvciB3aXRoIHgveSBjb29yZGluYXRlcy5cbiovXG5mdW5jdGlvbiBnZXRVbml0VmVjdG9yKHgsIHkpIHtcbiAgICB2YXIgZCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblxuICAgIHggLz0gZDtcbiAgICB5IC89IGQ7XG5cbiAgICBpZiAoeCA9PT0gMSAmJiB5ID09PSAwKSB7IHJldHVybiB4VW5pdFZlY3RvcjsgfVxuICAgIGVsc2UgaWYgKHggPT09IDAgJiYgeSA9PT0gMSkgeyByZXR1cm4geVVuaXRWZWN0b3I7IH1cbiAgICBlbHNlIHsgcmV0dXJuIG5ldyBVbml0VmVjdG9yKHgsIHkpOyB9XG59XG5cbi8qXG4qIENyZWF0ZXMgYSBwb2ludCBpbiB0aGUgaGludGluZyBlbmdpbmUuXG4qL1xuZnVuY3Rpb24gSFBvaW50KFxuICAgIHgsXG4gICAgeSxcbiAgICBsYXN0UG9pbnRPZkNvbnRvdXIsXG4gICAgb25DdXJ2ZVxuKSB7XG4gICAgdGhpcy54ID0gdGhpcy54byA9IE1hdGgucm91bmQoeCAqIDY0KSAvIDY0OyAvLyBoaW50ZWQgeCB2YWx1ZSBhbmQgb3JpZ2luYWwgeC12YWx1ZVxuICAgIHRoaXMueSA9IHRoaXMueW8gPSBNYXRoLnJvdW5kKHkgKiA2NCkgLyA2NDsgLy8gaGludGVkIHkgdmFsdWUgYW5kIG9yaWdpbmFsIHktdmFsdWVcblxuICAgIHRoaXMubGFzdFBvaW50T2ZDb250b3VyID0gbGFzdFBvaW50T2ZDb250b3VyO1xuICAgIHRoaXMub25DdXJ2ZSA9IG9uQ3VydmU7XG4gICAgdGhpcy5wcmV2UG9pbnRPbkNvbnRvdXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5uZXh0UG9pbnRPbkNvbnRvdXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54VG91Y2hlZCA9IGZhbHNlO1xuICAgIHRoaXMueVRvdWNoZWQgPSBmYWxzZTtcblxuICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbn1cblxuLypcbiogUmV0dXJucyB0aGUgbmV4dCB0b3VjaGVkIHBvaW50IG9uIHRoZSBjb250b3VyLlxuKlxuKiB2ICAuLi4gdW5pdCB2ZWN0b3IgdG8gdGVzdCB0b3VjaCBheGlzLlxuKi9cbkhQb2ludC5wcm90b3R5cGUubmV4dFRvdWNoZWQgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHAgPSB0aGlzLm5leHRQb2ludE9uQ29udG91cjtcblxuICAgIHdoaWxlICghdi50b3VjaGVkKHApICYmIHAgIT09IHRoaXMpIHsgcCA9IHAubmV4dFBvaW50T25Db250b3VyOyB9XG5cbiAgICByZXR1cm4gcDtcbn07XG5cbi8qXG4qIFJldHVybnMgdGhlIHByZXZpb3VzIHRvdWNoZWQgcG9pbnQgb24gdGhlIGNvbnRvdXJcbipcbiogdiAgLi4uIHVuaXQgdmVjdG9yIHRvIHRlc3QgdG91Y2ggYXhpcy5cbiovXG5IUG9pbnQucHJvdG90eXBlLnByZXZUb3VjaGVkID0gZnVuY3Rpb24odikge1xuICAgIHZhciBwID0gdGhpcy5wcmV2UG9pbnRPbkNvbnRvdXI7XG5cbiAgICB3aGlsZSAoIXYudG91Y2hlZChwKSAmJiBwICE9PSB0aGlzKSB7IHAgPSBwLnByZXZQb2ludE9uQ29udG91cjsgfVxuXG4gICAgcmV0dXJuIHA7XG59O1xuXG4vKlxuKiBUaGUgemVybyBwb2ludC5cbiovXG52YXIgSFBaZXJvID0gT2JqZWN0LmZyZWV6ZShuZXcgSFBvaW50KDAsIDApKTtcblxuLypcbiogVGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlIGludGVycHJldGVyLlxuKlxuKiBOb3RlOiBGcmVlemluZyB0aGUgZGVmYXVsdFN0YXRlIGFuZCB0aGVuIGRlcml2aW5nIGZyb20gaXRcbiogbWFrZXMgdGhlIFY4IEphdmFzY3JpcHQgZW5naW5lIGdvaW5nIGF3a3dhcmQsXG4qIHNvIHRoaXMgaXMgYXZvaWRlZCwgYWxiZWl0IHRoZSBkZWZhdWx0U3RhdGUgc2hvdWxkbid0XG4qIGV2ZXIgY2hhbmdlLlxuKi9cbnZhciBkZWZhdWx0U3RhdGUgPSB7XG4gICAgY3ZDdXRJbjogMTcgLyAxNiwgICAgLy8gY29udHJvbCB2YWx1ZSBjdXQgaW5cbiAgICBkZWx0YUJhc2U6IDksXG4gICAgZGVsdGFTaGlmdDogMC4xMjUsXG4gICAgbG9vcDogMSwgICAgICAgICAgICAgLy8gbG9vcHMgc29tZSBpbnN0cnVjdGlvbnNcbiAgICBtaW5EaXM6IDEsICAgICAgICAgICAvLyBtaW5pbXVtIGRpc3RhbmNlXG4gICAgYXV0b0ZsaXA6IHRydWVcbn07XG5cbi8qXG4qIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBpbnRlcnByZXRlci5cbipcbiogZW52ICAuLi4gJ2ZwZ20nIG9yICdwcmVwJyBvciAnZ2x5ZidcbiogcHJvZyAuLi4gdGhlIHByb2dyYW1cbiovXG5mdW5jdGlvbiBTdGF0ZShlbnYsIHByb2cpIHtcbiAgICB0aGlzLmVudiA9IGVudjtcbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgdGhpcy5wcm9nID0gcHJvZztcblxuICAgIHN3aXRjaCAoZW52KSB7XG4gICAgICAgIGNhc2UgJ2dseWYnIDpcbiAgICAgICAgICAgIHRoaXMuenAwID0gdGhpcy56cDEgPSB0aGlzLnpwMiA9IDE7XG4gICAgICAgICAgICB0aGlzLnJwMCA9IHRoaXMucnAxID0gdGhpcy5ycDIgPSAwO1xuICAgICAgICAgICAgLyogZmFsbCB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3ByZXAnIDpcbiAgICAgICAgICAgIHRoaXMuZnYgPSB0aGlzLnB2ID0gdGhpcy5kcHYgPSB4VW5pdFZlY3RvcjtcbiAgICAgICAgICAgIHRoaXMucm91bmQgPSByb3VuZFRvR3JpZDtcbiAgICB9XG59XG5cbi8qXG4qIEV4ZWN1dGVzIGEgZ2x5cGggcHJvZ3JhbS5cbipcbiogVGhpcyBkb2VzIHRoZSBoaW50aW5nIGZvciBlYWNoIGdseXBoLlxuKlxuKiBSZXR1cm5zIGFuIGFycmF5IG9mIG1vdmVkIHBvaW50cy5cbipcbiogZ2x5cGg6IHRoZSBnbHlwaCB0byBoaW50XG4qIHBwZW06IHRoZSBzaXplIHRoZSBnbHlwaCBpcyByZW5kZXJlZCBmb3JcbiovXG5IaW50aW5nLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oZ2x5cGgsIHBwZW0pIHtcbiAgICBpZiAodHlwZW9mIHBwZW0gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgc2l6ZSBpcyBub3QgYSBudW1iZXIhJyk7XG4gICAgfVxuXG4gICAgLy8gUmVjZWl2ZWQgYSBmYXRhbCBlcnJvciwgZG9uJ3QgZG8gYW55IGhpbnRpbmcgYW55bW9yZS5cbiAgICBpZiAodGhpcy5fZXJyb3JTdGF0ZSA+IDIpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgZm9udCA9IHRoaXMuZm9udDtcbiAgICB2YXIgcHJlcFN0YXRlID0gdGhpcy5fcHJlcFN0YXRlO1xuXG4gICAgaWYgKCFwcmVwU3RhdGUgfHwgcHJlcFN0YXRlLnBwZW0gIT09IHBwZW0pIHtcbiAgICAgICAgdmFyIGZwZ21TdGF0ZSA9IHRoaXMuX2ZwZ21TdGF0ZTtcblxuICAgICAgICBpZiAoIWZwZ21TdGF0ZSkge1xuICAgICAgICAgICAgLy8gRXhlY3V0ZXMgdGhlIGZwZ20gc3RhdGUuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHVzZWQgYnkgZm9udHMgdG8gZGVmaW5lIGZ1bmN0aW9ucy5cbiAgICAgICAgICAgIFN0YXRlLnByb3RvdHlwZSA9IGRlZmF1bHRTdGF0ZTtcblxuICAgICAgICAgICAgZnBnbVN0YXRlID1cbiAgICAgICAgICAgIHRoaXMuX2ZwZ21TdGF0ZSA9XG4gICAgICAgICAgICAgICAgbmV3IFN0YXRlKCdmcGdtJywgZm9udC50YWJsZXMuZnBnbSk7XG5cbiAgICAgICAgICAgIGZwZ21TdGF0ZS5mdW5jcyA9IFsgXTtcbiAgICAgICAgICAgIGZwZ21TdGF0ZS5mb250ID0gZm9udDtcblxuICAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBGUEdNLS0tJyk7XG4gICAgICAgICAgICAgICAgZnBnbVN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBleGVjKGZwZ21TdGF0ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0hpbnRpbmcgZXJyb3IgaW4gRlBHTTonICsgZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhlY3V0ZXMgdGhlIHByZXAgcHJvZ3JhbSBmb3IgdGhpcyBwcGVtIHNldHRpbmcuXG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCBieSBmb250cyB0byBzZXQgY3Z0IHZhbHVlc1xuICAgICAgICAvLyBkZXBlbmRpbmcgb24gdG8gYmUgcmVuZGVyZWQgZm9udCBzaXplLlxuXG4gICAgICAgIFN0YXRlLnByb3RvdHlwZSA9IGZwZ21TdGF0ZTtcbiAgICAgICAgcHJlcFN0YXRlID1cbiAgICAgICAgdGhpcy5fcHJlcFN0YXRlID1cbiAgICAgICAgICAgIG5ldyBTdGF0ZSgncHJlcCcsIGZvbnQudGFibGVzLnByZXApO1xuXG4gICAgICAgIHByZXBTdGF0ZS5wcGVtID0gcHBlbTtcblxuICAgICAgICAvLyBDcmVhdGVzIGEgY29weSBvZiB0aGUgY3Z0IHRhYmxlXG4gICAgICAgIC8vIGFuZCBzY2FsZXMgaXQgdG8gdGhlIGN1cnJlbnQgcHBlbSBzZXR0aW5nLlxuICAgICAgICB2YXIgb0N2dCA9IGZvbnQudGFibGVzLmN2dDtcbiAgICAgICAgaWYgKG9DdnQpIHtcbiAgICAgICAgICAgIHZhciBjdnQgPSBwcmVwU3RhdGUuY3Z0ID0gbmV3IEFycmF5KG9DdnQubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHBwZW0gLyBmb250LnVuaXRzUGVyRW07XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG9DdnQubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICBjdnRbY10gPSBvQ3Z0W2NdICogc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmVwU3RhdGUuY3Z0ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgUFJFUC0tLScpO1xuICAgICAgICAgICAgcHJlcFN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBleGVjKHByZXBTdGF0ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvclN0YXRlIDwgMikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaW50aW5nIGVycm9yIGluIFBSRVA6JyArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXJyb3JTdGF0ZSA+IDEpIHsgcmV0dXJuOyB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZXhlY0dseXBoKGdseXBoLCBwcmVwU3RhdGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Vycm9yU3RhdGUgPCAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSGludGluZyBlcnJvcjonICsgZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm90ZTogZnVydGhlciBoaW50aW5nIGVycm9ycyBhcmUgc2lsZW5jZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lcnJvclN0YXRlID0gMTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuXG4vKlxuKiBFeGVjdXRlcyB0aGUgaGludGluZyBwcm9ncmFtIGZvciBhIGdseXBoLlxuKi9cbmV4ZWNHbHlwaCA9IGZ1bmN0aW9uKGdseXBoLCBwcmVwU3RhdGUpIHtcbiAgICAvLyBvcmlnaW5hbCBwb2ludCBwb3NpdGlvbnNcbiAgICB2YXIgeFNjYWxlID0gcHJlcFN0YXRlLnBwZW0gLyBwcmVwU3RhdGUuZm9udC51bml0c1BlckVtO1xuICAgIHZhciB5U2NhbGUgPSB4U2NhbGU7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBnbHlwaC5jb21wb25lbnRzO1xuICAgIHZhciBjb250b3VycztcbiAgICB2YXIgZ1pvbmU7XG4gICAgdmFyIHN0YXRlO1xuXG4gICAgU3RhdGUucHJvdG90eXBlID0gcHJlcFN0YXRlO1xuICAgIGlmICghY29tcG9uZW50cykge1xuICAgICAgICBzdGF0ZSA9IG5ldyBTdGF0ZSgnZ2x5ZicsIGdseXBoLmluc3RydWN0aW9ucyk7XG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBHTFlQSC0tLScpO1xuICAgICAgICAgICAgc3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGV4ZWNDb21wb25lbnQoZ2x5cGgsIHN0YXRlLCB4U2NhbGUsIHlTY2FsZSk7XG4gICAgICAgIGdab25lID0gc3RhdGUuZ1pvbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZvbnQgPSBwcmVwU3RhdGUuZm9udDtcbiAgICAgICAgZ1pvbmUgPSBbXTtcbiAgICAgICAgY29udG91cnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICB2YXIgY2cgPSBmb250LmdseXBocy5nZXQoYy5nbHlwaEluZGV4KTtcblxuICAgICAgICAgICAgc3RhdGUgPSBuZXcgU3RhdGUoJ2dseWYnLCBjZy5pbnN0cnVjdGlvbnMpO1xuXG4gICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIENPTVAgJyArIGkgKyAnLS0tJyk7XG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGVjQ29tcG9uZW50KGNnLCBzdGF0ZSwgeFNjYWxlLCB5U2NhbGUpO1xuICAgICAgICAgICAgLy8gYXBwZW5kcyB0aGUgY29tcHV0ZWQgcG9pbnRzIHRvIHRoZSByZXN1bHQgYXJyYXlcbiAgICAgICAgICAgIC8vIHBvc3QgcHJvY2Vzc2VzIHRoZSBjb21wb25lbnQgcG9pbnRzXG4gICAgICAgICAgICB2YXIgZHggPSBNYXRoLnJvdW5kKGMuZHggKiB4U2NhbGUpO1xuICAgICAgICAgICAgdmFyIGR5ID0gTWF0aC5yb3VuZChjLmR5ICogeVNjYWxlKTtcbiAgICAgICAgICAgIHZhciBneiA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgdmFyIGNjID0gc3RhdGUuY29udG91cnM7XG4gICAgICAgICAgICBmb3IgKHZhciBwaSA9IDA7IHBpIDwgZ3oubGVuZ3RoOyBwaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBneltwaV07XG4gICAgICAgICAgICAgICAgcC54VG91Y2hlZCA9IHAueVRvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwLnhvID0gcC54ID0gcC54ICsgZHg7XG4gICAgICAgICAgICAgICAgcC55byA9IHAueSA9IHAueSArIGR5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ0xlbiA9IGdab25lLmxlbmd0aDtcbiAgICAgICAgICAgIGdab25lLnB1c2guYXBwbHkoZ1pvbmUsIGd6KTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb250b3Vycy5wdXNoKGNjW2pdICsgZ0xlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2x5cGguaW5zdHJ1Y3Rpb25zICYmICFzdGF0ZS5pbmhpYml0R3JpZEZpdCkge1xuICAgICAgICAgICAgLy8gdGhlIGNvbXBvc2l0ZSBoYXMgaW5zdHJ1Y3Rpb25zIG9uIGl0cyBvd25cbiAgICAgICAgICAgIHN0YXRlID0gbmV3IFN0YXRlKCdnbHlmJywgZ2x5cGguaW5zdHJ1Y3Rpb25zKTtcblxuICAgICAgICAgICAgc3RhdGUuZ1pvbmUgPSBzdGF0ZS56MCA9IHN0YXRlLnoxID0gc3RhdGUuejIgPSBnWm9uZTtcblxuICAgICAgICAgICAgc3RhdGUuY29udG91cnMgPSBjb250b3VycztcblxuICAgICAgICAgICAgLy8gbm90ZTogSFBaZXJvIGNhbm5vdCBiZSB1c2VkIGhlcmUsIHNpbmNlXG4gICAgICAgICAgICAvLyAgICAgICB0aGUgcG9pbnQgbWlnaHQgYmUgbW9kaWZpZWRcbiAgICAgICAgICAgIGdab25lLnB1c2goXG4gICAgICAgICAgICAgICAgbmV3IEhQb2ludCgwLCAwKSxcbiAgICAgICAgICAgICAgICBuZXcgSFBvaW50KE1hdGgucm91bmQoZ2x5cGguYWR2YW5jZVdpZHRoICogeFNjYWxlKSwgMClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgQ09NUE9TSVRFLS0tJyk7XG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGVjKHN0YXRlKTtcblxuICAgICAgICAgICAgZ1pvbmUubGVuZ3RoIC09IDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ1pvbmU7XG59O1xuXG4vKlxuKiBFeGVjdXRlcyB0aGUgaGludGluZyBwcm9ncmFtIGZvciBhIGNvbXBvbmVudCBvZiBhIG11bHRpLWNvbXBvbmVudCBnbHlwaFxuKiBvciBvZiB0aGUgZ2x5cGggaXRzZWxmIGZvciBhIG5vbi1jb21wb25lbnQgZ2x5cGguXG4qL1xuZXhlY0NvbXBvbmVudCA9IGZ1bmN0aW9uKGdseXBoLCBzdGF0ZSwgeFNjYWxlLCB5U2NhbGUpXG57XG4gICAgdmFyIHBvaW50cyA9IGdseXBoLnBvaW50cyB8fCBbXTtcbiAgICB2YXIgcExlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgdmFyIGdab25lID0gc3RhdGUuZ1pvbmUgPSBzdGF0ZS56MCA9IHN0YXRlLnoxID0gc3RhdGUuejIgPSBbXTtcbiAgICB2YXIgY29udG91cnMgPSBzdGF0ZS5jb250b3VycyA9IFtdO1xuXG4gICAgLy8gU2NhbGVzIHRoZSBvcmlnaW5hbCBwb2ludHMgYW5kXG4gICAgLy8gbWFrZXMgY29waWVzIGZvciB0aGUgaGludGVkIHBvaW50cy5cbiAgICB2YXIgY3A7IC8vIGN1cnJlbnQgcG9pbnRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBMZW47IGkrKykge1xuICAgICAgICBjcCA9IHBvaW50c1tpXTtcblxuICAgICAgICBnWm9uZVtpXSA9IG5ldyBIUG9pbnQoXG4gICAgICAgICAgICBjcC54ICogeFNjYWxlLFxuICAgICAgICAgICAgY3AueSAqIHlTY2FsZSxcbiAgICAgICAgICAgIGNwLmxhc3RQb2ludE9mQ29udG91cixcbiAgICAgICAgICAgIGNwLm9uQ3VydmVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBDaGFpbiBsaW5rcyB0aGUgY29udG91cnMuXG4gICAgdmFyIHNwOyAvLyBzdGFydCBwb2ludFxuICAgIHZhciBucDsgLy8gbmV4dCBwb2ludFxuXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcExlbjsgaSQxKyspIHtcbiAgICAgICAgY3AgPSBnWm9uZVtpJDFdO1xuXG4gICAgICAgIGlmICghc3ApIHtcbiAgICAgICAgICAgIHNwID0gY3A7XG4gICAgICAgICAgICBjb250b3Vycy5wdXNoKGkkMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3AubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICBjcC5uZXh0UG9pbnRPbkNvbnRvdXIgPSBzcDtcbiAgICAgICAgICAgIHNwLnByZXZQb2ludE9uQ29udG91ciA9IGNwO1xuICAgICAgICAgICAgc3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBucCA9IGdab25lW2kkMSArIDFdO1xuICAgICAgICAgICAgY3AubmV4dFBvaW50T25Db250b3VyID0gbnA7XG4gICAgICAgICAgICBucC5wcmV2UG9pbnRPbkNvbnRvdXIgPSBjcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5pbmhpYml0R3JpZEZpdCkgeyByZXR1cm47IH1cblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdQUk9DRVNTSU5HIEdMWVBIJywgc3RhdGUuc3RhY2spO1xuICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBwTGVuOyBpJDIrKykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coaSQyLCBnWm9uZVtpJDJdLngsIGdab25lW2kkMl0ueSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnWm9uZS5wdXNoKFxuICAgICAgICBuZXcgSFBvaW50KDAsIDApLFxuICAgICAgICBuZXcgSFBvaW50KE1hdGgucm91bmQoZ2x5cGguYWR2YW5jZVdpZHRoICogeFNjYWxlKSwgMClcbiAgICApO1xuXG4gICAgZXhlYyhzdGF0ZSk7XG5cbiAgICAvLyBSZW1vdmVzIHRoZSBleHRyYSBwb2ludHMuXG4gICAgZ1pvbmUubGVuZ3RoIC09IDI7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICBjb25zb2xlLmxvZygnRklOSVNIRUQgR0xZUEgnLCBzdGF0ZS5zdGFjayk7XG4gICAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IHBMZW47IGkkMysrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhpJDMsIGdab25lW2kkM10ueCwgZ1pvbmVbaSQzXS55KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qXG4qIEV4ZWN1dGVzIHRoZSBwcm9ncmFtIGxvYWRlZCBpbiBzdGF0ZS5cbiovXG5leGVjID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG5cbiAgICBpZiAoIXByb2cpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgcExlbiA9IHByb2cubGVuZ3RoO1xuICAgIHZhciBpbnM7XG5cbiAgICBmb3IgKHN0YXRlLmlwID0gMDsgc3RhdGUuaXAgPCBwTGVuOyBzdGF0ZS5pcCsrKSB7XG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IHN0YXRlLnN0ZXArKzsgfVxuICAgICAgICBpbnMgPSBpbnN0cnVjdGlvblRhYmxlW3Byb2dbc3RhdGUuaXBdXTtcblxuICAgICAgICBpZiAoIWlucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICd1bmtub3duIGluc3RydWN0aW9uOiAweCcgK1xuICAgICAgICAgICAgICAgIE51bWJlcihwcm9nW3N0YXRlLmlwXSkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zKHN0YXRlKTtcblxuICAgICAgICAvLyB2ZXJ5IGV4dGVuc2l2ZSBkZWJ1Z2dpbmcgZm9yIGVhY2ggc3RlcFxuICAgICAgICAvKlxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgdmFyIGRhO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmdab25lKSB7XG4gICAgICAgICAgICAgICAgZGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLmdab25lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZGEucHVzaChpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmdab25lW2ldLnggKiA2NCArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5nWm9uZVtpXS55ICogNjQgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLmdab25lW2ldLnhUb3VjaGVkID8gJ3gnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5nWm9uZVtpXS55VG91Y2hlZCA/ICd5JyA6ICcnKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnR1onLCBkYSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS50Wm9uZSkge1xuICAgICAgICAgICAgICAgIGRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS50Wm9uZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkYS5wdXNoKGkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudFpvbmVbaV0ueCAqIDY0ICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRab25lW2ldLnkgKiA2NCArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUudFpvbmVbaV0ueFRvdWNoZWQgPyAneCcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLnRab25lW2ldLnlUb3VjaGVkID8gJ3knIDogJycpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUWicsIGRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YXRlLnN0YWNrLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YWNrLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgJy4uLicsIHN0YXRlLnN0YWNrLnNsaWNlKHN0YXRlLnN0YWNrLmxlbmd0aCAtIDEwKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnN0YWNrLmxlbmd0aCwgc3RhdGUuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICovXG4gICAgfVxufTtcblxuLypcbiogSW5pdGlhbGl6ZXMgdGhlIHR3aWxpZ2h0IHpvbmUuXG4qXG4qIFRoaXMgaXMgb25seSBkb25lIGlmIGEgU1pQeCBpbnN0cnVjdGlvblxuKiByZWZlcnMgdG8gdGhlIHR3aWxpZ2h0IHpvbmUuXG4qL1xuZnVuY3Rpb24gaW5pdFRab25lKHN0YXRlKVxue1xuICAgIHZhciB0Wm9uZSA9IHN0YXRlLnRab25lID0gbmV3IEFycmF5KHN0YXRlLmdab25lLmxlbmd0aCk7XG5cbiAgICAvLyBubyBpZGVhIGlmIHRoaXMgaXMgYWN0dWFsbHkgY29ycmVjdC4uLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdFpvbmUubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB0Wm9uZVtpXSA9IG5ldyBIUG9pbnQoMCwgMCk7XG4gICAgfVxufVxuXG4vKlxuKiBTa2lwcyB0aGUgaW5zdHJ1Y3Rpb24gcG9pbnRlciBhaGVhZCBvdmVyIGFuIElGL0VMU0UgYmxvY2suXG4qIGhhbmRsZUVsc2UgLi4gaWYgdHJ1ZSBicmVha3Mgb24gbWF0Y2hpbmcgRUxTRVxuKi9cbmZ1bmN0aW9uIHNraXAoc3RhdGUsIGhhbmRsZUVsc2UpXG57XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBuZXN0aW5nID0gMTtcbiAgICB2YXIgaW5zO1xuXG4gICAgZG8ge1xuICAgICAgICBpbnMgPSBwcm9nWysraXBdO1xuICAgICAgICBpZiAoaW5zID09PSAweDU4KSAvLyBJRlxuICAgICAgICAgICAgeyBuZXN0aW5nKys7IH1cbiAgICAgICAgZWxzZSBpZiAoaW5zID09PSAweDU5KSAvLyBFSUZcbiAgICAgICAgICAgIHsgbmVzdGluZy0tOyB9XG4gICAgICAgIGVsc2UgaWYgKGlucyA9PT0gMHg0MCkgLy8gTlBVU0hCXG4gICAgICAgICAgICB7IGlwICs9IHByb2dbaXAgKyAxXSArIDE7IH1cbiAgICAgICAgZWxzZSBpZiAoaW5zID09PSAweDQxKSAvLyBOUFVTSFdcbiAgICAgICAgICAgIHsgaXAgKz0gMiAqIHByb2dbaXAgKyAxXSArIDE7IH1cbiAgICAgICAgZWxzZSBpZiAoaW5zID49IDB4QjAgJiYgaW5zIDw9IDB4QjcpIC8vIFBVU0hCXG4gICAgICAgICAgICB7IGlwICs9IGlucyAtIDB4QjAgKyAxOyB9XG4gICAgICAgIGVsc2UgaWYgKGlucyA+PSAweEI4ICYmIGlucyA8PSAweEJGKSAvLyBQVVNIV1xuICAgICAgICAgICAgeyBpcCArPSAoaW5zIC0gMHhCOCArIDEpICogMjsgfVxuICAgICAgICBlbHNlIGlmIChoYW5kbGVFbHNlICYmIG5lc3RpbmcgPT09IDEgJiYgaW5zID09PSAweDFCKSAvLyBFTFNFXG4gICAgICAgICAgICB7IGJyZWFrOyB9XG4gICAgfSB3aGlsZSAobmVzdGluZyA+IDApO1xuXG4gICAgc3RhdGUuaXAgPSBpcDtcbn1cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxuKiAgICAgICAgICBBbmQgdGhlbiBhIGxvdCBvZiBpbnN0cnVjdGlvbnMuLi4gICAgICAgICAgICAgICAgKlxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vLyBTVlRDQVthXSBTZXQgZnJlZWRvbSBhbmQgcHJvamVjdGlvbiBWZWN0b3JzIFRvIENvb3JkaW5hdGUgQXhpc1xuLy8gMHgwMC0weDAxXG5mdW5jdGlvbiBTVlRDQSh2LCBzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTVlRDQVsnICsgdi5heGlzICsgJ10nKTsgfVxuXG4gICAgc3RhdGUuZnYgPSBzdGF0ZS5wdiA9IHN0YXRlLmRwdiA9IHY7XG59XG5cbi8vIFNQVlRDQVthXSBTZXQgUHJvamVjdGlvbiBWZWN0b3IgdG8gQ29vcmRpbmF0ZSBBeGlzXG4vLyAweDAyLTB4MDNcbmZ1bmN0aW9uIFNQVlRDQSh2LCBzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUFZUQ0FbJyArIHYuYXhpcyArICddJyk7IH1cblxuICAgIHN0YXRlLnB2ID0gc3RhdGUuZHB2ID0gdjtcbn1cblxuLy8gU0ZWVENBW2FdIFNldCBGcmVlZG9tIFZlY3RvciB0byBDb29yZGluYXRlIEF4aXNcbi8vIDB4MDQtMHgwNVxuZnVuY3Rpb24gU0ZWVENBKHYsIHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NGVlRDQVsnICsgdi5heGlzICsgJ10nKTsgfVxuXG4gICAgc3RhdGUuZnYgPSB2O1xufVxuXG4vLyBTUFZUTFthXSBTZXQgUHJvamVjdGlvbiBWZWN0b3IgVG8gTGluZVxuLy8gMHgwNi0weDA3XG5mdW5jdGlvbiBTUFZUTChhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwMmkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDFpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAyID0gc3RhdGUuejJbcDJpXTtcbiAgICB2YXIgcDEgPSBzdGF0ZS56MVtwMWldO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coJ1NQVlRMWycgKyBhICsgJ10nLCBwMmksIHAxaSk7IH1cblxuICAgIHZhciBkeDtcbiAgICB2YXIgZHk7XG5cbiAgICBpZiAoIWEpIHtcbiAgICAgICAgZHggPSBwMS54IC0gcDIueDtcbiAgICAgICAgZHkgPSBwMS55IC0gcDIueTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkeCA9IHAyLnkgLSBwMS55O1xuICAgICAgICBkeSA9IHAxLnggLSBwMi54O1xuICAgIH1cblxuICAgIHN0YXRlLnB2ID0gc3RhdGUuZHB2ID0gZ2V0VW5pdFZlY3RvcihkeCwgZHkpO1xufVxuXG4vLyBTRlZUTFthXSBTZXQgRnJlZWRvbSBWZWN0b3IgVG8gTGluZVxuLy8gMHgwOC0weDA5XG5mdW5jdGlvbiBTRlZUTChhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwMmkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDFpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAyID0gc3RhdGUuejJbcDJpXTtcbiAgICB2YXIgcDEgPSBzdGF0ZS56MVtwMWldO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coJ1NGVlRMWycgKyBhICsgJ10nLCBwMmksIHAxaSk7IH1cblxuICAgIHZhciBkeDtcbiAgICB2YXIgZHk7XG5cbiAgICBpZiAoIWEpIHtcbiAgICAgICAgZHggPSBwMS54IC0gcDIueDtcbiAgICAgICAgZHkgPSBwMS55IC0gcDIueTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkeCA9IHAyLnkgLSBwMS55O1xuICAgICAgICBkeSA9IHAxLnggLSBwMi54O1xuICAgIH1cblxuICAgIHN0YXRlLmZ2ID0gZ2V0VW5pdFZlY3RvcihkeCwgZHkpO1xufVxuXG4vLyBTUFZGU1tdIFNldCBQcm9qZWN0aW9uIFZlY3RvciBGcm9tIFN0YWNrXG4vLyAweDBBXG5mdW5jdGlvbiBTUFZGUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciB5ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHggPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUFZGU1tdJywgeSwgeCk7IH1cblxuICAgIHN0YXRlLnB2ID0gc3RhdGUuZHB2ID0gZ2V0VW5pdFZlY3Rvcih4LCB5KTtcbn1cblxuLy8gU0ZWRlNbXSBTZXQgRnJlZWRvbSBWZWN0b3IgRnJvbSBTdGFja1xuLy8gMHgwQlxuZnVuY3Rpb24gU0ZWRlMoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgeSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciB4ID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1BWRlNbXScsIHksIHgpOyB9XG5cbiAgICBzdGF0ZS5mdiA9IGdldFVuaXRWZWN0b3IoeCwgeSk7XG59XG5cbi8vIEdQVltdIEdldCBQcm9qZWN0aW9uIFZlY3RvclxuLy8gMHgwQ1xuZnVuY3Rpb24gR1BWKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR1BWW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChwdi54ICogMHg0MDAwKTtcbiAgICBzdGFjay5wdXNoKHB2LnkgKiAweDQwMDApO1xufVxuXG4vLyBHRlZbXSBHZXQgRnJlZWRvbSBWZWN0b3Jcbi8vIDB4MENcbmZ1bmN0aW9uIEdGVihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dGVltdJyk7IH1cblxuICAgIHN0YWNrLnB1c2goZnYueCAqIDB4NDAwMCk7XG4gICAgc3RhY2sucHVzaChmdi55ICogMHg0MDAwKTtcbn1cblxuLy8gU0ZWVFBWW10gU2V0IEZyZWVkb20gVmVjdG9yIFRvIFByb2plY3Rpb24gVmVjdG9yXG4vLyAweDBFXG5mdW5jdGlvbiBTRlZUUFYoc3RhdGUpIHtcbiAgICBzdGF0ZS5mdiA9IHN0YXRlLnB2O1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NGVlRQVltdJyk7IH1cbn1cblxuLy8gSVNFQ1RbXSBtb3ZlcyBwb2ludCBwIHRvIHRoZSBJbnRlclNFQ1Rpb24gb2YgdHdvIGxpbmVzXG4vLyAweDBGXG5mdW5jdGlvbiBJU0VDVChzdGF0ZSlcbntcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcGEwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwYTFpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBiMGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGIxaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciB6MCA9IHN0YXRlLnowO1xuICAgIHZhciB6MSA9IHN0YXRlLnoxO1xuICAgIHZhciBwYTAgPSB6MFtwYTBpXTtcbiAgICB2YXIgcGExID0gejBbcGExaV07XG4gICAgdmFyIHBiMCA9IHoxW3BiMGldO1xuICAgIHZhciBwYjEgPSB6MVtwYjFpXTtcbiAgICB2YXIgcCA9IHN0YXRlLnoyW3BpXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKCdJU0VDVFtdLCAnLCBwYTBpLCBwYTFpLCBwYjBpLCBwYjFpLCBwaSk7IH1cblxuICAgIC8vIG1hdGggZnJvbVxuICAgIC8vIGVuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lJUUyJTgwJTkzbGluZV9pbnRlcnNlY3Rpb24jR2l2ZW5fdHdvX3BvaW50c19vbl9lYWNoX2xpbmVcblxuICAgIHZhciB4MSA9IHBhMC54O1xuICAgIHZhciB5MSA9IHBhMC55O1xuICAgIHZhciB4MiA9IHBhMS54O1xuICAgIHZhciB5MiA9IHBhMS55O1xuICAgIHZhciB4MyA9IHBiMC54O1xuICAgIHZhciB5MyA9IHBiMC55O1xuICAgIHZhciB4NCA9IHBiMS54O1xuICAgIHZhciB5NCA9IHBiMS55O1xuXG4gICAgdmFyIGRpdiA9ICh4MSAtIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAtIHg0KTtcbiAgICB2YXIgZjEgPSB4MSAqIHkyIC0geTEgKiB4MjtcbiAgICB2YXIgZjIgPSB4MyAqIHk0IC0geTMgKiB4NDtcblxuICAgIHAueCA9IChmMSAqICh4MyAtIHg0KSAtIGYyICogKHgxIC0geDIpKSAvIGRpdjtcbiAgICBwLnkgPSAoZjEgKiAoeTMgLSB5NCkgLSBmMiAqICh5MSAtIHkyKSkgLyBkaXY7XG59XG5cbi8vIFNSUDBbXSBTZXQgUmVmZXJlbmNlIFBvaW50IDBcbi8vIDB4MTBcbmZ1bmN0aW9uIFNSUDAoc3RhdGUpIHtcbiAgICBzdGF0ZS5ycDAgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUlAwW10nLCBzdGF0ZS5ycDApOyB9XG59XG5cbi8vIFNSUDFbXSBTZXQgUmVmZXJlbmNlIFBvaW50IDFcbi8vIDB4MTFcbmZ1bmN0aW9uIFNSUDEoc3RhdGUpIHtcbiAgICBzdGF0ZS5ycDEgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUlAxW10nLCBzdGF0ZS5ycDEpOyB9XG59XG5cbi8vIFNSUDFbXSBTZXQgUmVmZXJlbmNlIFBvaW50IDJcbi8vIDB4MTJcbmZ1bmN0aW9uIFNSUDIoc3RhdGUpIHtcbiAgICBzdGF0ZS5ycDIgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUlAyW10nLCBzdGF0ZS5ycDIpOyB9XG59XG5cbi8vIFNaUDBbXSBTZXQgWm9uZSBQb2ludGVyIDBcbi8vIDB4MTNcbmZ1bmN0aW9uIFNaUDAoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NaUDBbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS56cDAgPSBuO1xuXG4gICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghc3RhdGUudFpvbmUpIHsgaW5pdFRab25lKHN0YXRlKTsgfVxuICAgICAgICAgICAgc3RhdGUuejAgPSBzdGF0ZS50Wm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgOlxuICAgICAgICAgICAgc3RhdGUuejAgPSBzdGF0ZS5nWm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lIHBvaW50ZXInKTtcbiAgICB9XG59XG5cbi8vIFNaUDFbXSBTZXQgWm9uZSBQb2ludGVyIDFcbi8vIDB4MTRcbmZ1bmN0aW9uIFNaUDEoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NaUDFbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS56cDEgPSBuO1xuXG4gICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghc3RhdGUudFpvbmUpIHsgaW5pdFRab25lKHN0YXRlKTsgfVxuICAgICAgICAgICAgc3RhdGUuejEgPSBzdGF0ZS50Wm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgOlxuICAgICAgICAgICAgc3RhdGUuejEgPSBzdGF0ZS5nWm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lIHBvaW50ZXInKTtcbiAgICB9XG59XG5cbi8vIFNaUDJbXSBTZXQgWm9uZSBQb2ludGVyIDJcbi8vIDB4MTVcbmZ1bmN0aW9uIFNaUDIoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NaUDJbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS56cDIgPSBuO1xuXG4gICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghc3RhdGUudFpvbmUpIHsgaW5pdFRab25lKHN0YXRlKTsgfVxuICAgICAgICAgICAgc3RhdGUuejIgPSBzdGF0ZS50Wm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgOlxuICAgICAgICAgICAgc3RhdGUuejIgPSBzdGF0ZS5nWm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lIHBvaW50ZXInKTtcbiAgICB9XG59XG5cbi8vIFNaUFNbXSBTZXQgWm9uZSBQb2ludGVyU1xuLy8gMHgxNlxuZnVuY3Rpb24gU1pQUyhzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQU1tdJywgbik7IH1cblxuICAgIHN0YXRlLnpwMCA9IHN0YXRlLnpwMSA9IHN0YXRlLnpwMiA9IG47XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgeyBpbml0VFpvbmUoc3RhdGUpOyB9XG4gICAgICAgICAgICBzdGF0ZS56MCA9IHN0YXRlLnoxID0gc3RhdGUuejIgPSBzdGF0ZS50Wm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgOlxuICAgICAgICAgICAgc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG4gICAgfVxufVxuXG4vLyBTTE9PUFtdIFNldCBMT09QIHZhcmlhYmxlXG4vLyAweDE3XG5mdW5jdGlvbiBTTE9PUChzdGF0ZSkge1xuICAgIHN0YXRlLmxvb3AgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTTE9PUFtdJywgc3RhdGUubG9vcCk7IH1cbn1cblxuLy8gUlRHW10gUm91bmQgVG8gR3JpZFxuLy8gMHgxOFxuZnVuY3Rpb24gUlRHKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JUR1tdJyk7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRUb0dyaWQ7XG59XG5cbi8vIFJUSEdbXSBSb3VuZCBUbyBIYWxmIEdyaWRcbi8vIDB4MTlcbmZ1bmN0aW9uIFJUSEcoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlRIR1tdJyk7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRUb0hhbGZHcmlkO1xufVxuXG4vLyBTTURbXSBTZXQgTWluaW11bSBEaXN0YW5jZVxuLy8gMHgxQVxuZnVuY3Rpb24gU01EKHN0YXRlKSB7XG4gICAgdmFyIGQgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTTURbXScsIGQpOyB9XG5cbiAgICBzdGF0ZS5taW5EaXMgPSBkIC8gMHg0MDtcbn1cblxuLy8gRUxTRVtdIEVMU0UgY2xhdXNlXG4vLyAweDFCXG5mdW5jdGlvbiBFTFNFKHN0YXRlKSB7XG4gICAgLy8gVGhpcyBpbnN0cnVjdGlvbiBoYXMgYmVlbiByZWFjaGVkIGJ5IGV4ZWN1dGluZyBhIHRoZW4gYnJhbmNoXG4gICAgLy8gc28gaXQganVzdCBza2lwcyBhaGVhZCB1bnRpbCBtYXRjaGluZyBFSUYuXG4gICAgLy9cbiAgICAvLyBJbiBjYXNlIHRoZSBJRiB3YXMgbmVnYXRpdmUgdGhlIElGW10gaW5zdHJ1Y3Rpb24gYWxyZWFkeVxuICAgIC8vIHNraXBwZWQgZm9yd2FyZCBvdmVyIHRoZSBFTFNFW11cblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFTFNFW10nKTsgfVxuXG4gICAgc2tpcChzdGF0ZSwgZmFsc2UpO1xufVxuXG4vLyBKTVBSW10gSnVNUCBSZWxhdGl2ZVxuLy8gMHgxQ1xuZnVuY3Rpb24gSk1QUihzdGF0ZSkge1xuICAgIHZhciBvID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnSk1QUltdJywgbyk7IH1cblxuICAgIC8vIEEganVtcCBieSAxIHdvdWxkIGRvIG5vdGhpbmcuXG4gICAgc3RhdGUuaXAgKz0gbyAtIDE7XG59XG5cbi8vIFNDVlRDSVtdIFNldCBDb250cm9sIFZhbHVlIFRhYmxlIEN1dC1JblxuLy8gMHgxRFxuZnVuY3Rpb24gU0NWVENJKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTQ1ZUQ0lbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS5jdkN1dEluID0gbiAvIDB4NDA7XG59XG5cbi8vIERVUFtdIERVUGxpY2F0ZSB0b3Agc3RhY2sgZWxlbWVudFxuLy8gMHgyMFxuZnVuY3Rpb24gRFVQKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRFVQW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGFja1tzdGFjay5sZW5ndGggLSAxXSk7XG59XG5cbi8vIFBPUFtdIFBPUCB0b3Agc3RhY2sgZWxlbWVudFxuLy8gMHgyMVxuZnVuY3Rpb24gUE9QKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1BPUFtdJyk7IH1cblxuICAgIHN0YXRlLnN0YWNrLnBvcCgpO1xufVxuXG4vLyBDTEVBUltdIENMRUFSIHRoZSBzdGFja1xuLy8gMHgyMlxuZnVuY3Rpb24gQ0xFQVIoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0xFQVJbXScpOyB9XG5cbiAgICBzdGF0ZS5zdGFjay5sZW5ndGggPSAwO1xufVxuXG4vLyBTV0FQW10gU1dBUCB0aGUgdG9wIHR3byBlbGVtZW50cyBvbiB0aGUgc3RhY2tcbi8vIDB4MjNcbmZ1bmN0aW9uIFNXQVAoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIHZhciBhID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGIgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTV0FQW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChhKTtcbiAgICBzdGFjay5wdXNoKGIpO1xufVxuXG4vLyBERVBUSFtdIERFUFRIIG9mIHRoZSBzdGFja1xuLy8gMHgyNFxuZnVuY3Rpb24gREVQVEgoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdERVBUSFtdJyk7IH1cblxuICAgIHN0YWNrLnB1c2goc3RhY2subGVuZ3RoKTtcbn1cblxuLy8gTE9PUENBTExbXSBMT09QQ0FMTCBmdW5jdGlvblxuLy8gMHgyQVxuZnVuY3Rpb24gTE9PUENBTEwoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZm4gPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgYyA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0xPT1BDQUxMW10nLCBmbiwgYyk7IH1cblxuICAgIC8vIHNhdmVzIGNhbGxlcnMgcHJvZ3JhbVxuICAgIHZhciBjaXAgPSBzdGF0ZS5pcDtcbiAgICB2YXIgY3Byb2cgPSBzdGF0ZS5wcm9nO1xuXG4gICAgc3RhdGUucHJvZyA9IHN0YXRlLmZ1bmNzW2ZuXTtcblxuICAgIC8vIGV4ZWN1dGVzIHRoZSBmdW5jdGlvblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYzsgaSsrKSB7XG4gICAgICAgIGV4ZWMoc3RhdGUpO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgKytzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgaSArIDEgPCBjID8gJ25leHQgbG9vcGNhbGwnIDogJ2RvbmUgbG9vcGNhbGwnLFxuICAgICAgICAgICAgaVxuICAgICAgICApOyB9XG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZXMgdGhlIGNhbGxlcnMgcHJvZ3JhbVxuICAgIHN0YXRlLmlwID0gY2lwO1xuICAgIHN0YXRlLnByb2cgPSBjcHJvZztcbn1cblxuLy8gQ0FMTFtdIENBTEwgZnVuY3Rpb25cbi8vIDB4MkJcbmZ1bmN0aW9uIENBTEwoc3RhdGUpIHtcbiAgICB2YXIgZm4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdDQUxMW10nLCBmbik7IH1cblxuICAgIC8vIHNhdmVzIGNhbGxlcnMgcHJvZ3JhbVxuICAgIHZhciBjaXAgPSBzdGF0ZS5pcDtcbiAgICB2YXIgY3Byb2cgPSBzdGF0ZS5wcm9nO1xuXG4gICAgc3RhdGUucHJvZyA9IHN0YXRlLmZ1bmNzW2ZuXTtcblxuICAgIC8vIGV4ZWN1dGVzIHRoZSBmdW5jdGlvblxuICAgIGV4ZWMoc3RhdGUpO1xuXG4gICAgLy8gcmVzdG9yZXMgdGhlIGNhbGxlcnMgcHJvZ3JhbVxuICAgIHN0YXRlLmlwID0gY2lwO1xuICAgIHN0YXRlLnByb2cgPSBjcHJvZztcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKCsrc3RhdGUuc3RlcCwgJ3JldHVybmluZyBmcm9tJywgZm4pOyB9XG59XG5cbi8vIENJTkRFWFtdIENvcHkgdGhlIElOREVYZWQgZWxlbWVudCB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xuLy8gMHgyNVxuZnVuY3Rpb24gQ0lOREVYKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGsgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdDSU5ERVhbXScsIGspOyB9XG5cbiAgICAvLyBJbiBjYXNlIG9mIGsgPT0gMSwgaXQgY29waWVzIHRoZSBsYXN0IGVsZW1lbnQgYWZ0ZXIgcG9wcGluZ1xuICAgIC8vIHRodXMgc3RhY2subGVuZ3RoIC0gay5cbiAgICBzdGFjay5wdXNoKHN0YWNrW3N0YWNrLmxlbmd0aCAtIGtdKTtcbn1cblxuLy8gTUlOREVYW10gTW92ZSB0aGUgSU5ERVhlZCBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4vLyAweDI2XG5mdW5jdGlvbiBNSU5ERVgoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgayA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01JTkRFWFtdJywgayk7IH1cblxuICAgIHN0YWNrLnB1c2goc3RhY2suc3BsaWNlKHN0YWNrLmxlbmd0aCAtIGssIDEpWzBdKTtcbn1cblxuLy8gRkRFRltdIEZ1bmN0aW9uIERFRmluaXRpb25cbi8vIDB4MkNcbmZ1bmN0aW9uIEZERUYoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZW52ICE9PSAnZnBnbScpIHsgdGhyb3cgbmV3IEVycm9yKCdGREVGIG5vdCBhbGxvd2VkIGhlcmUnKTsgfVxuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcblxuICAgIHZhciBmbiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBpcEJlZ2luID0gaXA7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRkRFRltdJywgZm4pOyB9XG5cbiAgICB3aGlsZSAocHJvZ1srK2lwXSAhPT0gMHgyRCl7IH1cblxuICAgIHN0YXRlLmlwID0gaXA7XG4gICAgc3RhdGUuZnVuY3NbZm5dID0gcHJvZy5zbGljZShpcEJlZ2luICsgMSwgaXApO1xufVxuXG4vLyBNREFQW2FdIE1vdmUgRGlyZWN0IEFic29sdXRlIFBvaW50XG4vLyAweDJFLTB4MkZcbmZ1bmN0aW9uIE1EQVAocm91bmQsIHN0YXRlKSB7XG4gICAgdmFyIHBpID0gc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgdmFyIHAgPSBzdGF0ZS56MFtwaV07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTURBUFsnICsgcm91bmQgKyAnXScsIHBpKTsgfVxuXG4gICAgdmFyIGQgPSBwdi5kaXN0YW5jZShwLCBIUFplcm8pO1xuXG4gICAgaWYgKHJvdW5kKSB7IGQgPSBzdGF0ZS5yb3VuZChkKTsgfVxuXG4gICAgZnYuc2V0UmVsYXRpdmUocCwgSFBaZXJvLCBkLCBwdik7XG4gICAgZnYudG91Y2gocCk7XG5cbiAgICBzdGF0ZS5ycDAgPSBzdGF0ZS5ycDEgPSBwaTtcbn1cblxuLy8gSVVQW2FdIEludGVycG9sYXRlIFVudG91Y2hlZCBQb2ludHMgdGhyb3VnaCB0aGUgb3V0bGluZVxuLy8gMHgzMFxuZnVuY3Rpb24gSVVQKHYsIHN0YXRlKSB7XG4gICAgdmFyIHoyID0gc3RhdGUuejI7XG4gICAgdmFyIHBMZW4gPSB6Mi5sZW5ndGggLSAyO1xuICAgIHZhciBjcDtcbiAgICB2YXIgcHA7XG4gICAgdmFyIG5wO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0lVUFsnICsgdi5heGlzICsgJ10nKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwTGVuOyBpKyspIHtcbiAgICAgICAgY3AgPSB6MltpXTsgLy8gY3VycmVudCBwb2ludFxuXG4gICAgICAgIC8vIGlmIHRoaXMgcG9pbnQgaGFzIGJlZW4gdG91Y2hlZCBnbyBvblxuICAgICAgICBpZiAodi50b3VjaGVkKGNwKSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHBwID0gY3AucHJldlRvdWNoZWQodik7XG5cbiAgICAgICAgLy8gbm8gcG9pbnQgb24gdGhlIGNvbnRvdXIgaGFzIGJlZW4gdG91Y2hlZD9cbiAgICAgICAgaWYgKHBwID09PSBjcCkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIG5wID0gY3AubmV4dFRvdWNoZWQodik7XG5cbiAgICAgICAgaWYgKHBwID09PSBucCkge1xuICAgICAgICAgICAgLy8gb25seSBvbmUgcG9pbnQgb24gdGhlIGNvbnRvdXIgaGFzIGJlZW4gdG91Y2hlZFxuICAgICAgICAgICAgLy8gc28gc2ltcGx5IG1vdmVzIHRoZSBwb2ludCBsaWtlIHRoYXRcblxuICAgICAgICAgICAgdi5zZXRSZWxhdGl2ZShjcCwgY3AsIHYuZGlzdGFuY2UocHAsIHBwLCBmYWxzZSwgdHJ1ZSksIHYsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdi5pbnRlcnBvbGF0ZShjcCwgcHAsIG5wLCB2KTtcbiAgICB9XG59XG5cbi8vIFNIUFtdIFNIaWZ0IFBvaW50IHVzaW5nIHJlZmVyZW5jZSBwb2ludFxuLy8gMHgzMi0weDMzXG5mdW5jdGlvbiBTSFAoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcnBpID0gYSA/IHN0YXRlLnJwMSA6IHN0YXRlLnJwMjtcbiAgICB2YXIgcnAgPSAoYSA/IHN0YXRlLnowIDogc3RhdGUuejEpW3JwaV07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG4gICAgdmFyIGxvb3AgPSBzdGF0ZS5sb29wO1xuICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuXG4gICAgd2hpbGUgKGxvb3AtLSlcbiAgICB7XG4gICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcCA9IHoyW3BpXTtcblxuICAgICAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHJwLCBycCwgZmFsc2UsIHRydWUpO1xuICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkLCBwdik7XG4gICAgICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgICAgIChzdGF0ZS5sb29wID4gMSA/XG4gICAgICAgICAgICAgICAgICAgJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDpcbiAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAgICdTSFBbJyArIChhID8gJ3JwMScgOiAncnAyJykgKyAnXScsIHBpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUubG9vcCA9IDE7XG59XG5cbi8vIFNIQ1tdIFNIaWZ0IENvbnRvdXIgdXNpbmcgcmVmZXJlbmNlIHBvaW50XG4vLyAweDM2LTB4MzdcbmZ1bmN0aW9uIFNIQyhhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBycGkgPSBhID8gc3RhdGUucnAxIDogc3RhdGUucnAyO1xuICAgIHZhciBycCA9IChhID8gc3RhdGUuejAgOiBzdGF0ZS56MSlbcnBpXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcbiAgICB2YXIgY2kgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgc3AgPSBzdGF0ZS56MltzdGF0ZS5jb250b3Vyc1tjaV1dO1xuICAgIHZhciBwID0gc3A7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0hDWycgKyBhICsgJ10nLCBjaSk7IH1cblxuICAgIHZhciBkID0gcHYuZGlzdGFuY2UocnAsIHJwLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICBkbyB7XG4gICAgICAgIGlmIChwICE9PSBycCkgeyBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkLCBwdik7IH1cbiAgICAgICAgcCA9IHAubmV4dFBvaW50T25Db250b3VyO1xuICAgIH0gd2hpbGUgKHAgIT09IHNwKTtcbn1cblxuLy8gU0haW10gU0hpZnQgWm9uZSB1c2luZyByZWZlcmVuY2UgcG9pbnRcbi8vIDB4MzYtMHgzN1xuZnVuY3Rpb24gU0haKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHJwaSA9IGEgPyBzdGF0ZS5ycDEgOiBzdGF0ZS5ycDI7XG4gICAgdmFyIHJwID0gKGEgPyBzdGF0ZS56MCA6IHN0YXRlLnoxKVtycGldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG4gICAgdmFyIGUgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTSFpbJyArIGEgKyAnXScsIGUpOyB9XG5cbiAgICB2YXIgejtcbiAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSAwIDogeiA9IHN0YXRlLnRab25lOyBicmVhaztcbiAgICAgICAgY2FzZSAxIDogeiA9IHN0YXRlLmdab25lOyBicmVhaztcbiAgICAgICAgZGVmYXVsdCA6IHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lJyk7XG4gICAgfVxuXG4gICAgdmFyIHA7XG4gICAgdmFyIGQgPSBwdi5kaXN0YW5jZShycCwgcnAsIGZhbHNlLCB0cnVlKTtcbiAgICB2YXIgcExlbiA9IHoubGVuZ3RoIC0gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBMZW47IGkrKylcbiAgICB7XG4gICAgICAgIHAgPSB6W2ldO1xuICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkLCBwdik7XG4gICAgICAgIC8vaWYgKHAgIT09IHJwKSBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkLCBwdik7XG4gICAgfVxufVxuXG4vLyBTSFBJWFtdIFNIaWZ0IHBvaW50IGJ5IGEgUElYZWwgYW1vdW50XG4vLyAweDM4XG5mdW5jdGlvbiBTSFBJWChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBsb29wID0gc3RhdGUubG9vcDtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgZCA9IHN0YWNrLnBvcCgpIC8gMHg0MDtcbiAgICB2YXIgejIgPSBzdGF0ZS56MjtcblxuICAgIHdoaWxlIChsb29wLS0pIHtcbiAgICAgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBwID0gejJbcGldO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgICAgIChzdGF0ZS5sb29wID4gMSA/ICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgJ1NIUElYW10nLCBwaSwgZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQpO1xuICAgICAgICBmdi50b3VjaChwKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5sb29wID0gMTtcbn1cblxuLy8gSVBbXSBJbnRlcnBvbGF0ZSBQb2ludFxuLy8gMHgzOVxuZnVuY3Rpb24gSVAoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcnAxaSA9IHN0YXRlLnJwMTtcbiAgICB2YXIgcnAyaSA9IHN0YXRlLnJwMjtcbiAgICB2YXIgbG9vcCA9IHN0YXRlLmxvb3A7XG4gICAgdmFyIHJwMSA9IHN0YXRlLnowW3JwMWldO1xuICAgIHZhciBycDIgPSBzdGF0ZS56MVtycDJpXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5kcHY7XG4gICAgdmFyIHoyID0gc3RhdGUuejI7XG5cbiAgICB3aGlsZSAobG9vcC0tKSB7XG4gICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcCA9IHoyW3BpXTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgPyAnbG9vcCAnICsgKHN0YXRlLmxvb3AgLSBsb29wKSArICc6ICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICdJUFtdJywgcGksIHJwMWksICc8LT4nLCBycDJpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnYuaW50ZXJwb2xhdGUocCwgcnAxLCBycDIsIHB2KTtcblxuICAgICAgICBmdi50b3VjaChwKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5sb29wID0gMTtcbn1cblxuLy8gTVNJUlBbYV0gTW92ZSBTdGFjayBJbmRpcmVjdCBSZWxhdGl2ZSBQb2ludFxuLy8gMHgzQS0weDNCXG5mdW5jdGlvbiBNU0lSUChhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBkID0gc3RhY2sucG9wKCkgLyA2NDtcbiAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcCA9IHN0YXRlLnoxW3BpXTtcbiAgICB2YXIgcnAwID0gc3RhdGUuejBbc3RhdGUucnAwXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblxuICAgIGZ2LnNldFJlbGF0aXZlKHAsIHJwMCwgZCwgcHYpO1xuICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01TSVJQWycgKyBhICsgJ10nLCBkLCBwaSk7IH1cblxuICAgIHN0YXRlLnJwMSA9IHN0YXRlLnJwMDtcbiAgICBzdGF0ZS5ycDIgPSBwaTtcbiAgICBpZiAoYSkgeyBzdGF0ZS5ycDAgPSBwaTsgfVxufVxuXG4vLyBBTElHTlJQW10gQWxpZ24gdG8gcmVmZXJlbmNlIHBvaW50LlxuLy8gMHgzQ1xuZnVuY3Rpb24gQUxJR05SUChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBycDBpID0gc3RhdGUucnAwO1xuICAgIHZhciBycDAgPSBzdGF0ZS56MFtycDBpXTtcbiAgICB2YXIgbG9vcCA9IHN0YXRlLmxvb3A7XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG4gICAgdmFyIHoxID0gc3RhdGUuejE7XG5cbiAgICB3aGlsZSAobG9vcC0tKSB7XG4gICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcCA9IHoxW3BpXTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgPyAnbG9vcCAnICsgKHN0YXRlLmxvb3AgLSBsb29wKSArICc6ICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICdBTElHTlJQW10nLCBwaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ2LnNldFJlbGF0aXZlKHAsIHJwMCwgMCwgcHYpO1xuICAgICAgICBmdi50b3VjaChwKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5sb29wID0gMTtcbn1cblxuLy8gUlRHW10gUm91bmQgVG8gRG91YmxlIEdyaWRcbi8vIDB4M0RcbmZ1bmN0aW9uIFJUREcoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlRER1tdJyk7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRUb0RvdWJsZUdyaWQ7XG59XG5cbi8vIE1JQVBbYV0gTW92ZSBJbmRpcmVjdCBBYnNvbHV0ZSBQb2ludFxuLy8gMHgzRS0weDNGXG5mdW5jdGlvbiBNSUFQKHJvdW5kLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAgPSBzdGF0ZS56MFtwaV07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG4gICAgdmFyIGN2ID0gc3RhdGUuY3Z0W25dO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgJ01JQVBbJyArIHJvdW5kICsgJ10nLFxuICAgICAgICAgICAgbiwgJygnLCBjdiwgJyknLCBwaVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBkID0gcHYuZGlzdGFuY2UocCwgSFBaZXJvKTtcblxuICAgIGlmIChyb3VuZCkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZCAtIGN2KSA8IHN0YXRlLmN2Q3V0SW4pIHsgZCA9IGN2OyB9XG5cbiAgICAgICAgZCA9IHN0YXRlLnJvdW5kKGQpO1xuICAgIH1cblxuICAgIGZ2LnNldFJlbGF0aXZlKHAsIEhQWmVybywgZCwgcHYpO1xuXG4gICAgaWYgKHN0YXRlLnpwMCA9PT0gMCkge1xuICAgICAgICBwLnhvID0gcC54O1xuICAgICAgICBwLnlvID0gcC55O1xuICAgIH1cblxuICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgc3RhdGUucnAwID0gc3RhdGUucnAxID0gcGk7XG59XG5cbi8vIE5QVVNCW10gUFVTSCBOIEJ5dGVzXG4vLyAweDQwXG5mdW5jdGlvbiBOUFVTSEIoc3RhdGUpIHtcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgdmFyIGlwID0gc3RhdGUuaXA7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICB2YXIgbiA9IHByb2dbKytpcF07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTlBVU0hCW10nLCBuKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHsgc3RhY2sucHVzaChwcm9nWysraXBdKTsgfVxuXG4gICAgc3RhdGUuaXAgPSBpcDtcbn1cblxuLy8gTlBVU0hXW10gUFVTSCBOIFdvcmRzXG4vLyAweDQxXG5mdW5jdGlvbiBOUFVTSFcoc3RhdGUpIHtcbiAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBwcm9nWysraXBdO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05QVVNIV1tdJywgbik7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gKHByb2dbKytpcF0gPDwgOCkgfCBwcm9nWysraXBdO1xuICAgICAgICBpZiAodyAmIDB4ODAwMCkgeyB3ID0gLSgodyBeIDB4ZmZmZikgKyAxKTsgfVxuICAgICAgICBzdGFjay5wdXNoKHcpO1xuICAgIH1cblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8vIFdTW10gV3JpdGUgU3RvcmVcbi8vIDB4NDJcbmZ1bmN0aW9uIFdTKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHN0b3JlID0gc3RhdGUuc3RvcmU7XG5cbiAgICBpZiAoIXN0b3JlKSB7IHN0b3JlID0gc3RhdGUuc3RvcmUgPSBbXTsgfVxuXG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1dTJywgdiwgbCk7IH1cblxuICAgIHN0b3JlW2xdID0gdjtcbn1cblxuLy8gUlNbXSBSZWFkIFN0b3JlXG4vLyAweDQzXG5mdW5jdGlvbiBSUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBzdG9yZSA9IHN0YXRlLnN0b3JlO1xuXG4gICAgdmFyIGwgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSUycsIGwpOyB9XG5cbiAgICB2YXIgdiA9IChzdG9yZSAmJiBzdG9yZVtsXSkgfHwgMDtcblxuICAgIHN0YWNrLnB1c2godik7XG59XG5cbi8vIFdDVlRQW10gV3JpdGUgQ29udHJvbCBWYWx1ZSBUYWJsZSBpbiBQaXhlbCB1bml0c1xuLy8gMHg0NFxuZnVuY3Rpb24gV0NWVFAoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGwgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdXQ1ZUUCcsIHYsIGwpOyB9XG5cbiAgICBzdGF0ZS5jdnRbbF0gPSB2IC8gMHg0MDtcbn1cblxuLy8gUkNWVFtdIFJlYWQgQ29udHJvbCBWYWx1ZSBUYWJsZSBlbnRyeVxuLy8gMHg0NVxuZnVuY3Rpb24gUkNWVChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBjdnRlID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUkNWVCcsIGN2dGUpOyB9XG5cbiAgICBzdGFjay5wdXNoKHN0YXRlLmN2dFtjdnRlXSAqIDB4NDApO1xufVxuXG4vLyBHQ1tdIEdldCBDb29yZGluYXRlIHByb2plY3RlZCBvbnRvIHRoZSBwcm9qZWN0aW9uIHZlY3RvclxuLy8gMHg0Ni0weDQ3XG5mdW5jdGlvbiBHQyhhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwID0gc3RhdGUuejJbcGldO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dDWycgKyBhICsgJ10nLCBwaSk7IH1cblxuICAgIHN0YWNrLnB1c2goc3RhdGUuZHB2LmRpc3RhbmNlKHAsIEhQWmVybywgYSwgZmFsc2UpICogMHg0MCk7XG59XG5cbi8vIE1EW2FdIE1lYXN1cmUgRGlzdGFuY2Vcbi8vIDB4NDktMHg0QVxuZnVuY3Rpb24gTUQoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcGkyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBpMSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMiA9IHN0YXRlLnoxW3BpMl07XG4gICAgdmFyIHAxID0gc3RhdGUuejBbcGkxXTtcbiAgICB2YXIgZCA9IHN0YXRlLmRwdi5kaXN0YW5jZShwMSwgcDIsIGEsIGEpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01EWycgKyBhICsgJ10nLCBwaTIsIHBpMSwgJy0+JywgZCk7IH1cblxuICAgIHN0YXRlLnN0YWNrLnB1c2goTWF0aC5yb3VuZChkICogNjQpKTtcbn1cblxuLy8gTVBQRU1bXSBNZWFzdXJlIFBpeGVscyBQZXIgRU1cbi8vIDB4NEJcbmZ1bmN0aW9uIE1QUEVNKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01QUEVNW10nKTsgfVxuICAgIHN0YXRlLnN0YWNrLnB1c2goc3RhdGUucHBlbSk7XG59XG5cbi8vIEZMSVBPTltdIHNldCB0aGUgYXV0byBGTElQIEJvb2xlYW4gdG8gT05cbi8vIDB4NERcbmZ1bmN0aW9uIEZMSVBPTihzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdGTElQT05bXScpOyB9XG4gICAgc3RhdGUuYXV0b0ZsaXAgPSB0cnVlO1xufVxuXG4vLyBMVFtdIExlc3MgVGhhblxuLy8gMHg1MFxuZnVuY3Rpb24gTFQoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdMVFtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMSA8IGUyID8gMSA6IDApO1xufVxuXG4vLyBMVEVRW10gTGVzcyBUaGFuIG9yIEVRdWFsXG4vLyAweDUzXG5mdW5jdGlvbiBMVEVRKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTFRFUVtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMSA8PSBlMiA/IDEgOiAwKTtcbn1cblxuLy8gR1RFUVtdIEdyZWF0ZXIgVGhhblxuLy8gMHg1MlxuZnVuY3Rpb24gR1Qoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHVFtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMSA+IGUyID8gMSA6IDApO1xufVxuXG4vLyBHVEVRW10gR3JlYXRlciBUaGFuIG9yIEVRdWFsXG4vLyAweDUzXG5mdW5jdGlvbiBHVEVRKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR1RFUVtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMSA+PSBlMiA/IDEgOiAwKTtcbn1cblxuLy8gRVFbXSBFUXVhbFxuLy8gMHg1NFxuZnVuY3Rpb24gRVEoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFUVtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMiA9PT0gZTEgPyAxIDogMCk7XG59XG5cbi8vIE5FUVtdIE5vdCBFUXVhbFxuLy8gMHg1NVxuZnVuY3Rpb24gTkVRKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTkVRW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUyICE9PSBlMSA/IDEgOiAwKTtcbn1cblxuLy8gT0REW10gT0REXG4vLyAweDU2XG5mdW5jdGlvbiBPREQoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ09ERFtdJywgbik7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC50cnVuYyhuKSAlIDIgPyAxIDogMCk7XG59XG5cbi8vIEVWRU5bXSBFVkVOXG4vLyAweDU3XG5mdW5jdGlvbiBFVkVOKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFVkVOW10nLCBuKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLnRydW5jKG4pICUgMiA/IDAgOiAxKTtcbn1cblxuLy8gSUZbXSBJRiB0ZXN0XG4vLyAweDU4XG5mdW5jdGlvbiBJRihzdGF0ZSkge1xuICAgIHZhciB0ZXN0ID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnSUZbXScsIHRlc3QpOyB9XG5cbiAgICAvLyBpZiB0ZXN0IGlzIHRydWUgaXQganVzdCBjb250aW51ZXNcbiAgICAvLyBpZiBub3QgdGhlIGlwIGlzIHNraXBwZWQgdW50aWwgbWF0Y2hpbmcgRUxTRSBvciBFSUZcbiAgICBpZiAoIXRlc3QpIHtcbiAgICAgICAgc2tpcChzdGF0ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgICdFSUZbXScpOyB9XG4gICAgfVxufVxuXG4vLyBFSUZbXSBFbmQgSUZcbi8vIDB4NTlcbmZ1bmN0aW9uIEVJRihzdGF0ZSkge1xuICAgIC8vIHRoaXMgY2FuIGJlIHJlYWNoZWQgbm9ybWFsbHkgd2hlblxuICAgIC8vIGV4ZWN1dGluZyBhbiBlbHNlIGJyYW5jaC5cbiAgICAvLyAtPiBqdXN0IGlnbm9yZSBpdFxuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0VJRltdJyk7IH1cbn1cblxuLy8gQU5EW10gbG9naWNhbCBBTkRcbi8vIDB4NUFcbmZ1bmN0aW9uIEFORChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0FORFtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMiAmJiBlMSA/IDEgOiAwKTtcbn1cblxuLy8gT1JbXSBsb2dpY2FsIE9SXG4vLyAweDVCXG5mdW5jdGlvbiBPUihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ09SW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUyIHx8IGUxID8gMSA6IDApO1xufVxuXG4vLyBOT1RbXSBsb2dpY2FsIE5PVFxuLy8gMHg1Q1xuZnVuY3Rpb24gTk9UKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdOT1RbXScsIGUpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUgPyAwIDogMSk7XG59XG5cbi8vIERFTFRBUDFbXSBERUxUQSBleGNlcHRpb24gUDFcbi8vIERFTFRBUDJbXSBERUxUQSBleGNlcHRpb24gUDJcbi8vIERFTFRBUDNbXSBERUxUQSBleGNlcHRpb24gUDNcbi8vIDB4NUQsIDB4NzEsIDB4NzJcbmZ1bmN0aW9uIERFTFRBUDEyMyhiLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG4gICAgdmFyIHBwZW0gPSBzdGF0ZS5wcGVtO1xuICAgIHZhciBiYXNlID0gc3RhdGUuZGVsdGFCYXNlICsgKGIgLSAxKSAqIDE2O1xuICAgIHZhciBkcyA9IHN0YXRlLmRlbHRhU2hpZnQ7XG4gICAgdmFyIHowID0gc3RhdGUuejA7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFQWycgKyBiICsgJ10nLCBuLCBzdGFjayk7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgYXJnID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBhcHBlbSA9IGJhc2UgKyAoKGFyZyAmIDB4RjApID4+IDQpO1xuICAgICAgICBpZiAoYXBwZW0gIT09IHBwZW0pIHsgY29udGludWU7IH1cblxuICAgICAgICB2YXIgbWFnID0gKGFyZyAmIDB4MEYpIC0gODtcbiAgICAgICAgaWYgKG1hZyA+PSAwKSB7IG1hZysrOyB9XG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdERUxUQVBGSVgnLCBwaSwgJ2J5JywgbWFnICogZHMpOyB9XG5cbiAgICAgICAgdmFyIHAgPSB6MFtwaV07XG4gICAgICAgIGZ2LnNldFJlbGF0aXZlKHAsIHAsIG1hZyAqIGRzLCBwdik7XG4gICAgfVxufVxuXG4vLyBTREJbXSBTZXQgRGVsdGEgQmFzZSBpbiB0aGUgZ3JhcGhpY3Mgc3RhdGVcbi8vIDB4NUVcbmZ1bmN0aW9uIFNEQihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0RCW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuZGVsdGFCYXNlID0gbjtcbn1cblxuLy8gU0RTW10gU2V0IERlbHRhIFNoaWZ0IGluIHRoZSBncmFwaGljcyBzdGF0ZVxuLy8gMHg1RlxuZnVuY3Rpb24gU0RTKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRFNbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS5kZWx0YVNoaWZ0ID0gTWF0aC5wb3coMC41LCBuKTtcbn1cblxuLy8gQUREW10gQUREXG4vLyAweDYwXG5mdW5jdGlvbiBBREQoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbjIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdBRERbXScsIG4yLCBuMSk7IH1cblxuICAgIHN0YWNrLnB1c2gobjEgKyBuMik7XG59XG5cbi8vIFNVQltdIFNVQlxuLy8gMHg2MVxuZnVuY3Rpb24gU1VCKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4yID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIG4xID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1VCW10nLCBuMiwgbjEpOyB9XG5cbiAgICBzdGFjay5wdXNoKG4xIC0gbjIpO1xufVxuXG4vLyBESVZbXSBESVZcbi8vIDB4NjJcbmZ1bmN0aW9uIERJVihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBuMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RJVltdJywgbjIsIG4xKTsgfVxuXG4gICAgc3RhY2sucHVzaChuMSAqIDY0IC8gbjIpO1xufVxuXG4vLyBNVUxbXSBNVUxcbi8vIDB4NjNcbmZ1bmN0aW9uIE1VTChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBuMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01VTFtdJywgbjIsIG4xKTsgfVxuXG4gICAgc3RhY2sucHVzaChuMSAqIG4yIC8gNjQpO1xufVxuXG4vLyBBQlNbXSBBQlNvbHV0ZSB2YWx1ZVxuLy8gMHg2NFxuZnVuY3Rpb24gQUJTKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdBQlNbXScsIG4pOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGguYWJzKG4pKTtcbn1cblxuLy8gTkVHW10gTkVHYXRlXG4vLyAweDY1XG5mdW5jdGlvbiBORUcoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05FR1tdJywgbik7IH1cblxuICAgIHN0YWNrLnB1c2goLW4pO1xufVxuXG4vLyBGTE9PUltdIEZMT09SXG4vLyAweDY2XG5mdW5jdGlvbiBGTE9PUihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRkxPT1JbXScsIG4pOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGguZmxvb3IobiAvIDB4NDApICogMHg0MCk7XG59XG5cbi8vIENFSUxJTkdbXSBDRUlMSU5HXG4vLyAweDY3XG5mdW5jdGlvbiBDRUlMSU5HKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdDRUlMSU5HW10nLCBuKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLmNlaWwobiAvIDB4NDApICogMHg0MCk7XG59XG5cbi8vIFJPVU5EW2FiXSBST1VORCB2YWx1ZVxuLy8gMHg2OC0weDZCXG5mdW5jdGlvbiBST1VORChkdCwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JPVU5EW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGF0ZS5yb3VuZChuIC8gMHg0MCkgKiAweDQwKTtcbn1cblxuLy8gV0NWVEZbXSBXcml0ZSBDb250cm9sIFZhbHVlIFRhYmxlIGluIEZ1bml0c1xuLy8gMHg3MFxuZnVuY3Rpb24gV0NWVEYoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnV0NWVEZbXScsIHYsIGwpOyB9XG5cbiAgICBzdGF0ZS5jdnRbbF0gPSB2ICogc3RhdGUucHBlbSAvIHN0YXRlLmZvbnQudW5pdHNQZXJFbTtcbn1cblxuLy8gREVMVEFDMVtdIERFTFRBIGV4Y2VwdGlvbiBDMVxuLy8gREVMVEFDMltdIERFTFRBIGV4Y2VwdGlvbiBDMlxuLy8gREVMVEFDM1tdIERFTFRBIGV4Y2VwdGlvbiBDM1xuLy8gMHg3MywgMHg3NCwgMHg3NVxuZnVuY3Rpb24gREVMVEFDMTIzKGIsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcHBlbSA9IHN0YXRlLnBwZW07XG4gICAgdmFyIGJhc2UgPSBzdGF0ZS5kZWx0YUJhc2UgKyAoYiAtIDEpICogMTY7XG4gICAgdmFyIGRzID0gc3RhdGUuZGVsdGFTaGlmdDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdERUxUQUNbJyArIGIgKyAnXScsIG4sIHN0YWNrKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIGFyZyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgYXBwZW0gPSBiYXNlICsgKChhcmcgJiAweEYwKSA+PiA0KTtcbiAgICAgICAgaWYgKGFwcGVtICE9PSBwcGVtKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIG1hZyA9IChhcmcgJiAweDBGKSAtIDg7XG4gICAgICAgIGlmIChtYWcgPj0gMCkgeyBtYWcrKzsgfVxuXG4gICAgICAgIHZhciBkZWx0YSA9IG1hZyAqIGRzO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdERUxUQUNGSVgnLCBjLCAnYnknLCBkZWx0YSk7IH1cblxuICAgICAgICBzdGF0ZS5jdnRbY10gKz0gZGVsdGE7XG4gICAgfVxufVxuXG4vLyBTUk9VTkRbXSBTdXBlciBST1VORFxuLy8gMHg3NlxuZnVuY3Rpb24gU1JPVU5EKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUk9VTkRbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kU3VwZXI7XG5cbiAgICB2YXIgcGVyaW9kO1xuXG4gICAgc3dpdGNoIChuICYgMHhDMCkge1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICBwZXJpb2QgPSAwLjU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDQwOlxuICAgICAgICAgICAgcGVyaW9kID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4ODA6XG4gICAgICAgICAgICBwZXJpb2QgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgU1JPVU5EIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgc3RhdGUuc3JQZXJpb2QgPSBwZXJpb2Q7XG5cbiAgICBzd2l0Y2ggKG4gJiAweDMwKSB7XG4gICAgICAgIGNhc2UgMHgwMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjI1ICogcGVyaW9kO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgyMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjUgICogcGVyaW9kO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgzMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjc1ICogcGVyaW9kO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTUk9VTkQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBuICY9IDB4MEY7XG5cbiAgICBpZiAobiA9PT0gMCkgeyBzdGF0ZS5zclRocmVzaG9sZCA9IDA7IH1cbiAgICBlbHNlIHsgc3RhdGUuc3JUaHJlc2hvbGQgPSAobiAvIDggLSAwLjUpICogcGVyaW9kOyB9XG59XG5cbi8vIFM0NVJPVU5EW10gU3VwZXIgUk9VTkQgNDUgZGVncmVlc1xuLy8gMHg3N1xuZnVuY3Rpb24gUzQ1Uk9VTkQoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1M0NVJPVU5EW10nLCBuKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFN1cGVyO1xuXG4gICAgdmFyIHBlcmlvZDtcblxuICAgIHN3aXRjaCAobiAmIDB4QzApIHtcbiAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgcGVyaW9kID0gTWF0aC5zcXJ0KDIpIC8gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4NDA6XG4gICAgICAgICAgICBwZXJpb2QgPSBNYXRoLnNxcnQoMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDgwOlxuICAgICAgICAgICAgcGVyaW9kID0gMiAqIE1hdGguc3FydCgyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFM0NVJPVU5EIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgc3RhdGUuc3JQZXJpb2QgPSBwZXJpb2Q7XG5cbiAgICBzd2l0Y2ggKG4gJiAweDMwKSB7XG4gICAgICAgIGNhc2UgMHgwMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjI1ICogcGVyaW9kO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgyMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjUgICogcGVyaW9kO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgzMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjc1ICogcGVyaW9kO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUzQ1Uk9VTkQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBuICY9IDB4MEY7XG5cbiAgICBpZiAobiA9PT0gMCkgeyBzdGF0ZS5zclRocmVzaG9sZCA9IDA7IH1cbiAgICBlbHNlIHsgc3RhdGUuc3JUaHJlc2hvbGQgPSAobiAvIDggLSAwLjUpICogcGVyaW9kOyB9XG59XG5cbi8vIFJPRkZbXSBSb3VuZCBPZmZcbi8vIDB4N0FcbmZ1bmN0aW9uIFJPRkYoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUk9GRltdJyk7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRPZmY7XG59XG5cbi8vIFJVVEdbXSBSb3VuZCBVcCBUbyBHcmlkXG4vLyAweDdDXG5mdW5jdGlvbiBSVVRHKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JVVEdbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVXBUb0dyaWQ7XG59XG5cbi8vIFJEVEdbXSBSb3VuZCBEb3duIFRvIEdyaWRcbi8vIDB4N0RcbmZ1bmN0aW9uIFJEVEcoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUkRUR1tdJyk7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmREb3duVG9HcmlkO1xufVxuXG4vLyBTQ0FOQ1RSTFtdIFNDQU4gY29udmVyc2lvbiBDb25UUm9MXG4vLyAweDg1XG5mdW5jdGlvbiBTQ0FOQ1RSTChzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICAvLyBpZ25vcmVkIGJ5IG9wZW50eXBlLmpzXG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0NBTkNUUkxbXScsIG4pOyB9XG59XG5cbi8vIFNEUFZUTFthXSBTZXQgRHVhbCBQcm9qZWN0aW9uIFZlY3RvciBUbyBMaW5lXG4vLyAweDg2LTB4ODdcbmZ1bmN0aW9uIFNEUFZUTChhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwMmkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDFpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAyID0gc3RhdGUuejJbcDJpXTtcbiAgICB2YXIgcDEgPSBzdGF0ZS56MVtwMWldO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NEUFZUTFsnICsgYSArICddJywgcDJpLCBwMWkpOyB9XG5cbiAgICB2YXIgZHg7XG4gICAgdmFyIGR5O1xuXG4gICAgaWYgKCFhKSB7XG4gICAgICAgIGR4ID0gcDEueCAtIHAyLng7XG4gICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBwMi55IC0gcDEueTtcbiAgICAgICAgZHkgPSBwMS54IC0gcDIueDtcbiAgICB9XG5cbiAgICBzdGF0ZS5kcHYgPSBnZXRVbml0VmVjdG9yKGR4LCBkeSk7XG59XG5cbi8vIEdFVElORk9bXSBHRVQgSU5GT3JtYXRpb25cbi8vIDB4ODhcbmZ1bmN0aW9uIEdFVElORk8oc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgc2VsID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHIgPSAwO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dFVElORk9bXScsIHNlbCk7IH1cblxuICAgIC8vIHYzNSBhcyBpbiBubyBzdWJwaXhlbCBoaW50aW5nXG4gICAgaWYgKHNlbCAmIDB4MDEpIHsgciA9IDM1OyB9XG5cbiAgICAvLyBUT0RPIHJvdGF0aW9uIGFuZCBzdHJldGNoIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXG4gICAgLy8gYW5kIHRodXMgdGhvc2UgR0VUSU5GTyBhcmUgYWx3YXlzIDAuXG5cbiAgICAvLyBvcGVudHlwZS5qcyBpcyBhbHdheXMgZ3JheSBzY2FsaW5nXG4gICAgaWYgKHNlbCAmIDB4MjApIHsgciB8PSAweDEwMDA7IH1cblxuICAgIHN0YWNrLnB1c2gocik7XG59XG5cbi8vIFJPTExbXSBST0xMIHRoZSB0b3AgdGhyZWUgc3RhY2sgZWxlbWVudHNcbi8vIDB4OEFcbmZ1bmN0aW9uIFJPTEwoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgYSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBiID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGMgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdST0xMW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChiKTtcbiAgICBzdGFjay5wdXNoKGEpO1xuICAgIHN0YWNrLnB1c2goYyk7XG59XG5cbi8vIE1BWFtdIE1BWGltdW0gb2YgdG9wIHR3byBzdGFjayBlbGVtZW50c1xuLy8gMHg4QlxuZnVuY3Rpb24gTUFYKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTUFYW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGgubWF4KGUxLCBlMikpO1xufVxuXG4vLyBNSU5bXSBNSU5pbXVtIG9mIHRvcCB0d28gc3RhY2sgZWxlbWVudHNcbi8vIDB4OENcbmZ1bmN0aW9uIE1JTihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01JTltdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLm1pbihlMSwgZTIpKTtcbn1cblxuLy8gU0NBTlRZUEVbXSBTQ0FOVFlQRVxuLy8gMHg4RFxuZnVuY3Rpb24gU0NBTlRZUEUoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgIC8vIGlnbm9yZWQgYnkgb3BlbnR5cGUuanNcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0NBTlRZUEVbXScsIG4pOyB9XG59XG5cbi8vIElOU1RDVFJMW10gSU5TVENUUkxcbi8vIDB4OERcbmZ1bmN0aW9uIElOU1RDVFJMKHN0YXRlKSB7XG4gICAgdmFyIHMgPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICB2YXIgdiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0lOU1RDVFJMW10nLCBzLCB2KTsgfVxuXG4gICAgc3dpdGNoIChzKSB7XG4gICAgICAgIGNhc2UgMSA6IHN0YXRlLmluaGliaXRHcmlkRml0ID0gISF2OyByZXR1cm47XG4gICAgICAgIGNhc2UgMiA6IHN0YXRlLmlnbm9yZUN2dCA9ICEhdjsgcmV0dXJuO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgSU5TVENUUkxbXSBzZWxlY3RvcicpO1xuICAgIH1cbn1cblxuLy8gUFVTSEJbYWJjXSBQVVNIIEJ5dGVzXG4vLyAweEIwLTB4QjdcbmZ1bmN0aW9uIFBVU0hCKG4sIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1BVU0hCWycgKyBuICsgJ10nKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHsgc3RhY2sucHVzaChwcm9nWysraXBdKTsgfVxuXG4gICAgc3RhdGUuaXAgPSBpcDtcbn1cblxuLy8gUFVTSFdbYWJjXSBQVVNIIFdvcmRzXG4vLyAweEI4LTB4QkZcbmZ1bmN0aW9uIFBVU0hXKG4sIHN0YXRlKSB7XG4gICAgdmFyIGlwID0gc3RhdGUuaXA7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuaXAsICdQVVNIV1snICsgbiArICddJyk7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gKHByb2dbKytpcF0gPDwgOCkgfCBwcm9nWysraXBdO1xuICAgICAgICBpZiAodyAmIDB4ODAwMCkgeyB3ID0gLSgodyBeIDB4ZmZmZikgKyAxKTsgfVxuICAgICAgICBzdGFjay5wdXNoKHcpO1xuICAgIH1cblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8vIE1EUlBbYWJjZGVdIE1vdmUgRGlyZWN0IFJlbGF0aXZlIFBvaW50XG4vLyAweEQwLTB4RUZcbi8vIChpZiBpbmRpcmVjdCBpcyAwKVxuLy9cbi8vIGFuZFxuLy9cbi8vIE1JUlBbYWJjZGVdIE1vdmUgSW5kaXJlY3QgUmVsYXRpdmUgUG9pbnRcbi8vIDB4RTAtMHhGRlxuLy8gKGlmIGluZGlyZWN0IGlzIDEpXG5cbmZ1bmN0aW9uIE1EUlBfTUlSUChpbmRpcmVjdCwgc2V0UnAwLCBrZWVwRCwgcm8sIGR0LCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBjdnRlID0gaW5kaXJlY3QgJiYgc3RhY2sucG9wKCk7XG4gICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHJwMGkgPSBzdGF0ZS5ycDA7XG4gICAgdmFyIHJwID0gc3RhdGUuejBbcnAwaV07XG4gICAgdmFyIHAgPSBzdGF0ZS56MVtwaV07XG5cbiAgICB2YXIgbWQgPSBzdGF0ZS5taW5EaXM7XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUuZHB2O1xuICAgIHZhciBvZDsgLy8gb3JpZ2luYWwgZGlzdGFuY2VcbiAgICB2YXIgZDsgLy8gbW92aW5nIGRpc3RhbmNlXG4gICAgdmFyIHNpZ247IC8vIHNpZ24gb2YgZGlzdGFuY2VcbiAgICB2YXIgY3Y7XG5cbiAgICBkID0gb2QgPSBwdi5kaXN0YW5jZShwLCBycCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgc2lnbiA9IGQgPj0gMCA/IDEgOiAtMTsgLy8gTWF0aC5zaWduIHdvdWxkIGJlIDAgaW4gY2FzZSBvZiAwXG5cbiAgICAvLyBUT0RPIGNvbnNpZGVyIGF1dG9GbGlwXG4gICAgZCA9IE1hdGguYWJzKGQpO1xuXG4gICAgaWYgKGluZGlyZWN0KSB7XG4gICAgICAgIGN2ID0gc3RhdGUuY3Z0W2N2dGVdO1xuXG4gICAgICAgIGlmIChybyAmJiBNYXRoLmFicyhkIC0gY3YpIDwgc3RhdGUuY3ZDdXRJbikgeyBkID0gY3Y7IH1cbiAgICB9XG5cbiAgICBpZiAoa2VlcEQgJiYgZCA8IG1kKSB7IGQgPSBtZDsgfVxuXG4gICAgaWYgKHJvKSB7IGQgPSBzdGF0ZS5yb3VuZChkKTsgfVxuXG4gICAgZnYuc2V0UmVsYXRpdmUocCwgcnAsIHNpZ24gKiBkLCBwdik7XG4gICAgZnYudG91Y2gocCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAoaW5kaXJlY3QgPyAnTUlSUFsnIDogJ01EUlBbJykgK1xuICAgICAgICAgICAgKHNldFJwMCA/ICdNJyA6ICdtJykgK1xuICAgICAgICAgICAgKGtlZXBEID8gJz4nIDogJ18nKSArXG4gICAgICAgICAgICAocm8gPyAnUicgOiAnXycpICtcbiAgICAgICAgICAgIChkdCA9PT0gMCA/ICdHcicgOiAoZHQgPT09IDEgPyAnQmwnIDogKGR0ID09PSAyID8gJ1doJyA6ICcnKSkpICtcbiAgICAgICAgICAgICddJyxcbiAgICAgICAgICAgIGluZGlyZWN0ID9cbiAgICAgICAgICAgICAgICBjdnRlICsgJygnICsgc3RhdGUuY3Z0W2N2dGVdICsgJywnICsgIGN2ICsgJyknIDpcbiAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIHBpLFxuICAgICAgICAgICAgJyhkID0nLCBvZCwgJy0+Jywgc2lnbiAqIGQsICcpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRlLnJwMSA9IHN0YXRlLnJwMDtcbiAgICBzdGF0ZS5ycDIgPSBwaTtcbiAgICBpZiAoc2V0UnAwKSB7IHN0YXRlLnJwMCA9IHBpOyB9XG59XG5cbi8qXG4qIFRoZSBpbnN0cnVjdGlvbiB0YWJsZS5cbiovXG5pbnN0cnVjdGlvblRhYmxlID0gW1xuICAgIC8qIDB4MDAgKi8gU1ZUQ0EuYmluZCh1bmRlZmluZWQsIHlVbml0VmVjdG9yKSxcbiAgICAvKiAweDAxICovIFNWVENBLmJpbmQodW5kZWZpbmVkLCB4VW5pdFZlY3RvciksXG4gICAgLyogMHgwMiAqLyBTUFZUQ0EuYmluZCh1bmRlZmluZWQsIHlVbml0VmVjdG9yKSxcbiAgICAvKiAweDAzICovIFNQVlRDQS5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDQgKi8gU0ZWVENBLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG4gICAgLyogMHgwNSAqLyBTRlZUQ0EuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcbiAgICAvKiAweDA2ICovIFNQVlRMLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDA3ICovIFNQVlRMLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDA4ICovIFNGVlRMLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDA5ICovIFNGVlRMLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDBBICovIFNQVkZTLFxuICAgIC8qIDB4MEIgKi8gU0ZWRlMsXG4gICAgLyogMHgwQyAqLyBHUFYsXG4gICAgLyogMHgwRCAqLyBHRlYsXG4gICAgLyogMHgwRSAqLyBTRlZUUFYsXG4gICAgLyogMHgwRiAqLyBJU0VDVCxcbiAgICAvKiAweDEwICovIFNSUDAsXG4gICAgLyogMHgxMSAqLyBTUlAxLFxuICAgIC8qIDB4MTIgKi8gU1JQMixcbiAgICAvKiAweDEzICovIFNaUDAsXG4gICAgLyogMHgxNCAqLyBTWlAxLFxuICAgIC8qIDB4MTUgKi8gU1pQMixcbiAgICAvKiAweDE2ICovIFNaUFMsXG4gICAgLyogMHgxNyAqLyBTTE9PUCxcbiAgICAvKiAweDE4ICovIFJURyxcbiAgICAvKiAweDE5ICovIFJUSEcsXG4gICAgLyogMHgxQSAqLyBTTUQsXG4gICAgLyogMHgxQiAqLyBFTFNFLFxuICAgIC8qIDB4MUMgKi8gSk1QUixcbiAgICAvKiAweDFEICovIFNDVlRDSSxcbiAgICAvKiAweDFFICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIFNTV0NJXG4gICAgLyogMHgxRiAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBTU1dcbiAgICAvKiAweDIwICovIERVUCxcbiAgICAvKiAweDIxICovIFBPUCxcbiAgICAvKiAweDIyICovIENMRUFSLFxuICAgIC8qIDB4MjMgKi8gU1dBUCxcbiAgICAvKiAweDI0ICovIERFUFRILFxuICAgIC8qIDB4MjUgKi8gQ0lOREVYLFxuICAgIC8qIDB4MjYgKi8gTUlOREVYLFxuICAgIC8qIDB4MjcgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gQUxJR05QVFNcbiAgICAvKiAweDI4ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDI5ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIFVUUFxuICAgIC8qIDB4MkEgKi8gTE9PUENBTEwsXG4gICAgLyogMHgyQiAqLyBDQUxMLFxuICAgIC8qIDB4MkMgKi8gRkRFRixcbiAgICAvKiAweDJEICovIHVuZGVmaW5lZCwgICAvLyBFTkRGIChlYXRlbiBieSBGREVGKVxuICAgIC8qIDB4MkUgKi8gTURBUC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgyRiAqLyBNREFQLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDMwICovIElVUC5iaW5kKHVuZGVmaW5lZCwgeVVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MzEgKi8gSVVQLmJpbmQodW5kZWZpbmVkLCB4VW5pdFZlY3RvciksXG4gICAgLyogMHgzMiAqLyBTSFAuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MzMgKi8gU0hQLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDM0ICovIFNIQy5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgzNSAqLyBTSEMuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MzYgKi8gU0haLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDM3ICovIFNIWi5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgzOCAqLyBTSFBJWCxcbiAgICAvKiAweDM5ICovIElQLFxuICAgIC8qIDB4M0EgKi8gTVNJUlAuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4M0IgKi8gTVNJUlAuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4M0MgKi8gQUxJR05SUCxcbiAgICAvKiAweDNEICovIFJUREcsXG4gICAgLyogMHgzRSAqLyBNSUFQLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDNGICovIE1JQVAuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NDAgKi8gTlBVU0hCLFxuICAgIC8qIDB4NDEgKi8gTlBVU0hXLFxuICAgIC8qIDB4NDIgKi8gV1MsXG4gICAgLyogMHg0MyAqLyBSUyxcbiAgICAvKiAweDQ0ICovIFdDVlRQLFxuICAgIC8qIDB4NDUgKi8gUkNWVCxcbiAgICAvKiAweDQ2ICovIEdDLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDQ3ICovIEdDLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDQ4ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIFNDRlNcbiAgICAvKiAweDQ5ICovIE1ELmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDRBICovIE1ELmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDRCICovIE1QUEVNLFxuICAgIC8qIDB4NEMgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTVBTXG4gICAgLyogMHg0RCAqLyBGTElQT04sXG4gICAgLyogMHg0RSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBGTElQT0ZGXG4gICAgLyogMHg0RiAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBERUJVR1xuICAgIC8qIDB4NTAgKi8gTFQsXG4gICAgLyogMHg1MSAqLyBMVEVRLFxuICAgIC8qIDB4NTIgKi8gR1QsXG4gICAgLyogMHg1MyAqLyBHVEVRLFxuICAgIC8qIDB4NTQgKi8gRVEsXG4gICAgLyogMHg1NSAqLyBORVEsXG4gICAgLyogMHg1NiAqLyBPREQsXG4gICAgLyogMHg1NyAqLyBFVkVOLFxuICAgIC8qIDB4NTggKi8gSUYsXG4gICAgLyogMHg1OSAqLyBFSUYsXG4gICAgLyogMHg1QSAqLyBBTkQsXG4gICAgLyogMHg1QiAqLyBPUixcbiAgICAvKiAweDVDICovIE5PVCxcbiAgICAvKiAweDVEICovIERFTFRBUDEyMy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg1RSAqLyBTREIsXG4gICAgLyogMHg1RiAqLyBTRFMsXG4gICAgLyogMHg2MCAqLyBBREQsXG4gICAgLyogMHg2MSAqLyBTVUIsXG4gICAgLyogMHg2MiAqLyBESVYsXG4gICAgLyogMHg2MyAqLyBNVUwsXG4gICAgLyogMHg2NCAqLyBBQlMsXG4gICAgLyogMHg2NSAqLyBORUcsXG4gICAgLyogMHg2NiAqLyBGTE9PUixcbiAgICAvKiAweDY3ICovIENFSUxJTkcsXG4gICAgLyogMHg2OCAqLyBST1VORC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHg2OSAqLyBST1VORC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg2QSAqLyBST1VORC5iaW5kKHVuZGVmaW5lZCwgMiksXG4gICAgLyogMHg2QiAqLyBST1VORC5iaW5kKHVuZGVmaW5lZCwgMyksXG4gICAgLyogMHg2QyAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBOUk9VTkRbYWJdXG4gICAgLyogMHg2RCAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBOUk9VTkRbYWJdXG4gICAgLyogMHg2RSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBOUk9VTkRbYWJdXG4gICAgLyogMHg2RiAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBOUk9VTkRbYWJdXG4gICAgLyogMHg3MCAqLyBXQ1ZURixcbiAgICAvKiAweDcxICovIERFTFRBUDEyMy5iaW5kKHVuZGVmaW5lZCwgMiksXG4gICAgLyogMHg3MiAqLyBERUxUQVAxMjMuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgIC8qIDB4NzMgKi8gREVMVEFDMTIzLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDc0ICovIERFTFRBQzEyMy5iaW5kKHVuZGVmaW5lZCwgMiksXG4gICAgLyogMHg3NSAqLyBERUxUQUMxMjMuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgIC8qIDB4NzYgKi8gU1JPVU5ELFxuICAgIC8qIDB4NzcgKi8gUzQ1Uk9VTkQsXG4gICAgLyogMHg3OCAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBKUk9UW11cbiAgICAvKiAweDc5ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEpST0ZbXVxuICAgIC8qIDB4N0EgKi8gUk9GRixcbiAgICAvKiAweDdCICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDdDICovIFJVVEcsXG4gICAgLyogMHg3RCAqLyBSRFRHLFxuICAgIC8qIDB4N0UgKi8gUE9QLCAvLyBhY3R1YWxseSBTQU5HVywgc3VwcG9zZWQgdG8gZG8gb25seSBhIHBvcCB0aG91Z2hcbiAgICAvKiAweDdGICovIFBPUCwgLy8gYWN0dWFsbHkgQUEsIHN1cHBvc2VkIHRvIGRvIG9ubHkgYSBwb3AgdGhvdWdoXG4gICAgLyogMHg4MCAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBGTElQUFRcbiAgICAvKiAweDgxICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEZMSVBSR09OXG4gICAgLyogMHg4MiAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBGTElQUkdPRkZcbiAgICAvKiAweDgzICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDg0ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDg1ICovIFNDQU5DVFJMLFxuICAgIC8qIDB4ODYgKi8gU0RQVlRMLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDg3ICovIFNEUFZUTC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg4OCAqLyBHRVRJTkZPLFxuICAgIC8qIDB4ODkgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gSURFRlxuICAgIC8qIDB4OEEgKi8gUk9MTCxcbiAgICAvKiAweDhCICovIE1BWCxcbiAgICAvKiAweDhDICovIE1JTixcbiAgICAvKiAweDhEICovIFNDQU5UWVBFLFxuICAgIC8qIDB4OEUgKi8gSU5TVENUUkwsXG4gICAgLyogMHg4RiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5MCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5MSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5MiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5MyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5NCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5NSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5NiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5NyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5OCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5OSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5QSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5QiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5QyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5RCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5RSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5RiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBMCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBMSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBMiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBMyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBNCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBNSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBNiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBNyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBOCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBOSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBQSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBQiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBQyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBRCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBRSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBRiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhCMCAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHhCMSAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgMiksXG4gICAgLyogMHhCMiAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgMyksXG4gICAgLyogMHhCMyAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgNCksXG4gICAgLyogMHhCNCAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgNSksXG4gICAgLyogMHhCNSAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgNiksXG4gICAgLyogMHhCNiAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgNyksXG4gICAgLyogMHhCNyAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgOCksXG4gICAgLyogMHhCOCAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHhCOSAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgMiksXG4gICAgLyogMHhCQSAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgMyksXG4gICAgLyogMHhCQiAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgNCksXG4gICAgLyogMHhCQyAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgNSksXG4gICAgLyogMHhCRCAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgNiksXG4gICAgLyogMHhCRSAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgNyksXG4gICAgLyogMHhCRiAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgOCksXG4gICAgLyogMHhDMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDApLFxuICAgIC8qIDB4QzEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAxKSxcbiAgICAvKiAweEMyICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMCwgMiksXG4gICAgLyogMHhDMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDMpLFxuICAgIC8qIDB4QzQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAwKSxcbiAgICAvKiAweEM1ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMSwgMSksXG4gICAgLyogMHhDNiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDIpLFxuICAgIC8qIDB4QzcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAzKSxcbiAgICAvKiAweEM4ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMCwgMCksXG4gICAgLyogMHhDOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDEpLFxuICAgIC8qIDB4Q0EgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAyKSxcbiAgICAvKiAweENCICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMCwgMyksXG4gICAgLyogMHhDQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDApLFxuICAgIC8qIDB4Q0QgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAxKSxcbiAgICAvKiAweENFICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMSwgMiksXG4gICAgLyogMHhDRiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDMpLFxuICAgIC8qIDB4RDAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAwKSxcbiAgICAvKiAweEQxICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMCwgMSksXG4gICAgLyogMHhEMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDIpLFxuICAgIC8qIDB4RDMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAzKSxcbiAgICAvKiAweEQ0ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMSwgMCksXG4gICAgLyogMHhENSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDEpLFxuICAgIC8qIDB4RDYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAyKSxcbiAgICAvKiAweEQ3ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMSwgMyksXG4gICAgLyogMHhEOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDApLFxuICAgIC8qIDB4RDkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAxKSxcbiAgICAvKiAweERBICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMCwgMiksXG4gICAgLyogMHhEQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDMpLFxuICAgIC8qIDB4REMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAwKSxcbiAgICAvKiAweEREICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMSwgMSksXG4gICAgLyogMHhERSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDIpLFxuICAgIC8qIDB4REYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAzKSxcbiAgICAvKiAweEUwICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMCwgMCksXG4gICAgLyogMHhFMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDEpLFxuICAgIC8qIDB4RTIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAyKSxcbiAgICAvKiAweEUzICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMCwgMyksXG4gICAgLyogMHhFNCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDApLFxuICAgIC8qIDB4RTUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAxKSxcbiAgICAvKiAweEU2ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMSwgMiksXG4gICAgLyogMHhFNyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDMpLFxuICAgIC8qIDB4RTggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAwKSxcbiAgICAvKiAweEU5ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMCwgMSksXG4gICAgLyogMHhFQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDIpLFxuICAgIC8qIDB4RUIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAzKSxcbiAgICAvKiAweEVDICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMSwgMCksXG4gICAgLyogMHhFRCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDEpLFxuICAgIC8qIDB4RUUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAyKSxcbiAgICAvKiAweEVGICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMSwgMyksXG4gICAgLyogMHhGMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDApLFxuICAgIC8qIDB4RjEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAxKSxcbiAgICAvKiAweEYyICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMCwgMiksXG4gICAgLyogMHhGMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDMpLFxuICAgIC8qIDB4RjQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAwKSxcbiAgICAvKiAweEY1ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMSwgMSksXG4gICAgLyogMHhGNiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDIpLFxuICAgIC8qIDB4RjcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAzKSxcbiAgICAvKiAweEY4ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMCwgMCksXG4gICAgLyogMHhGOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDEpLFxuICAgIC8qIDB4RkEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAyKSxcbiAgICAvKiAweEZCICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMCwgMyksXG4gICAgLyogMHhGQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDApLFxuICAgIC8qIDB4RkQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAxKSxcbiAgICAvKiAweEZFICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMSwgMiksXG4gICAgLyogMHhGRiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDMpXG5dO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgTWF0aGVtYXRpY2FsIENvbnNpZGVyYXRpb25zXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuZnYgLi4uIHJlZmVycyB0byBmcmVlZG9tIHZlY3RvclxucHYgLi4uIHJlZmVycyB0byBwcm9qZWN0aW9uIHZlY3RvclxucnAgLi4uIHJlZmVycyB0byByZWZlcmVuY2UgcG9pbnRcbnAgIC4uLiByZWZlcnMgdG8gdG8gcG9pbnQgYmVpbmcgb3BlcmF0ZWQgb25cbmQgIC4uLiByZWZlcnMgdG8gZGlzdGFuY2VcblxuU0VUUkVMQVRJVkU6XG49PT09PT09PT09PT1cblxuY2FzZSBmcmVlZG9tIHZlY3RvciA9PSB4LWF4aXM6XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgKHB2KVxuICAgICAgICAgICAgICAgICAgICAgLi0nXG4gICAgICAgICAgICAgIHJwZCAuLSdcbiAgICAgICAgICAgICAgIC4tKlxuICAgICAgICAgIGQgLi0nOTDCsCdcbiAgICAgICAgIC4tJyAgICAgICAnXG4gICAgICAuLScgICAgICAgICAgICdcbiAgICotJyAgICAgICAgICAgICAgICcgYlxuICBycCAgICAgICAgICAgICAgICAgICdcbiAgICAgICAgICAgICAgICAgICAgICAgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xuICAgICAgICAgICAgcCAqLS0tLS0tLS0tLSotLS0tLS0tLS0tLS0tLSAoZnYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBtXG5cbiAgcnBkeCA9IHJweCArIGQgKiBwdi54XG4gIHJwZHkgPSBycHkgKyBkICogcHYueVxuXG4gIGVxdWF0aW9uIG9mIGxpbmUgYlxuXG4gICB5IC0gcnBkeSA9IHB2bnMgKiAoeC0gcnBkeClcblxuICAgeSA9IHAueVxuXG4gICB4ID0gcnBkeCArICggcC55IC0gcnBkeSApIC8gcHZuc1xuXG5cbmNhc2UgZnJlZWRvbSB2ZWN0b3IgPT0geS1heGlzOlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAqIHBtXG4gICAgfFxcXG4gICAgfCBcXFxuICAgIHwgIFxcXG4gICAgfCAgIFxcXG4gICAgfCAgICBcXFxuICAgIHwgICAgIFxcXG4gICAgfCAgICAgIFxcXG4gICAgfCAgICAgICBcXFxuICAgIHwgICAgICAgIFxcXG4gICAgfCAgICAgICAgIFxcIGJcbiAgICB8ICAgICAgICAgIFxcXG4gICAgfCAgICAgICAgICAgXFxcbiAgICB8ICAgICAgICAgICAgXFwgICAgLi0nIChwdilcbiAgICB8ICAgICAgICAgOTDCsCBcXC4tJ1xuICAgIHwgICAgICAgICAgIC4tJyogcnBkXG4gICAgfCAgICAgICAgLi0nXG4gICAgKiAgICAgKi0nICBkXG4gICAgcCAgICAgcnBcblxuICBycGR4ID0gcnB4ICsgZCAqIHB2LnhcbiAgcnBkeSA9IHJweSArIGQgKiBwdi55XG5cbiAgZXF1YXRpb24gb2YgbGluZSBiOlxuICAgICAgICAgICBwdm5zIC4uLiBub3JtYWwgc2xvcGUgdG8gcHZcblxuICAgeSAtIHJwZHkgPSBwdm5zICogKHggLSBycGR4KVxuXG4gICB4ID0gcC54XG5cbiAgIHkgPSBycGR5ICsgIHB2bnMgKiAocC54IC0gcnBkeClcblxuXG5cbmdlbmVyaWMgY2FzZTpcbi0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuJyhmdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAuKiBwbVxuICAgICAgICAgICAgICAgICAgICAgICAgLicgIVxuICAgICAgICAgICAgICAgICAgICAgIC4nICAgIC5cbiAgICAgICAgICAgICAgICAgICAgLicgICAgICAhXG4gICAgICAgICAgICAgICAgICAuJyAgICAgICAgIC4gYlxuICAgICAgICAgICAgICAgIC4nICAgICAgICAgICAhXG4gICAgICAgICAgICAgICAqICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgIHAgICAgICAgICAgICAgICAhXG4gICAgICAgICAgICAgICAgICAgICAgICAgOTDCsCAgIC4gICAgLi4uIChwdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLi0qLScnJ1xuICAgICAgICAgICAgICAgICAgLi4uLS0tJycnICAgIHJwZFxuICAgICAgICAgLi4uLS0tJycnICAgZFxuICAgKi0tJycnXG4gIHJwXG5cbiAgICBycGR4ID0gcnB4ICsgZCAqIHB2LnhcbiAgICBycGR5ID0gcnB5ICsgZCAqIHB2LnlcblxuIGVxdWF0aW9uIG9mIGxpbmUgYjpcbiAgICBwdm5zLi4uIG5vcm1hbCBzbG9wZSB0byBwdlxuXG4gICAgeSAtIHJwZHkgPSBwdm5zICogKHggLSBycGR4KVxuXG4gZXF1YXRpb24gb2YgZnJlZWRvbSB2ZWN0b3IgbGluZTpcbiAgICBmdnMgLi4uIHNsb3BlIG9mIGZyZWVkb20gdmVjdG9yICg9ZnkvZngpXG5cbiAgICB5IC0gcHkgPSBmdnMgKiAoeCAtIHB4KVxuXG5cbiAgb24gcG0gYm90aCBlcXVhdGlvbnMgYXJlIHRydWUgZm9yIHNhbWUgeC95XG5cbiAgICB5IC0gcnBkeSA9IHB2bnMgKiAoeCAtIHJwZHgpXG5cbiAgICB5IC0gcHkgPSBmdnMgKiAoeCAtIHB4KVxuXG4gIGZvcm0gdG8geSBhbmQgc2V0IGVxdWFsOlxuXG4gICAgcHZucyAqICh4IC0gcnBkeCkgKyBycGR5ID0gZnZzICogKHggLSBweCkgKyBweVxuXG4gIGV4cGFuZDpcblxuICAgIHB2bnMgKiB4IC0gcHZucyAqIHJwZHggKyBycGR5ID0gZnZzICogeCAtIGZ2cyAqIHB4ICsgcHlcblxuICBzd2l0Y2g6XG5cbiAgICBmdnMgKiB4IC0gZnZzICogcHggKyBweSA9IHB2bnMgKiB4IC0gcHZucyAqIHJwZHggKyBycGR5XG5cbiAgc29sdmUgZm9yIHg6XG5cbiAgICBmdnMgKiB4IC0gcHZucyAqIHggPSBmdnMgKiBweCAtIHB2bnMgKiBycGR4IC0gcHkgKyBycGR5XG5cblxuXG4gICAgICAgICAgZnZzICogcHggLSBwdm5zICogcnBkeCArIHJwZHkgLSBweVxuICAgIHggPSAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgICAgICAgZnZzIC0gcHZuc1xuXG4gIGFuZDpcblxuICAgIHkgPSBmdnMgKiAoeCAtIHB4KSArIHB5XG5cblxuXG5JTlRFUlBPTEFURTpcbj09PT09PT09PT09PVxuXG5FeGFtcGxlcyBvZiBwb2ludCBpbnRlcnBvbGF0aW9uLlxuXG5UaGUgd2VpZ2h0IG9mIHRoZSBtb3ZlbWVudCBvZiB0aGUgcmVmZXJlbmNlIHBvaW50IGdldHMgYmlnZ2VyXG50aGUgZnVydGhlciB0aGUgb3RoZXIgcmVmZXJlbmNlIHBvaW50IGlzIGF3YXksIHRodXMgdGhlIHNhZmVzdFxub3B0aW9uICh0aGF0IGlzIGF2b2lkaW5nIDAvMCBkaXZpc2lvbnMpIGlzIHRvIHdlaWdodCB0aGVcbm9yaWdpbmFsIGRpc3RhbmNlIG9mIHRoZSBvdGhlciBwb2ludCBieSB0aGUgc3VtIG9mIGJvdGggZGlzdGFuY2VzLlxuXG5JZiB0aGUgc3VtIG9mIGJvdGggZGlzdGFuY2VzIGlzIDAsIHRoZW4gbW92ZSB0aGUgcG9pbnQgYnkgdGhlXG5hcml0aG1ldGljIGF2ZXJhZ2Ugb2YgdGhlIG1vdmVtZW50IG9mIGJvdGggcmVmZXJlbmNlIHBvaW50cy5cblxuXG5cblxuICAgICAgICAgICAoKzYpXG4gICAgcnAxbyAqLS0tLT4qcnAxXG4gICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICAoKzEyKVxuICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgIHJwMm8gKi0tLS0tLS0tLS0+KiBycDJcbiAgICAgICAgIC4gICAgIC4gICAgICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAgIC5cbiAgICAgICAgIC4gICAgIC4gICAgICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAgIC5cbiAgICAgICAgIC4gICAgMTAgICAgICAgICAgMjAgICAgICAgICAgIC4gICAgICAgICAgIC5cbiAgICAgICAgIHwuLi4uLi4uLi58Li4uLi4uLi4uLi4uLi4uLi4uLnwgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgIC4gICAuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgIC4gICAuICgrOCkgICAgICAgICAgICAgICAgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgICBwbyAqLS0tLS0tPipwICAgICAgICAgICAgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgIC4gICAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgIC4gICAgMTIgICAgIC4gICAgICAgICAgMjQgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgIHwuLi4uLi4uLi4uLnwuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLnxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzNlxuXG5cbi0tLS0tLS1cblxuXG5cbiAgICAgICAgICAgKCsxMClcbiAgICBycDFvICotLS0tLS0tLT4qcnAxXG4gICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAgICAoLTEwKVxuICAgICAgICAgLiAgICAgICAgIC4gICAgICAgICAgICAgIHJwMiAqPC0tLS0tLS0tLSogcnBvMlxuICAgICAgICAgLiAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICAuICAgIDEwICAgLiAgICAgICAgICAzMCAgICAgICAuICAgICAgICAgLlxuICAgICAgICAgfC4uLi4uLi4uLnwuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLnxcbiAgICAgICAgICAgICAgICAgICAuICAgICAgICAgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgICAgICAuICgrNSkgICAgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgICBwbyAqLS0tPiogcCAgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgICAgICAuICAgIC4gICAgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgICAgICAuICAgIC4gICAyMCAgICAgICAgIC5cbiAgICAgICAgICAgICAgICAgICB8Li4uLnwuLi4uLi4uLi4uLi4uLnxcbiAgICAgICAgICAgICAgICAgICAgIDUgICAgICAgIDE1XG5cblxuLS0tLS0tLVxuXG5cbiAgICAgICAgICAgKCsxMClcbiAgICBycDFvICotLS0tLS0tLT4qcnAxXG4gICAgICAgICAuICAgICAgICAgLlxuICAgICAgICAgLiAgICAgICAgIC5cbiAgICBycDJvICotLS0tLS0tLT4qcnAyXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgrMTApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvICotLS0tLS0tLT4qIHBcblxuLS0tLS0tLVxuXG5cbiAgICAgICAgICAgKCsxMClcbiAgICBycDFvICotLS0tLS0tLT4qcnAxXG4gICAgICAgICAuICAgICAgICAgLlxuICAgICAgICAgLiAgICAgICAgIC4oKzMwKVxuICAgIHJwMm8gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+KnJwMlxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKzI1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwbyAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+KiBwXG5cblxuXG52aW06IHNldCB0cz00IHN3PTQgZXhwYW5kdGFiOlxuKioqKiovXG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGxpc3Qgb2YgdG9rZW5zLlxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhciBhIHNpbmdsZSBjaGFyXG4gKi9cbmZ1bmN0aW9uIFRva2VuKGNoYXIpIHtcbiAgICB0aGlzLmNoYXIgPSBjaGFyO1xuICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICB0aGlzLmFjdGl2ZVN0YXRlID0gbnVsbDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY29udGV4dCByYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggcmFuZ2Ugc3RhcnQgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRPZmZzZXQgcmFuZ2UgZW5kIGluZGV4IG9mZnNldFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lIG93bmVyIGNvbnRleHQgbmFtZVxuICovXG5mdW5jdGlvbiBDb250ZXh0UmFuZ2Uoc3RhcnRJbmRleCwgZW5kT2Zmc2V0LCBjb250ZXh0TmFtZSkge1xuICAgIHRoaXMuY29udGV4dE5hbWUgPSBjb250ZXh0TmFtZTtcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xuICAgIHRoaXMuZW5kT2Zmc2V0ID0gZW5kT2Zmc2V0O1xufVxuXG4vKipcbiAqIENoZWNrIGNvbnRleHQgc3RhcnQgYW5kIGVuZFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lIGEgdW5pcXVlIGNvbnRleHQgbmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2hlY2tTdGFydCBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0aGUgaW5kaWNhdGVzIGEgY29udGV4dCdzIHN0YXJ0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjaGVja0VuZCBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0aGUgaW5kaWNhdGVzIGEgY29udGV4dCdzIGVuZFxuICovXG5mdW5jdGlvbiBDb250ZXh0Q2hlY2tlcihjb250ZXh0TmFtZSwgY2hlY2tTdGFydCwgY2hlY2tFbmQpIHtcbiAgICB0aGlzLmNvbnRleHROYW1lID0gY29udGV4dE5hbWU7XG4gICAgdGhpcy5vcGVuUmFuZ2UgPSBudWxsO1xuICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgdGhpcy5jaGVja1N0YXJ0ID0gY2hlY2tTdGFydDtcbiAgICB0aGlzLmNoZWNrRW5kID0gY2hlY2tFbmQ7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgQ29udGV4dFBhcmFtc1xuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge2FycmF5fSBjb250ZXh0IGNvbnRleHQgaXRlbXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXJyZW50SW5kZXggY3VycmVudCBpdGVtIGluZGV4XG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBjb250ZXh0IHBhcmFtc1xuICogQHBhcmFtIHthcnJheX0gY29udGV4dCBhIGxpc3Qgb2YgaXRlbXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50SW5kZXggY3VycmVudCBpdGVtIGluZGV4XG4gKi9cbmZ1bmN0aW9uIENvbnRleHRQYXJhbXMoY29udGV4dCwgY3VycmVudEluZGV4KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmluZGV4ID0gY3VycmVudEluZGV4O1xuICAgIHRoaXMubGVuZ3RoID0gY29udGV4dC5sZW5ndGg7XG4gICAgdGhpcy5jdXJyZW50ID0gY29udGV4dFtjdXJyZW50SW5kZXhdO1xuICAgIHRoaXMuYmFja3RyYWNrID0gY29udGV4dC5zbGljZSgwLCBjdXJyZW50SW5kZXgpO1xuICAgIHRoaXMubG9va2FoZWFkID0gY29udGV4dC5zbGljZShjdXJyZW50SW5kZXggKyAxKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXZlbnQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudElkIGV2ZW50IHVuaXF1ZSBpZFxuICovXG5mdW5jdGlvbiBFdmVudChldmVudElkKSB7XG4gICAgdGhpcy5ldmVudElkID0gZXZlbnRJZDtcbiAgICB0aGlzLnN1YnNjcmliZXJzID0gW107XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIGNvcmUgZXZlbnRzIGFuZCBhdXRvIHN1YnNjcmliZSByZXF1aXJlZCBldmVudCBoYW5kbGVyc1xuICogQHBhcmFtIHthbnl9IGV2ZW50cyBhbiBvYmplY3QgdGhhdCBlbmxpc3RzIGNvcmUgZXZlbnRzIGhhbmRsZXJzXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVDb3JlRXZlbnRzKGV2ZW50cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNvcmVFdmVudHMgPSBbXG4gICAgICAgICdzdGFydCcsICdlbmQnLCAnbmV4dCcsICduZXdUb2tlbicsICdjb250ZXh0U3RhcnQnLFxuICAgICAgICAnY29udGV4dEVuZCcsICdpbnNlcnRUb2tlbicsICdyZW1vdmVUb2tlbicsICdyZW1vdmVSYW5nZScsXG4gICAgICAgICdyZXBsYWNlVG9rZW4nLCAncmVwbGFjZVJhbmdlJywgJ2NvbXBvc2VSVUQnLCAndXBkYXRlQ29udGV4dHNSYW5nZXMnXG4gICAgXTtcblxuICAgIGNvcmVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRJZCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyQxLmV2ZW50cywgZXZlbnRJZCwge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBFdmVudChldmVudElkKVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmICghIWV2ZW50cykge1xuICAgICAgICBjb3JlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SWQpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IGV2ZW50c1tldmVudElkXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzJDEuZXZlbnRzW2V2ZW50SWRdLnN1YnNjcmliZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcmVxdWlyZXNDb250ZXh0VXBkYXRlID0gW1xuICAgICAgICAnaW5zZXJ0VG9rZW4nLCAncmVtb3ZlVG9rZW4nLCAncmVtb3ZlUmFuZ2UnLFxuICAgICAgICAncmVwbGFjZVRva2VuJywgJ3JlcGxhY2VSYW5nZScsICdjb21wb3NlUlVEJ1xuICAgIF07XG4gICAgcmVxdWlyZXNDb250ZXh0VXBkYXRlLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SWQpIHtcbiAgICAgICAgdGhpcyQxLmV2ZW50c1tldmVudElkXS5zdWJzY3JpYmUoXG4gICAgICAgICAgICB0aGlzJDEudXBkYXRlQ29udGV4dHNSYW5nZXNcbiAgICAgICAgKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBpbnRvIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7YW55fSBldmVudHMgdG9rZW5pemVyIGNvcmUgZXZlbnRzXG4gKi9cbmZ1bmN0aW9uIFRva2VuaXplcihldmVudHMpIHtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMucmVnaXN0ZXJlZENvbnRleHRzID0ge307XG4gICAgdGhpcy5jb250ZXh0Q2hlY2tlcnMgPSBbXTtcbiAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIHRoaXMucmVnaXN0ZXJlZE1vZGlmaWVycyA9IFtdO1xuXG4gICAgaW5pdGlhbGl6ZUNvcmVFdmVudHMuY2FsbCh0aGlzLCBldmVudHMpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YXRlIG9mIGEgdG9rZW4sIHVzdWFsbHkgY2FsbGVkIGJ5IGEgc3RhdGUgbW9kaWZpZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0YXRlIGl0ZW0ga2V5XG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgc3RhdGUgaXRlbSB2YWx1ZVxuICovXG5Ub2tlbi5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5zdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgdGhpcy5hY3RpdmVTdGF0ZSA9IHsga2V5OiBrZXksIHZhbHVlOiB0aGlzLnN0YXRlW2tleV0gfTtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVTdGF0ZTtcbn07XG5cblRva2VuLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVbc3RhdGVJZF0gfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGluZGV4IGV4aXN0cyBpbiB0aGUgdG9rZW5zIGxpc3QuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5pbmJvdW5kSW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDb21wb3NlIGFuZCBhcHBseSBhIGxpc3Qgb2Ygb3BlcmF0aW9ucyAocmVwbGFjZSwgdXBkYXRlLCBkZWxldGUpXG4gKiBAcGFyYW0ge2FycmF5fSBSVURzIHJlcGxhY2UsIHVwZGF0ZSBhbmQgZGVsZXRlIG9wZXJhdGlvbnNcbiAqIFRPRE86IFBlcmYuIE9wdGltaXphdGlvbiAobGVuZ3RoQmVmb3JlID09PSBsZW5ndGhBZnRlciA/IGRpc3BhdGNoIG9uY2UpXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUuY29tcG9zZVJVRCA9IGZ1bmN0aW9uIChSVURzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2lsZW50ID0gdHJ1ZTtcbiAgICB2YXIgc3RhdGUgPSBSVURzLm1hcChmdW5jdGlvbiAoUlVEKSB7IHJldHVybiAoXG4gICAgICAgIHRoaXMkMVtSVURbMF1dLmFwcGx5KHRoaXMkMSwgUlVELnNsaWNlKDEpLmNvbmNhdChzaWxlbnQpKVxuICAgICk7IH0pO1xuICAgIHZhciBoYXNGQUlMT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gKFxuICAgICAgICB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoJ0ZBSUwnKVxuICAgICk7IH07XG4gICAgaWYgKHN0YXRlLmV2ZXJ5KGhhc0ZBSUxPYmplY3QpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBGQUlMOiBcImNvbXBvc2VSVUQ6IG9uZSBvciBtb3JlIG9wZXJhdGlvbnMgaGFzbid0IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlcIixcbiAgICAgICAgICAgIHJlcG9ydDogc3RhdGUuZmlsdGVyKGhhc0ZBSUxPYmplY3QpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2goJ2NvbXBvc2VSVUQnLCBbc3RhdGUuZmlsdGVyKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gIWhhc0ZBSUxPYmplY3Qob3ApOyB9KV0pO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIGEgcmFuZ2Ugb2YgdG9rZW5zIHdpdGggYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggcmFuZ2Ugc3RhcnQgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgcmFuZ2Ugb2Zmc2V0XG4gKiBAcGFyYW0ge3Rva2VufSB0b2tlbnMgYSBsaXN0IG9mIHRva2VucyB0byByZXBsYWNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCBkaXNwYXRjaCBldmVudHMgYW5kIHVwZGF0ZSBjb250ZXh0IHJhbmdlc1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlcGxhY2VSYW5nZSA9IGZ1bmN0aW9uIChzdGFydEluZGV4LCBvZmZzZXQsIHRva2Vucywgc2lsZW50KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICE9PSBudWxsID8gb2Zmc2V0IDogdGhpcy50b2tlbnMubGVuZ3RoO1xuICAgIHZhciBpc1Rva2VuVHlwZSA9IHRva2Vucy5ldmVyeShmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuIGluc3RhbmNlb2YgVG9rZW47IH0pO1xuICAgIGlmICghaXNOYU4oc3RhcnRJbmRleCkgJiYgdGhpcy5pbmJvdW5kSW5kZXgoc3RhcnRJbmRleCkgJiYgaXNUb2tlblR5cGUpIHtcbiAgICAgICAgdmFyIHJlcGxhY2VkID0gdGhpcy50b2tlbnMuc3BsaWNlLmFwcGx5KFxuICAgICAgICAgICAgdGhpcy50b2tlbnMsIFtzdGFydEluZGV4LCBvZmZzZXRdLmNvbmNhdCh0b2tlbnMpXG4gICAgICAgICk7XG4gICAgICAgIGlmICghc2lsZW50KSB7IHRoaXMuZGlzcGF0Y2goJ3JlcGxhY2VUb2tlbicsIFtzdGFydEluZGV4LCBvZmZzZXQsIHRva2Vuc10pOyB9XG4gICAgICAgIHJldHVybiBbcmVwbGFjZWQsIHRva2Vuc107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgRkFJTDogJ3JlcGxhY2VSYW5nZTogaW52YWxpZCB0b2tlbnMgb3Igc3RhcnRJbmRleC4nIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXBsYWNlIGEgdG9rZW4gd2l0aCBhbm90aGVyIHRva2VuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAqIEBwYXJhbSB7dG9rZW59IHRva2VuIGEgdG9rZW4gdG8gcmVwbGFjZVxuICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgZGlzcGF0Y2ggZXZlbnRzIGFuZCB1cGRhdGUgY29udGV4dCByYW5nZXNcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5yZXBsYWNlVG9rZW4gPSBmdW5jdGlvbiAoaW5kZXgsIHRva2VuLCBzaWxlbnQpIHtcbiAgICBpZiAoIWlzTmFOKGluZGV4KSAmJiB0aGlzLmluYm91bmRJbmRleChpbmRleCkgJiYgdG9rZW4gaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICB2YXIgcmVwbGFjZWQgPSB0aGlzLnRva2Vucy5zcGxpY2UoaW5kZXgsIDEsIHRva2VuKTtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHsgdGhpcy5kaXNwYXRjaCgncmVwbGFjZVRva2VuJywgW2luZGV4LCB0b2tlbl0pOyB9XG4gICAgICAgIHJldHVybiBbcmVwbGFjZWRbMF0sIHRva2VuXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBGQUlMOiAncmVwbGFjZVRva2VuOiBpbnZhbGlkIHRva2VuIG9yIGluZGV4LicgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSByYW5nZSBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IHJhbmdlIHN0YXJ0IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHJhbmdlIG9mZnNldFxuICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgZGlzcGF0Y2ggZXZlbnRzIGFuZCB1cGRhdGUgY29udGV4dCByYW5nZXNcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5yZW1vdmVSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0SW5kZXgsIG9mZnNldCwgc2lsZW50KSB7XG4gICAgb2Zmc2V0ID0gIWlzTmFOKG9mZnNldCkgPyBvZmZzZXQgOiB0aGlzLnRva2Vucy5sZW5ndGg7XG4gICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zLnNwbGljZShzdGFydEluZGV4LCBvZmZzZXQpO1xuICAgIGlmICghc2lsZW50KSB7IHRoaXMuZGlzcGF0Y2goJ3JlbW92ZVJhbmdlJywgW3Rva2Vucywgc3RhcnRJbmRleCwgb2Zmc2V0XSk7IH1cbiAgICByZXR1cm4gdG9rZW5zO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSB0b2tlbiBhdCBhIGNlcnRhaW4gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgZGlzcGF0Y2ggZXZlbnRzIGFuZCB1cGRhdGUgY29udGV4dCByYW5nZXNcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5yZW1vdmVUb2tlbiA9IGZ1bmN0aW9uKGluZGV4LCBzaWxlbnQpIHtcbiAgICBpZiAoIWlzTmFOKGluZGV4KSAmJiB0aGlzLmluYm91bmRJbmRleChpbmRleCkpIHtcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcy50b2tlbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHsgdGhpcy5kaXNwYXRjaCgncmVtb3ZlVG9rZW4nLCBbdG9rZW4sIGluZGV4XSk7IH1cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IEZBSUw6ICdyZW1vdmVUb2tlbjogaW52YWxpZCB0b2tlbiBpbmRleC4nIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBJbnNlcnQgYSBsaXN0IG9mIHRva2VucyBhdCBhIGNlcnRhaW4gaW5kZXhcbiAqIEBwYXJhbSB7YXJyYXl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zIHRvIGluc2VydFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluc2VydCB0aGUgbGlzdCBvZiB0b2tlbnMgYXQgaW5kZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IGRpc3BhdGNoIGV2ZW50cyBhbmQgdXBkYXRlIGNvbnRleHQgcmFuZ2VzXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUuaW5zZXJ0VG9rZW4gPSBmdW5jdGlvbiAodG9rZW5zLCBpbmRleCwgc2lsZW50KSB7XG4gICAgdmFyIHRva2VuVHlwZSA9IHRva2Vucy5ldmVyeShcbiAgICAgICAgZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbiBpbnN0YW5jZW9mIFRva2VuOyB9XG4gICAgKTtcbiAgICBpZiAodG9rZW5UeXBlKSB7XG4gICAgICAgIHRoaXMudG9rZW5zLnNwbGljZS5hcHBseShcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLCBbaW5kZXgsIDBdLmNvbmNhdCh0b2tlbnMpXG4gICAgICAgICk7XG4gICAgICAgIGlmICghc2lsZW50KSB7IHRoaXMuZGlzcGF0Y2goJ2luc2VydFRva2VuJywgW3Rva2VucywgaW5kZXhdKTsgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IEZBSUw6ICdpbnNlcnRUb2tlbjogaW52YWxpZCB0b2tlbihzKS4nIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBBIHN0YXRlIG1vZGlmaWVyIHRoYXQgaXMgY2FsbGVkIG9uICduZXdUb2tlbicgZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RpZmllcklkIHN0YXRlIG1vZGlmaWVyIGlkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgb3IgZmFsc2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vZGlmaWVyIGEgZnVuY3Rpb24gdG8gdXBkYXRlIHRva2VuIHN0YXRlXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmVnaXN0ZXJNb2RpZmllciA9IGZ1bmN0aW9uKG1vZGlmaWVySWQsIGNvbmRpdGlvbiwgbW9kaWZpZXIpIHtcbiAgICB0aGlzLmV2ZW50cy5uZXdUb2tlbi5zdWJzY3JpYmUoZnVuY3Rpb24odG9rZW4sIGNvbnRleHRQYXJhbXMpIHtcbiAgICAgICAgdmFyIGNvbmRpdGlvblBhcmFtcyA9IFt0b2tlbiwgY29udGV4dFBhcmFtc107XG4gICAgICAgIHZhciBjYW5BcHBseU1vZGlmaWVyID0gKFxuICAgICAgICAgICAgY29uZGl0aW9uID09PSBudWxsIHx8XG4gICAgICAgICAgICBjb25kaXRpb24uYXBwbHkodGhpcywgY29uZGl0aW9uUGFyYW1zKSA9PT0gdHJ1ZVxuICAgICAgICApO1xuICAgICAgICB2YXIgbW9kaWZpZXJQYXJhbXMgPSBbdG9rZW4sIGNvbnRleHRQYXJhbXNdO1xuICAgICAgICBpZiAoY2FuQXBwbHlNb2RpZmllcikge1xuICAgICAgICAgICAgdmFyIG5ld1N0YXRlVmFsdWUgPSBtb2RpZmllci5hcHBseSh0aGlzLCBtb2RpZmllclBhcmFtcyk7XG4gICAgICAgICAgICB0b2tlbi5zZXRTdGF0ZShtb2RpZmllcklkLCBuZXdTdGF0ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXJlZE1vZGlmaWVycy5wdXNoKG1vZGlmaWVySWQpO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgYSBoYW5kbGVyIHRvIGFuIGV2ZW50XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBldmVudEhhbmRsZXIgYW4gZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICovXG5FdmVudC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGV2ZW50SGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgZXZlbnRIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMuc3Vic2NyaWJlcnMucHVzaChldmVudEhhbmRsZXIpKSAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IEZBSUw6IChcImludmFsaWQgJ1wiICsgKHRoaXMuZXZlbnRJZCkgKyBcIicgZXZlbnQgaGFuZGxlclwiKX07XG4gICAgfVxufTtcblxuLyoqXG4gKiBVbnN1YnNjcmliZSBhbiBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3Vic0lkIHN1YnNjcmlwdGlvbiBpZFxuICovXG5FdmVudC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic0lkKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5zcGxpY2Uoc3Vic0lkLCAxKTtcbn07XG5cbi8qKlxuICogU2V0cyBjb250ZXh0IHBhcmFtcyBjdXJyZW50IHZhbHVlIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggY29udGV4dCBwYXJhbXMgY3VycmVudCB2YWx1ZSBpbmRleFxuICovXG5Db250ZXh0UGFyYW1zLnByb3RvdHlwZS5zZXRDdXJyZW50SW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmNvbnRleHRbaW5kZXhdO1xuICAgIHRoaXMuYmFja3RyYWNrID0gdGhpcy5jb250ZXh0LnNsaWNlKDAsIGluZGV4KTtcbiAgICB0aGlzLmxvb2thaGVhZCA9IHRoaXMuY29udGV4dC5zbGljZShpbmRleCArIDEpO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gaXRlbSBhdCBhbiBvZmZzZXQgZnJvbSB0aGUgY3VycmVudCB2YWx1ZVxuICogZXhhbXBsZSAoY3VycmVudCB2YWx1ZSBpcyAzKTpcbiAqICAxICAgIDIgICBbM10gICA0ICAgIDUgICB8ICAgaXRlbXMgdmFsdWVzXG4gKiAtMiAgIC0xICAgIDAgICAgMSAgICAyICAgfCAgIG9mZnNldCB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgYW4gb2Zmc2V0IGZyb20gY3VycmVudCB2YWx1ZSBpbmRleFxuICovXG5Db250ZXh0UGFyYW1zLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgKG9mZnNldCA9PT0gMCk6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICAgICAgICBjYXNlIChvZmZzZXQgPCAwICYmIE1hdGguYWJzKG9mZnNldCkgPD0gdGhpcy5iYWNrdHJhY2subGVuZ3RoKTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhY2t0cmFjay5zbGljZShvZmZzZXQpWzBdO1xuICAgICAgICBjYXNlIChvZmZzZXQgPiAwICYmIG9mZnNldCA8PSB0aGlzLmxvb2thaGVhZC5sZW5ndGgpOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9va2FoZWFkW29mZnNldCAtIDFdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGNvbnRleHQgcmFuZ2UgaW50byBhIHN0cmluZyB2YWx1ZVxuICogQHBhcmFtIHtjb250ZXh0UmFuZ2V9IHJhbmdlIGEgY29udGV4dCByYW5nZVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJhbmdlVG9UZXh0ID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29udGV4dFJhbmdlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmdldFJhbmdlVG9rZW5zKHJhbmdlKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5jaGFyOyB9KS5qb2luKCcnKVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29udmVydHMgYWxsIHRva2VucyBpbnRvIGEgc3RyaW5nXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uY2hhcjsgfSkuam9pbignJyk7XG59O1xuXG4vKipcbiAqIEdldCBhIGNvbnRleHQgYnkgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lIGNvbnRleHQgbmFtZSB0byBnZXRcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHROYW1lKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLnJlZ2lzdGVyZWRDb250ZXh0c1tjb250ZXh0TmFtZV07XG4gICAgcmV0dXJuICEhY29udGV4dCA/IGNvbnRleHQgOiBudWxsO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVzIGEgbmV3IGV2ZW50IGhhbmRsZXIgdG8gYW4gZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgZXZlbnQgbmFtZSB0byBzdWJzY3JpYmUgdG9cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGV2ZW50SGFuZGxlciBhIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb24gZXZlbnRcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXTtcbiAgICBpZiAoISFldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQuc3Vic2NyaWJlKGV2ZW50SGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7YW55fSBhcmdzIGV2ZW50IGhhbmRsZXIgYXJndW1lbnRzXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbihldmVudE5hbWUsIGFyZ3MpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBldmVudCA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgRXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5hcHBseSh0aGlzJDEsIGFyZ3MgfHwgW10pO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbmV3IGNvbnRleHQgY2hlY2tlclxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lIGEgdW5pcXVlIGNvbnRleHQgbmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29udGV4dFN0YXJ0Q2hlY2sgYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgb24gY29udGV4dCBzdGFydFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29udGV4dEVuZENoZWNrICBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBvbiBjb250ZXh0IGVuZFxuICogVE9ETzogY2FsbCB0b2tlbml6ZSBvbiByZWdpc3RyYXRpb24gdG8gdXBkYXRlIGNvbnRleHQgcmFuZ2VzIHdpdGggdGhlIG5ldyBjb250ZXh0LlxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlZ2lzdGVyQ29udGV4dENoZWNrZXIgPSBmdW5jdGlvbihjb250ZXh0TmFtZSwgY29udGV4dFN0YXJ0Q2hlY2ssIGNvbnRleHRFbmRDaGVjaykge1xuICAgIGlmICghIXRoaXMuZ2V0Q29udGV4dChjb250ZXh0TmFtZSkpIHsgcmV0dXJuIHtcbiAgICAgICAgRkFJTDpcbiAgICAgICAgKFwiY29udGV4dCBuYW1lICdcIiArIGNvbnRleHROYW1lICsgXCInIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC5cIilcbiAgICB9OyB9XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0U3RhcnRDaGVjayAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4ge1xuICAgICAgICBGQUlMOlxuICAgICAgICBcIm1pc3NpbmcgY29udGV4dCBzdGFydCBjaGVjay5cIlxuICAgIH07IH1cbiAgICBpZiAodHlwZW9mIGNvbnRleHRFbmRDaGVjayAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4ge1xuICAgICAgICBGQUlMOlxuICAgICAgICBcIm1pc3NpbmcgY29udGV4dCBlbmQgY2hlY2suXCJcbiAgICB9OyB9XG4gICAgdmFyIGNvbnRleHRDaGVja2VycyA9IG5ldyBDb250ZXh0Q2hlY2tlcihcbiAgICAgICAgY29udGV4dE5hbWUsIGNvbnRleHRTdGFydENoZWNrLCBjb250ZXh0RW5kQ2hlY2tcbiAgICApO1xuICAgIHRoaXMucmVnaXN0ZXJlZENvbnRleHRzW2NvbnRleHROYW1lXSA9IGNvbnRleHRDaGVja2VycztcbiAgICB0aGlzLmNvbnRleHRDaGVja2Vycy5wdXNoKGNvbnRleHRDaGVja2Vycyk7XG4gICAgcmV0dXJuIGNvbnRleHRDaGVja2Vycztcbn07XG5cbi8qKlxuICogR2V0cyBhIGNvbnRleHQgcmFuZ2UgdG9rZW5zXG4gKiBAcGFyYW0ge2NvbnRleHRSYW5nZX0gcmFuZ2UgYSBjb250ZXh0IHJhbmdlXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUuZ2V0UmFuZ2VUb2tlbnMgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgIHZhciBlbmRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXggKyByYW5nZS5lbmRPZmZzZXQ7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChcbiAgICAgICAgdGhpcy50b2tlbnNcbiAgICAgICAgICAgIC5zbGljZShyYW5nZS5zdGFydEluZGV4LCBlbmRJbmRleClcbiAgICApO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSByYW5nZXMgb2YgYSBjb250ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWUgY29udGV4dCBuYW1lXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUuZ2V0Q29udGV4dFJhbmdlcyA9IGZ1bmN0aW9uKGNvbnRleHROYW1lKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoY29udGV4dE5hbWUpO1xuICAgIGlmICghIWNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQucmFuZ2VzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IEZBSUw6IChcImNvbnRleHQgY2hlY2tlciAnXCIgKyBjb250ZXh0TmFtZSArIFwiJyBpcyBub3QgcmVnaXN0ZXJlZC5cIikgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlc2V0cyBjb250ZXh0IHJhbmdlcyB0byBydW4gY29udGV4dCB1cGRhdGVcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5yZXNldENvbnRleHRzUmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWdpc3RlcmVkQ29udGV4dHMgPSB0aGlzLnJlZ2lzdGVyZWRDb250ZXh0cztcbiAgICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiByZWdpc3RlcmVkQ29udGV4dHMpIHtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRDb250ZXh0cy5oYXNPd25Qcm9wZXJ0eShjb250ZXh0TmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gcmVnaXN0ZXJlZENvbnRleHRzW2NvbnRleHROYW1lXTtcbiAgICAgICAgICAgIGNvbnRleHQucmFuZ2VzID0gW107XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgY29udGV4dCByYW5nZXNcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS51cGRhdGVDb250ZXh0c1JhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2V0Q29udGV4dHNSYW5nZXMoKTtcbiAgICB2YXIgY2hhcnMgPSB0aGlzLnRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5jaGFyOyB9KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb250ZXh0UGFyYW1zID0gbmV3IENvbnRleHRQYXJhbXMoY2hhcnMsIGkpO1xuICAgICAgICB0aGlzLnJ1bkNvbnRleHRDaGVjayhjb250ZXh0UGFyYW1zKTtcbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaCgndXBkYXRlQ29udGV4dHNSYW5nZXMnLCBbdGhpcy5yZWdpc3RlcmVkQ29udGV4dHNdKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZW5kIG9mZnNldCBvZiBhbiBvcGVuIHJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHJhbmdlIGVuZCBvZmZzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBjb250ZXh0IG5hbWVcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5zZXRFbmRPZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0LCBjb250ZXh0TmFtZSkge1xuICAgIHZhciBzdGFydEluZGV4ID0gdGhpcy5nZXRDb250ZXh0KGNvbnRleHROYW1lKS5vcGVuUmFuZ2Uuc3RhcnRJbmRleDtcbiAgICB2YXIgcmFuZ2UgPSBuZXcgQ29udGV4dFJhbmdlKHN0YXJ0SW5kZXgsIG9mZnNldCwgY29udGV4dE5hbWUpO1xuICAgIHZhciByYW5nZXMgPSB0aGlzLmdldENvbnRleHQoY29udGV4dE5hbWUpLnJhbmdlcztcbiAgICByYW5nZS5yYW5nZUlkID0gY29udGV4dE5hbWUgKyBcIi5cIiArIChyYW5nZXMubGVuZ3RoKTtcbiAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgdGhpcy5nZXRDb250ZXh0KGNvbnRleHROYW1lKS5vcGVuUmFuZ2UgPSBudWxsO1xuICAgIHJldHVybiByYW5nZTtcbn07XG5cbi8qKlxuICogUnVucyBhIGNvbnRleHQgY2hlY2sgb24gdGhlIGN1cnJlbnQgY29udGV4dFxuICogQHBhcmFtIHtjb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGN1cnJlbnQgY29udGV4dCBwYXJhbXNcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5ydW5Db250ZXh0Q2hlY2sgPSBmdW5jdGlvbihjb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaW5kZXggPSBjb250ZXh0UGFyYW1zLmluZGV4O1xuICAgIHRoaXMuY29udGV4dENoZWNrZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRleHRDaGVja2VyKSB7XG4gICAgICAgIHZhciBjb250ZXh0TmFtZSA9IGNvbnRleHRDaGVja2VyLmNvbnRleHROYW1lO1xuICAgICAgICB2YXIgb3BlblJhbmdlID0gdGhpcyQxLmdldENvbnRleHQoY29udGV4dE5hbWUpLm9wZW5SYW5nZTtcbiAgICAgICAgaWYgKCFvcGVuUmFuZ2UgJiYgY29udGV4dENoZWNrZXIuY2hlY2tTdGFydChjb250ZXh0UGFyYW1zKSkge1xuICAgICAgICAgICAgb3BlblJhbmdlID0gbmV3IENvbnRleHRSYW5nZShpbmRleCwgbnVsbCwgY29udGV4dE5hbWUpO1xuICAgICAgICAgICAgdGhpcyQxLmdldENvbnRleHQoY29udGV4dE5hbWUpLm9wZW5SYW5nZSA9IG9wZW5SYW5nZTtcbiAgICAgICAgICAgIHRoaXMkMS5kaXNwYXRjaCgnY29udGV4dFN0YXJ0JywgW2NvbnRleHROYW1lLCBpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIW9wZW5SYW5nZSAmJiBjb250ZXh0Q2hlY2tlci5jaGVja0VuZChjb250ZXh0UGFyYW1zKSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IChpbmRleCAtIG9wZW5SYW5nZS5zdGFydEluZGV4KSArIDE7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzJDEuc2V0RW5kT2Zmc2V0KG9mZnNldCwgY29udGV4dE5hbWUpO1xuICAgICAgICAgICAgdGhpcyQxLmRpc3BhdGNoKCdjb250ZXh0RW5kJywgW2NvbnRleHROYW1lLCByYW5nZV0pO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgdGV4dCBpbnRvIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IGEgdGV4dCB0byB0b2tlbml6ZVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMucmVzZXRDb250ZXh0c1JhbmdlcygpO1xuICAgIHZhciBjaGFycyA9IEFycmF5LmZyb20odGV4dCk7XG4gICAgdGhpcy5kaXNwYXRjaCgnc3RhcnQnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyID0gY2hhcnNbaV07XG4gICAgICAgIHZhciBjb250ZXh0UGFyYW1zID0gbmV3IENvbnRleHRQYXJhbXMoY2hhcnMsIGkpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKCduZXh0JywgW2NvbnRleHRQYXJhbXNdKTtcbiAgICAgICAgdGhpcy5ydW5Db250ZXh0Q2hlY2soY29udGV4dFBhcmFtcyk7XG4gICAgICAgIHZhciB0b2tlbiA9IG5ldyBUb2tlbihjaGFyKTtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goJ25ld1Rva2VuJywgW3Rva2VuLCBjb250ZXh0UGFyYW1zXSk7XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2goJ2VuZCcsIFt0aGlzLnRva2Vuc10pO1xuICAgIHJldHVybiB0aGlzLnRva2Vucztcbn07XG5cbi8vIOKVreKUgOKUhOKUhOKUhOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUhOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKVrlxuLy8g4pSKIENoYXJhY3RlciBDbGFzcyBBc3NlcnRpb25zIOKUiiBDaGVja3MgaWYgYSBjaGFyIGJlbG9uZ3MgdG8gYSBjZXJ0YWluIGNsYXNzIOKUilxuLy8g4pWw4pSA4pW+4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSE4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pWvXG4vLyBqc2NzOmRpc2FibGUgbWF4aW11bUxpbmVMZW5ndGhcbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFyIGlzIEFyYWJpY1xuICogQHBhcmFtIHtzdHJpbmd9IGMgYSBzaW5nbGUgY2hhclxuICovXG5mdW5jdGlvbiBpc0FyYWJpY0NoYXIoYykge1xuICAgIHJldHVybiAvW1xcdTA2MDAtXFx1MDY1RlxcdTA2NkEtXFx1MDZEMlxcdTA2RkEtXFx1MDZGRl0vLnRlc3QoYyk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFyIGlzIGFuIGlzb2xhdGVkIGFyYWJpYyBjaGFyXG4gKiBAcGFyYW0ge3N0cmluZ30gYyBhIHNpbmdsZSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzSXNvbGF0ZWRBcmFiaWNDaGFyKGNoYXIpIHtcbiAgICByZXR1cm4gL1tcXHUwNjMwXFx1MDY5MFxcdTA2MjFcXHUwNjMxXFx1MDY2MVxcdTA2NzFcXHUwNjIyXFx1MDYzMlxcdTA2NzJcXHUwNjkyXFx1MDZDMlxcdTA2MjNcXHUwNjczXFx1MDY5M1xcdTA2QzNcXHUwNjI0XFx1MDY5NFxcdTA2QzRcXHUwNjI1XFx1MDY3NVxcdTA2OTVcXHUwNkM1XFx1MDZFNVxcdTA2NzZcXHUwNjk2XFx1MDZDNlxcdTA2MjdcXHUwNjc3XFx1MDY5N1xcdTA2QzdcXHUwNjQ4XFx1MDY4OFxcdTA2OThcXHUwNkM4XFx1MDY4OVxcdTA2OTlcXHUwNkM5XFx1MDY4QVxcdTA2Q0FcXHUwNjZCXFx1MDY4QlxcdTA2Q0JcXHUwNjhDXFx1MDY4RFxcdTA2Q0RcXHUwNkZEXFx1MDY4RVxcdTA2RUVcXHUwNkZFXFx1MDYyRlxcdTA2OEZcXHUwNkNGXFx1MDZFRl0vLnRlc3QoY2hhcik7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFyIGlzIGFuIEFyYWJpYyBUYXNoa2VlbCBjaGFyXG4gKiBAcGFyYW0ge3N0cmluZ30gYyBhIHNpbmdsZSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzVGFzaGtlZWxBcmFiaWNDaGFyKGNoYXIpIHtcbiAgICByZXR1cm4gL1tcXHUwNjAwLVxcdTA2MDVcXHUwNjBDLVxcdTA2MEVcXHUwNjEwLVxcdTA2MUJcXHUwNjFFXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXS8udGVzdChjaGFyKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNoYXIgaXMgTGF0aW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjIGEgc2luZ2xlIGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNMYXRpbkNoYXIoYykge1xuICAgIHJldHVybiAvW0Etel0vLnRlc3QoYyk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFyIGlzIHdoaXRlc3BhY2UgY2hhclxuICogQHBhcmFtIHtzdHJpbmd9IGMgYSBzaW5nbGUgY2hhclxuICovXG5mdW5jdGlvbiBpc1doaXRlU3BhY2UoYykge1xuICAgIHJldHVybiAvXFxzLy50ZXN0KGMpO1xufVxuXG4vKipcbiAqIFF1ZXJ5IGEgZmVhdHVyZSBieSBzb21lIG9mIGl0J3MgcHJvcGVydGllcyB0byBsb29rdXAgYSBnbHlwaCBzdWJzdGl0dXRpb24uXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgZmVhdHVyZSBxdWVyeSBpbnN0YW5jZVxuICogQHBhcmFtIHtGb250fSBmb250IG9wZW50eXBlIGZvbnQgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gRmVhdHVyZVF1ZXJ5KGZvbnQpIHtcbiAgICB0aGlzLmZvbnQgPSBmb250O1xuICAgIHRoaXMuZmVhdHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBTdWJzdGl0dXRpb25BY3Rpb25cbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlkIHN1YnN0aXR1dGlvbiB0eXBlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGFnIGZlYXR1cmUgdGFnXG4gKiBAcHJvcGVydHkge2FueX0gc3Vic3RpdHV0aW9uIHN1YnN0aXR1dGlvbiB2YWx1ZShzKVxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgc3Vic3RpdHV0aW9uIGFjdGlvbiBpbnN0YW5jZVxuICogQHBhcmFtIHtTdWJzdGl0dXRpb25BY3Rpb259IGFjdGlvblxuICovXG5mdW5jdGlvbiBTdWJzdGl0dXRpb25BY3Rpb24oYWN0aW9uKSB7XG4gICAgdGhpcy5pZCA9IGFjdGlvbi5pZDtcbiAgICB0aGlzLnRhZyA9IGFjdGlvbi50YWc7XG4gICAgdGhpcy5zdWJzdGl0dXRpb24gPSBhY3Rpb24uc3Vic3RpdHV0aW9uO1xufVxuXG4vKipcbiAqIExvb2t1cCBhIGNvdmVyYWdlIHRhYmxlXG4gKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhJbmRleCBnbHlwaCBpbmRleFxuICogQHBhcmFtIHtDb3ZlcmFnZVRhYmxlfSBjb3ZlcmFnZSBjb3ZlcmFnZSB0YWJsZVxuICovXG5mdW5jdGlvbiBsb29rdXBDb3ZlcmFnZShnbHlwaEluZGV4LCBjb3ZlcmFnZSkge1xuICAgIGlmICghZ2x5cGhJbmRleCkgeyByZXR1cm4gLTE7IH1cbiAgICBzd2l0Y2ggKGNvdmVyYWdlLmZvcm1hdCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gY292ZXJhZ2UuZ2x5cGhzLmluZGV4T2YoZ2x5cGhJbmRleCk7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IGNvdmVyYWdlLnJhbmdlcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaEluZGV4ID49IHJhbmdlLnN0YXJ0ICYmIGdseXBoSW5kZXggPD0gcmFuZ2UuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBnbHlwaEluZGV4IC0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZS5pbmRleCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAtMTsgLy8gbm90IGZvdW5kXG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgYSBzaW5nbGUgc3Vic3RpdHV0aW9uIC0gZm9ybWF0IDFcbiAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtcyB0byBsb29rdXBcbiAqL1xuZnVuY3Rpb24gc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MShnbHlwaEluZGV4LCBzdWJ0YWJsZSkge1xuICAgIHZhciBzdWJzdGl0dXRlSW5kZXggPSBsb29rdXBDb3ZlcmFnZShnbHlwaEluZGV4LCBzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgaWYgKHN1YnN0aXR1dGVJbmRleCA9PT0gLTEpIHsgcmV0dXJuIG51bGw7IH1cbiAgICByZXR1cm4gZ2x5cGhJbmRleCArIHN1YnRhYmxlLmRlbHRhR2x5cGhJZDtcbn1cblxuLyoqXG4gKiBIYW5kbGUgYSBzaW5nbGUgc3Vic3RpdHV0aW9uIC0gZm9ybWF0IDJcbiAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtcyB0byBsb29rdXBcbiAqL1xuZnVuY3Rpb24gc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MihnbHlwaEluZGV4LCBzdWJ0YWJsZSkge1xuICAgIHZhciBzdWJzdGl0dXRlSW5kZXggPSBsb29rdXBDb3ZlcmFnZShnbHlwaEluZGV4LCBzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgaWYgKHN1YnN0aXR1dGVJbmRleCA9PT0gLTEpIHsgcmV0dXJuIG51bGw7IH1cbiAgICByZXR1cm4gc3VidGFibGUuc3Vic3RpdHV0ZVtzdWJzdGl0dXRlSW5kZXhdO1xufVxuXG4vKipcbiAqIExvb2t1cCBhIGxpc3Qgb2YgY292ZXJhZ2UgdGFibGVzXG4gKiBAcGFyYW0ge2FueX0gY292ZXJhZ2VMaXN0IGEgbGlzdCBvZiBjb3ZlcmFnZSB0YWJsZXNcbiAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtcyB0byBsb29rdXBcbiAqL1xuZnVuY3Rpb24gbG9va3VwQ292ZXJhZ2VMaXN0KGNvdmVyYWdlTGlzdCwgY29udGV4dFBhcmFtcykge1xuICAgIHZhciBsb29rdXBMaXN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3ZlcmFnZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvdmVyYWdlID0gY292ZXJhZ2VMaXN0W2ldO1xuICAgICAgICB2YXIgZ2x5cGhJbmRleCA9IGNvbnRleHRQYXJhbXMuY3VycmVudDtcbiAgICAgICAgZ2x5cGhJbmRleCA9IEFycmF5LmlzQXJyYXkoZ2x5cGhJbmRleCkgPyBnbHlwaEluZGV4WzBdIDogZ2x5cGhJbmRleDtcbiAgICAgICAgdmFyIGxvb2t1cEluZGV4ID0gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgY292ZXJhZ2UpO1xuICAgICAgICBpZiAobG9va3VwSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBsb29rdXBMaXN0LnB1c2gobG9va3VwSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsb29rdXBMaXN0Lmxlbmd0aCAhPT0gY292ZXJhZ2VMaXN0Lmxlbmd0aCkgeyByZXR1cm4gLTE7IH1cbiAgICByZXR1cm4gbG9va3VwTGlzdDtcbn1cblxuLyoqXG4gKiBIYW5kbGUgY2hhaW5pbmcgY29udGV4dCBzdWJzdGl0dXRpb24gLSBmb3JtYXQgM1xuICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIHRvIGxvb2t1cFxuICovXG5mdW5jdGlvbiBjaGFpbmluZ1N1YnN0aXR1dGlvbkZvcm1hdDMoY29udGV4dFBhcmFtcywgc3VidGFibGUpIHtcbiAgICB2YXIgbG9va3Vwc0NvdW50ID0gKFxuICAgICAgICBzdWJ0YWJsZS5pbnB1dENvdmVyYWdlLmxlbmd0aCArXG4gICAgICAgIHN1YnRhYmxlLmxvb2thaGVhZENvdmVyYWdlLmxlbmd0aCArXG4gICAgICAgIHN1YnRhYmxlLmJhY2t0cmFja0NvdmVyYWdlLmxlbmd0aFxuICAgICk7XG4gICAgaWYgKGNvbnRleHRQYXJhbXMuY29udGV4dC5sZW5ndGggPCBsb29rdXBzQ291bnQpIHsgcmV0dXJuIFtdOyB9XG4gICAgLy8gSU5QVVQgTE9PS1VQIC8vXG4gICAgdmFyIGlucHV0TG9va3VwcyA9IGxvb2t1cENvdmVyYWdlTGlzdChcbiAgICAgICAgc3VidGFibGUuaW5wdXRDb3ZlcmFnZSwgY29udGV4dFBhcmFtc1xuICAgICk7XG4gICAgaWYgKGlucHV0TG9va3VwcyA9PT0gLTEpIHsgcmV0dXJuIFtdOyB9XG4gICAgLy8gTE9PS0FIRUFEIExPT0tVUCAvL1xuICAgIHZhciBsb29rYWhlYWRPZmZzZXQgPSBzdWJ0YWJsZS5pbnB1dENvdmVyYWdlLmxlbmd0aCAtIDE7XG4gICAgaWYgKGNvbnRleHRQYXJhbXMubG9va2FoZWFkLmxlbmd0aCA8IHN1YnRhYmxlLmxvb2thaGVhZENvdmVyYWdlLmxlbmd0aCkgeyByZXR1cm4gW107IH1cbiAgICB2YXIgbG9va2FoZWFkQ29udGV4dCA9IGNvbnRleHRQYXJhbXMubG9va2FoZWFkLnNsaWNlKGxvb2thaGVhZE9mZnNldCk7XG4gICAgd2hpbGUgKGxvb2thaGVhZENvbnRleHQubGVuZ3RoICYmIGlzVGFzaGtlZWxBcmFiaWNDaGFyKGxvb2thaGVhZENvbnRleHRbMF0uY2hhcikpIHtcbiAgICAgICAgbG9va2FoZWFkQ29udGV4dC5zaGlmdCgpO1xuICAgIH1cbiAgICB2YXIgbG9va2FoZWFkUGFyYW1zID0gbmV3IENvbnRleHRQYXJhbXMobG9va2FoZWFkQ29udGV4dCwgMCk7XG4gICAgdmFyIGxvb2thaGVhZExvb2t1cHMgPSBsb29rdXBDb3ZlcmFnZUxpc3QoXG4gICAgICAgIHN1YnRhYmxlLmxvb2thaGVhZENvdmVyYWdlLCBsb29rYWhlYWRQYXJhbXNcbiAgICApO1xuICAgIC8vIEJBQ0tUUkFDSyBMT09LVVAgLy9cbiAgICB2YXIgYmFja3RyYWNrQ29udGV4dCA9IFtdLmNvbmNhdChjb250ZXh0UGFyYW1zLmJhY2t0cmFjayk7XG4gICAgYmFja3RyYWNrQ29udGV4dC5yZXZlcnNlKCk7XG4gICAgd2hpbGUgKGJhY2t0cmFja0NvbnRleHQubGVuZ3RoICYmIGlzVGFzaGtlZWxBcmFiaWNDaGFyKGJhY2t0cmFja0NvbnRleHRbMF0uY2hhcikpIHtcbiAgICAgICAgYmFja3RyYWNrQ29udGV4dC5zaGlmdCgpO1xuICAgIH1cbiAgICBpZiAoYmFja3RyYWNrQ29udGV4dC5sZW5ndGggPCBzdWJ0YWJsZS5iYWNrdHJhY2tDb3ZlcmFnZS5sZW5ndGgpIHsgcmV0dXJuIFtdOyB9XG4gICAgdmFyIGJhY2t0cmFja1BhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKGJhY2t0cmFja0NvbnRleHQsIDApO1xuICAgIHZhciBiYWNrdHJhY2tMb29rdXBzID0gbG9va3VwQ292ZXJhZ2VMaXN0KFxuICAgICAgICBzdWJ0YWJsZS5iYWNrdHJhY2tDb3ZlcmFnZSwgYmFja3RyYWNrUGFyYW1zXG4gICAgKTtcbiAgICB2YXIgY29udGV4dFJ1bGVzTWF0Y2ggPSAoXG4gICAgICAgIGlucHV0TG9va3Vwcy5sZW5ndGggPT09IHN1YnRhYmxlLmlucHV0Q292ZXJhZ2UubGVuZ3RoICYmXG4gICAgICAgIGxvb2thaGVhZExvb2t1cHMubGVuZ3RoID09PSBzdWJ0YWJsZS5sb29rYWhlYWRDb3ZlcmFnZS5sZW5ndGggJiZcbiAgICAgICAgYmFja3RyYWNrTG9va3Vwcy5sZW5ndGggPT09IHN1YnRhYmxlLmJhY2t0cmFja0NvdmVyYWdlLmxlbmd0aFxuICAgICk7XG4gICAgdmFyIHN1YnN0aXR1dGlvbnMgPSBbXTtcbiAgICBpZiAoY29udGV4dFJ1bGVzTWF0Y2gpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZS5sb29rdXBSZWNvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbG9va3VwUmVjb3JkID0gc3VidGFibGUubG9va3VwUmVjb3Jkc1tpXTtcbiAgICAgICAgICAgIHZhciBsb29rdXBMaXN0SW5kZXggPSBsb29rdXBSZWNvcmQubG9va3VwTGlzdEluZGV4O1xuICAgICAgICAgICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBCeUluZGV4KGxvb2t1cExpc3RJbmRleCk7XG4gICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IGxvb2t1cFRhYmxlLnN1YnRhYmxlcy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgICAgIHZhciBzdWJ0YWJsZSQxID0gbG9va3VwVGFibGUuc3VidGFibGVzW3NdO1xuICAgICAgICAgICAgICAgIHZhciBsb29rdXAgPSB0aGlzLmdldExvb2t1cE1ldGhvZChsb29rdXBUYWJsZSwgc3VidGFibGUkMSk7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0aXR1dGlvblR5cGUgPSB0aGlzLmdldFN1YnN0aXR1dGlvblR5cGUobG9va3VwVGFibGUsIHN1YnRhYmxlJDEpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb25UeXBlID09PSAnMTInKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgaW5wdXRMb29rdXBzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2x5cGhJbmRleCA9IGNvbnRleHRQYXJhbXMuZ2V0KG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnN0aXR1dGlvbiA9IGxvb2t1cChnbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb24pIHsgc3Vic3RpdHV0aW9ucy5wdXNoKHN1YnN0aXR1dGlvbik7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3Vic3RpdHV0aW9ucztcbn1cblxuLyoqXG4gKiBIYW5kbGUgbGlnYXR1cmUgc3Vic3RpdHV0aW9uIC0gZm9ybWF0IDFcbiAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtcyB0byBsb29rdXBcbiAqL1xuZnVuY3Rpb24gbGlnYXR1cmVTdWJzdGl0dXRpb25Gb3JtYXQxKGNvbnRleHRQYXJhbXMsIHN1YnRhYmxlKSB7XG4gICAgLy8gQ09WRVJBR0UgTE9PS1VQIC8vXG4gICAgdmFyIGdseXBoSW5kZXggPSBjb250ZXh0UGFyYW1zLmN1cnJlbnQ7XG4gICAgdmFyIGxpZ1NldEluZGV4ID0gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgc3VidGFibGUuY292ZXJhZ2UpO1xuICAgIGlmIChsaWdTZXRJbmRleCA9PT0gLTEpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvLyBDT01QT05FTlRTIExPT0tVUFxuICAgIC8vICghKSBub3RlLCBjb21wb25lbnRzIGFyZSBvcmRlcmVkIGluIHRoZSB3cml0dGVuIGRpcmVjdGlvbi5cbiAgICB2YXIgbGlnYXR1cmU7XG4gICAgdmFyIGxpZ2F0dXJlU2V0ID0gc3VidGFibGUubGlnYXR1cmVTZXRzW2xpZ1NldEluZGV4XTtcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8IGxpZ2F0dXJlU2V0Lmxlbmd0aDsgcysrKSB7XG4gICAgICAgIGxpZ2F0dXJlID0gbGlnYXR1cmVTZXRbc107XG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGlnYXR1cmUuY29tcG9uZW50cy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgdmFyIGxvb2thaGVhZEl0ZW0gPSBjb250ZXh0UGFyYW1zLmxvb2thaGVhZFtsXTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBsaWdhdHVyZS5jb21wb25lbnRzW2xdO1xuICAgICAgICAgICAgaWYgKGxvb2thaGVhZEl0ZW0gIT09IGNvbXBvbmVudCkgeyBicmVhazsgfVxuICAgICAgICAgICAgaWYgKGwgPT09IGxpZ2F0dXJlLmNvbXBvbmVudHMubGVuZ3RoIC0gMSkgeyByZXR1cm4gbGlnYXR1cmU7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBIYW5kbGUgZGVjb21wb3NpdGlvbiBzdWJzdGl0dXRpb24gLSBmb3JtYXQgMVxuICogQHBhcmFtIHtudW1iZXJ9IGdseXBoSW5kZXggZ2x5cGggaW5kZXhcbiAqIEBwYXJhbSB7YW55fSBzdWJ0YWJsZSBzdWJ0YWJsZVxuICovXG5mdW5jdGlvbiBkZWNvbXBvc2l0aW9uU3Vic3RpdHV0aW9uRm9ybWF0MShnbHlwaEluZGV4LCBzdWJ0YWJsZSkge1xuICAgIHZhciBzdWJzdGl0dXRlSW5kZXggPSBsb29rdXBDb3ZlcmFnZShnbHlwaEluZGV4LCBzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgaWYgKHN1YnN0aXR1dGVJbmRleCA9PT0gLTEpIHsgcmV0dXJuIG51bGw7IH1cbiAgICByZXR1cm4gc3VidGFibGUuc2VxdWVuY2VzW3N1YnN0aXR1dGVJbmRleF07XG59XG5cbi8qKlxuICogR2V0IGRlZmF1bHQgc2NyaXB0IGZlYXR1cmVzIGluZGV4ZXNcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXREZWZhdWx0U2NyaXB0RmVhdHVyZXNJbmRleGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY3JpcHRzID0gdGhpcy5mb250LnRhYmxlcy5nc3ViLnNjcmlwdHM7XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzY3JpcHRzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBzY3JpcHRzW3NdO1xuICAgICAgICBpZiAoc2NyaXB0LnRhZyA9PT0gJ0RGTFQnKSB7IHJldHVybiAoXG4gICAgICAgICAgICBzY3JpcHQuc2NyaXB0LmRlZmF1bHRMYW5nU3lzLmZlYXR1cmVJbmRleGVzXG4gICAgICAgICk7IH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufTtcblxuLyoqXG4gKiBHZXQgZmVhdHVyZSBpbmRleGVzIG9mIGEgc3BlY2lmaWMgc2NyaXB0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0VGFnIHNjcmlwdCB0YWdcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRTY3JpcHRGZWF0dXJlc0luZGV4ZXMgPSBmdW5jdGlvbihzY3JpcHRUYWcpIHtcbiAgICB2YXIgdGFibGVzID0gdGhpcy5mb250LnRhYmxlcztcbiAgICBpZiAoIXRhYmxlcy5nc3ViKSB7IHJldHVybiBbXTsgfVxuICAgIGlmICghc2NyaXB0VGFnKSB7IHJldHVybiB0aGlzLmdldERlZmF1bHRTY3JpcHRGZWF0dXJlc0luZGV4ZXMoKTsgfVxuICAgIHZhciBzY3JpcHRzID0gdGhpcy5mb250LnRhYmxlcy5nc3ViLnNjcmlwdHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBzY3JpcHRzW2ldO1xuICAgICAgICBpZiAoc2NyaXB0LnRhZyA9PT0gc2NyaXB0VGFnICYmIHNjcmlwdC5zY3JpcHQuZGVmYXVsdExhbmdTeXMpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHQuc2NyaXB0LmRlZmF1bHRMYW5nU3lzLmZlYXR1cmVJbmRleGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxhbmdTeXNSZWNvcmRzID0gc2NyaXB0LmxhbmdTeXNSZWNvcmRzO1xuICAgICAgICAgICAgaWYgKCEhbGFuZ1N5c1JlY29yZHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxhbmdTeXNSZWNvcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYW5nU3lzUmVjb3JkID0gbGFuZ1N5c1JlY29yZHNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5nU3lzUmVjb3JkLnRhZyA9PT0gc2NyaXB0VGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZ1N5cyA9IGxhbmdTeXNSZWNvcmQubGFuZ1N5cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYW5nU3lzLmZlYXR1cmVJbmRleGVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRTY3JpcHRGZWF0dXJlc0luZGV4ZXMoKTtcbn07XG5cbi8qKlxuICogTWFwIGEgZmVhdHVyZSB0YWcgdG8gYSBnc3ViIGZlYXR1cmVcbiAqIEBwYXJhbSB7YW55fSBmZWF0dXJlcyBnc3ViIGZlYXR1cmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0VGFnIHNjcmlwdCB0YWdcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5tYXBUYWdzVG9GZWF0dXJlcyA9IGZ1bmN0aW9uIChmZWF0dXJlcywgc2NyaXB0VGFnKSB7XG4gICAgdmFyIHRhZ3MgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0YWcgPSBmZWF0dXJlc1tpXS50YWc7XG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV0uZmVhdHVyZTtcbiAgICAgICAgdGFnc1t0YWddID0gZmVhdHVyZTtcbiAgICB9XG4gICAgdGhpcy5mZWF0dXJlc1tzY3JpcHRUYWddLnRhZ3MgPSB0YWdzO1xufTtcblxuLyoqXG4gKiBHZXQgZmVhdHVyZXMgb2YgYSBzcGVjaWZpYyBzY3JpcHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHRUYWcgc2NyaXB0IHRhZ1xuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldFNjcmlwdEZlYXR1cmVzID0gZnVuY3Rpb24gKHNjcmlwdFRhZykge1xuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXNbc2NyaXB0VGFnXTtcbiAgICBpZiAodGhpcy5mZWF0dXJlcy5oYXNPd25Qcm9wZXJ0eShzY3JpcHRUYWcpKSB7IHJldHVybiBmZWF0dXJlczsgfVxuICAgIHZhciBmZWF0dXJlc0luZGV4ZXMgPSB0aGlzLmdldFNjcmlwdEZlYXR1cmVzSW5kZXhlcyhzY3JpcHRUYWcpO1xuICAgIGlmICghZmVhdHVyZXNJbmRleGVzKSB7IHJldHVybiBudWxsOyB9XG4gICAgdmFyIGdzdWIgPSB0aGlzLmZvbnQudGFibGVzLmdzdWI7XG4gICAgZmVhdHVyZXMgPSBmZWF0dXJlc0luZGV4ZXMubWFwKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gZ3N1Yi5mZWF0dXJlc1tpbmRleF07IH0pO1xuICAgIHRoaXMuZmVhdHVyZXNbc2NyaXB0VGFnXSA9IGZlYXR1cmVzO1xuICAgIHRoaXMubWFwVGFnc1RvRmVhdHVyZXMoZmVhdHVyZXMsIHNjcmlwdFRhZyk7XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xufTtcblxuLyoqXG4gKiBHZXQgc3Vic3RpdHV0aW9uIHR5cGVcbiAqIEBwYXJhbSB7YW55fSBsb29rdXBUYWJsZSBsb29rdXAgdGFibGVcbiAqIEBwYXJhbSB7YW55fSBzdWJ0YWJsZSBzdWJ0YWJsZVxuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldFN1YnN0aXR1dGlvblR5cGUgPSBmdW5jdGlvbihsb29rdXBUYWJsZSwgc3VidGFibGUpIHtcbiAgICB2YXIgbG9va3VwVHlwZSA9IGxvb2t1cFRhYmxlLmxvb2t1cFR5cGUudG9TdHJpbmcoKTtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSBzdWJ0YWJsZS5zdWJzdEZvcm1hdC50b1N0cmluZygpO1xuICAgIHJldHVybiBsb29rdXBUeXBlICsgc3Vic3RGb3JtYXQ7XG59O1xuXG4vKipcbiAqIEdldCBsb29rdXAgbWV0aG9kXG4gKiBAcGFyYW0ge2FueX0gbG9va3VwVGFibGUgbG9va3VwIHRhYmxlXG4gKiBAcGFyYW0ge2FueX0gc3VidGFibGUgc3VidGFibGVcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRMb29rdXBNZXRob2QgPSBmdW5jdGlvbihsb29rdXBUYWJsZSwgc3VidGFibGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzdWJzdGl0dXRpb25UeXBlID0gdGhpcy5nZXRTdWJzdGl0dXRpb25UeXBlKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSk7XG4gICAgc3dpdGNoIChzdWJzdGl0dXRpb25UeXBlKSB7XG4gICAgICAgIGNhc2UgJzExJzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ2x5cGhJbmRleCkgeyByZXR1cm4gc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MS5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzJDEsIFtnbHlwaEluZGV4LCBzdWJ0YWJsZV1cbiAgICAgICAgICAgICk7IH07XG4gICAgICAgIGNhc2UgJzEyJzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ2x5cGhJbmRleCkgeyByZXR1cm4gc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0Mi5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzJDEsIFtnbHlwaEluZGV4LCBzdWJ0YWJsZV1cbiAgICAgICAgICAgICk7IH07XG4gICAgICAgIGNhc2UgJzYzJzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dFBhcmFtcykgeyByZXR1cm4gY2hhaW5pbmdTdWJzdGl0dXRpb25Gb3JtYXQzLmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMkMSwgW2NvbnRleHRQYXJhbXMsIHN1YnRhYmxlXVxuICAgICAgICAgICAgKTsgfTtcbiAgICAgICAgY2FzZSAnNDEnOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0UGFyYW1zKSB7IHJldHVybiBsaWdhdHVyZVN1YnN0aXR1dGlvbkZvcm1hdDEuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyQxLCBbY29udGV4dFBhcmFtcywgc3VidGFibGVdXG4gICAgICAgICAgICApOyB9O1xuICAgICAgICBjYXNlICcyMSc6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdseXBoSW5kZXgpIHsgcmV0dXJuIGRlY29tcG9zaXRpb25TdWJzdGl0dXRpb25Gb3JtYXQxLmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMkMSwgW2dseXBoSW5kZXgsIHN1YnRhYmxlXVxuICAgICAgICAgICAgKTsgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImxvb2t1cFR5cGU6IFwiICsgKGxvb2t1cFRhYmxlLmxvb2t1cFR5cGUpICsgXCIgLSBcIiArXG4gICAgICAgICAgICAgICAgXCJzdWJzdEZvcm1hdDogXCIgKyAoc3VidGFibGUuc3Vic3RGb3JtYXQpICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgIFwiaXMgbm90IHlldCBzdXBwb3J0ZWRcIlxuICAgICAgICAgICAgKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFsgTE9PS1VQIFRZUEVTIF1cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFNpbmdsZSAgICAgICAgICAgICAgICAgICAgICAgIDE7XG4gKiBNdWx0aXBsZSAgICAgICAgICAgICAgICAgICAgICAyO1xuICogQWx0ZXJuYXRlICAgICAgICAgICAgICAgICAgICAgMztcbiAqIExpZ2F0dXJlICAgICAgICAgICAgICAgICAgICAgIDQ7XG4gKiBDb250ZXh0ICAgICAgICAgICAgICAgICAgICAgICA1O1xuICogQ2hhaW5pbmdDb250ZXh0ICAgICAgICAgICAgICAgNjtcbiAqIEV4dGVuc2lvblN1YnN0aXR1dGlvbiAgICAgICAgIDc7XG4gKiBSZXZlcnNlQ2hhaW5pbmdDb250ZXh0ICAgICAgICA4O1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIEZRdWVyeVxuICogQHR5cGUgT2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIGZlYXR1cmUgdGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0IGZlYXR1cmUgc2NyaXB0XG4gKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIExvb2t1cCBhIGZlYXR1cmUgdXNpbmcgYSBxdWVyeSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0ZRdWVyeX0gcXVlcnkgZmVhdHVyZSBxdWVyeVxuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmxvb2t1cEZlYXR1cmUgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICB2YXIgY29udGV4dFBhcmFtcyA9IHF1ZXJ5LmNvbnRleHRQYXJhbXM7XG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IGNvbnRleHRQYXJhbXMuaW5kZXg7XG4gICAgdmFyIGZlYXR1cmUgPSB0aGlzLmdldEZlYXR1cmUoe1xuICAgICAgICB0YWc6IHF1ZXJ5LnRhZywgc2NyaXB0OiBxdWVyeS5zY3JpcHRcbiAgICB9KTtcbiAgICBpZiAoIWZlYXR1cmUpIHsgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgXCJmb250ICdcIiArICh0aGlzLmZvbnQubmFtZXMuZnVsbE5hbWUuZW4pICsgXCInIFwiICtcbiAgICAgICAgXCJkb2Vzbid0IHN1cHBvcnQgZmVhdHVyZSAnXCIgKyAocXVlcnkudGFnKSArIFwiJyBcIiArXG4gICAgICAgIFwiZm9yIHNjcmlwdCAnXCIgKyAocXVlcnkuc2NyaXB0KSArIFwiJy5cIlxuICAgICk7IH1cbiAgICB2YXIgbG9va3VwcyA9IHRoaXMuZ2V0RmVhdHVyZUxvb2t1cHMoZmVhdHVyZSk7XG4gICAgdmFyIHN1YnN0aXR1dGlvbnMgPSBbXS5jb25jYXQoY29udGV4dFBhcmFtcy5jb250ZXh0KTtcbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxvb2t1cHMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgdmFyIGxvb2t1cFRhYmxlID0gbG9va3Vwc1tsXTtcbiAgICAgICAgdmFyIHN1YnRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwU3VidGFibGVzKGxvb2t1cFRhYmxlKTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdWJ0YWJsZXMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tzXTtcbiAgICAgICAgICAgIHZhciBzdWJzdFR5cGUgPSB0aGlzLmdldFN1YnN0aXR1dGlvblR5cGUobG9va3VwVGFibGUsIHN1YnRhYmxlKTtcbiAgICAgICAgICAgIHZhciBsb29rdXAgPSB0aGlzLmdldExvb2t1cE1ldGhvZChsb29rdXBUYWJsZSwgc3VidGFibGUpO1xuICAgICAgICAgICAgdmFyIHN1YnN0aXR1dGlvbiA9ICh2b2lkIDApO1xuICAgICAgICAgICAgc3dpdGNoIChzdWJzdFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcxMSc6XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IGxvb2t1cChjb250ZXh0UGFyYW1zLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnNwbGljZShjdXJyZW50SW5kZXgsIDEsIG5ldyBTdWJzdGl0dXRpb25BY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAxMSwgdGFnOiBxdWVyeS50YWcsIHN1YnN0aXR1dGlvbjogc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnMTInOlxuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb24gPSBsb29rdXAoY29udGV4dFBhcmFtcy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0aXR1dGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5zcGxpY2UoY3VycmVudEluZGV4LCAxLCBuZXcgU3Vic3RpdHV0aW9uQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogMTIsIHRhZzogcXVlcnkudGFnLCBzdWJzdGl0dXRpb246IHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzYzJzpcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uID0gbG9va3VwKGNvbnRleHRQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJzdGl0dXRpb24pICYmIHN1YnN0aXR1dGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSwgbmV3IFN1YnN0aXR1dGlvbkFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDYzLCB0YWc6IHF1ZXJ5LnRhZywgc3Vic3RpdHV0aW9uOiBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICc0MSc6XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IGxvb2t1cChjb250ZXh0UGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0aXR1dGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5zcGxpY2UoY3VycmVudEluZGV4LCAxLCBuZXcgU3Vic3RpdHV0aW9uQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogNDEsIHRhZzogcXVlcnkudGFnLCBzdWJzdGl0dXRpb246IHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzIxJzpcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uID0gbG9va3VwKGNvbnRleHRQYXJhbXMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSwgbmV3IFN1YnN0aXR1dGlvbkFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDIxLCB0YWc6IHF1ZXJ5LnRhZywgc3Vic3RpdHV0aW9uOiBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHRQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhzdWJzdGl0dXRpb25zLCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic3RpdHV0aW9uKSAmJiAhc3Vic3RpdHV0aW9uLmxlbmd0aCkgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgc3Vic3RpdHV0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3Vic3RpdHV0aW9ucy5sZW5ndGggPyBzdWJzdGl0dXRpb25zIDogbnVsbDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZm9udCBzdXBwb3J0cyBhIHNwZWNpZmljIGZlYXR1cmVzXG4gKiBAcGFyYW0ge0ZRdWVyeX0gcXVlcnkgZmVhdHVyZSBxdWVyeSBvYmplY3RcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIGlmICghcXVlcnkuc2NyaXB0KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHRoaXMuZ2V0U2NyaXB0RmVhdHVyZXMocXVlcnkuc2NyaXB0KTtcbiAgICB2YXIgc3VwcG9ydGVkU2NyaXB0ID0gdGhpcy5mZWF0dXJlcy5oYXNPd25Qcm9wZXJ0eShxdWVyeS5zY3JpcHQpO1xuICAgIGlmICghcXVlcnkudGFnKSB7IHJldHVybiBzdXBwb3J0ZWRTY3JpcHQ7IH1cbiAgICB2YXIgc3VwcG9ydGVkRmVhdHVyZSA9IChcbiAgICAgICAgdGhpcy5mZWF0dXJlc1txdWVyeS5zY3JpcHRdLnNvbWUoZnVuY3Rpb24gKGZlYXR1cmUpIHsgcmV0dXJuIGZlYXR1cmUudGFnID09PSBxdWVyeS50YWc7IH0pXG4gICAgKTtcbiAgICByZXR1cm4gc3VwcG9ydGVkU2NyaXB0ICYmIHN1cHBvcnRlZEZlYXR1cmU7XG59O1xuXG4vKipcbiAqIEdldCBsb29rdXAgdGFibGUgc3VidGFibGVzXG4gKiBAcGFyYW0ge2FueX0gbG9va3VwVGFibGUgbG9va3VwIHRhYmxlXG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0TG9va3VwU3VidGFibGVzID0gZnVuY3Rpb24gKGxvb2t1cFRhYmxlKSB7XG4gICAgcmV0dXJuIGxvb2t1cFRhYmxlLnN1YnRhYmxlcyB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgbG9va3VwIHRhYmxlIGJ5IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggbG9va3VwIHRhYmxlIGluZGV4XG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0TG9va3VwQnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBsb29rdXBzID0gdGhpcy5mb250LnRhYmxlcy5nc3ViLmxvb2t1cHM7XG4gICAgcmV0dXJuIGxvb2t1cHNbaW5kZXhdIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEdldCBsb29rdXAgdGFibGVzIGZvciBhIGZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlXG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0RmVhdHVyZUxvb2t1cHMgPSBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgIC8vIFRPRE86IG1lbW9pemVcbiAgICByZXR1cm4gZmVhdHVyZS5sb29rdXBMaXN0SW5kZXhlcy5tYXAodGhpcy5nZXRMb29rdXBCeUluZGV4LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBRdWVyeSBhIGZlYXR1cmUgYnkgaXQncyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge2FueX0gcXVlcnkgYW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBwcm9wZXJ0aWVzIG9mIGEgcXVlcnlcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRGZWF0dXJlID0gZnVuY3Rpb24gZ2V0RmVhdHVyZShxdWVyeSkge1xuICAgIGlmICghdGhpcy5mb250KSB7IHJldHVybiB7IEZBSUw6IFwiTm8gZm9udCB3YXMgZm91bmRcIn07IH1cbiAgICBpZiAoIXRoaXMuZmVhdHVyZXMuaGFzT3duUHJvcGVydHkocXVlcnkuc2NyaXB0KSkge1xuICAgICAgICB0aGlzLmdldFNjcmlwdEZlYXR1cmVzKHF1ZXJ5LnNjcmlwdCk7XG4gICAgfVxuICAgIHZhciBzY3JpcHRGZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXNbcXVlcnkuc2NyaXB0XTtcbiAgICBpZiAoIXNjcmlwdEZlYXR1cmVzKSB7IHJldHVybiAoXG4gICAgICAgIHsgRkFJTDogKFwiTm8gZmVhdHVyZSBmb3Igc2NyaXB0IFwiICsgKHF1ZXJ5LnNjcmlwdCkpfVxuICAgICk7IH1cbiAgICBpZiAoIXNjcmlwdEZlYXR1cmVzLnRhZ3NbcXVlcnkudGFnXSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHJldHVybiB0aGlzLmZlYXR1cmVzW3F1ZXJ5LnNjcmlwdF0udGFnc1txdWVyeS50YWddO1xufTtcblxuLyoqXG4gKiBBcmFiaWMgd29yZCBjb250ZXh0IGNoZWNrZXJzXG4gKi9cblxuZnVuY3Rpb24gYXJhYmljV29yZFN0YXJ0Q2hlY2soY29udGV4dFBhcmFtcykge1xuICAgIHZhciBjaGFyID0gY29udGV4dFBhcmFtcy5jdXJyZW50O1xuICAgIHZhciBwcmV2Q2hhciA9IGNvbnRleHRQYXJhbXMuZ2V0KC0xKTtcbiAgICByZXR1cm4gKFxuICAgICAgICAvLyA/IGFyYWJpYyBmaXJzdCBjaGFyXG4gICAgICAgIChwcmV2Q2hhciA9PT0gbnVsbCAmJiBpc0FyYWJpY0NoYXIoY2hhcikpIHx8XG4gICAgICAgIC8vID8gYXJhYmljIGNoYXIgcHJlY2VkZWQgd2l0aCBhIG5vbiBhcmFiaWMgY2hhclxuICAgICAgICAoIWlzQXJhYmljQ2hhcihwcmV2Q2hhcikgJiYgaXNBcmFiaWNDaGFyKGNoYXIpKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGFyYWJpY1dvcmRFbmRDaGVjayhjb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIG5leHRDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoMSk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgLy8gPyBsYXN0IGFyYWJpYyBjaGFyXG4gICAgICAgIChuZXh0Q2hhciA9PT0gbnVsbCkgfHxcbiAgICAgICAgLy8gPyBuZXh0IGNoYXIgaXMgbm90IGFyYWJpY1xuICAgICAgICAoIWlzQXJhYmljQ2hhcihuZXh0Q2hhcikpXG4gICAgKTtcbn1cblxudmFyIGFyYWJpY1dvcmRDaGVjayA9IHtcbiAgICBzdGFydENoZWNrOiBhcmFiaWNXb3JkU3RhcnRDaGVjayxcbiAgICBlbmRDaGVjazogYXJhYmljV29yZEVuZENoZWNrXG59O1xuXG4vKipcbiAqIEFyYWJpYyBzZW50ZW5jZSBjb250ZXh0IGNoZWNrZXJzXG4gKi9cblxuZnVuY3Rpb24gYXJhYmljU2VudGVuY2VTdGFydENoZWNrKGNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgY2hhciA9IGNvbnRleHRQYXJhbXMuY3VycmVudDtcbiAgICB2YXIgcHJldkNoYXIgPSBjb250ZXh0UGFyYW1zLmdldCgtMSk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgLy8gPyBhbiBhcmFiaWMgY2hhciBwcmVjZWRlZCB3aXRoIGEgbm9uIGFyYWJpYyBjaGFyXG4gICAgICAgIChpc0FyYWJpY0NoYXIoY2hhcikgfHwgaXNUYXNoa2VlbEFyYWJpY0NoYXIoY2hhcikpICYmXG4gICAgICAgICFpc0FyYWJpY0NoYXIocHJldkNoYXIpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gYXJhYmljU2VudGVuY2VFbmRDaGVjayhjb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIG5leHRDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoMSk7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgbmV4dENoYXIgPT09IG51bGw6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAoIWlzQXJhYmljQ2hhcihuZXh0Q2hhcikgJiYgIWlzVGFzaGtlZWxBcmFiaWNDaGFyKG5leHRDaGFyKSk6XG4gICAgICAgICAgICB2YXIgbmV4dElzV2hpdGVzcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG4gICAgICAgICAgICBpZiAoIW5leHRJc1doaXRlc3BhY2UpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICAgIGlmIChuZXh0SXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyYWJpY0NoYXJBaGVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFyYWJpY0NoYXJBaGVhZCA9IChcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFBhcmFtcy5sb29rYWhlYWQuc29tZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjKSB7IHJldHVybiBpc0FyYWJpY0NoYXIoYykgfHwgaXNUYXNoa2VlbEFyYWJpY0NoYXIoYyk7IH1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCFhcmFiaWNDaGFyQWhlYWQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxudmFyIGFyYWJpY1NlbnRlbmNlQ2hlY2sgPSB7XG4gICAgc3RhcnRDaGVjazogYXJhYmljU2VudGVuY2VTdGFydENoZWNrLFxuICAgIGVuZENoZWNrOiBhcmFiaWNTZW50ZW5jZUVuZENoZWNrXG59O1xuXG4vKipcbiAqIEFwcGx5IHNpbmdsZSBzdWJzdGl0dXRpb24gZm9ybWF0IDFcbiAqIEBwYXJhbSB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgc3Vic3RpdHV0aW9uc1xuICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAqL1xuZnVuY3Rpb24gc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MSQxKGFjdGlvbiwgdG9rZW5zLCBpbmRleCkge1xuICAgIHRva2Vuc1tpbmRleF0uc2V0U3RhdGUoYWN0aW9uLnRhZywgYWN0aW9uLnN1YnN0aXR1dGlvbik7XG59XG5cbi8qKlxuICogQXBwbHkgc2luZ2xlIHN1YnN0aXR1dGlvbiBmb3JtYXQgMlxuICogQHBhcmFtIHtBcnJheX0gc3Vic3RpdHV0aW9ucyBzdWJzdGl0dXRpb25zXG4gKiBAcGFyYW0ge2FueX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuICovXG5mdW5jdGlvbiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQyJDEoYWN0aW9uLCB0b2tlbnMsIGluZGV4KSB7XG4gICAgdG9rZW5zW2luZGV4XS5zZXRTdGF0ZShhY3Rpb24udGFnLCBhY3Rpb24uc3Vic3RpdHV0aW9uKTtcbn1cblxuLyoqXG4gKiBBcHBseSBjaGFpbmluZyBjb250ZXh0IHN1YnN0aXR1dGlvbiBmb3JtYXQgM1xuICogQHBhcmFtIHtBcnJheX0gc3Vic3RpdHV0aW9ucyBzdWJzdGl0dXRpb25zXG4gKiBAcGFyYW0ge2FueX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuICovXG5mdW5jdGlvbiBjaGFpbmluZ1N1YnN0aXR1dGlvbkZvcm1hdDMkMShhY3Rpb24sIHRva2VucywgaW5kZXgpIHtcbiAgICBhY3Rpb24uc3Vic3RpdHV0aW9uLmZvckVhY2goZnVuY3Rpb24gKHN1YnN0LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2luZGV4ICsgb2Zmc2V0XTtcbiAgICAgICAgdG9rZW4uc2V0U3RhdGUoYWN0aW9uLnRhZywgc3Vic3QpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFwcGx5IGxpZ2F0dXJlIHN1YnN0aXR1dGlvbiBmb3JtYXQgMVxuICogQHBhcmFtIHtBcnJheX0gc3Vic3RpdHV0aW9ucyBzdWJzdGl0dXRpb25zXG4gKiBAcGFyYW0ge2FueX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuICovXG5mdW5jdGlvbiBsaWdhdHVyZVN1YnN0aXR1dGlvbkZvcm1hdDEkMShhY3Rpb24sIHRva2VucywgaW5kZXgpIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaW5kZXhdO1xuICAgIHRva2VuLnNldFN0YXRlKGFjdGlvbi50YWcsIGFjdGlvbi5zdWJzdGl0dXRpb24ubGlnR2x5cGgpO1xuICAgIHZhciBjb21wc0NvdW50ID0gYWN0aW9uLnN1YnN0aXR1dGlvbi5jb21wb25lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBzQ291bnQ7IGkrKykge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpbmRleCArIGkgKyAxXTtcbiAgICAgICAgdG9rZW4uc2V0U3RhdGUoJ2RlbGV0ZWQnLCB0cnVlKTtcbiAgICB9XG59XG5cbi8qKlxuICogU3VwcG9ydGVkIHN1YnN0aXR1dGlvbnNcbiAqL1xudmFyIFNVQlNUSVRVVElPTlMgPSB7XG4gICAgMTE6IHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDEkMSxcbiAgICAxMjogc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MiQxLFxuICAgIDYzOiBjaGFpbmluZ1N1YnN0aXR1dGlvbkZvcm1hdDMkMSxcbiAgICA0MTogbGlnYXR1cmVTdWJzdGl0dXRpb25Gb3JtYXQxJDFcbn07XG5cbi8qKlxuICogQXBwbHkgc3Vic3RpdHV0aW9ucyB0byBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge0FycmF5fSBzdWJzdGl0dXRpb25zIHN1YnN0aXR1dGlvbnNcbiAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3Vic3RpdHV0aW9uKGFjdGlvbiwgdG9rZW5zLCBpbmRleCkge1xuICAgIGlmIChhY3Rpb24gaW5zdGFuY2VvZiBTdWJzdGl0dXRpb25BY3Rpb24gJiYgU1VCU1RJVFVUSU9OU1thY3Rpb24uaWRdKSB7XG4gICAgICAgIFNVQlNUSVRVVElPTlNbYWN0aW9uLmlkXShhY3Rpb24sIHRva2VucywgaW5kZXgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcHBseSBBcmFiaWMgcHJlc2VudGF0aW9uIGZvcm1zIHRvIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNoYXIgY2FuIGJlIGNvbm5lY3RlZCB0byBpdCdzIHByZWNlZGluZyBjaGFyXG4gKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNoYXJDb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIG9mIGEgY2hhclxuICovXG5mdW5jdGlvbiB3aWxsQ29ubmVjdFByZXYoY2hhckNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgYmFja3RyYWNrID0gW10uY29uY2F0KGNoYXJDb250ZXh0UGFyYW1zLmJhY2t0cmFjayk7XG4gICAgZm9yICh2YXIgaSA9IGJhY2t0cmFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgcHJldkNoYXIgPSBiYWNrdHJhY2tbaV07XG4gICAgICAgIHZhciBpc29sYXRlZCA9IGlzSXNvbGF0ZWRBcmFiaWNDaGFyKHByZXZDaGFyKTtcbiAgICAgICAgdmFyIHRhc2hrZWVsID0gaXNUYXNoa2VlbEFyYWJpY0NoYXIocHJldkNoYXIpO1xuICAgICAgICBpZiAoIWlzb2xhdGVkICYmICF0YXNoa2VlbCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICBpZiAoaXNvbGF0ZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNoYXIgY2FuIGJlIGNvbm5lY3RlZCB0byBpdCdzIHByb2NlZWRpbmcgY2hhclxuICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjaGFyQ29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtcyBvZiBhIGNoYXJcbiAqL1xuZnVuY3Rpb24gd2lsbENvbm5lY3ROZXh0KGNoYXJDb250ZXh0UGFyYW1zKSB7XG4gICAgaWYgKGlzSXNvbGF0ZWRBcmFiaWNDaGFyKGNoYXJDb250ZXh0UGFyYW1zLmN1cnJlbnQpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhckNvbnRleHRQYXJhbXMubG9va2FoZWFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXh0Q2hhciA9IGNoYXJDb250ZXh0UGFyYW1zLmxvb2thaGVhZFtpXTtcbiAgICAgICAgdmFyIHRhc2hrZWVsID0gaXNUYXNoa2VlbEFyYWJpY0NoYXIobmV4dENoYXIpO1xuICAgICAgICBpZiAoIXRhc2hrZWVsKSB7IHJldHVybiB0cnVlOyB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBcHBseSBhcmFiaWMgcHJlc2VudGF0aW9uIGZvcm1zIHRvIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7Q29udGV4dFJhbmdlfSByYW5nZSBhIHJhbmdlIG9mIHRva2Vuc1xuICovXG5mdW5jdGlvbiBhcmFiaWNQcmVzZW50YXRpb25Gb3JtcyhyYW5nZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNjcmlwdCA9ICdhcmFiJztcbiAgICB2YXIgdGFncyA9IHRoaXMuZmVhdHVyZXNUYWdzW3NjcmlwdF07XG4gICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5pemVyLmdldFJhbmdlVG9rZW5zKHJhbmdlKTtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSkgeyByZXR1cm47IH1cbiAgICB2YXIgY29udGV4dFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKFxuICAgICAgICB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uZ2V0U3RhdGUoJ2dseXBoSW5kZXgnKTsgfVxuICAgICksIDApO1xuICAgIHZhciBjaGFyQ29udGV4dFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKFxuICAgICAgICB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uY2hhcjsgfVxuICAgICksIDApO1xuICAgIHRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbiwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGlzVGFzaGtlZWxBcmFiaWNDaGFyKHRva2VuLmNoYXIpKSB7IHJldHVybjsgfVxuICAgICAgICBjb250ZXh0UGFyYW1zLnNldEN1cnJlbnRJbmRleChpbmRleCk7XG4gICAgICAgIGNoYXJDb250ZXh0UGFyYW1zLnNldEN1cnJlbnRJbmRleChpbmRleCk7XG4gICAgICAgIHZhciBDT05ORUNUID0gMDsgLy8gMiBiaXRzIDAwICgxMDogY2FuIGNvbm5lY3QgbmV4dCkgKDAxOiBjYW4gY29ubmVjdCBwcmV2KVxuICAgICAgICBpZiAod2lsbENvbm5lY3RQcmV2KGNoYXJDb250ZXh0UGFyYW1zKSkgeyBDT05ORUNUIHw9IDE7IH1cbiAgICAgICAgaWYgKHdpbGxDb25uZWN0TmV4dChjaGFyQ29udGV4dFBhcmFtcykpIHsgQ09OTkVDVCB8PSAyOyB9XG4gICAgICAgIHZhciB0YWc7XG4gICAgICAgIHN3aXRjaCAoQ09OTkVDVCkge1xuICAgICAgICAgICAgY2FzZSAxOiAodGFnID0gJ2ZpbmEnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6ICh0YWcgPSAnaW5pdCcpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzogKHRhZyA9ICdtZWRpJyk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWdzLmluZGV4T2YodGFnKSA9PT0gLTEpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBzdWJzdGl0dXRpb25zID0gdGhpcyQxLnF1ZXJ5Lmxvb2t1cEZlYXR1cmUoe1xuICAgICAgICAgICAgdGFnOiB0YWcsIHNjcmlwdDogc2NyaXB0LCBjb250ZXh0UGFyYW1zOiBjb250ZXh0UGFyYW1zXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3Vic3RpdHV0aW9ucyBpbnN0YW5jZW9mIEVycm9yKSB7IHJldHVybiBjb25zb2xlLmluZm8oc3Vic3RpdHV0aW9ucy5tZXNzYWdlKTsgfVxuICAgICAgICBzdWJzdGl0dXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGFjdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gaW5zdGFuY2VvZiBTdWJzdGl0dXRpb25BY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBhcHBseVN1YnN0aXR1dGlvbihhY3Rpb24sIHRva2VucywgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHRQYXJhbXMuY29udGV4dFtpbmRleF0gPSBhY3Rpb24uc3Vic3RpdHV0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBcHBseSBBcmFiaWMgcmVxdWlyZWQgbGlnYXR1cmVzIGZlYXR1cmUgdG8gYSByYW5nZSBvZiB0b2tlbnNcbiAqL1xuXG4vKipcbiAqIFVwZGF0ZSBjb250ZXh0IHBhcmFtc1xuICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggY3VycmVudCBpdGVtIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGdldENvbnRleHRQYXJhbXModG9rZW5zLCBpbmRleCkge1xuICAgIHZhciBjb250ZXh0ID0gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmFjdGl2ZVN0YXRlLnZhbHVlOyB9KTtcbiAgICByZXR1cm4gbmV3IENvbnRleHRQYXJhbXMoY29udGV4dCwgaW5kZXggfHwgMCk7XG59XG5cbi8qKlxuICogQXBwbHkgQXJhYmljIHJlcXVpcmVkIGxpZ2F0dXJlcyB0byBhIGNvbnRleHQgcmFuZ2VcbiAqIEBwYXJhbSB7Q29udGV4dFJhbmdlfSByYW5nZSBhIHJhbmdlIG9mIHRva2Vuc1xuICovXG5mdW5jdGlvbiBhcmFiaWNSZXF1aXJlZExpZ2F0dXJlcyhyYW5nZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNjcmlwdCA9ICdhcmFiJztcbiAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbml6ZXIuZ2V0UmFuZ2VUb2tlbnMocmFuZ2UpO1xuICAgIHZhciBjb250ZXh0UGFyYW1zID0gZ2V0Q29udGV4dFBhcmFtcyh0b2tlbnMpO1xuICAgIGNvbnRleHRQYXJhbXMuY29udGV4dC5mb3JFYWNoKGZ1bmN0aW9uIChnbHlwaEluZGV4LCBpbmRleCkge1xuICAgICAgICBjb250ZXh0UGFyYW1zLnNldEN1cnJlbnRJbmRleChpbmRleCk7XG4gICAgICAgIHZhciBzdWJzdGl0dXRpb25zID0gdGhpcyQxLnF1ZXJ5Lmxvb2t1cEZlYXR1cmUoe1xuICAgICAgICAgICAgdGFnOiAncmxpZycsIHNjcmlwdDogc2NyaXB0LCBjb250ZXh0UGFyYW1zOiBjb250ZXh0UGFyYW1zXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3Vic3RpdHV0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuZm9yRWFjaChcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBhcHBseVN1YnN0aXR1dGlvbihhY3Rpb24sIHRva2VucywgaW5kZXgpOyB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGV4dFBhcmFtcyA9IGdldENvbnRleHRQYXJhbXModG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIExhdGluIHdvcmQgY29udGV4dCBjaGVja2Vyc1xuICovXG5cbmZ1bmN0aW9uIGxhdGluV29yZFN0YXJ0Q2hlY2soY29udGV4dFBhcmFtcykge1xuICAgIHZhciBjaGFyID0gY29udGV4dFBhcmFtcy5jdXJyZW50O1xuICAgIHZhciBwcmV2Q2hhciA9IGNvbnRleHRQYXJhbXMuZ2V0KC0xKTtcbiAgICByZXR1cm4gKFxuICAgICAgICAvLyA/IGxhdGluIGZpcnN0IGNoYXJcbiAgICAgICAgKHByZXZDaGFyID09PSBudWxsICYmIGlzTGF0aW5DaGFyKGNoYXIpKSB8fFxuICAgICAgICAvLyA/IGxhdGluIGNoYXIgcHJlY2VkZWQgd2l0aCBhIG5vbiBsYXRpbiBjaGFyXG4gICAgICAgICghaXNMYXRpbkNoYXIocHJldkNoYXIpICYmIGlzTGF0aW5DaGFyKGNoYXIpKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGxhdGluV29yZEVuZENoZWNrKGNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgbmV4dENoYXIgPSBjb250ZXh0UGFyYW1zLmdldCgxKTtcbiAgICByZXR1cm4gKFxuICAgICAgICAvLyA/IGxhc3QgbGF0aW4gY2hhclxuICAgICAgICAobmV4dENoYXIgPT09IG51bGwpIHx8XG4gICAgICAgIC8vID8gbmV4dCBjaGFyIGlzIG5vdCBsYXRpblxuICAgICAgICAoIWlzTGF0aW5DaGFyKG5leHRDaGFyKSlcbiAgICApO1xufVxuXG52YXIgbGF0aW5Xb3JkQ2hlY2sgPSB7XG4gICAgc3RhcnRDaGVjazogbGF0aW5Xb3JkU3RhcnRDaGVjayxcbiAgICBlbmRDaGVjazogbGF0aW5Xb3JkRW5kQ2hlY2tcbn07XG5cbi8qKlxuICogQXBwbHkgTGF0aW4gbGlnYXR1cmUgZmVhdHVyZSB0byBhIHJhbmdlIG9mIHRva2Vuc1xuICovXG5cbi8qKlxuICogVXBkYXRlIGNvbnRleHQgcGFyYW1zXG4gKiBAcGFyYW0ge2FueX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBjdXJyZW50IGl0ZW0gaW5kZXhcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dFBhcmFtcyQxKHRva2VucywgaW5kZXgpIHtcbiAgICB2YXIgY29udGV4dCA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5hY3RpdmVTdGF0ZS52YWx1ZTsgfSk7XG4gICAgcmV0dXJuIG5ldyBDb250ZXh0UGFyYW1zKGNvbnRleHQsIGluZGV4IHx8IDApO1xufVxuXG4vKipcbiAqIEFwcGx5IEFyYWJpYyByZXF1aXJlZCBsaWdhdHVyZXMgdG8gYSBjb250ZXh0IHJhbmdlXG4gKiBAcGFyYW0ge0NvbnRleHRSYW5nZX0gcmFuZ2UgYSByYW5nZSBvZiB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gbGF0aW5MaWdhdHVyZShyYW5nZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNjcmlwdCA9ICdsYXRuJztcbiAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbml6ZXIuZ2V0UmFuZ2VUb2tlbnMocmFuZ2UpO1xuICAgIHZhciBjb250ZXh0UGFyYW1zID0gZ2V0Q29udGV4dFBhcmFtcyQxKHRva2Vucyk7XG4gICAgY29udGV4dFBhcmFtcy5jb250ZXh0LmZvckVhY2goZnVuY3Rpb24gKGdseXBoSW5kZXgsIGluZGV4KSB7XG4gICAgICAgIGNvbnRleHRQYXJhbXMuc2V0Q3VycmVudEluZGV4KGluZGV4KTtcbiAgICAgICAgdmFyIHN1YnN0aXR1dGlvbnMgPSB0aGlzJDEucXVlcnkubG9va3VwRmVhdHVyZSh7XG4gICAgICAgICAgICB0YWc6ICdsaWdhJywgc2NyaXB0OiBzY3JpcHQsIGNvbnRleHRQYXJhbXM6IGNvbnRleHRQYXJhbXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdWJzdGl0dXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGFwcGx5U3Vic3RpdHV0aW9uKGFjdGlvbiwgdG9rZW5zLCBpbmRleCk7IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250ZXh0UGFyYW1zID0gZ2V0Q29udGV4dFBhcmFtcyQxKHRva2Vucyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBJbmZlciBiaWRpcmVjdGlvbmFsIHByb3BlcnRpZXMgZm9yIGEgZ2l2ZW4gdGV4dCBhbmQgYXBwbHlcbiAqIHRoZSBjb3JyZXNwb25kaW5nIGxheW91dCBydWxlcy5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBCaWRpLiBmZWF0dXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VEaXIgdGV4dCBiYXNlIGRpcmVjdGlvbi4gdmFsdWUgZWl0aGVyICdsdHInIG9yICdydGwnXG4gKi9cbmZ1bmN0aW9uIEJpZGkoYmFzZURpcikge1xuICAgIHRoaXMuYmFzZURpciA9IGJhc2VEaXIgfHwgJ2x0cic7XG4gICAgdGhpcy50b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKCk7XG4gICAgdGhpcy5mZWF0dXJlc1RhZ3MgPSB7fTtcbn1cblxuLyoqXG4gKiBTZXRzIEJpZGkgdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgYSB0ZXh0IGlucHV0XG4gKi9cbkJpZGkucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG59O1xuXG4vKipcbiAqIFN0b3JlIGVzc2VudGlhbCBjb250ZXh0IGNoZWNrczpcbiAqIGFyYWJpYyB3b3JkIGNoZWNrIGZvciBhcHBseWluZyBnc3ViIGZlYXR1cmVzXG4gKiBhcmFiaWMgc2VudGVuY2UgY2hlY2sgZm9yIGFkanVzdGluZyBhcmFiaWMgbGF5b3V0XG4gKi9cbkJpZGkucHJvdG90eXBlLmNvbnRleHRDaGVja3MgPSAoe1xuICAgIGxhdGluV29yZENoZWNrOiBsYXRpbldvcmRDaGVjayxcbiAgICBhcmFiaWNXb3JkQ2hlY2s6IGFyYWJpY1dvcmRDaGVjayxcbiAgICBhcmFiaWNTZW50ZW5jZUNoZWNrOiBhcmFiaWNTZW50ZW5jZUNoZWNrXG59KTtcblxuLyoqXG4gKiBSZWdpc3RlciBhcmFiaWMgd29yZCBjaGVja1xuICovXG5mdW5jdGlvbiByZWdpc3RlckNvbnRleHRDaGVja2VyKGNoZWNrSWQpIHtcbiAgICB2YXIgY2hlY2sgPSB0aGlzLmNvbnRleHRDaGVja3NbKGNoZWNrSWQgKyBcIkNoZWNrXCIpXTtcbiAgICByZXR1cm4gdGhpcy50b2tlbml6ZXIucmVnaXN0ZXJDb250ZXh0Q2hlY2tlcihcbiAgICAgICAgY2hlY2tJZCwgY2hlY2suc3RhcnRDaGVjaywgY2hlY2suZW5kQ2hlY2tcbiAgICApO1xufVxuXG4vKipcbiAqIFBlcmZvcm0gcHJlIHRva2VuaXphdGlvbiBwcm9jZWR1cmUgdGhlblxuICogdG9rZW5pemUgdGV4dCBpbnB1dFxuICovXG5mdW5jdGlvbiB0b2tlbml6ZVRleHQoKSB7XG4gICAgcmVnaXN0ZXJDb250ZXh0Q2hlY2tlci5jYWxsKHRoaXMsICdsYXRpbldvcmQnKTtcbiAgICByZWdpc3RlckNvbnRleHRDaGVja2VyLmNhbGwodGhpcywgJ2FyYWJpY1dvcmQnKTtcbiAgICByZWdpc3RlckNvbnRleHRDaGVja2VyLmNhbGwodGhpcywgJ2FyYWJpY1NlbnRlbmNlJyk7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5pemVyLnRva2VuaXplKHRoaXMudGV4dCk7XG59XG5cbi8qKlxuICogUmV2ZXJzZSBhcmFiaWMgc2VudGVuY2UgbGF5b3V0XG4gKiBUT0RPOiBjaGVjayBiYXNlIGRpciBiZWZvcmUgYXBwbHlpbmcgYWRqdXN0bWVudHMgLSBwcmlvcml0eSBsb3dcbiAqL1xuZnVuY3Rpb24gcmV2ZXJzZUFyYWJpY1NlbnRlbmNlcygpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByYW5nZXMgPSB0aGlzLnRva2VuaXplci5nZXRDb250ZXh0UmFuZ2VzKCdhcmFiaWNTZW50ZW5jZScpO1xuICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgcmFuZ2VUb2tlbnMgPSB0aGlzJDEudG9rZW5pemVyLmdldFJhbmdlVG9rZW5zKHJhbmdlKTtcbiAgICAgICAgdGhpcyQxLnRva2VuaXplci5yZXBsYWNlUmFuZ2UoXG4gICAgICAgICAgICByYW5nZS5zdGFydEluZGV4LFxuICAgICAgICAgICAgcmFuZ2UuZW5kT2Zmc2V0LFxuICAgICAgICAgICAgcmFuZ2VUb2tlbnMucmV2ZXJzZSgpXG4gICAgICAgICk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgc3VwcG9ydGVkIGZlYXR1cmVzIHRhZ3NcbiAqIEBwYXJhbSB7c2NyaXB0fSBzY3JpcHQgc2NyaXB0IHRhZ1xuICogQHBhcmFtIHtBcnJheX0gdGFncyBmZWF0dXJlcyB0YWdzIGxpc3RcbiAqL1xuQmlkaS5wcm90b3R5cGUucmVnaXN0ZXJGZWF0dXJlcyA9IGZ1bmN0aW9uIChzY3JpcHQsIHRhZ3MpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzdXBwb3J0ZWRUYWdzID0gdGFncy5maWx0ZXIoXG4gICAgICAgIGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRoaXMkMS5xdWVyeS5zdXBwb3J0cyh7c2NyaXB0OiBzY3JpcHQsIHRhZzogdGFnfSk7IH1cbiAgICApO1xuICAgIGlmICghdGhpcy5mZWF0dXJlc1RhZ3MuaGFzT3duUHJvcGVydHkoc2NyaXB0KSkge1xuICAgICAgICB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdID0gc3VwcG9ydGVkVGFncztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdID1cbiAgICAgICAgdGhpcy5mZWF0dXJlc1RhZ3Nbc2NyaXB0XS5jb25jYXQoc3VwcG9ydGVkVGFncyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBcHBseSBHU1VCIGZlYXR1cmVzXG4gKiBAcGFyYW0ge0FycmF5fSB0YWdzTGlzdCBhIGxpc3Qgb2YgZmVhdHVyZXMgdGFnc1xuICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdCBhIHNjcmlwdCB0YWdcbiAqIEBwYXJhbSB7Rm9udH0gZm9udCBvcGVudHlwZSBmb250IGluc3RhbmNlXG4gKi9cbkJpZGkucHJvdG90eXBlLmFwcGx5RmVhdHVyZXMgPSBmdW5jdGlvbiAoZm9udCwgZmVhdHVyZXMpIHtcbiAgICBpZiAoIWZvbnQpIHsgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnTm8gdmFsaWQgZm9udCB3YXMgcHJvdmlkZWQgdG8gYXBwbHkgZmVhdHVyZXMnXG4gICAgKTsgfVxuICAgIGlmICghdGhpcy5xdWVyeSkgeyB0aGlzLnF1ZXJ5ID0gbmV3IEZlYXR1cmVRdWVyeShmb250KTsgfVxuICAgIGZvciAodmFyIGYgPSAwOyBmIDwgZmVhdHVyZXMubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tmXTtcbiAgICAgICAgaWYgKCF0aGlzLnF1ZXJ5LnN1cHBvcnRzKHtzY3JpcHQ6IGZlYXR1cmUuc2NyaXB0fSkpIHsgY29udGludWU7IH1cbiAgICAgICAgdGhpcy5yZWdpc3RlckZlYXR1cmVzKGZlYXR1cmUuc2NyaXB0LCBmZWF0dXJlLnRhZ3MpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBzdGF0ZSBtb2RpZmllclxuICogQHBhcmFtIHtzdHJpbmd9IG1vZGlmaWVySWQgc3RhdGUgbW9kaWZpZXIgaWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBvciBmYWxzZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbW9kaWZpZXIgYSBtb2RpZmllciBmdW5jdGlvbiB0byBzZXQgdG9rZW4gc3RhdGVcbiAqL1xuQmlkaS5wcm90b3R5cGUucmVnaXN0ZXJNb2RpZmllciA9IGZ1bmN0aW9uIChtb2RpZmllcklkLCBjb25kaXRpb24sIG1vZGlmaWVyKSB7XG4gICAgdGhpcy50b2tlbml6ZXIucmVnaXN0ZXJNb2RpZmllcihtb2RpZmllcklkLCBjb25kaXRpb24sIG1vZGlmaWVyKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgJ2dseXBoSW5kZXgnIGlzIHJlZ2lzdGVyZWRcbiAqL1xuZnVuY3Rpb24gY2hlY2tHbHlwaEluZGV4U3RhdHVzKCkge1xuICAgIGlmICh0aGlzLnRva2VuaXplci5yZWdpc3RlcmVkTW9kaWZpZXJzLmluZGV4T2YoJ2dseXBoSW5kZXgnKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ2dseXBoSW5kZXggbW9kaWZpZXIgaXMgcmVxdWlyZWQgdG8gYXBwbHkgJyArXG4gICAgICAgICAgICAnYXJhYmljIHByZXNlbnRhdGlvbiBmZWF0dXJlcy4nXG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFwcGx5IGFyYWJpYyBwcmVzZW50YXRpb24gZm9ybXMgZmVhdHVyZXNcbiAqL1xuZnVuY3Rpb24gYXBwbHlBcmFiaWNQcmVzZW50YXRpb25Gb3JtcygpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzY3JpcHQgPSAnYXJhYic7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzVGFncy5oYXNPd25Qcm9wZXJ0eShzY3JpcHQpKSB7IHJldHVybjsgfVxuICAgIGNoZWNrR2x5cGhJbmRleFN0YXR1cy5jYWxsKHRoaXMpO1xuICAgIHZhciByYW5nZXMgPSB0aGlzLnRva2VuaXplci5nZXRDb250ZXh0UmFuZ2VzKCdhcmFiaWNXb3JkJyk7XG4gICAgcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIGFyYWJpY1ByZXNlbnRhdGlvbkZvcm1zLmNhbGwodGhpcyQxLCByYW5nZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQXBwbHkgcmVxdWlyZWQgYXJhYmljIGxpZ2F0dXJlc1xuICovXG5mdW5jdGlvbiBhcHBseUFyYWJpY1JlcXVpcmVMaWdhdHVyZXMoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2NyaXB0ID0gJ2FyYWInO1xuICAgIGlmICghdGhpcy5mZWF0dXJlc1RhZ3MuaGFzT3duUHJvcGVydHkoc2NyaXB0KSkgeyByZXR1cm47IH1cbiAgICB2YXIgdGFncyA9IHRoaXMuZmVhdHVyZXNUYWdzW3NjcmlwdF07XG4gICAgaWYgKHRhZ3MuaW5kZXhPZigncmxpZycpID09PSAtMSkgeyByZXR1cm47IH1cbiAgICBjaGVja0dseXBoSW5kZXhTdGF0dXMuY2FsbCh0aGlzKTtcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy50b2tlbml6ZXIuZ2V0Q29udGV4dFJhbmdlcygnYXJhYmljV29yZCcpO1xuICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICBhcmFiaWNSZXF1aXJlZExpZ2F0dXJlcy5jYWxsKHRoaXMkMSwgcmFuZ2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFwcGx5IHJlcXVpcmVkIGFyYWJpYyBsaWdhdHVyZXNcbiAqL1xuZnVuY3Rpb24gYXBwbHlMYXRpbkxpZ2F0dXJlcygpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzY3JpcHQgPSAnbGF0bic7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzVGFncy5oYXNPd25Qcm9wZXJ0eShzY3JpcHQpKSB7IHJldHVybjsgfVxuICAgIHZhciB0YWdzID0gdGhpcy5mZWF0dXJlc1RhZ3Nbc2NyaXB0XTtcbiAgICBpZiAodGFncy5pbmRleE9mKCdsaWdhJykgPT09IC0xKSB7IHJldHVybjsgfVxuICAgIGNoZWNrR2x5cGhJbmRleFN0YXR1cy5jYWxsKHRoaXMpO1xuICAgIHZhciByYW5nZXMgPSB0aGlzLnRva2VuaXplci5nZXRDb250ZXh0UmFuZ2VzKCdsYXRpbldvcmQnKTtcbiAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgbGF0aW5MaWdhdHVyZS5jYWxsKHRoaXMkMSwgcmFuZ2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY29udGV4dCBpcyByZWdpc3RlcmVkXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dElkIGNvbnRleHQgaWRcbiAqL1xuQmlkaS5wcm90b3R5cGUuY2hlY2tDb250ZXh0UmVhZHkgPSBmdW5jdGlvbiAoY29udGV4dElkKSB7XG4gICAgcmV0dXJuICEhdGhpcy50b2tlbml6ZXIuZ2V0Q29udGV4dChjb250ZXh0SWQpO1xufTtcblxuLyoqXG4gKiBBcHBseSBmZWF0dXJlcyB0byByZWdpc3RlcmVkIGNvbnRleHRzXG4gKi9cbkJpZGkucHJvdG90eXBlLmFwcGx5RmVhdHVyZXNUb0NvbnRleHRzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmNoZWNrQ29udGV4dFJlYWR5KCdhcmFiaWNXb3JkJykpIHtcbiAgICAgICAgYXBwbHlBcmFiaWNQcmVzZW50YXRpb25Gb3Jtcy5jYWxsKHRoaXMpO1xuICAgICAgICBhcHBseUFyYWJpY1JlcXVpcmVMaWdhdHVyZXMuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hlY2tDb250ZXh0UmVhZHkoJ2xhdGluV29yZCcpKSB7XG4gICAgICAgIGFwcGx5TGF0aW5MaWdhdHVyZXMuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hlY2tDb250ZXh0UmVhZHkoJ2FyYWJpY1NlbnRlbmNlJykpIHtcbiAgICAgICAgcmV2ZXJzZUFyYWJpY1NlbnRlbmNlcy5jYWxsKHRoaXMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogcHJvY2VzcyB0ZXh0IGlucHV0XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBhbiBpbnB1dCB0ZXh0XG4gKi9cbkJpZGkucHJvdG90eXBlLnByb2Nlc3NUZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICAgIGlmICghdGhpcy50ZXh0IHx8IHRoaXMudGV4dCAhPT0gdGV4dCkge1xuICAgICAgICB0aGlzLnNldFRleHQodGV4dCk7XG4gICAgICAgIHRva2VuaXplVGV4dC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmFwcGx5RmVhdHVyZXNUb0NvbnRleHRzKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQcm9jZXNzIGEgc3RyaW5nIG9mIHRleHQgdG8gaWRlbnRpZnkgYW5kIGFkanVzdFxuICogYmlkaXJlY3Rpb25hbCB0ZXh0IGVudGl0aWVzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgaW5wdXQgdGV4dFxuICovXG5CaWRpLnByb3RvdHlwZS5nZXRCaWRpVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdGhpcy5wcm9jZXNzVGV4dCh0ZXh0KTtcbiAgICByZXR1cm4gdGhpcy50b2tlbml6ZXIuZ2V0VGV4dCgpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUgaW5kZXggb2YgZWFjaCB0b2tlblxuICogQHBhcmFtIHt0ZXh0fSB0ZXh0IGFuIGlucHV0IHRleHRcbiAqL1xuQmlkaS5wcm90b3R5cGUuZ2V0VGV4dEdseXBocyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdGhpcy5wcm9jZXNzVGV4dCh0ZXh0KTtcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50b2tlbml6ZXIudG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRva2Vuc1tpXTtcbiAgICAgICAgaWYgKHRva2VuLnN0YXRlLmRlbGV0ZWQpIHsgY29udGludWU7IH1cbiAgICAgICAgdmFyIGluZGV4ID0gdG9rZW4uYWN0aXZlU3RhdGUudmFsdWU7XG4gICAgICAgIGluZGV4ZXMucHVzaChBcnJheS5pc0FycmF5KGluZGV4KSA/IGluZGV4WzBdIDogaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXhlcztcbn07XG5cbi8vIFRoZSBGb250IG9iamVjdFxuXG4vKipcbiAqIEB0eXBlZGVmIEZvbnRPcHRpb25zXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZW1wdHkgLSB3aGV0aGVyIHRvIGNyZWF0ZSBhIG5ldyBlbXB0eSBmb250XG4gKiBAcHJvcGVydHkge3N0cmluZ30gZmFtaWx5TmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0eWxlTmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBmdWxsTmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBwb3N0U2NyaXB0TmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBkZXNpZ25lclxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBkZXNpZ25lclVSTFxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBtYW51ZmFjdHVyZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbWFudWZhY3R1cmVyVVJMXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGxpY2Vuc2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbGljZW5zZVVSTFxuICogQHByb3BlcnR5IHtzdHJpbmc9fSB2ZXJzaW9uXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGRlc2NyaXB0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGNvcHlyaWdodFxuICogQHByb3BlcnR5IHtzdHJpbmc9fSB0cmFkZW1hcmtcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB1bml0c1BlckVtXG4gKiBAcHJvcGVydHkge051bWJlcn0gYXNjZW5kZXJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZXNjZW5kZXJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjcmVhdGVkVGltZXN0YW1wXG4gKiBAcHJvcGVydHkge3N0cmluZz19IHdlaWdodENsYXNzXG4gKiBAcHJvcGVydHkge3N0cmluZz19IHdpZHRoQ2xhc3NcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZnNTZWxlY3Rpb25cbiAqL1xuXG4vKipcbiAqIEEgRm9udCByZXByZXNlbnRzIGEgbG9hZGVkIE9wZW5UeXBlIGZvbnQgZmlsZS5cbiAqIEl0IGNvbnRhaW5zIGEgc2V0IG9mIGdseXBocyBhbmQgbWV0aG9kcyB0byBkcmF3IHRleHQgb24gYSBkcmF3aW5nIGNvbnRleHQsXG4gKiBvciB0byBnZXQgYSBwYXRoIHJlcHJlc2VudGluZyB0aGUgdGV4dC5cbiAqIEBleHBvcnRzIG9wZW50eXBlLkZvbnRcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGb250T3B0aW9uc31cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGb250KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnRhYmxlcyA9IG9wdGlvbnMudGFibGVzIHx8IHt9O1xuXG4gICAgaWYgKCFvcHRpb25zLmVtcHR5KSB7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgd2UndmUgcHJvdmlkZWQgdGhlIG1pbmltdW0gc2V0IG9mIG5hbWVzLlxuICAgICAgICBjaGVja0FyZ3VtZW50KFxuICAgICAgICAgICAgb3B0aW9ucy5mYW1pbHlOYW1lLFxuICAgICAgICAgICAgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIGZhbWlseU5hbWUgaXMgcmVxdWlyZWQuJ1xuICAgICAgICApO1xuICAgICAgICBjaGVja0FyZ3VtZW50KFxuICAgICAgICAgICAgb3B0aW9ucy5zdHlsZU5hbWUsXG4gICAgICAgICAgICAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgc3R5bGVOYW1lIGlzIHJlcXVpcmVkLidcbiAgICAgICAgKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChcbiAgICAgICAgICAgIG9wdGlvbnMudW5pdHNQZXJFbSxcbiAgICAgICAgICAgICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCB1bml0c1BlckVtIGlzIHJlcXVpcmVkLidcbiAgICAgICAgKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChcbiAgICAgICAgICAgIG9wdGlvbnMuYXNjZW5kZXIsXG4gICAgICAgICAgICAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgYXNjZW5kZXIgaXMgcmVxdWlyZWQuJ1xuICAgICAgICApO1xuICAgICAgICBjaGVja0FyZ3VtZW50KFxuICAgICAgICAgICAgb3B0aW9ucy5kZXNjZW5kZXIgPD0gMCxcbiAgICAgICAgICAgICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBuZWdhdGl2ZSBkZXNjZW5kZXIgdmFsdWUgaXMgcmVxdWlyZWQuJ1xuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMudW5pdHNQZXJFbSA9IG9wdGlvbnMudW5pdHNQZXJFbSB8fCAxMDAwO1xuICAgICAgICB0aGlzLmFzY2VuZGVyID0gb3B0aW9ucy5hc2NlbmRlcjtcbiAgICAgICAgdGhpcy5kZXNjZW5kZXIgPSBvcHRpb25zLmRlc2NlbmRlcjtcbiAgICAgICAgdGhpcy5jcmVhdGVkVGltZXN0YW1wID0gb3B0aW9ucy5jcmVhdGVkVGltZXN0YW1wO1xuICAgICAgICB0aGlzLnRhYmxlcyA9IE9iamVjdC5hc3NpZ24ob3B0aW9ucy50YWJsZXMsIHtcbiAgICAgICAgICAgIG9zMjogT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHVzV2VpZ2h0Q2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLndlaWdodENsYXNzIHx8IHRoaXMudXNXZWlnaHRDbGFzc2VzLk1FRElVTSxcbiAgICAgICAgICAgICAgICAgICAgdXNXaWR0aENsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy53aWR0aENsYXNzIHx8IHRoaXMudXNXaWR0aENsYXNzZXMuTUVESVVNLFxuICAgICAgICAgICAgICAgICAgICBmc1NlbGVjdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZnNTZWxlY3Rpb24gfHwgdGhpcy5mc1NlbGVjdGlvblZhbHVlcy5SRUdVTEFSLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50YWJsZXMub3MyXG4gICAgICAgICAgICApLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnN1cHBvcnRlZCA9IHRydWU7IC8vIERlcHJlY2F0ZWQ6IHBhcnNlQnVmZmVyIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgZm9udCBpcyBub3Qgc3VwcG9ydGVkLlxuICAgIHRoaXMuZ2x5cGhzID0gbmV3IGdseXBoc2V0LkdseXBoU2V0KHRoaXMsIG9wdGlvbnMuZ2x5cGhzIHx8IFtdKTtcbiAgICB0aGlzLmVuY29kaW5nID0gbmV3IERlZmF1bHRFbmNvZGluZyh0aGlzKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKHRoaXMpO1xuICAgIHRoaXMuc3Vic3RpdHV0aW9uID0gbmV3IFN1YnN0aXR1dGlvbih0aGlzKTtcbiAgICB0aGlzLnRhYmxlcyA9IHRoaXMudGFibGVzIHx8IHt9O1xuXG4gICAgLy8gbmVlZGVkIGZvciBsb3cgbWVtb3J5IG1vZGUgb25seS5cbiAgICB0aGlzLl9wdXNoID0gbnVsbDtcbiAgICB0aGlzLl9obXR4VGFibGVEYXRhID0ge307XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2hpbnRpbmcnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hpbnRpbmcpIHsgcmV0dXJuIHRoaXMuX2hpbnRpbmc7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dGxpbmVzRm9ybWF0ID09PSAndHJ1ZXR5cGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9oaW50aW5nID0gbmV3IEhpbnRpbmcodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBmb250IGhhcyBhIGdseXBoIGZvciB0aGUgZ2l2ZW4gY2hhcmFjdGVyLlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuRm9udC5wcm90b3R5cGUuaGFzQ2hhciA9IGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RpbmcuY2hhclRvR2x5cGhJbmRleChjKSAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gY2hhcmFjdGVyIHRvIGEgc2luZ2xlIGdseXBoIGluZGV4LlxuICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW5cbiAqIHRoZSBnaXZlbiBjaGFyYWN0ZXIgYW5kIGEgZ2x5cGg7IGZvciBjb21wbGV4IHNjcmlwdHMgdGhpcyBtaWdodCBub3QgYmUgdGhlIGNhc2UuXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkZvbnQucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgocyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGNoYXJhY3RlciB0byBhIHNpbmdsZSBHbHlwaCBvYmplY3QuXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlcmUgaXMgYSBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlblxuICogdGhlIGdpdmVuIGNoYXJhY3RlciBhbmQgYSBnbHlwaDsgZm9yIGNvbXBsZXggc2NyaXB0cyB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgY2FzZS5cbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5Gb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIGdseXBoSW5kZXggPSB0aGlzLmNoYXJUb0dseXBoSW5kZXgoYyk7XG4gICAgdmFyIGdseXBoID0gdGhpcy5nbHlwaHMuZ2V0KGdseXBoSW5kZXgpO1xuICAgIGlmICghZ2x5cGgpIHtcbiAgICAgICAgLy8gLm5vdGRlZlxuICAgICAgICBnbHlwaCA9IHRoaXMuZ2x5cGhzLmdldCgwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGg7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBmZWF0dXJlc1xuICogQHBhcmFtIHthbnl9IG9wdGlvbnMgZmVhdHVyZXMgb3B0aW9uc1xuICovXG5Gb250LnByb3RvdHlwZS51cGRhdGVGZWF0dXJlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gVE9ETzogdXBkYXRlIGFsbCBmZWF0dXJlcyBvcHRpb25zIG5vdCBvbmx5ICdsYXRuJy5cbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0UmVuZGVyT3B0aW9ucy5mZWF0dXJlcy5tYXAoZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUuc2NyaXB0ID09PSAnbGF0bicpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NyaXB0OiAnbGF0bicsXG4gICAgICAgICAgICAgICAgdGFnczogZmVhdHVyZS50YWdzLmZpbHRlcihmdW5jdGlvbiAodGFnKSB7IHJldHVybiBvcHRpb25zW3RhZ107IH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIHRleHQgdG8gYSBsaXN0IG9mIEdseXBoIG9iamVjdHMuXG4gKiBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gc3RyaWN0IG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuIGNoYXJhY3RlcnMgYW5kXG4gKiBnbHlwaHMsIHNvIHRoZSBsaXN0IG9mIHJldHVybmVkIGdseXBocyBjYW4gYmUgbGFyZ2VyIG9yIHNtYWxsZXIgdGhhbiB0aGVcbiAqIGxlbmd0aCBvZiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBoW119XG4gKi9cbkZvbnQucHJvdG90eXBlLnN0cmluZ1RvR2x5cGhzID0gZnVuY3Rpb24gKHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBiaWRpID0gbmV3IEJpZGkoKTtcblxuICAgIC8vIENyZWF0ZSBhbmQgcmVnaXN0ZXIgJ2dseXBoSW5kZXgnIHN0YXRlIG1vZGlmaWVyXG4gICAgdmFyIGNoYXJUb0dseXBoSW5kZXhNb2QgPSBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRoaXMkMS5jaGFyVG9HbHlwaEluZGV4KHRva2VuLmNoYXIpOyB9O1xuICAgIGJpZGkucmVnaXN0ZXJNb2RpZmllcignZ2x5cGhJbmRleCcsIG51bGwsIGNoYXJUb0dseXBoSW5kZXhNb2QpO1xuXG4gICAgLy8gcm9sbC1iYWNrIHRvIGRlZmF1bHQgZmVhdHVyZXNcbiAgICB2YXIgZmVhdHVyZXMgPSBvcHRpb25zXG4gICAgICAgID8gdGhpcy51cGRhdGVGZWF0dXJlcyhvcHRpb25zLmZlYXR1cmVzKVxuICAgICAgICA6IHRoaXMuZGVmYXVsdFJlbmRlck9wdGlvbnMuZmVhdHVyZXM7XG5cbiAgICBiaWRpLmFwcGx5RmVhdHVyZXModGhpcywgZmVhdHVyZXMpO1xuXG4gICAgdmFyIGluZGV4ZXMgPSBiaWRpLmdldFRleHRHbHlwaHMocyk7XG5cbiAgICB2YXIgbGVuZ3RoID0gaW5kZXhlcy5sZW5ndGg7XG5cbiAgICAvLyBjb252ZXJ0IGdseXBoIGluZGV4ZXMgdG8gZ2x5cGggb2JqZWN0c1xuICAgIHZhciBnbHlwaHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB2YXIgbm90ZGVmID0gdGhpcy5nbHlwaHMuZ2V0KDApO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZ2x5cGhzW2ldID0gdGhpcy5nbHlwaHMuZ2V0KGluZGV4ZXNbaV0pIHx8IG5vdGRlZjtcbiAgICB9XG4gICAgcmV0dXJuIGdseXBocztcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHZhbHVlIG9mIHRoZSBrZXJuaW5nIHBhaXIgYmV0d2VlbiB0aGUgbGVmdCBnbHlwaCAob3IgaXRzIGluZGV4KVxuICogYW5kIHRoZSByaWdodCBnbHlwaCAob3IgaXRzIGluZGV4KS4gSWYgbm8ga2VybmluZyBwYWlyIGlzIGZvdW5kLCByZXR1cm4gMC5cbiAqIFRoZSBrZXJuaW5nIHZhbHVlIGdldHMgYWRkZWQgdG8gdGhlIGFkdmFuY2Ugd2lkdGggd2hlbiBjYWxjdWxhdGluZyB0aGUgc3BhY2luZ1xuICogYmV0d2VlbiBnbHlwaHMuXG4gKiBGb3IgR1BPUyBrZXJuaW5nLCB0aGlzIG1ldGhvZCB1c2VzIHRoZSBkZWZhdWx0IHNjcmlwdCBhbmQgbGFuZ3VhZ2UsIHdoaWNoIGNvdmVyc1xuICogbW9zdCB1c2UgY2FzZXMuIFRvIGhhdmUgZ3JlYXRlciBjb250cm9sLCB1c2UgZm9udC5wb3NpdGlvbi5nZXRLZXJuaW5nVmFsdWUgLlxuICogQHBhcmFtICB7b3BlbnR5cGUuR2x5cGh9IGxlZnRHbHlwaFxuICogQHBhcmFtICB7b3BlbnR5cGUuR2x5cGh9IHJpZ2h0R2x5cGhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRm9udC5wcm90b3R5cGUuZ2V0S2VybmluZ1ZhbHVlID0gZnVuY3Rpb24gKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkge1xuICAgIGxlZnRHbHlwaCA9IGxlZnRHbHlwaC5pbmRleCB8fCBsZWZ0R2x5cGg7XG4gICAgcmlnaHRHbHlwaCA9IHJpZ2h0R2x5cGguaW5kZXggfHwgcmlnaHRHbHlwaDtcbiAgICB2YXIgZ3Bvc0tlcm5pbmcgPSB0aGlzLnBvc2l0aW9uLmRlZmF1bHRLZXJuaW5nVGFibGVzO1xuICAgIGlmIChncG9zS2VybmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5nZXRLZXJuaW5nVmFsdWUoXG4gICAgICAgICAgICBncG9zS2VybmluZyxcbiAgICAgICAgICAgIGxlZnRHbHlwaCxcbiAgICAgICAgICAgIHJpZ2h0R2x5cGhcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLy8gXCJrZXJuXCIgdGFibGVcbiAgICByZXR1cm4gdGhpcy5rZXJuaW5nUGFpcnNbbGVmdEdseXBoICsgJywnICsgcmlnaHRHbHlwaF0gfHwgMDtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgR2x5cGhSZW5kZXJPcHRpb25zXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2NyaXB0XSAtIHNjcmlwdCB1c2VkIHRvIGRldGVybWluZSB3aGljaCBmZWF0dXJlcyB0byBhcHBseS4gQnkgZGVmYXVsdCwgJ0RGTFQnIG9yICdsYXRuJyBpcyB1c2VkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMvc2NyaXB0dGFncy5odG1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXSAtIGxhbmd1YWdlIHN5c3RlbSB1c2VkIHRvIGRldGVybWluZSB3aGljaCBmZWF0dXJlcyB0byBhcHBseS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvZGV2ZWxvcGVycy9vcGVudHlwZS9sYW5ndWFnZXRhZ3MuYXNweFxuICogQHByb3BlcnR5IHtib29sZWFufSBba2VybmluZz10cnVlXSAtIHdoZXRoZXIgdG8gaW5jbHVkZSBrZXJuaW5nIHZhbHVlc1xuICogQHByb3BlcnR5IHtvYmplY3R9IFtmZWF0dXJlc10gLSBPcGVuVHlwZSBMYXlvdXQgZmVhdHVyZSB0YWdzLiBVc2VkIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBmZWF0dXJlcyBvZiB0aGUgZ2l2ZW4gc2NyaXB0L2xhbmd1YWdlIHN5c3RlbS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMvZmVhdHVyZXRhZ3MuaHRtXG4gKi9cbkZvbnQucHJvdG90eXBlLmRlZmF1bHRSZW5kZXJPcHRpb25zID0ge1xuICAgIGtlcm5pbmc6IHRydWUsXG4gICAgZmVhdHVyZXM6IFtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZXNlIDQgZmVhdHVyZXMgYXJlIHJlcXVpcmVkIHRvIHJlbmRlciBBcmFiaWMgdGV4dCBwcm9wZXJseVxuICAgICAgICAgKiBhbmQgc2hvdWxkbid0IGJlIHR1cm5lZCBvZmYgd2hlbiByZW5kZXJpbmcgYXJhYmljIHRleHQuXG4gICAgICAgICAqL1xuICAgICAgICB7IHNjcmlwdDogJ2FyYWInLCB0YWdzOiBbJ2luaXQnLCAnbWVkaScsICdmaW5hJywgJ3JsaWcnXSB9LFxuICAgICAgICB7IHNjcmlwdDogJ2xhdG4nLCB0YWdzOiBbJ2xpZ2EnLCAncmxpZyddIH0gXSxcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGVhY2ggZ2x5cGggaW4gdGhlIGdpdmVuIHRleHQuXG4gKiBUaGUgY2FsbGJhY2sgZ2V0cyBgKGdseXBoLCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucylgLiogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGFwcGx5LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuRm9udC5wcm90b3R5cGUuZm9yRWFjaEdseXBoID0gZnVuY3Rpb24gKFxuICAgIHRleHQsXG4gICAgeCxcbiAgICB5LFxuICAgIGZvbnRTaXplLFxuICAgIG9wdGlvbnMsXG4gICAgY2FsbGJhY2tcbikge1xuICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiA3MjtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0UmVuZGVyT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdmFyIGZvbnRTY2FsZSA9ICgxIC8gdGhpcy51bml0c1BlckVtKSAqIGZvbnRTaXplO1xuICAgIHZhciBnbHlwaHMgPSB0aGlzLnN0cmluZ1RvR2x5cGhzKHRleHQsIG9wdGlvbnMpO1xuICAgIHZhciBrZXJuaW5nTG9va3VwcztcbiAgICBpZiAob3B0aW9ucy5rZXJuaW5nKSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBvcHRpb25zLnNjcmlwdCB8fCB0aGlzLnBvc2l0aW9uLmdldERlZmF1bHRTY3JpcHROYW1lKCk7XG4gICAgICAgIGtlcm5pbmdMb29rdXBzID0gdGhpcy5wb3NpdGlvbi5nZXRLZXJuaW5nVGFibGVzKFxuICAgICAgICAgICAgc2NyaXB0LFxuICAgICAgICAgICAgb3B0aW9ucy5sYW5ndWFnZVxuICAgICAgICApO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZ2x5cGgsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGdseXBoLmFkdmFuY2VXaWR0aCkge1xuICAgICAgICAgICAgeCArPSBnbHlwaC5hZHZhbmNlV2lkdGggKiBmb250U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5rZXJuaW5nICYmIGkgPCBnbHlwaHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGFwcGx5IHBvc2l0aW9uIGFkanVzdG1lbnQgbG9va3VwcyBpbiBhIG1vcmUgZ2VuZXJpYyB3YXkuXG4gICAgICAgICAgICAvLyBIZXJlIHdlIG9ubHkgdXNlIHRoZSB4QWR2YW5jZSB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBrZXJuaW5nVmFsdWUgPSBrZXJuaW5nTG9va3Vwc1xuICAgICAgICAgICAgICAgID8gdGhpcy5wb3NpdGlvbi5nZXRLZXJuaW5nVmFsdWUoXG4gICAgICAgICAgICAgICAgICAgICAga2VybmluZ0xvb2t1cHMsXG4gICAgICAgICAgICAgICAgICAgICAgZ2x5cGguaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgZ2x5cGhzW2kgKyAxXS5pbmRleFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXRLZXJuaW5nVmFsdWUoZ2x5cGgsIGdseXBoc1tpICsgMV0pO1xuICAgICAgICAgICAgeCArPSBrZXJuaW5nVmFsdWUgKiBmb250U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5sZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgICAgICB4ICs9IG9wdGlvbnMubGV0dGVyU3BhY2luZyAqIGZvbnRTaXplO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudHJhY2tpbmcpIHtcbiAgICAgICAgICAgIHggKz0gKG9wdGlvbnMudHJhY2tpbmcgLyAxMDAwKSAqIGZvbnRTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBQYXRoIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGdpdmVuIHRleHQuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqIEByZXR1cm4ge29wZW50eXBlLlBhdGh9XG4gKi9cbkZvbnQucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZnVsbFBhdGggPSBuZXcgUGF0aCgpO1xuICAgIHRoaXMuZm9yRWFjaEdseXBoKFxuICAgICAgICB0ZXh0LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZnVuY3Rpb24gKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuICAgICAgICAgICAgdmFyIGdseXBoUGF0aCA9IGdseXBoLmdldFBhdGgoZ1gsIGdZLCBnRm9udFNpemUsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICAgICAgZnVsbFBhdGguZXh0ZW5kKGdseXBoUGF0aCk7XG4gICAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBmdWxsUGF0aDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IG9mIFBhdGggb2JqZWN0cyB0aGF0IHJlcHJlc2VudCB0aGUgZ2x5cGhzIG9mIGEgZ2l2ZW4gdGV4dC5cbiAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICogQHJldHVybiB7b3BlbnR5cGUuUGF0aFtdfVxuICovXG5Gb250LnByb3RvdHlwZS5nZXRQYXRocyA9IGZ1bmN0aW9uICh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHZhciBnbHlwaFBhdGhzID0gW107XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgoXG4gICAgICAgIHRleHQsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBmdW5jdGlvbiAoZ2x5cGgsIGdYLCBnWSwgZ0ZvbnRTaXplKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGhQYXRoID0gZ2x5cGguZ2V0UGF0aChnWCwgZ1ksIGdGb250U2l6ZSwgb3B0aW9ucywgdGhpcyk7XG4gICAgICAgICAgICBnbHlwaFBhdGhzLnB1c2goZ2x5cGhQYXRoKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gZ2x5cGhQYXRocztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWR2YW5jZSB3aWR0aCBvZiBhIHRleHQuXG4gKlxuICogVGhpcyBpcyBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gUGF0aC5nZXRCb3VuZGluZ0JveCgpIGFzIGZvciBleGFtcGxlIGFcbiAqIHN1ZmZpeGVkIHdoaXRlc3BhY2UgaW5jcmVhc2VzIHRoZSBhZHZhbmNlV2lkdGggYnV0IG5vdCB0aGUgYm91bmRpbmcgYm94XG4gKiBvciBhbiBvdmVyaGFuZ2luZyBsZXR0ZXIgbGlrZSBhIGNhbGxpZ3JhcGhpYyAnZicgbWlnaHQgaGF2ZSBhIHF1aXRlIGxhcmdlclxuICogYm91bmRpbmcgYm94IHRoYW4gaXRzIGFkdmFuY2Ugd2lkdGguXG4gKlxuICogVGhpcyBjb3JyZXNwb25kcyB0byBjYW52YXMyZENvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGhcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICogQHJldHVybiBhZHZhbmNlIHdpZHRoXG4gKi9cbkZvbnQucHJvdG90eXBlLmdldEFkdmFuY2VXaWR0aCA9IGZ1bmN0aW9uICh0ZXh0LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCAwLCAwLCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24gKCkge30pO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5Gb250LnByb3RvdHlwZS5mc1NlbGVjdGlvblZhbHVlcyA9IHtcbiAgICBJVEFMSUM6IDB4MDAxLCAvLzFcbiAgICBVTkRFUlNDT1JFOiAweDAwMiwgLy8yXG4gICAgTkVHQVRJVkU6IDB4MDA0LCAvLzRcbiAgICBPVVRMSU5FRDogMHgwMDgsIC8vOFxuICAgIFNUUklLRU9VVDogMHgwMTAsIC8vMTZcbiAgICBCT0xEOiAweDAyMCwgLy8zMlxuICAgIFJFR1VMQVI6IDB4MDQwLCAvLzY0XG4gICAgVVNFUl9UWVBPX01FVFJJQ1M6IDB4MDgwLCAvLzEyOFxuICAgIFdXUzogMHgxMDAsIC8vMjU2XG4gICAgT0JMSVFVRTogMHgyMDAsIC8vNTEyXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkZvbnQucHJvdG90eXBlLnVzV2lkdGhDbGFzc2VzID0ge1xuICAgIFVMVFJBX0NPTkRFTlNFRDogMSxcbiAgICBFWFRSQV9DT05ERU5TRUQ6IDIsXG4gICAgQ09OREVOU0VEOiAzLFxuICAgIFNFTUlfQ09OREVOU0VEOiA0LFxuICAgIE1FRElVTTogNSxcbiAgICBTRU1JX0VYUEFOREVEOiA2LFxuICAgIEVYUEFOREVEOiA3LFxuICAgIEVYVFJBX0VYUEFOREVEOiA4LFxuICAgIFVMVFJBX0VYUEFOREVEOiA5LFxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5Gb250LnByb3RvdHlwZS51c1dlaWdodENsYXNzZXMgPSB7XG4gICAgVEhJTjogMTAwLFxuICAgIEVYVFJBX0xJR0hUOiAyMDAsXG4gICAgTElHSFQ6IDMwMCxcbiAgICBOT1JNQUw6IDQwMCxcbiAgICBNRURJVU06IDUwMCxcbiAgICBTRU1JX0JPTEQ6IDYwMCxcbiAgICBCT0xEOiA3MDAsXG4gICAgRVhUUkFfQk9MRDogODAwLFxuICAgIEJMQUNLOiA5MDAsXG59O1xuXG4vLyBUaGUgYGNtYXBgIHRhYmxlIHN0b3JlcyB0aGUgbWFwcGluZ3MgZnJvbSBjaGFyYWN0ZXJzIHRvIGdseXBocy5cblxuZnVuY3Rpb24gcGFyc2VDbWFwVGFibGVGb3JtYXQxMihjbWFwLCBwKSB7XG4gICAgLy9Ta2lwIHJlc2VydmVkLlxuICAgIHAucGFyc2VVU2hvcnQoKTtcblxuICAgIC8vIExlbmd0aCBpbiBieXRlcyBvZiB0aGUgc3ViLXRhYmxlcy5cbiAgICBjbWFwLmxlbmd0aCA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNtYXAubGFuZ3VhZ2UgPSBwLnBhcnNlVUxvbmcoKTtcblxuICAgIHZhciBncm91cENvdW50O1xuICAgIGNtYXAuZ3JvdXBDb3VudCA9IGdyb3VwQ291bnQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjbWFwLmdseXBoSW5kZXhNYXAgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBzdGFydENoYXJDb2RlID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIHZhciBlbmRDaGFyQ29kZSA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICB2YXIgc3RhcnRHbHlwaElkID0gcC5wYXJzZVVMb25nKCk7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IHN0YXJ0Q2hhckNvZGU7IGMgPD0gZW5kQ2hhckNvZGU7IGMgKz0gMSkge1xuICAgICAgICAgICAgY21hcC5nbHlwaEluZGV4TWFwW2NdID0gc3RhcnRHbHlwaElkO1xuICAgICAgICAgICAgc3RhcnRHbHlwaElkKys7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ21hcFRhYmxlRm9ybWF0NChjbWFwLCBwLCBkYXRhLCBzdGFydCwgb2Zmc2V0KSB7XG4gICAgLy8gTGVuZ3RoIGluIGJ5dGVzIG9mIHRoZSBzdWItdGFibGVzLlxuICAgIGNtYXAubGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNtYXAubGFuZ3VhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICAvLyBzZWdDb3VudCBpcyBzdG9yZWQgeCAyLlxuICAgIHZhciBzZWdDb3VudDtcbiAgICBjbWFwLnNlZ0NvdW50ID0gc2VnQ291bnQgPSBwLnBhcnNlVVNob3J0KCkgPj4gMTtcblxuICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcblxuICAgIC8vIFRoZSBcInVucm9sbGVkXCIgbWFwcGluZyBmcm9tIGNoYXJhY3RlciBjb2RlcyB0byBnbHlwaCBpbmRpY2VzLlxuICAgIGNtYXAuZ2x5cGhJbmRleE1hcCA9IHt9O1xuICAgIHZhciBlbmRDb3VudFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNCk7XG4gICAgdmFyIHN0YXJ0Q291bnRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKFxuICAgICAgICBkYXRhLFxuICAgICAgICBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiAyXG4gICAgKTtcbiAgICB2YXIgaWREZWx0YVBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDRcbiAgICApO1xuICAgIHZhciBpZFJhbmdlT2Zmc2V0UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogNlxuICAgICk7XG4gICAgdmFyIGdseXBoSW5kZXhPZmZzZXQgPSBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA4O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnQ291bnQgLSAxOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoSW5kZXggPSAodm9pZCAwKTtcbiAgICAgICAgdmFyIGVuZENvdW50ID0gZW5kQ291bnRQYXJzZXIucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHN0YXJ0Q291bnQgPSBzdGFydENvdW50UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBpZERlbHRhID0gaWREZWx0YVBhcnNlci5wYXJzZVNob3J0KCk7XG4gICAgICAgIHZhciBpZFJhbmdlT2Zmc2V0ID0gaWRSYW5nZU9mZnNldFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBmb3IgKHZhciBjID0gc3RhcnRDb3VudDsgYyA8PSBlbmRDb3VudDsgYyArPSAxKSB7XG4gICAgICAgICAgICBpZiAoaWRSYW5nZU9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBpZFJhbmdlT2Zmc2V0IGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBpZFJhbmdlT2Zmc2V0IGFycmF5LlxuICAgICAgICAgICAgICAgIC8vIFRha2UgdGhlIGN1cnJlbnQgb2Zmc2V0IGluIHRoZSBpZFJhbmdlT2Zmc2V0IGFycmF5LlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgPVxuICAgICAgICAgICAgICAgICAgICBpZFJhbmdlT2Zmc2V0UGFyc2VyLm9mZnNldCArXG4gICAgICAgICAgICAgICAgICAgIGlkUmFuZ2VPZmZzZXRQYXJzZXIucmVsYXRpdmVPZmZzZXQgLVxuICAgICAgICAgICAgICAgICAgICAyO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSB2YWx1ZSBvZiB0aGUgaWRSYW5nZU9mZnNldCwgd2hpY2ggd2lsbCBtb3ZlIHVzIGludG8gdGhlIGdseXBoSW5kZXggYXJyYXkuXG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleE9mZnNldCArPSBpZFJhbmdlT2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlbiBhZGQgdGhlIGNoYXJhY3RlciBpbmRleCBvZiB0aGUgY3VycmVudCBzZWdtZW50LCBtdWx0aXBsaWVkIGJ5IDIgZm9yIFVTSE9SVHMuXG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleE9mZnNldCArPSAoYyAtIHN0YXJ0Q291bnQpICogMjtcbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIGdseXBoSW5kZXhPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaEluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSAoZ2x5cGhJbmRleCArIGlkRGVsdGEpICYgMHhmZmZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IChjICsgaWREZWx0YSkgJiAweGZmZmY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNtYXAuZ2x5cGhJbmRleE1hcFtjXSA9IGdseXBoSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFBhcnNlIHRoZSBgY21hcGAgdGFibGUuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBtYXBwaW5ncyBmcm9tIGNoYXJhY3RlcnMgdG8gZ2x5cGhzLlxuLy8gVGhlcmUgYXJlIG1hbnkgYXZhaWxhYmxlIGZvcm1hdHMsIGJ1dCB3ZSBvbmx5IHN1cHBvcnQgdGhlIFdpbmRvd3MgZm9ybWF0IDQgYW5kIDEyLlxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYENtYXBFbmNvZGluZ2Agb2JqZWN0IG9yIG51bGwgaWYgbm8gc3VwcG9ydGVkIGZvcm1hdCBjb3VsZCBiZSBmb3VuZC5cbmZ1bmN0aW9uIHBhcnNlQ21hcFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIGNtYXAgPSB7fTtcbiAgICBjbWFwLnZlcnNpb24gPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQpO1xuICAgIGNoZWNrLmFyZ3VtZW50KGNtYXAudmVyc2lvbiA9PT0gMCwgJ2NtYXAgdGFibGUgdmVyc2lvbiBzaG91bGQgYmUgMC4nKTtcblxuICAgIC8vIFRoZSBjbWFwIHRhYmxlIGNhbiBjb250YWluIG1hbnkgc3ViLXRhYmxlcywgZWFjaCB3aXRoIHRoZWlyIG93biBmb3JtYXQuXG4gICAgLy8gV2UncmUgb25seSBpbnRlcmVzdGVkIGluIGEgXCJwbGF0Zm9ybSAwXCIgKFVuaWNvZGUgZm9ybWF0KSBhbmQgXCJwbGF0Zm9ybSAzXCIgKFdpbmRvd3MgZm9ybWF0KSB0YWJsZS5cbiAgICBjbWFwLm51bVRhYmxlcyA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCArIDIpO1xuICAgIHZhciBvZmZzZXQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gY21hcC5udW1UYWJsZXMgLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICB2YXIgcGxhdGZvcm1JZCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCArIDQgKyBpICogOCk7XG4gICAgICAgIHZhciBlbmNvZGluZ0lkID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgNCArIGkgKiA4ICsgMik7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChwbGF0Zm9ybUlkID09PSAzICYmXG4gICAgICAgICAgICAgICAgKGVuY29kaW5nSWQgPT09IDAgfHwgZW5jb2RpbmdJZCA9PT0gMSB8fCBlbmNvZGluZ0lkID09PSAxMCkpIHx8XG4gICAgICAgICAgICAocGxhdGZvcm1JZCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIChlbmNvZGluZ0lkID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nSWQgPT09IDEgfHxcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmdJZCA9PT0gMiB8fFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZ0lkID09PSAzIHx8XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nSWQgPT09IDQpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHN0YXJ0ICsgNCArIGkgKiA4ICsgNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGNtYXAgdGFibGUgaW4gdGhlIGZvbnQgdGhhdCB3ZSBzdXBwb3J0LlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGNtYXAgc3ViLXRhYmxlcyBmb3VuZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQpO1xuICAgIGNtYXAuZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuXG4gICAgaWYgKGNtYXAuZm9ybWF0ID09PSAxMikge1xuICAgICAgICBwYXJzZUNtYXBUYWJsZUZvcm1hdDEyKGNtYXAsIHApO1xuICAgIH0gZWxzZSBpZiAoY21hcC5mb3JtYXQgPT09IDQpIHtcbiAgICAgICAgcGFyc2VDbWFwVGFibGVGb3JtYXQ0KGNtYXAsIHAsIGRhdGEsIHN0YXJ0LCBvZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdPbmx5IGZvcm1hdCA0IGFuZCAxMiBjbWFwIHRhYmxlcyBhcmUgc3VwcG9ydGVkIChmb3VuZCBmb3JtYXQgJyArXG4gICAgICAgICAgICAgICAgY21hcC5mb3JtYXQgK1xuICAgICAgICAgICAgICAgICcpLidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY21hcDtcbn1cblxudmFyIGNtYXAgPSB7IHBhcnNlOiBwYXJzZUNtYXBUYWJsZSB9O1xuXG4vLyBUaGUgYENGRmAgdGFibGUgY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuXG4vLyBTdWJyb3V0aW5lcyBhcmUgZW5jb2RlZCB1c2luZyB0aGUgbmVnYXRpdmUgaGFsZiBvZiB0aGUgbnVtYmVyIHNwYWNlLlxuLy8gU2VlIHR5cGUgMiBjaGFwdGVyIDQuNyBcIlN1YnJvdXRpbmUgb3BlcmF0b3JzXCIuXG5mdW5jdGlvbiBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoc3VicnMpIHtcbiAgICB2YXIgYmlhcztcbiAgICBpZiAoc3VicnMubGVuZ3RoIDwgMTI0MCkge1xuICAgICAgICBiaWFzID0gMTA3O1xuICAgIH0gZWxzZSBpZiAoc3VicnMubGVuZ3RoIDwgMzM5MDApIHtcbiAgICAgICAgYmlhcyA9IDExMzE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYmlhcyA9IDMyNzY4O1xuICAgIH1cblxuICAgIHJldHVybiBiaWFzO1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIElOREVYIGFycmF5LlxuLy8gQW4gaW5kZXggYXJyYXkgY29uc2lzdHMgb2YgYSBsaXN0IG9mIG9mZnNldHMsIHRoZW4gYSBsaXN0IG9mIG9iamVjdHMgYXQgdGhvc2Ugb2Zmc2V0cy5cbmZ1bmN0aW9uIHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3RhcnQsIGNvbnZlcnNpb25Gbikge1xuICAgIHZhciBvZmZzZXRzID0gW107XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICB2YXIgY291bnQgPSBwYXJzZS5nZXRDYXJkMTYoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBvYmplY3RPZmZzZXQ7XG4gICAgdmFyIGVuZE9mZnNldDtcbiAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgdmFyIG9mZnNldFNpemUgPSBwYXJzZS5nZXRCeXRlKGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgICAgIG9iamVjdE9mZnNldCA9IHN0YXJ0ICsgKGNvdW50ICsgMSkgKiBvZmZzZXRTaXplICsgMjtcbiAgICAgICAgdmFyIHBvcyA9IHN0YXJ0ICsgMztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCArIDE7IGkgKz0gMSkge1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKHBhcnNlLmdldE9mZnNldChkYXRhLCBwb3MsIG9mZnNldFNpemUpKTtcbiAgICAgICAgICAgIHBvcyArPSBvZmZzZXRTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHRvdGFsIHNpemUgb2YgdGhlIGluZGV4IGFycmF5IGlzIDQgaGVhZGVyIGJ5dGVzICsgdGhlIHZhbHVlIG9mIHRoZSBsYXN0IG9mZnNldC5cbiAgICAgICAgZW5kT2Zmc2V0ID0gb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tjb3VudF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZW5kT2Zmc2V0ID0gc3RhcnQgKyAyO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9mZnNldHMubGVuZ3RoIC0gMTsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyc2UuZ2V0Qnl0ZXMoXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tpJDFdLFxuICAgICAgICAgICAgb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tpJDEgKyAxXVxuICAgICAgICApO1xuICAgICAgICBpZiAoY29udmVyc2lvbkZuKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnZlcnNpb25Gbih2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmplY3RzLnB1c2godmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB7IG9iamVjdHM6IG9iamVjdHMsIHN0YXJ0T2Zmc2V0OiBzdGFydCwgZW5kT2Zmc2V0OiBlbmRPZmZzZXQgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDRkZJbmRleExvd01lbW9yeShkYXRhLCBzdGFydCkge1xuICAgIHZhciBvZmZzZXRzID0gW107XG4gICAgdmFyIGNvdW50ID0gcGFyc2UuZ2V0Q2FyZDE2KGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgb2JqZWN0T2Zmc2V0O1xuICAgIHZhciBlbmRPZmZzZXQ7XG4gICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgIHZhciBvZmZzZXRTaXplID0gcGFyc2UuZ2V0Qnl0ZShkYXRhLCBzdGFydCArIDIpO1xuICAgICAgICBvYmplY3RPZmZzZXQgPSBzdGFydCArIChjb3VudCArIDEpICogb2Zmc2V0U2l6ZSArIDI7XG4gICAgICAgIHZhciBwb3MgPSBzdGFydCArIDM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgKyAxOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG9mZnNldHMucHVzaChwYXJzZS5nZXRPZmZzZXQoZGF0YSwgcG9zLCBvZmZzZXRTaXplKSk7XG4gICAgICAgICAgICBwb3MgKz0gb2Zmc2V0U2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSB0b3RhbCBzaXplIG9mIHRoZSBpbmRleCBhcnJheSBpcyA0IGhlYWRlciBieXRlcyArIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBvZmZzZXQuXG4gICAgICAgIGVuZE9mZnNldCA9IG9iamVjdE9mZnNldCArIG9mZnNldHNbY291bnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZE9mZnNldCA9IHN0YXJ0ICsgMjtcbiAgICB9XG5cbiAgICByZXR1cm4geyBvZmZzZXRzOiBvZmZzZXRzLCBzdGFydE9mZnNldDogc3RhcnQsIGVuZE9mZnNldDogZW5kT2Zmc2V0IH07XG59XG5mdW5jdGlvbiBnZXRDZmZJbmRleE9iamVjdChpLCBvZmZzZXRzLCBkYXRhLCBzdGFydCwgY29udmVyc2lvbkZuKSB7XG4gICAgdmFyIGNvdW50ID0gcGFyc2UuZ2V0Q2FyZDE2KGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgb2JqZWN0T2Zmc2V0ID0gMDtcbiAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgdmFyIG9mZnNldFNpemUgPSBwYXJzZS5nZXRCeXRlKGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgICAgIG9iamVjdE9mZnNldCA9IHN0YXJ0ICsgKGNvdW50ICsgMSkgKiBvZmZzZXRTaXplICsgMjtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBwYXJzZS5nZXRCeXRlcyhcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tpXSxcbiAgICAgICAgb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tpICsgMV1cbiAgICApO1xuICAgIGlmIChjb252ZXJzaW9uRm4pIHtcbiAgICAgICAgdmFsdWUgPSBjb252ZXJzaW9uRm4odmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgRElDVCByZWFsIHZhbHVlLlxuZnVuY3Rpb24gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKSB7XG4gICAgdmFyIHMgPSAnJztcbiAgICB2YXIgZW9mID0gMTU7XG4gICAgdmFyIGxvb2t1cCA9IFtcbiAgICAgICAgJzAnLFxuICAgICAgICAnMScsXG4gICAgICAgICcyJyxcbiAgICAgICAgJzMnLFxuICAgICAgICAnNCcsXG4gICAgICAgICc1JyxcbiAgICAgICAgJzYnLFxuICAgICAgICAnNycsXG4gICAgICAgICc4JyxcbiAgICAgICAgJzknLFxuICAgICAgICAnLicsXG4gICAgICAgICdFJyxcbiAgICAgICAgJ0UtJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgJy0nIF07XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHZhciBuMSA9IGIgPj4gNDtcbiAgICAgICAgdmFyIG4yID0gYiAmIDE1O1xuXG4gICAgICAgIGlmIChuMSA9PT0gZW9mKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHMgKz0gbG9va3VwW24xXTtcblxuICAgICAgICBpZiAobjIgPT09IGVvZikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzICs9IGxvb2t1cFtuMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocyk7XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgRElDVCBvcGVyYW5kLlxuZnVuY3Rpb24gcGFyc2VPcGVyYW5kKHBhcnNlciwgYjApIHtcbiAgICB2YXIgYjE7XG4gICAgdmFyIGIyO1xuICAgIHZhciBiMztcbiAgICB2YXIgYjQ7XG4gICAgaWYgKGIwID09PSAyOCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHJldHVybiAoYjEgPDwgOCkgfCBiMjtcbiAgICB9XG5cbiAgICBpZiAoYjAgPT09IDI5KSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiMiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjMgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGI0ID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gKGIxIDw8IDI0KSB8IChiMiA8PCAxNikgfCAoYjMgPDwgOCkgfCBiNDtcbiAgICB9XG5cbiAgICBpZiAoYjAgPT09IDMwKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0T3BlcmFuZChwYXJzZXIpO1xuICAgIH1cblxuICAgIGlmIChiMCA+PSAzMiAmJiBiMCA8PSAyNDYpIHtcbiAgICAgICAgcmV0dXJuIGIwIC0gMTM5O1xuICAgIH1cblxuICAgIGlmIChiMCA+PSAyNDcgJiYgYjAgPD0gMjUwKSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gKGIwIC0gMjQ3KSAqIDI1NiArIGIxICsgMTA4O1xuICAgIH1cblxuICAgIGlmIChiMCA+PSAyNTEgJiYgYjAgPD0gMjU0KSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gLShiMCAtIDI1MSkgKiAyNTYgLSBiMSAtIDEwODtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYjAgJyArIGIwKTtcbn1cblxuLy8gQ29udmVydCB0aGUgZW50cmllcyByZXR1cm5lZCBieSBgcGFyc2VEaWN0YCB0byBhIHByb3BlciBkaWN0aW9uYXJ5LlxuLy8gSWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2Ygb25lLCBpdCBpcyB1bnBhY2tlZC5cbmZ1bmN0aW9uIGVudHJpZXNUb09iamVjdChlbnRyaWVzKSB7XG4gICAgdmFyIG8gPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGtleSA9IGVudHJpZXNbaV1bMF07XG4gICAgICAgIHZhciB2YWx1ZXMgPSBlbnRyaWVzW2ldWzFdO1xuICAgICAgICB2YXIgdmFsdWUgPSAodm9pZCAwKTtcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFpc05hTihvW2tleV0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCAnICsgbyArICcgYWxyZWFkeSBoYXMga2V5ICcgKyBrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG87XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgRElDVCBvYmplY3QuXG4vLyBBIGRpY3Rpb25hcnkgY29udGFpbnMga2V5LXZhbHVlIHBhaXJzIGluIGEgY29tcGFjdCB0b2tlbml6ZWQgZm9ybWF0LlxuZnVuY3Rpb24gcGFyc2VDRkZEaWN0KGRhdGEsIHN0YXJ0LCBzaXplKSB7XG4gICAgc3RhcnQgPSBzdGFydCAhPT0gdW5kZWZpbmVkID8gc3RhcnQgOiAwO1xuICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIHZhciBvcGVyYW5kcyA9IFtdO1xuICAgIHNpemUgPSBzaXplICE9PSB1bmRlZmluZWQgPyBzaXplIDogZGF0YS5sZW5ndGg7XG5cbiAgICB3aGlsZSAocGFyc2VyLnJlbGF0aXZlT2Zmc2V0IDwgc2l6ZSkge1xuICAgICAgICB2YXIgb3AgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IGJ5dGUgZm9yIGVhY2ggZGljdCBpdGVtIGRpc3Rpbmd1aXNoZXMgYmV0d2VlbiBvcGVyYXRvciAoa2V5KSBhbmQgb3BlcmFuZCAodmFsdWUpLlxuICAgICAgICAvLyBWYWx1ZXMgPD0gMjEgYXJlIG9wZXJhdG9ycy5cbiAgICAgICAgaWYgKG9wIDw9IDIxKSB7XG4gICAgICAgICAgICAvLyBUd28tYnl0ZSBvcGVyYXRvcnMgaGF2ZSBhbiBpbml0aWFsIGVzY2FwZSBieXRlIG9mIDEyLlxuICAgICAgICAgICAgaWYgKG9wID09PSAxMikge1xuICAgICAgICAgICAgICAgIG9wID0gMTIwMCArIHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW50cmllcy5wdXNoKFtvcCwgb3BlcmFuZHNdKTtcbiAgICAgICAgICAgIG9wZXJhbmRzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgb3BlcmFuZHMgKHZhbHVlcykgY29tZSBiZWZvcmUgdGhlIG9wZXJhdG9ycyAoa2V5cyksIHdlIHN0b3JlIGFsbCBvcGVyYW5kcyBpbiBhIGxpc3RcbiAgICAgICAgICAgIC8vIHVudGlsIHdlIGVuY291bnRlciBhbiBvcGVyYXRvci5cbiAgICAgICAgICAgIG9wZXJhbmRzLnB1c2gocGFyc2VPcGVyYW5kKHBhcnNlciwgb3ApKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbnRyaWVzVG9PYmplY3QoZW50cmllcyk7XG59XG5cbi8vIEdpdmVuIGEgU3RyaW5nIEluZGV4IChTSUQpLCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBzdHJpbmcuXG4vLyBTdHJpbmdzIGJlbG93IGluZGV4IDM5MiBhcmUgc3RhbmRhcmQgQ0ZGIHN0cmluZ3MgYW5kIGFyZSBub3QgZW5jb2RlZCBpbiB0aGUgZm9udC5cbmZ1bmN0aW9uIGdldENGRlN0cmluZyhzdHJpbmdzLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA8PSAzOTApIHtcbiAgICAgICAgaW5kZXggPSBjZmZTdGFuZGFyZFN0cmluZ3NbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0gc3RyaW5nc1tpbmRleCAtIDM5MV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG4vLyBJbnRlcnByZXQgYSBkaWN0aW9uYXJ5IGFuZCByZXR1cm4gYSBuZXcgZGljdGlvbmFyeSB3aXRoIHJlYWRhYmxlIGtleXMgYW5kIHZhbHVlcyBmb3IgbWlzc2luZyBlbnRyaWVzLlxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBgbWV0YWAgd2hpY2ggaXMgYSBsaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBgb3BlcmFuZGAsIGBuYW1lYCBhbmQgYGRlZmF1bHRgLlxuZnVuY3Rpb24gaW50ZXJwcmV0RGljdChkaWN0LCBtZXRhLCBzdHJpbmdzKSB7XG4gICAgdmFyIG5ld0RpY3QgPSB7fTtcbiAgICB2YXIgdmFsdWU7XG5cbiAgICAvLyBCZWNhdXNlIHdlIGFsc28gd2FudCB0byBpbmNsdWRlIG1pc3NpbmcgdmFsdWVzLCB3ZSBzdGFydCBvdXQgZnJvbSB0aGUgbWV0YSBsaXN0XG4gICAgLy8gYW5kIGxvb2t1cCB2YWx1ZXMgaW4gdGhlIGRpY3QuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBtID0gbWV0YVtpXTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtLnR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgICB2YWx1ZXMubGVuZ3RoID0gbS50eXBlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbS50eXBlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkaWN0W20ub3BdICE9PSB1bmRlZmluZWQgPyBkaWN0W20ub3BdW2pdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG0udmFsdWUgIT09IHVuZGVmaW5lZCAmJiBtLnZhbHVlW2pdICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG0udmFsdWVbal1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtLnR5cGVbal0gPT09ICdTSUQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVzW2pdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdEaWN0W20ubmFtZV0gPSB2YWx1ZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGRpY3RbbS5vcF07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbS52YWx1ZSAhPT0gdW5kZWZpbmVkID8gbS52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtLnR5cGUgPT09ICdTSUQnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRDRkZTdHJpbmcoc3RyaW5ncywgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3RGljdFttLm5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGljdDtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBoZWFkZXIuXG5mdW5jdGlvbiBwYXJzZUNGRkhlYWRlcihkYXRhLCBzdGFydCkge1xuICAgIHZhciBoZWFkZXIgPSB7fTtcbiAgICBoZWFkZXIuZm9ybWF0TWFqb3IgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCk7XG4gICAgaGVhZGVyLmZvcm1hdE1pbm9yID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAxKTtcbiAgICBoZWFkZXIuc2l6ZSA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgaGVhZGVyLm9mZnNldFNpemUgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDMpO1xuICAgIGhlYWRlci5zdGFydE9mZnNldCA9IHN0YXJ0O1xuICAgIGhlYWRlci5lbmRPZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgcmV0dXJuIGhlYWRlcjtcbn1cblxudmFyIFRPUF9ESUNUX01FVEEgPSBbXG4gICAgeyBuYW1lOiAndmVyc2lvbicsIG9wOiAwLCB0eXBlOiAnU0lEJyB9LFxuICAgIHsgbmFtZTogJ25vdGljZScsIG9wOiAxLCB0eXBlOiAnU0lEJyB9LFxuICAgIHsgbmFtZTogJ2NvcHlyaWdodCcsIG9wOiAxMjAwLCB0eXBlOiAnU0lEJyB9LFxuICAgIHsgbmFtZTogJ2Z1bGxOYW1lJywgb3A6IDIsIHR5cGU6ICdTSUQnIH0sXG4gICAgeyBuYW1lOiAnZmFtaWx5TmFtZScsIG9wOiAzLCB0eXBlOiAnU0lEJyB9LFxuICAgIHsgbmFtZTogJ3dlaWdodCcsIG9wOiA0LCB0eXBlOiAnU0lEJyB9LFxuICAgIHsgbmFtZTogJ2lzRml4ZWRQaXRjaCcsIG9wOiAxMjAxLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDAgfSxcbiAgICB7IG5hbWU6ICdpdGFsaWNBbmdsZScsIG9wOiAxMjAyLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDAgfSxcbiAgICB7IG5hbWU6ICd1bmRlcmxpbmVQb3NpdGlvbicsIG9wOiAxMjAzLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IC0xMDAgfSxcbiAgICB7IG5hbWU6ICd1bmRlcmxpbmVUaGlja25lc3MnLCBvcDogMTIwNCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiA1MCB9LFxuICAgIHsgbmFtZTogJ3BhaW50VHlwZScsIG9wOiAxMjA1LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDAgfSxcbiAgICB7IG5hbWU6ICdjaGFyc3RyaW5nVHlwZScsIG9wOiAxMjA2LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDIgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdmb250TWF0cml4JyxcbiAgICAgICAgb3A6IDEyMDcsXG4gICAgICAgIHR5cGU6IFsncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnXSxcbiAgICAgICAgdmFsdWU6IFswLjAwMSwgMCwgMCwgMC4wMDEsIDAsIDBdLFxuICAgIH0sXG4gICAgeyBuYW1lOiAndW5pcXVlSWQnLCBvcDogMTMsIHR5cGU6ICdudW1iZXInIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnZm9udEJCb3gnLFxuICAgICAgICBvcDogNSxcbiAgICAgICAgdHlwZTogWydudW1iZXInLCAnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInXSxcbiAgICAgICAgdmFsdWU6IFswLCAwLCAwLCAwXSxcbiAgICB9LFxuICAgIHsgbmFtZTogJ3N0cm9rZVdpZHRoJywgb3A6IDEyMDgsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMCB9LFxuICAgIHsgbmFtZTogJ3h1aWQnLCBvcDogMTQsIHR5cGU6IFtdLCB2YWx1ZTogbnVsbCB9LFxuICAgIHsgbmFtZTogJ2NoYXJzZXQnLCBvcDogMTUsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMCB9LFxuICAgIHsgbmFtZTogJ2VuY29kaW5nJywgb3A6IDE2LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDAgfSxcbiAgICB7IG5hbWU6ICdjaGFyU3RyaW5ncycsIG9wOiAxNywgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwIH0sXG4gICAgeyBuYW1lOiAncHJpdmF0ZScsIG9wOiAxOCwgdHlwZTogWydudW1iZXInLCAnb2Zmc2V0J10sIHZhbHVlOiBbMCwgMF0gfSxcbiAgICB7IG5hbWU6ICdyb3MnLCBvcDogMTIzMCwgdHlwZTogWydTSUQnLCAnU0lEJywgJ251bWJlciddIH0sXG4gICAgeyBuYW1lOiAnY2lkRm9udFZlcnNpb24nLCBvcDogMTIzMSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwIH0sXG4gICAgeyBuYW1lOiAnY2lkRm9udFJldmlzaW9uJywgb3A6IDEyMzIsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMCB9LFxuICAgIHsgbmFtZTogJ2NpZEZvbnRUeXBlJywgb3A6IDEyMzMsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMCB9LFxuICAgIHsgbmFtZTogJ2NpZENvdW50Jywgb3A6IDEyMzQsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogODcyMCB9LFxuICAgIHsgbmFtZTogJ3VpZEJhc2UnLCBvcDogMTIzNSwgdHlwZTogJ251bWJlcicgfSxcbiAgICB7IG5hbWU6ICdmZEFycmF5Jywgb3A6IDEyMzYsIHR5cGU6ICdvZmZzZXQnIH0sXG4gICAgeyBuYW1lOiAnZmRTZWxlY3QnLCBvcDogMTIzNywgdHlwZTogJ29mZnNldCcgfSxcbiAgICB7IG5hbWU6ICdmb250TmFtZScsIG9wOiAxMjM4LCB0eXBlOiAnU0lEJyB9IF07XG5cbnZhciBQUklWQVRFX0RJQ1RfTUVUQSA9IFtcbiAgICB7IG5hbWU6ICdzdWJycycsIG9wOiAxOSwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwIH0sXG4gICAgeyBuYW1lOiAnZGVmYXVsdFdpZHRoWCcsIG9wOiAyMCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwIH0sXG4gICAgeyBuYW1lOiAnbm9taW5hbFdpZHRoWCcsIG9wOiAyMSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwIH0gXTtcblxuLy8gUGFyc2UgdGhlIENGRiB0b3AgZGljdGlvbmFyeS4gQSBDRkYgdGFibGUgY2FuIGNvbnRhaW4gbXVsdGlwbGUgZm9udHMsIGVhY2ggd2l0aCB0aGVpciBvd24gdG9wIGRpY3Rpb25hcnkuXG4vLyBUaGUgdG9wIGRpY3Rpb25hcnkgY29udGFpbnMgdGhlIGVzc2VudGlhbCBtZXRhZGF0YSBmb3IgdGhlIGZvbnQsIHRvZ2V0aGVyIHdpdGggdGhlIHByaXZhdGUgZGljdGlvbmFyeS5cbmZ1bmN0aW9uIHBhcnNlQ0ZGVG9wRGljdChkYXRhLCBzdHJpbmdzKSB7XG4gICAgdmFyIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgMCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gaW50ZXJwcmV0RGljdChkaWN0LCBUT1BfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBwcml2YXRlIGRpY3Rpb25hcnkuIFdlIGRvbid0IGZ1bGx5IHBhcnNlIG91dCBhbGwgdGhlIHZhbHVlcywgb25seSB0aGUgb25lcyB3ZSBuZWVkLlxuZnVuY3Rpb24gcGFyc2VDRkZQcml2YXRlRGljdChkYXRhLCBzdGFydCwgc2l6ZSwgc3RyaW5ncykge1xuICAgIHZhciBkaWN0ID0gcGFyc2VDRkZEaWN0KGRhdGEsIHN0YXJ0LCBzaXplKTtcbiAgICByZXR1cm4gaW50ZXJwcmV0RGljdChkaWN0LCBQUklWQVRFX0RJQ1RfTUVUQSwgc3RyaW5ncyk7XG59XG5cbi8vIFJldHVybnMgYSBsaXN0IG9mIFwiVG9wIERJQ1RcInMgZm91bmQgdXNpbmcgYW4gSU5ERVggbGlzdC5cbi8vIFVzZWQgdG8gcmVhZCBib3RoIHRoZSB1c3VhbCBoaWdoLWxldmVsIFRvcCBESUNUcyBhbmQgYWxzbyB0aGUgRkRBcnJheVxuLy8gZGlzY292ZXJlZCBpbnNpZGUgQ0lELWtleWVkIGZvbnRzLiAgV2hlbiBhIFRvcCBESUNUIGhhcyBhIHJlZmVyZW5jZSB0b1xuLy8gYSBQcml2YXRlIERJQ1QgdGhhdCBpcyByZWFkIGFuZCBzYXZlZCBpbnRvIHRoZSBUb3AgRElDVC5cbi8vXG4vLyBJbiBhZGRpdGlvbiB0byB0aGUgZXhwZWN0ZWQvb3B0aW9uYWwgdmFsdWVzIGFzIG91dGxpbmVkIGluIFRPUF9ESUNUX01FVEFcbi8vIHRoZSBmb2xsb3dpbmcgdmFsdWVzIG1pZ2h0IGJlIHNhdmVkIGludG8gdGhlIFRvcCBESUNULlxuLy9cbi8vICAgIF9zdWJycyBbXSAgICAgICAgYXJyYXkgb2YgbG9jYWwgQ0ZGIHN1YnJvdXRpbmVzIGZyb20gUHJpdmF0ZSBESUNUXG4vLyAgICBfc3VicnNCaWFzICAgICAgIGJpYXMgdmFsdWUgY29tcHV0ZWQgZnJvbSBudW1iZXIgb2Ygc3Vicm91dGluZXNcbi8vICAgICAgICAgICAgICAgICAgICAgIChzZWUgY2FsY0NGRlN1YnJvdXRpbmVCaWFzKCkgYW5kIHBhcnNlQ0ZGQ2hhcnN0cmluZygpKVxuLy8gICAgX2RlZmF1bHRXaWR0aFggICBkZWZhdWx0IHdpZHRocyBmb3IgQ0ZGIGNoYXJhY3RlcnNcbi8vICAgIF9ub21pbmFsV2lkdGhYICAgYmlhcyBhZGRlZCB0byB3aWR0aCBlbWJlZGRlZCB3aXRoaW4gZ2x5cGggZGVzY3JpcHRpb25cbi8vXG4vLyAgICBfcHJpdmF0ZURpY3QgICAgIHNhdmVkIGNvcHkgb2YgcGFyc2VkIFByaXZhdGUgRElDVCBmcm9tIFRvcCBESUNUXG5mdW5jdGlvbiBnYXRoZXJDRkZUb3BEaWN0cyhkYXRhLCBzdGFydCwgY2ZmSW5kZXgsIHN0cmluZ3MpIHtcbiAgICB2YXIgdG9wRGljdEFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaVRvcERpY3QgPSAwOyBpVG9wRGljdCA8IGNmZkluZGV4Lmxlbmd0aDsgaVRvcERpY3QgKz0gMSkge1xuICAgICAgICB2YXIgdG9wRGljdERhdGEgPSBuZXcgRGF0YVZpZXcoXG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShjZmZJbmRleFtpVG9wRGljdF0pLmJ1ZmZlclxuICAgICAgICApO1xuICAgICAgICB2YXIgdG9wRGljdCA9IHBhcnNlQ0ZGVG9wRGljdCh0b3BEaWN0RGF0YSwgc3RyaW5ncyk7XG4gICAgICAgIHRvcERpY3QuX3N1YnJzID0gW107XG4gICAgICAgIHRvcERpY3QuX3N1YnJzQmlhcyA9IDA7XG4gICAgICAgIHRvcERpY3QuX2RlZmF1bHRXaWR0aFggPSAwO1xuICAgICAgICB0b3BEaWN0Ll9ub21pbmFsV2lkdGhYID0gMDtcbiAgICAgICAgdmFyIHByaXZhdGVTaXplID0gdG9wRGljdC5wcml2YXRlWzBdO1xuICAgICAgICB2YXIgcHJpdmF0ZU9mZnNldCA9IHRvcERpY3QucHJpdmF0ZVsxXTtcbiAgICAgICAgaWYgKHByaXZhdGVTaXplICE9PSAwICYmIHByaXZhdGVPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBwcml2YXRlRGljdCA9IHBhcnNlQ0ZGUHJpdmF0ZURpY3QoXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBwcml2YXRlT2Zmc2V0ICsgc3RhcnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZVNpemUsXG4gICAgICAgICAgICAgICAgc3RyaW5nc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRvcERpY3QuX2RlZmF1bHRXaWR0aFggPSBwcml2YXRlRGljdC5kZWZhdWx0V2lkdGhYO1xuICAgICAgICAgICAgdG9wRGljdC5fbm9taW5hbFdpZHRoWCA9IHByaXZhdGVEaWN0Lm5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICBpZiAocHJpdmF0ZURpY3Quc3VicnMgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Vick9mZnNldCA9IHByaXZhdGVPZmZzZXQgKyBwcml2YXRlRGljdC5zdWJycztcbiAgICAgICAgICAgICAgICB2YXIgc3VickluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdWJyT2Zmc2V0ICsgc3RhcnQpO1xuICAgICAgICAgICAgICAgIHRvcERpY3QuX3N1YnJzID0gc3VickluZGV4Lm9iamVjdHM7XG4gICAgICAgICAgICAgICAgdG9wRGljdC5fc3VicnNCaWFzID0gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKHRvcERpY3QuX3N1YnJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvcERpY3QuX3ByaXZhdGVEaWN0ID0gcHJpdmF0ZURpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgdG9wRGljdEFycmF5LnB1c2godG9wRGljdCk7XG4gICAgfVxuICAgIHJldHVybiB0b3BEaWN0QXJyYXk7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgY2hhcnNldCB0YWJsZSwgd2hpY2ggY29udGFpbnMgaW50ZXJuYWwgbmFtZXMgZm9yIGFsbCB0aGUgZ2x5cGhzLlxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBhIGxpc3Qgb2YgZ2x5cGggbmFtZXMuXG4vLyBTZWUgQWRvYmUgVE4gIzUxNzYgY2hhcHRlciAxMywgXCJDaGFyc2V0c1wiLlxuZnVuY3Rpb24gcGFyc2VDRkZDaGFyc2V0KGRhdGEsIHN0YXJ0LCBuR2x5cGhzLCBzdHJpbmdzKSB7XG4gICAgdmFyIHNpZDtcbiAgICB2YXIgY291bnQ7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXG4gICAgLy8gVGhlIC5ub3RkZWYgZ2x5cGggaXMgbm90IGluY2x1ZGVkLCBzbyBzdWJ0cmFjdCAxLlxuICAgIG5HbHlwaHMgLT0gMTtcbiAgICB2YXIgY2hhcnNldCA9IFsnLm5vdGRlZiddO1xuXG4gICAgdmFyIGZvcm1hdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5HbHlwaHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG4gICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgd2hpbGUgKGNoYXJzZXQubGVuZ3RoIDw9IG5HbHlwaHMpIHtcbiAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuICAgICAgICAgICAgY291bnQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDw9IGNvdW50OyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNoYXJzZXQucHVzaChnZXRDRkZTdHJpbmcoc3RyaW5ncywgc2lkKSk7XG4gICAgICAgICAgICAgICAgc2lkICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICB3aGlsZSAoY2hhcnNldC5sZW5ndGggPD0gbkdseXBocykge1xuICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG4gICAgICAgICAgICBjb3VudCA9IHBhcnNlci5wYXJzZUNhcmQxNigpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDw9IGNvdW50OyBpJDIgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNoYXJzZXQucHVzaChnZXRDRkZTdHJpbmcoc3RyaW5ncywgc2lkKSk7XG4gICAgICAgICAgICAgICAgc2lkICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2hhcnNldCBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYXJzZXQ7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgZW5jb2RpbmcgZGF0YS4gT25seSBvbmUgZW5jb2RpbmcgY2FuIGJlIHNwZWNpZmllZCBwZXIgZm9udC5cbi8vIFNlZSBBZG9iZSBUTiAjNTE3NiBjaGFwdGVyIDEyLCBcIkVuY29kaW5nc1wiLlxuZnVuY3Rpb24gcGFyc2VDRkZFbmNvZGluZyhkYXRhLCBzdGFydCwgY2hhcnNldCkge1xuICAgIHZhciBjb2RlO1xuICAgIHZhciBlbmMgPSB7fTtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIGZvcm1hdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMCkge1xuICAgICAgICB2YXIgbkNvZGVzID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuQ29kZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29kZSA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBlbmNbY29kZV0gPSBpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgdmFyIG5SYW5nZXMgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICBjb2RlID0gMTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgblJhbmdlczsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICB2YXIgbkxlZnQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGZpcnN0OyBqIDw9IGZpcnN0ICsgbkxlZnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGVuY1tqXSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgY29kZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nIGZvcm1hdCAnICsgZm9ybWF0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENmZkVuY29kaW5nKGVuYywgY2hhcnNldCk7XG59XG5cbi8vIFRha2UgaW4gY2hhcnN0cmluZyBjb2RlIGFuZCByZXR1cm4gYSBHbHlwaCBvYmplY3QuXG4vLyBUaGUgZW5jb2RpbmcgaXMgZGVzY3JpYmVkIGluIHRoZSBUeXBlIDIgQ2hhcnN0cmluZyBGb3JtYXRcbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcnN0cjIuaHRtXG5mdW5jdGlvbiBwYXJzZUNGRkNoYXJzdHJpbmcoZm9udCwgZ2x5cGgsIGNvZGUpIHtcbiAgICB2YXIgYzF4O1xuICAgIHZhciBjMXk7XG4gICAgdmFyIGMyeDtcbiAgICB2YXIgYzJ5O1xuICAgIHZhciBwID0gbmV3IFBhdGgoKTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgblN0ZW1zID0gMDtcbiAgICB2YXIgaGF2ZVdpZHRoID0gZmFsc2U7XG4gICAgdmFyIG9wZW4gPSBmYWxzZTtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSAwO1xuICAgIHZhciBzdWJycztcbiAgICB2YXIgc3VicnNCaWFzO1xuICAgIHZhciBkZWZhdWx0V2lkdGhYO1xuICAgIHZhciBub21pbmFsV2lkdGhYO1xuICAgIGlmIChmb250LmlzQ0lERm9udCkge1xuICAgICAgICB2YXIgZmRJbmRleCA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9mZFNlbGVjdFtnbHlwaC5pbmRleF07XG4gICAgICAgIHZhciBmZERpY3QgPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fZmRBcnJheVtmZEluZGV4XTtcbiAgICAgICAgc3VicnMgPSBmZERpY3QuX3N1YnJzO1xuICAgICAgICBzdWJyc0JpYXMgPSBmZERpY3QuX3N1YnJzQmlhcztcbiAgICAgICAgZGVmYXVsdFdpZHRoWCA9IGZkRGljdC5fZGVmYXVsdFdpZHRoWDtcbiAgICAgICAgbm9taW5hbFdpZHRoWCA9IGZkRGljdC5fbm9taW5hbFdpZHRoWDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdWJycyA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9zdWJycztcbiAgICAgICAgc3VicnNCaWFzID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX3N1YnJzQmlhcztcbiAgICAgICAgZGVmYXVsdFdpZHRoWCA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9kZWZhdWx0V2lkdGhYO1xuICAgICAgICBub21pbmFsV2lkdGhYID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX25vbWluYWxXaWR0aFg7XG4gICAgfVxuICAgIHZhciB3aWR0aCA9IGRlZmF1bHRXaWR0aFg7XG5cbiAgICBmdW5jdGlvbiBuZXdDb250b3VyKHgsIHkpIHtcbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwLm1vdmVUbyh4LCB5KTtcbiAgICAgICAgb3BlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGVtcygpIHtcbiAgICAgICAgdmFyIGhhc1dpZHRoQXJnO1xuXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2Ygc3RlbSBvcGVyYXRvcnMgb24gdGhlIHN0YWNrIGlzIGFsd2F5cyBldmVuLlxuICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgdW5ldmVuLCB0aGF0IG1lYW5zIGEgd2lkdGggaXMgc3BlY2lmaWVkLlxuICAgICAgICBoYXNXaWR0aEFyZyA9IHN0YWNrLmxlbmd0aCAlIDIgIT09IDA7XG4gICAgICAgIGlmIChoYXNXaWR0aEFyZyAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICB9XG5cbiAgICAgICAgblN0ZW1zICs9IHN0YWNrLmxlbmd0aCA+PiAxO1xuICAgICAgICBzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlKGNvZGUpIHtcbiAgICAgICAgdmFyIGIxO1xuICAgICAgICB2YXIgYjI7XG4gICAgICAgIHZhciBiMztcbiAgICAgICAgdmFyIGI0O1xuICAgICAgICB2YXIgY29kZUluZGV4O1xuICAgICAgICB2YXIgc3VickNvZGU7XG4gICAgICAgIHZhciBqcHg7XG4gICAgICAgIHZhciBqcHk7XG4gICAgICAgIHZhciBjM3g7XG4gICAgICAgIHZhciBjM3k7XG4gICAgICAgIHZhciBjNHg7XG4gICAgICAgIHZhciBjNHk7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGNvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGNvZGVbaV07XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBzd2l0Y2ggKHYpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIGhzdGVtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiAvLyB2c3RlbVxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogLy8gdm1vdmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRvdXIoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTogLy8gcmxpbmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6IC8vIGhsaW5ldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogLy8gdmxpbmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OiAvLyBycmN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6IC8vIGNhbGxzdWJyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IHN0YWNrLnBvcCgpICsgc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgICAgICBzdWJyQ29kZSA9IHN1YnJzW2NvZGVJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2Uoc3VickNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTogLy8gcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiAvLyBmbGV4IG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICB2ID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzU6IC8vIGZsZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHkxIGR4MiBkeTIgZHgzIGR5MyBkeDQgZHk0IGR4NSBkeTUgZHg2IGR5NiBmZCBmbGV4ICgxMiAzNSkgfC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGpweSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzR5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHk2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suc2hpZnQoKTsgLy8gZmxleCBkZXB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzQ6IC8vIGhmbGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR4MiBkeTIgZHgzIGR4NCBkeDUgZHg2IGhmbGV4ICgxMiAzNCkgfC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTsgLy8gZHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5OyAvLyBkeTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3kgPSBjMnk7IC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IHk7IC8vIGR5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMzeCwgYzN5LCBjNHgsIGM0eSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM2OiAvLyBoZmxleDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHkxIGR4MiBkeTIgZHgzIGR4NCBkeDUgZHk1IGR4NiBoZmxleDEgKDEyIDM2KSB8LVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5OyAvLyBkeTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3kgPSBjMnk7IC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMzeCwgYzN5LCBjNHgsIGM0eSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM3OiAvLyBmbGV4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeTEgZHgyIGR5MiBkeDMgZHkzIGR4NCBkeTQgZHg1IGR5NSBkNiBmbGV4MSAoMTIgMzcpIHwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3kgPSBqcHkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoYzR4IC0geCkgPiBNYXRoLmFicyhjNHkgLSB5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzR5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMzeCwgYzN5LCBjNHgsIGM0eSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnR2x5cGggJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbHlwaC5pbmRleCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOiB1bmtub3duIG9wZXJhdG9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTIwMCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6IC8vIGVuZGNoYXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDAgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTg6IC8vIGhzdGVtaG1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE5OiAvLyBoaW50bWFza1xuICAgICAgICAgICAgICAgIGNhc2UgMjA6IC8vIGNudHJtYXNrXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAoblN0ZW1zICsgNykgPj4gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMTogLy8gcm1vdmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMiAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRvdXIoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjI6IC8vIGhtb3ZldG9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250b3VyKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzOiAvLyB2c3RlbWhtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDogLy8gcmN1cnZlbGluZVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI1OiAvLyBybGluZWN1cnZlXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNjogLy8gdnZjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6IC8vIGhoY3VydmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI4OiAvLyBzaG9ydGludFxuICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgIGIyID0gY29kZVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKChiMSA8PCAyNCkgfCAoYjIgPDwgMTYpKSA+PiAxNik7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOTogLy8gY2FsbGdzdWJyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IHN0YWNrLnBvcCgpICsgZm9udC5nc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgICAgICBzdWJyQ29kZSA9IGZvbnQuZ3N1YnJzW2NvZGVJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2Uoc3VickNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzMDogLy8gdmhjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMxOiAvLyBodmN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2IDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdHbHlwaCAnICsgZ2x5cGguaW5kZXggKyAnOiB1bmtub3duIG9wZXJhdG9yICcgKyB2XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNDcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godiAtIDEzOSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI1MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgodiAtIDI0NykgKiAyNTYgKyBiMSArIDEwOCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgtKHYgLSAyNTEpICogMjU2IC0gYjEgLSAxMDgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIzID0gY29kZVtpICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBiNCA9IGNvZGVbaSArIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGIxIDw8IDI0KSB8IChiMiA8PCAxNikgfCAoYjMgPDwgOCkgfCBiNCkgLyA2NTUzNlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2UoY29kZSk7XG5cbiAgICBnbHlwaC5hZHZhbmNlV2lkdGggPSB3aWR0aDtcbiAgICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gcGFyc2VDRkZGRFNlbGVjdChkYXRhLCBzdGFydCwgbkdseXBocywgZmRBcnJheUNvdW50KSB7XG4gICAgdmFyIGZkU2VsZWN0ID0gW107XG4gICAgdmFyIGZkSW5kZXg7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBmb3JtYXQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDApIHtcbiAgICAgICAgLy8gU2ltcGxlIGxpc3Qgb2YgbkdseXBocyBlbGVtZW50c1xuICAgICAgICBmb3IgKHZhciBpR2lkID0gMDsgaUdpZCA8IG5HbHlwaHM7IGlHaWQrKykge1xuICAgICAgICAgICAgZmRJbmRleCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBpZiAoZmRJbmRleCA+PSBmZEFycmF5Q291bnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdDRkYgdGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgaGFzIGJhZCBGRCBpbmRleCB2YWx1ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZkSW5kZXggK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAoRkQgY291bnQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBmZEFycmF5Q291bnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZkU2VsZWN0LnB1c2goZmRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMykge1xuICAgICAgICAvLyBSYW5nZXNcbiAgICAgICAgdmFyIG5SYW5nZXMgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcbiAgICAgICAgdmFyIGZpcnN0ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgIGlmIChmaXJzdCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdDRkYgVGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgZm9ybWF0IDMgcmFuZ2UgaGFzIGJhZCBpbml0aWFsIEdJRCAnICtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIGZvciAodmFyIGlSYW5nZSA9IDA7IGlSYW5nZSA8IG5SYW5nZXM7IGlSYW5nZSsrKSB7XG4gICAgICAgICAgICBmZEluZGV4ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIG5leHQgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcbiAgICAgICAgICAgIGlmIChmZEluZGV4ID49IGZkQXJyYXlDb3VudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ0NGRiB0YWJsZSBDSUQgRm9udCBGRFNlbGVjdCBoYXMgYmFkIEZEIGluZGV4IHZhbHVlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZmRJbmRleCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIChGRCBjb3VudCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZkQXJyYXlDb3VudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPiBuR2x5cGhzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IGZvcm1hdCAzIHJhbmdlIGhhcyBiYWQgR0lEICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgZmlyc3QgPCBuZXh0OyBmaXJzdCsrKSB7XG4gICAgICAgICAgICAgICAgZmRTZWxlY3QucHVzaChmZEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcnN0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dCAhPT0gbkdseXBocykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdDRkYgVGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgZm9ybWF0IDMgcmFuZ2UgaGFzIGJhZCBmaW5hbCBHSUQgJyArXG4gICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IHRhYmxlIGhhcyB1bnN1cHBvcnRlZCBmb3JtYXQgJyArIGZvcm1hdFxuICAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZmRTZWxlY3Q7XG59XG5cbi8vIFBhcnNlIHRoZSBgQ0ZGYCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuZnVuY3Rpb24gcGFyc2VDRkZUYWJsZShkYXRhLCBzdGFydCwgZm9udCwgb3B0KSB7XG4gICAgZm9udC50YWJsZXMuY2ZmID0ge307XG4gICAgdmFyIGhlYWRlciA9IHBhcnNlQ0ZGSGVhZGVyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgbmFtZUluZGV4ID0gcGFyc2VDRkZJbmRleChcbiAgICAgICAgZGF0YSxcbiAgICAgICAgaGVhZGVyLmVuZE9mZnNldCxcbiAgICAgICAgcGFyc2UuYnl0ZXNUb1N0cmluZ1xuICAgICk7XG4gICAgdmFyIHRvcERpY3RJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgbmFtZUluZGV4LmVuZE9mZnNldCk7XG4gICAgdmFyIHN0cmluZ0luZGV4ID0gcGFyc2VDRkZJbmRleChcbiAgICAgICAgZGF0YSxcbiAgICAgICAgdG9wRGljdEluZGV4LmVuZE9mZnNldCxcbiAgICAgICAgcGFyc2UuYnl0ZXNUb1N0cmluZ1xuICAgICk7XG4gICAgdmFyIGdsb2JhbFN1YnJJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3RyaW5nSW5kZXguZW5kT2Zmc2V0KTtcbiAgICBmb250LmdzdWJycyA9IGdsb2JhbFN1YnJJbmRleC5vYmplY3RzO1xuICAgIGZvbnQuZ3N1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyhmb250LmdzdWJycyk7XG5cbiAgICB2YXIgdG9wRGljdEFycmF5ID0gZ2F0aGVyQ0ZGVG9wRGljdHMoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICB0b3BEaWN0SW5kZXgub2JqZWN0cyxcbiAgICAgICAgc3RyaW5nSW5kZXgub2JqZWN0c1xuICAgICk7XG4gICAgaWYgKHRvcERpY3RBcnJheS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJDRkYgdGFibGUgaGFzIHRvbyBtYW55IGZvbnRzIGluICdGb250U2V0JyAtIGNvdW50IG9mIGZvbnRzIE5hbWVJbmRleC5sZW5ndGggPSBcIiArXG4gICAgICAgICAgICAgICAgdG9wRGljdEFycmF5Lmxlbmd0aFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciB0b3BEaWN0ID0gdG9wRGljdEFycmF5WzBdO1xuICAgIGZvbnQudGFibGVzLmNmZi50b3BEaWN0ID0gdG9wRGljdDtcblxuICAgIGlmICh0b3BEaWN0Ll9wcml2YXRlRGljdCkge1xuICAgICAgICBmb250LmRlZmF1bHRXaWR0aFggPSB0b3BEaWN0Ll9wcml2YXRlRGljdC5kZWZhdWx0V2lkdGhYO1xuICAgICAgICBmb250Lm5vbWluYWxXaWR0aFggPSB0b3BEaWN0Ll9wcml2YXRlRGljdC5ub21pbmFsV2lkdGhYO1xuICAgIH1cblxuICAgIGlmICh0b3BEaWN0LnJvc1swXSAhPT0gdW5kZWZpbmVkICYmIHRvcERpY3Qucm9zWzFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9udC5pc0NJREZvbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChmb250LmlzQ0lERm9udCkge1xuICAgICAgICB2YXIgZmRBcnJheU9mZnNldCA9IHRvcERpY3QuZmRBcnJheTtcbiAgICAgICAgdmFyIGZkU2VsZWN0T2Zmc2V0ID0gdG9wRGljdC5mZFNlbGVjdDtcbiAgICAgICAgaWYgKGZkQXJyYXlPZmZzZXQgPT09IDAgfHwgZmRTZWxlY3RPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnRm9udCBpcyBtYXJrZWQgYXMgYSBDSUQgZm9udCwgYnV0IEZEQXJyYXkgYW5kL29yIEZEU2VsZWN0IGluZm9ybWF0aW9uIGlzIG1pc3NpbmcnXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGZkQXJyYXlPZmZzZXQgKz0gc3RhcnQ7XG4gICAgICAgIHZhciBmZEFycmF5SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIGZkQXJyYXlPZmZzZXQpO1xuICAgICAgICB2YXIgZmRBcnJheSA9IGdhdGhlckNGRlRvcERpY3RzKFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZmRBcnJheUluZGV4Lm9iamVjdHMsXG4gICAgICAgICAgICBzdHJpbmdJbmRleC5vYmplY3RzXG4gICAgICAgICk7XG4gICAgICAgIHRvcERpY3QuX2ZkQXJyYXkgPSBmZEFycmF5O1xuICAgICAgICBmZFNlbGVjdE9mZnNldCArPSBzdGFydDtcbiAgICAgICAgdG9wRGljdC5fZmRTZWxlY3QgPSBwYXJzZUNGRkZEU2VsZWN0KFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGZkU2VsZWN0T2Zmc2V0LFxuICAgICAgICAgICAgZm9udC5udW1HbHlwaHMsXG4gICAgICAgICAgICBmZEFycmF5Lmxlbmd0aFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBwcml2YXRlRGljdE9mZnNldCA9IHN0YXJ0ICsgdG9wRGljdC5wcml2YXRlWzFdO1xuICAgIHZhciBwcml2YXRlRGljdCA9IHBhcnNlQ0ZGUHJpdmF0ZURpY3QoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHByaXZhdGVEaWN0T2Zmc2V0LFxuICAgICAgICB0b3BEaWN0LnByaXZhdGVbMF0sXG4gICAgICAgIHN0cmluZ0luZGV4Lm9iamVjdHNcbiAgICApO1xuICAgIGZvbnQuZGVmYXVsdFdpZHRoWCA9IHByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG4gICAgZm9udC5ub21pbmFsV2lkdGhYID0gcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcblxuICAgIGlmIChwcml2YXRlRGljdC5zdWJycyAhPT0gMCkge1xuICAgICAgICB2YXIgc3Vick9mZnNldCA9IHByaXZhdGVEaWN0T2Zmc2V0ICsgcHJpdmF0ZURpY3Quc3VicnM7XG4gICAgICAgIHZhciBzdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN1YnJPZmZzZXQpO1xuICAgICAgICBmb250LnN1YnJzID0gc3VickluZGV4Lm9iamVjdHM7XG4gICAgICAgIGZvbnQuc3VicnNCaWFzID0gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKGZvbnQuc3VicnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvbnQuc3VicnMgPSBbXTtcbiAgICAgICAgZm9udC5zdWJyc0JpYXMgPSAwO1xuICAgIH1cblxuICAgIC8vIE9mZnNldHMgaW4gdGhlIHRvcCBkaWN0IGFyZSByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBDRkYgZGF0YSwgc28gYWRkIHRoZSBDRkYgc3RhcnQgb2Zmc2V0LlxuICAgIHZhciBjaGFyU3RyaW5nc0luZGV4O1xuICAgIGlmIChvcHQubG93TWVtb3J5KSB7XG4gICAgICAgIGNoYXJTdHJpbmdzSW5kZXggPSBwYXJzZUNGRkluZGV4TG93TWVtb3J5KFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHN0YXJ0ICsgdG9wRGljdC5jaGFyU3RyaW5nc1xuICAgICAgICApO1xuICAgICAgICBmb250Lm5HbHlwaHMgPSBjaGFyU3RyaW5nc0luZGV4Lm9mZnNldHMubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYXJTdHJpbmdzSW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyU3RyaW5ncyk7XG4gICAgICAgIGZvbnQubkdseXBocyA9IGNoYXJTdHJpbmdzSW5kZXgub2JqZWN0cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJzZXQgPSBwYXJzZUNGRkNoYXJzZXQoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHN0YXJ0ICsgdG9wRGljdC5jaGFyc2V0LFxuICAgICAgICBmb250Lm5HbHlwaHMsXG4gICAgICAgIHN0cmluZ0luZGV4Lm9iamVjdHNcbiAgICApO1xuICAgIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAwKSB7XG4gICAgICAgIC8vIFN0YW5kYXJkIGVuY29kaW5nXG4gICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBuZXcgQ2ZmRW5jb2RpbmcoY2ZmU3RhbmRhcmRFbmNvZGluZywgY2hhcnNldCk7XG4gICAgfSBlbHNlIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAxKSB7XG4gICAgICAgIC8vIEV4cGVydCBlbmNvZGluZ1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gbmV3IENmZkVuY29kaW5nKGNmZkV4cGVydEVuY29kaW5nLCBjaGFyc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gcGFyc2VDRkZFbmNvZGluZyhcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBzdGFydCArIHRvcERpY3QuZW5jb2RpbmcsXG4gICAgICAgICAgICBjaGFyc2V0XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUHJlZmVyIHRoZSBDTUFQIGVuY29kaW5nIHRvIHRoZSBDRkYgZW5jb2RpbmcuXG4gICAgZm9udC5lbmNvZGluZyA9IGZvbnQuZW5jb2RpbmcgfHwgZm9udC5jZmZFbmNvZGluZztcblxuICAgIGZvbnQuZ2x5cGhzID0gbmV3IGdseXBoc2V0LkdseXBoU2V0KGZvbnQpO1xuICAgIGlmIChvcHQubG93TWVtb3J5KSB7XG4gICAgICAgIGZvbnQuX3B1c2ggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIGNoYXJTdHJpbmcgPSBnZXRDZmZJbmRleE9iamVjdChcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGNoYXJTdHJpbmdzSW5kZXgub2Zmc2V0cyxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIHN0YXJ0ICsgdG9wRGljdC5jaGFyU3RyaW5nc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZvbnQuZ2x5cGhzLnB1c2goXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBnbHlwaHNldC5jZmZHbHlwaExvYWRlcihmb250LCBpLCBwYXJzZUNGRkNoYXJzdHJpbmcsIGNoYXJTdHJpbmcpXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9udC5uR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjaGFyU3RyaW5nID0gY2hhclN0cmluZ3NJbmRleC5vYmplY3RzW2ldO1xuICAgICAgICAgICAgZm9udC5nbHlwaHMucHVzaChcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGdseXBoc2V0LmNmZkdseXBoTG9hZGVyKGZvbnQsIGksIHBhcnNlQ0ZGQ2hhcnN0cmluZywgY2hhclN0cmluZylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBjZmYgPSB7IHBhcnNlOiBwYXJzZUNGRlRhYmxlIH07XG5cbi8vIFRoZSBgZnZhcmAgdGFibGUgc3RvcmVzIGZvbnQgdmFyaWF0aW9uIGF4ZXMgYW5kIGluc3RhbmNlcy5cblxuZnVuY3Rpb24gcGFyc2VGdmFyQXhpcyhkYXRhLCBzdGFydCwgbmFtZXMpIHtcbiAgICB2YXIgYXhpcyA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgYXhpcy50YWcgPSBwLnBhcnNlVGFnKCk7XG4gICAgYXhpcy5taW5WYWx1ZSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIGF4aXMuZGVmYXVsdFZhbHVlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgYXhpcy5tYXhWYWx1ZSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIHAuc2tpcCgndVNob3J0JywgMSk7IC8vIHJlc2VydmVkIGZvciBmbGFnczsgbm8gdmFsdWVzIGRlZmluZWRcbiAgICBheGlzLm5hbWUgPSBuYW1lc1twLnBhcnNlVVNob3J0KCldIHx8IHt9O1xuICAgIHJldHVybiBheGlzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUZ2YXJJbnN0YW5jZShkYXRhLCBzdGFydCwgYXhlcywgbmFtZXMpIHtcbiAgICB2YXIgaW5zdCA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgaW5zdC5uYW1lID0gbmFtZXNbcC5wYXJzZVVTaG9ydCgpXSB8fCB7fTtcbiAgICBwLnNraXAoJ3VTaG9ydCcsIDEpOyAvLyByZXNlcnZlZCBmb3IgZmxhZ3M7IG5vIHZhbHVlcyBkZWZpbmVkXG5cbiAgICBpbnN0LmNvb3JkaW5hdGVzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGluc3QuY29vcmRpbmF0ZXNbYXhlc1tpXS50YWddID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3Q7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnZhclRhYmxlKGRhdGEsIHN0YXJ0LCBuYW1lcykge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KFxuICAgICAgICB0YWJsZVZlcnNpb24gPT09IDB4MDAwMTAwMDAsXG4gICAgICAgICdVbnN1cHBvcnRlZCBmdmFyIHRhYmxlIHZlcnNpb24uJ1xuICAgICk7XG4gICAgdmFyIG9mZnNldFRvRGF0YSA9IHAucGFyc2VPZmZzZXQxNigpO1xuICAgIC8vIFNraXAgY291bnRTaXplUGFpcnMuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAxKTtcbiAgICB2YXIgYXhpc0NvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBheGlzU2l6ZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgaW5zdGFuY2VDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgaW5zdGFuY2VTaXplID0gcC5wYXJzZVVTaG9ydCgpO1xuXG4gICAgdmFyIGF4ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4aXNDb3VudDsgaSsrKSB7XG4gICAgICAgIGF4ZXMucHVzaChcbiAgICAgICAgICAgIHBhcnNlRnZhckF4aXMoZGF0YSwgc3RhcnQgKyBvZmZzZXRUb0RhdGEgKyBpICogYXhpc1NpemUsIG5hbWVzKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZXMgPSBbXTtcbiAgICB2YXIgaW5zdGFuY2VTdGFydCA9IHN0YXJ0ICsgb2Zmc2V0VG9EYXRhICsgYXhpc0NvdW50ICogYXhpc1NpemU7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnN0YW5jZUNvdW50OyBqKyspIHtcbiAgICAgICAgaW5zdGFuY2VzLnB1c2goXG4gICAgICAgICAgICBwYXJzZUZ2YXJJbnN0YW5jZShcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQgKyBqICogaW5zdGFuY2VTaXplLFxuICAgICAgICAgICAgICAgIGF4ZXMsXG4gICAgICAgICAgICAgICAgbmFtZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBheGVzOiBheGVzLCBpbnN0YW5jZXM6IGluc3RhbmNlcyB9O1xufVxuXG52YXIgZnZhciA9IHsgcGFyc2U6IHBhcnNlRnZhclRhYmxlIH07XG5cbi8vIFRoZSBgR0RFRmAgdGFibGUgY29udGFpbnMgdmFyaW91cyBnbHlwaCBwcm9wZXJ0aWVzXG5cbnZhciBhdHRhY2hMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgIGF0dGFjaFBvaW50czogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLnVTaG9ydExpc3QpKVxuICAgIH07XG59O1xuXG52YXIgY2FyZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoZm9ybWF0ID09PSAxIHx8IGZvcm1hdCA9PT0gMiB8fCBmb3JtYXQgPT09IDMsXG4gICAgICAgICdVbnN1cHBvcnRlZCBDYXJldFZhbHVlIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4geyBjb29yZGluYXRlOiB0aGlzLnBhcnNlU2hvcnQoKSB9O1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7IHBvaW50aW5kZXg6IHRoaXMucGFyc2VTaG9ydCgpIH07XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDMpIHtcbiAgICAgICAgLy8gRGV2aWNlIC8gVmFyaWF0aW9uIEluZGV4IHRhYmxlcyB1bnN1cHBvcnRlZFxuICAgICAgICByZXR1cm4geyBjb29yZGluYXRlOiB0aGlzLnBhcnNlU2hvcnQoKSB9O1xuICAgIH1cbn07XG5cbnZhciBsaWdHbHlwaCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihjYXJldFZhbHVlKSk7XG59O1xuXG52YXIgbGlnQ2FyZXRMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgIGxpZ0dseXBoczogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIobGlnR2x5cGgpKVxuICAgIH07XG59O1xuXG52YXIgbWFya0dseXBoU2V0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucGFyc2VVU2hvcnQoKTsgLy8gVmVyc2lvblxuICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKTtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlR0RFRlRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIHZhciBwID0gbmV3IFBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKDEpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMSB8fCB0YWJsZVZlcnNpb24gPT09IDEuMiB8fCB0YWJsZVZlcnNpb24gPT09IDEuMyxcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIEdERUYgdGFibGUgdmVyc2lvbi4nKTtcbiAgICB2YXIgZ2RlZiA9IHtcbiAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuICAgICAgICBjbGFzc0RlZjogcC5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgYXR0YWNoTGlzdDogcC5wYXJzZVBvaW50ZXIoYXR0YWNoTGlzdCksXG4gICAgICAgIGxpZ0NhcmV0TGlzdDogcC5wYXJzZVBvaW50ZXIobGlnQ2FyZXRMaXN0KSxcbiAgICAgICAgbWFya0F0dGFjaENsYXNzRGVmOiBwLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpXG4gICAgfTtcbiAgICBpZiAodGFibGVWZXJzaW9uID49IDEuMikge1xuICAgICAgICBnZGVmLm1hcmtHbHlwaFNldHMgPSBwLnBhcnNlUG9pbnRlcihtYXJrR2x5cGhTZXRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGdkZWY7XG59XG52YXIgZ2RlZiA9IHsgcGFyc2U6IHBhcnNlR0RFRlRhYmxlIH07XG5cbi8vIFRoZSBgR1BPU2AgdGFibGUgY29udGFpbnMga2VybmluZyBwYWlycywgYW1vbmcgb3RoZXIgdGhpbmdzLlxuXG52YXIgc3VidGFibGVQYXJzZXJzID0gbmV3IEFycmF5KDEwKTsgLy8gc3VidGFibGVQYXJzZXJzWzBdIGlzIHVudXNlZFxuXG4vLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3BvcyNsb29rdXAtdHlwZS0xLXNpbmdsZS1hZGp1c3RtZW50LXBvc2l0aW9uaW5nLXN1YnRhYmxlXG4vLyB0aGlzID0gUGFyc2VyIGluc3RhbmNlXG5zdWJ0YWJsZVBhcnNlcnNbMV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDEoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBwb3Nmb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKHBvc2Zvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zRm9ybWF0OiAxLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKCksXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwb3Nmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc0Zvcm1hdDogMixcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgdmFsdWVzOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmRMaXN0KCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICcweCcgK1xuICAgICAgICAgICAgc3RhcnQudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICc6IEdQT1MgbG9va3VwIHR5cGUgMSBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJ1xuICAgICk7XG59O1xuXG4vLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3BvcyNsb29rdXAtdHlwZS0yLXBhaXItYWRqdXN0bWVudC1wb3NpdGlvbmluZy1zdWJ0YWJsZVxuc3VidGFibGVQYXJzZXJzWzJdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAyKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgcG9zRm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFzc2VydChcbiAgICAgICAgcG9zRm9ybWF0ID09PSAxIHx8IHBvc0Zvcm1hdCA9PT0gMixcbiAgICAgICAgJzB4JyArXG4gICAgICAgICAgICBzdGFydC50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgJzogR1BPUyBsb29rdXAgdHlwZSAyIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nXG4gICAgKTtcbiAgICB2YXIgY292ZXJhZ2UgPSB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpO1xuICAgIHZhciB2YWx1ZUZvcm1hdDEgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHZhbHVlRm9ybWF0MiA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAocG9zRm9ybWF0ID09PSAxKSB7XG4gICAgICAgIC8vIEFkanVzdG1lbnRzIGZvciBHbHlwaCBQYWlyc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zRm9ybWF0OiBwb3NGb3JtYXQsXG4gICAgICAgICAgICBjb3ZlcmFnZTogY292ZXJhZ2UsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdDE6IHZhbHVlRm9ybWF0MSxcbiAgICAgICAgICAgIHZhbHVlRm9ybWF0MjogdmFsdWVGb3JtYXQyLFxuICAgICAgICAgICAgcGFpclNldHM6IHRoaXMucGFyc2VMaXN0KFxuICAgICAgICAgICAgICAgIFBhcnNlci5wb2ludGVyKFxuICAgICAgICAgICAgICAgICAgICBQYXJzZXIubGlzdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhaXJWYWx1ZVJlY29yZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZEdseXBoOiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUxOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTI6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh2YWx1ZUZvcm1hdDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAocG9zRm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHZhciBjbGFzc0RlZjEgPSB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpO1xuICAgICAgICB2YXIgY2xhc3NEZWYyID0gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKTtcbiAgICAgICAgdmFyIGNsYXNzMUNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgY2xhc3MyQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBDbGFzcyBQYWlyIEFkanVzdG1lbnRcbiAgICAgICAgICAgIHBvc0Zvcm1hdDogcG9zRm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IGNvdmVyYWdlLFxuICAgICAgICAgICAgdmFsdWVGb3JtYXQxOiB2YWx1ZUZvcm1hdDEsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdDI6IHZhbHVlRm9ybWF0MixcbiAgICAgICAgICAgIGNsYXNzRGVmMTogY2xhc3NEZWYxLFxuICAgICAgICAgICAgY2xhc3NEZWYyOiBjbGFzc0RlZjIsXG4gICAgICAgICAgICBjbGFzczFDb3VudDogY2xhc3MxQ291bnQsXG4gICAgICAgICAgICBjbGFzczJDb3VudDogY2xhc3MyQ291bnQsXG4gICAgICAgICAgICBjbGFzc1JlY29yZHM6IHRoaXMucGFyc2VMaXN0KFxuICAgICAgICAgICAgICAgIGNsYXNzMUNvdW50LFxuICAgICAgICAgICAgICAgIFBhcnNlci5saXN0KGNsYXNzMkNvdW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTE6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh2YWx1ZUZvcm1hdDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUyOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQyKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5zdWJ0YWJsZVBhcnNlcnNbM10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDMoKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCAzIG5vdCBzdXBwb3J0ZWQnIH07XG59O1xuc3VidGFibGVQYXJzZXJzWzRdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA0KCkge1xuICAgIHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNCBub3Qgc3VwcG9ydGVkJyB9O1xufTtcbnN1YnRhYmxlUGFyc2Vyc1s1XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNSgpIHtcbiAgICByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDUgbm90IHN1cHBvcnRlZCcgfTtcbn07XG5zdWJ0YWJsZVBhcnNlcnNbNl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDYoKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA2IG5vdCBzdXBwb3J0ZWQnIH07XG59O1xuc3VidGFibGVQYXJzZXJzWzddID0gZnVuY3Rpb24gcGFyc2VMb29rdXA3KCkge1xuICAgIHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNyBub3Qgc3VwcG9ydGVkJyB9O1xufTtcbnN1YnRhYmxlUGFyc2Vyc1s4XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwOCgpIHtcbiAgICByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDggbm90IHN1cHBvcnRlZCcgfTtcbn07XG5zdWJ0YWJsZVBhcnNlcnNbOV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDkoKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA5IG5vdCBzdXBwb3J0ZWQnIH07XG59O1xuXG4vLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3Bvc1xuZnVuY3Rpb24gcGFyc2VHcG9zVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgdmFyIHAgPSBuZXcgUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oMSk7XG4gICAgY2hlY2suYXJndW1lbnQoXG4gICAgICAgIHRhYmxlVmVyc2lvbiA9PT0gMSB8fCB0YWJsZVZlcnNpb24gPT09IDEuMSxcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIEdQT1MgdGFibGUgdmVyc2lvbiAnICsgdGFibGVWZXJzaW9uXG4gICAgKTtcblxuICAgIGlmICh0YWJsZVZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgICAgIHNjcmlwdHM6IHAucGFyc2VTY3JpcHRMaXN0KCksXG4gICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG4gICAgICAgICAgICBsb29rdXBzOiBwLnBhcnNlTG9va3VwTGlzdChzdWJ0YWJsZVBhcnNlcnMpLFxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiB0YWJsZVZlcnNpb24sXG4gICAgICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuICAgICAgICAgICAgZmVhdHVyZXM6IHAucGFyc2VGZWF0dXJlTGlzdCgpLFxuICAgICAgICAgICAgbG9va3VwczogcC5wYXJzZUxvb2t1cExpc3Qoc3VidGFibGVQYXJzZXJzKSxcbiAgICAgICAgICAgIHZhcmlhdGlvbnM6IHAucGFyc2VGZWF0dXJlVmFyaWF0aW9uc0xpc3QoKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbnZhciBncG9zID0geyBwYXJzZTogcGFyc2VHcG9zVGFibGUgfTtcblxuLy8gVGhlIGBHU1VCYCB0YWJsZSBjb250YWlucyBsaWdhdHVyZXMsIGFtb25nIG90aGVyIHRoaW5ncy5cblxudmFyIHN1YnRhYmxlUGFyc2VycyQxID0gbmV3IEFycmF5KDkpOyAvLyBzdWJ0YWJsZVBhcnNlcnNbMF0gaXMgdW51c2VkXG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jU1NcbnN1YnRhYmxlUGFyc2VycyQxWzFdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAxKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKHN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgZGVsdGFHbHlwaElkOiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIHN1YnN0aXR1dGU6IHRoaXMucGFyc2VPZmZzZXQxNkxpc3QoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IGxvb2t1cCB0eXBlIDEgZm9ybWF0IG11c3QgYmUgMSBvciAyLidcbiAgICApO1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNNU1xuc3VidGFibGVQYXJzZXJzJDFbMl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDIoKSB7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KFxuICAgICAgICBzdWJzdEZvcm1hdCA9PT0gMSxcbiAgICAgICAgJ0dTVUIgTXVsdGlwbGUgU3Vic3RpdHV0aW9uIFN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMSdcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgIHNlcXVlbmNlczogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKCksXG4gICAgfTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jQVNcbnN1YnRhYmxlUGFyc2VycyQxWzNdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAzKCkge1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChcbiAgICAgICAgc3Vic3RGb3JtYXQgPT09IDEsXG4gICAgICAgICdHU1VCIEFsdGVybmF0ZSBTdWJzdGl0dXRpb24gU3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJ1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgYWx0ZXJuYXRlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKCksXG4gICAgfTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jTFNcbnN1YnRhYmxlUGFyc2VycyQxWzRdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA0KCkge1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChcbiAgICAgICAgc3Vic3RGb3JtYXQgPT09IDEsXG4gICAgICAgICdHU1VCIGxpZ2F0dXJlIHRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMSdcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgIGxpZ2F0dXJlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGlnR2x5cGg6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlVVNob3J0KCkgLSAxKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgIH07XG59O1xuXG52YXIgbG9va3VwUmVjb3JkRGVzYyA9IHtcbiAgICBzZXF1ZW5jZUluZGV4OiBQYXJzZXIudVNob3J0LFxuICAgIGxvb2t1cExpc3RJbmRleDogUGFyc2VyLnVTaG9ydCxcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jQ1NGXG5zdWJ0YWJsZVBhcnNlcnMkMVs1XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNSgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXG4gICAgaWYgKHN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIHJ1bGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdChnbHlwaENvdW50IC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZERlc2NcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBjbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgIGNsYXNzU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGhDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3RDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzOiB0aGlzLnBhcnNlVVNob3J0TGlzdChnbHlwaENvdW50IC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZERlc2NcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMykge1xuICAgICAgICB2YXIgZ2x5cGhDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHN1YnN0Q291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgICAgICBjb3ZlcmFnZXM6IHRoaXMucGFyc2VMaXN0KFxuICAgICAgICAgICAgICAgIGdseXBoQ291bnQsXG4gICAgICAgICAgICAgICAgUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KHN1YnN0Q291bnQsIGxvb2t1cFJlY29yZERlc2MpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogbG9va3VwIHR5cGUgNSBmb3JtYXQgbXVzdCBiZSAxLCAyIG9yIDMuJ1xuICAgICk7XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0NDXG5zdWJ0YWJsZVBhcnNlcnMkMVs2XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIGNoYWluUnVsZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja3RyYWNrOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogdGhpcy5wYXJzZVVTaG9ydExpc3QodGhpcy5wYXJzZVNob3J0KCkgLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va2FoZWFkOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChsb29rdXBSZWNvcmREZXNjKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIGJhY2t0cmFja0NsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICAgICAgaW5wdXRDbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgIGxvb2thaGVhZENsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICAgICAgY2hhaW5DbGFzc1NldDogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYWNrdHJhY2s6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlU2hvcnQoKSAtIDEpLFxuICAgICAgICAgICAgICAgICAgICBsb29rYWhlYWQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KGxvb2t1cFJlY29yZERlc2MpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMyxcbiAgICAgICAgICAgIGJhY2t0cmFja0NvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgICAgIGlucHV0Q292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICAgICAgbG9va2FoZWFkQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QobG9va3VwUmVjb3JkRGVzYyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBsb29rdXAgdHlwZSA2IGZvcm1hdCBtdXN0IGJlIDEsIDIgb3IgMy4nXG4gICAgKTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jRVNcbnN1YnRhYmxlUGFyc2VycyQxWzddID0gZnVuY3Rpb24gcGFyc2VMb29rdXA3KCkge1xuICAgIC8vIEV4dGVuc2lvbiBTdWJzdGl0dXRpb24gc3VidGFibGVcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoXG4gICAgICAgIHN1YnN0Rm9ybWF0ID09PSAxLFxuICAgICAgICAnR1NVQiBFeHRlbnNpb24gU3Vic3RpdHV0aW9uIHN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMSdcbiAgICApO1xuICAgIHZhciBleHRlbnNpb25Mb29rdXBUeXBlID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBleHRlbnNpb25QYXJzZXIgPSBuZXcgUGFyc2VyKFxuICAgICAgICB0aGlzLmRhdGEsXG4gICAgICAgIHRoaXMub2Zmc2V0ICsgdGhpcy5wYXJzZVVMb25nKClcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICBsb29rdXBUeXBlOiBleHRlbnNpb25Mb29rdXBUeXBlLFxuICAgICAgICBleHRlbnNpb246IHN1YnRhYmxlUGFyc2VycyQxW2V4dGVuc2lvbkxvb2t1cFR5cGVdLmNhbGwoZXh0ZW5zaW9uUGFyc2VyKSxcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNSQ0NTXG5zdWJ0YWJsZVBhcnNlcnMkMVs4XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwOCgpIHtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoXG4gICAgICAgIHN1YnN0Rm9ybWF0ID09PSAxLFxuICAgICAgICAnR1NVQiBSZXZlcnNlIENoYWluaW5nIENvbnRleHR1YWwgU2luZ2xlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBiYWNrdHJhY2tDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgIGxvb2thaGVhZENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgc3Vic3RpdHV0ZXM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgfTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3N1Yi5odG1cbmZ1bmN0aW9uIHBhcnNlR3N1YlRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIHZhciBwID0gbmV3IFBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKDEpO1xuICAgIGNoZWNrLmFyZ3VtZW50KFxuICAgICAgICB0YWJsZVZlcnNpb24gPT09IDEgfHwgdGFibGVWZXJzaW9uID09PSAxLjEsXG4gICAgICAgICdVbnN1cHBvcnRlZCBHU1VCIHRhYmxlIHZlcnNpb24uJ1xuICAgICk7XG4gICAgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuICAgICAgICAgICAgc2NyaXB0czogcC5wYXJzZVNjcmlwdExpc3QoKSxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBwLnBhcnNlRmVhdHVyZUxpc3QoKSxcbiAgICAgICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycyQxKSxcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuICAgICAgICAgICAgc2NyaXB0czogcC5wYXJzZVNjcmlwdExpc3QoKSxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBwLnBhcnNlRmVhdHVyZUxpc3QoKSxcbiAgICAgICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycyQxKSxcbiAgICAgICAgICAgIHZhcmlhdGlvbnM6IHAucGFyc2VGZWF0dXJlVmFyaWF0aW9uc0xpc3QoKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbnZhciBnc3ViID0geyBwYXJzZTogcGFyc2VHc3ViVGFibGUgfTtcblxuLy8gVGhlIGBoZWFkYCB0YWJsZSBjb250YWlucyBnbG9iYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGZvbnQuXG5cbi8vIFBhcnNlIHRoZSBoZWFkZXIgYGhlYWRgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhlYWRUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoZWFkID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoZWFkLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhlYWQuZm9udFJldmlzaW9uID0gTWF0aC5yb3VuZChwLnBhcnNlRml4ZWQoKSAqIDEwMDApIC8gMTAwMDtcbiAgICBoZWFkLmNoZWNrU3VtQWRqdXN0bWVudCA9IHAucGFyc2VVTG9uZygpO1xuICAgIGhlYWQubWFnaWNOdW1iZXIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudChcbiAgICAgICAgaGVhZC5tYWdpY051bWJlciA9PT0gMHg1ZjBmM2NmNSxcbiAgICAgICAgJ0ZvbnQgaGVhZGVyIGhhcyB3cm9uZyBtYWdpYyBudW1iZXIuJ1xuICAgICk7XG4gICAgaGVhZC5mbGFncyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLnVuaXRzUGVyRW0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGVhZC5jcmVhdGVkID0gcC5wYXJzZUxvbmdEYXRlVGltZSgpO1xuICAgIGhlYWQubW9kaWZpZWQgPSBwLnBhcnNlTG9uZ0RhdGVUaW1lKCk7XG4gICAgaGVhZC54TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC55TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC54TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC55TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC5tYWNTdHlsZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmxvd2VzdFJlY1BQRU0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGVhZC5mb250RGlyZWN0aW9uSGludCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQuaW5kZXhUb0xvY0Zvcm1hdCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQuZ2x5cGhEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcmV0dXJuIGhlYWQ7XG59XG5cbnZhciBoZWFkID0geyBwYXJzZTogcGFyc2VIZWFkVGFibGUgfTtcblxuLy8gVGhlIGBoaGVhYCB0YWJsZSBjb250YWlucyBpbmZvcm1hdGlvbiBmb3IgaG9yaXpvbnRhbCBsYXlvdXQuXG5cbi8vIFBhcnNlIHRoZSBob3Jpem9udGFsIGhlYWRlciBgaGhlYWAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlSGhlYVRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIGhoZWEgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGhoZWEudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgaGhlYS5hc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuZGVzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5saW5lR2FwID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5hZHZhbmNlV2lkdGhNYXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGhlYS5taW5MZWZ0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLm1pblJpZ2h0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLnhNYXhFeHRlbnQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmNhcmV0U2xvcGVSaXNlID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5jYXJldFNsb3BlUnVuID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5jYXJldE9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHAucmVsYXRpdmVPZmZzZXQgKz0gODtcbiAgICBoaGVhLm1ldHJpY0RhdGFGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLm51bWJlck9mSE1ldHJpY3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgcmV0dXJuIGhoZWE7XG59XG5cbnZhciBoaGVhID0geyBwYXJzZTogcGFyc2VIaGVhVGFibGUgfTtcblxuLy8gVGhlIGBobXR4YCB0YWJsZSBjb250YWlucyB0aGUgaG9yaXpvbnRhbCBtZXRyaWNzIGZvciBhbGwgZ2x5cGhzLlxuXG5mdW5jdGlvbiBwYXJzZUhtdHhUYWJsZUFsbChkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzLCBnbHlwaHMpIHtcbiAgICB2YXIgYWR2YW5jZVdpZHRoO1xuICAgIHZhciBsZWZ0U2lkZUJlYXJpbmc7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUdseXBoczsgaSArPSAxKSB7XG4gICAgICAgIC8vIElmIHRoZSBmb250IGlzIG1vbm9zcGFjZWQsIG9ubHkgb25lIGVudHJ5IGlzIG5lZWRlZC4gVGhpcyBsYXN0IGVudHJ5IGFwcGxpZXMgdG8gYWxsIHN1YnNlcXVlbnQgZ2x5cGhzLlxuICAgICAgICBpZiAoaSA8IG51bU1ldHJpY3MpIHtcbiAgICAgICAgICAgIGFkdmFuY2VXaWR0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGxlZnRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzLmdldChpKTtcbiAgICAgICAgZ2x5cGguYWR2YW5jZVdpZHRoID0gYWR2YW5jZVdpZHRoO1xuICAgICAgICBnbHlwaC5sZWZ0U2lkZUJlYXJpbmcgPSBsZWZ0U2lkZUJlYXJpbmc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUhtdHhUYWJsZU9uTG93TWVtb3J5KGZvbnQsIGRhdGEsIHN0YXJ0LCBudW1NZXRyaWNzLCBudW1HbHlwaHMpIHtcbiAgICBmb250Ll9obXR4VGFibGVEYXRhID0ge307XG5cbiAgICB2YXIgYWR2YW5jZVdpZHRoO1xuICAgIHZhciBsZWZ0U2lkZUJlYXJpbmc7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUdseXBoczsgaSArPSAxKSB7XG4gICAgICAgIC8vIElmIHRoZSBmb250IGlzIG1vbm9zcGFjZWQsIG9ubHkgb25lIGVudHJ5IGlzIG5lZWRlZC4gVGhpcyBsYXN0IGVudHJ5IGFwcGxpZXMgdG8gYWxsIHN1YnNlcXVlbnQgZ2x5cGhzLlxuICAgICAgICBpZiAoaSA8IG51bU1ldHJpY3MpIHtcbiAgICAgICAgICAgIGFkdmFuY2VXaWR0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGxlZnRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9udC5faG10eFRhYmxlRGF0YVtpXSA9IHtcbiAgICAgICAgICAgIGFkdmFuY2VXaWR0aDogYWR2YW5jZVdpZHRoLFxuICAgICAgICAgICAgbGVmdFNpZGVCZWFyaW5nOiBsZWZ0U2lkZUJlYXJpbmcsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vLyBQYXJzZSB0aGUgYGhtdHhgIHRhYmxlLCB3aGljaCBjb250YWlucyB0aGUgaG9yaXpvbnRhbCBtZXRyaWNzIGZvciBhbGwgZ2x5cGhzLlxuLy8gVGhpcyBmdW5jdGlvbiBhdWdtZW50cyB0aGUgZ2x5cGggYXJyYXksIGFkZGluZyB0aGUgYWR2YW5jZVdpZHRoIGFuZCBsZWZ0U2lkZUJlYXJpbmcgdG8gZWFjaCBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlSG10eFRhYmxlKGZvbnQsIGRhdGEsIHN0YXJ0LCBudW1NZXRyaWNzLCBudW1HbHlwaHMsIGdseXBocywgb3B0KSB7XG4gICAgaWYgKG9wdC5sb3dNZW1vcnkpXG4gICAgICAgIHsgcGFyc2VIbXR4VGFibGVPbkxvd01lbW9yeShmb250LCBkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzKTsgfVxuICAgIGVsc2UgeyBwYXJzZUhtdHhUYWJsZUFsbChkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzLCBnbHlwaHMpOyB9XG59XG5cbnZhciBobXR4ID0geyBwYXJzZTogcGFyc2VIbXR4VGFibGUgfTtcblxuLy8gVGhlIGBrZXJuYCB0YWJsZSBjb250YWlucyBrZXJuaW5nIHBhaXJzLlxuXG5mdW5jdGlvbiBwYXJzZVdpbmRvd3NLZXJuVGFibGUocCkge1xuICAgIHZhciBwYWlycyA9IHt9O1xuICAgIC8vIFNraXAgblRhYmxlcy5cbiAgICBwLnNraXAoJ3VTaG9ydCcpO1xuICAgIHZhciBzdWJ0YWJsZVZlcnNpb24gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoc3VidGFibGVWZXJzaW9uID09PSAwLCAnVW5zdXBwb3J0ZWQga2VybiBzdWItdGFibGUgdmVyc2lvbi4nKTtcbiAgICAvLyBTa2lwIHN1YnRhYmxlTGVuZ3RoLCBzdWJ0YWJsZUNvdmVyYWdlXG4gICAgcC5za2lwKCd1U2hvcnQnLCAyKTtcbiAgICB2YXIgblBhaXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYWlyczsgaSArPSAxKSB7XG4gICAgICAgIHZhciBsZWZ0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciByaWdodEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgdmFsdWUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgcGFpcnNbbGVmdEluZGV4ICsgJywnICsgcmlnaHRJbmRleF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1hY0tlcm5UYWJsZShwKSB7XG4gICAgdmFyIHBhaXJzID0ge307XG4gICAgLy8gVGhlIE1hYyBrZXJuIHRhYmxlIHN0b3JlcyB0aGUgdmVyc2lvbiBhcyBhIGZpeGVkICgzMiBiaXRzKSBidXQgd2Ugb25seSBsb2FkZWQgdGhlIGZpcnN0IDE2IGJpdHMuXG4gICAgLy8gU2tpcCB0aGUgcmVzdC5cbiAgICBwLnNraXAoJ3VTaG9ydCcpO1xuICAgIHZhciBuVGFibGVzID0gcC5wYXJzZVVMb25nKCk7XG4gICAgLy9jaGVjay5hcmd1bWVudChuVGFibGVzID09PSAxLCAnT25seSAxIHN1YnRhYmxlIGlzIHN1cHBvcnRlZCAoZ290ICcgKyBuVGFibGVzICsgJykuJyk7XG4gICAgaWYgKG5UYWJsZXMgPiAxKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignT25seSB0aGUgZmlyc3Qga2VybiBzdWJ0YWJsZSBpcyBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIHAuc2tpcCgndUxvbmcnKTtcbiAgICB2YXIgY292ZXJhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHN1YnRhYmxlVmVyc2lvbiA9IGNvdmVyYWdlICYgMHhGRjtcbiAgICBwLnNraXAoJ3VTaG9ydCcpO1xuICAgIGlmIChzdWJ0YWJsZVZlcnNpb24gPT09IDApIHtcbiAgICAgICAgdmFyIG5QYWlycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgLy8gU2tpcCBzZWFyY2hSYW5nZSwgZW50cnlTZWxlY3RvciwgcmFuZ2VTaGlmdC5cbiAgICAgICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFpcnM7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGxlZnRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHZhciByaWdodEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICBwYWlyc1tsZWZ0SW5kZXggKyAnLCcgKyByaWdodEluZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cblxuLy8gUGFyc2UgdGhlIGBrZXJuYCB0YWJsZSB3aGljaCBjb250YWlucyBrZXJuaW5nIHBhaXJzLlxuZnVuY3Rpb24gcGFyc2VLZXJuVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VXaW5kb3dzS2VyblRhYmxlKHApO1xuICAgIH0gZWxzZSBpZiAodGFibGVWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU1hY0tlcm5UYWJsZShwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtlcm4gdGFibGUgdmVyc2lvbiAoJyArIHRhYmxlVmVyc2lvbiArICcpLicpO1xuICAgIH1cbn1cblxudmFyIGtlcm4gPSB7IHBhcnNlOiBwYXJzZUtlcm5UYWJsZSB9O1xuXG4vLyBUaGUgYGx0YWdgIHRhYmxlIHN0b3JlcyBJRVRGIEJDUC00NyBsYW5ndWFnZSB0YWdzLiBJdCBhbGxvd3Mgc3VwcG9ydGluZ1xuXG5mdW5jdGlvbiBwYXJzZUx0YWdUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMSwgJ1Vuc3VwcG9ydGVkIGx0YWcgdGFibGUgdmVyc2lvbi4nKTtcbiAgICAvLyBUaGUgJ2x0YWcnIHNwZWNpZmljYXRpb24gZG9lcyBub3QgZGVmaW5lIGFueSBmbGFnczsgc2tpcCB0aGUgZmllbGQuXG4gICAgcC5za2lwKCd1TG9uZycsIDEpO1xuICAgIHZhciBudW1UYWdzID0gcC5wYXJzZVVMb25nKCk7XG5cbiAgICB2YXIgdGFncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGFnczsgaSsrKSB7XG4gICAgICAgIHZhciB0YWcgPSAnJztcbiAgICAgICAgdmFyIG9mZnNldCA9IHN0YXJ0ICsgcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBmb3IgKHZhciBqID0gb2Zmc2V0OyBqIDwgb2Zmc2V0ICsgbGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHRhZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGEuZ2V0SW50OChqKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0YWdzLnB1c2godGFnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFncztcbn1cblxudmFyIGx0YWcgPSB7IHBhcnNlOiBwYXJzZUx0YWdUYWJsZSB9O1xuXG4vLyBUaGUgYGxvY2FgIHRhYmxlIHN0b3JlcyB0aGUgb2Zmc2V0cyB0byB0aGUgbG9jYXRpb25zIG9mIHRoZSBnbHlwaHMgaW4gdGhlIGZvbnQuXG5cbi8vIFBhcnNlIHRoZSBgbG9jYWAgdGFibGUuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBvZmZzZXRzIHRvIHRoZSBsb2NhdGlvbnMgb2YgdGhlIGdseXBocyBpbiB0aGUgZm9udCxcbi8vIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGdseXBoRGF0YSB0YWJsZS5cbi8vIFRoZSBudW1iZXIgb2YgZ2x5cGhzIHN0b3JlZCBpbiB0aGUgYGxvY2FgIHRhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgYG1heHBgIHRhYmxlICh1bmRlciBudW1HbHlwaHMpXG4vLyBUaGUgbG9jYSB0YWJsZSBoYXMgdHdvIHZlcnNpb25zOiBhIHNob3J0IHZlcnNpb24gd2hlcmUgb2Zmc2V0cyBhcmUgc3RvcmVkIGFzIHVTaG9ydHMsIGFuZCBhIGxvbmdcbi8vIHZlcnNpb24gd2hlcmUgb2Zmc2V0cyBhcmUgc3RvcmVkIGFzIHVMb25ncy4gVGhlIGBoZWFkYCB0YWJsZSBzcGVjaWZpZXMgd2hpY2ggdmVyc2lvbiB0byB1c2Vcbi8vICh1bmRlciBpbmRleFRvTG9jRm9ybWF0KS5cbmZ1bmN0aW9uIHBhcnNlTG9jYVRhYmxlKGRhdGEsIHN0YXJ0LCBudW1HbHlwaHMsIHNob3J0VmVyc2lvbikge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHBhcnNlRm4gPSBzaG9ydFZlcnNpb24gPyBwLnBhcnNlVVNob3J0IDogcC5wYXJzZVVMb25nO1xuICAgIC8vIFRoZXJlIGlzIGFuIGV4dHJhIGVudHJ5IGFmdGVyIHRoZSBsYXN0IGluZGV4IGVsZW1lbnQgdG8gY29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBsYXN0IGdseXBoLlxuICAgIC8vIFRoYXQncyB3aHkgd2UgdXNlIG51bUdseXBocyArIDEuXG4gICAgdmFyIGdseXBoT2Zmc2V0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtR2x5cGhzICsgMTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaE9mZnNldCA9IHBhcnNlRm4uY2FsbChwKTtcbiAgICAgICAgaWYgKHNob3J0VmVyc2lvbikge1xuICAgICAgICAgICAgLy8gVGhlIHNob3J0IHRhYmxlIHZlcnNpb24gc3RvcmVzIHRoZSBhY3R1YWwgb2Zmc2V0IGRpdmlkZWQgYnkgMi5cbiAgICAgICAgICAgIGdseXBoT2Zmc2V0ICo9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBnbHlwaE9mZnNldHMucHVzaChnbHlwaE9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoT2Zmc2V0cztcbn1cblxudmFyIGxvY2EgPSB7IHBhcnNlOiBwYXJzZUxvY2FUYWJsZSB9O1xuXG4vLyBUaGUgYG1heHBgIHRhYmxlIGVzdGFibGlzaGVzIHRoZSBtZW1vcnkgcmVxdWlyZW1lbnRzIGZvciB0aGUgZm9udC5cblxuLy8gUGFyc2UgdGhlIG1heGltdW0gcHJvZmlsZSBgbWF4cGAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZU1heHBUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBtYXhwID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBtYXhwLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIG1heHAubnVtR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChtYXhwLnZlcnNpb24gPT09IDEuMCkge1xuICAgICAgICBtYXhwLm1heFBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb250b3VycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb3NpdGVQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9zaXRlQ29udG91cnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Wm9uZXMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4VHdpbGlnaHRQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U3RvcmFnZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhGdW5jdGlvbkRlZnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4SW5zdHJ1Y3Rpb25EZWZzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFN0YWNrRWxlbWVudHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvbmVudEVsZW1lbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvbmVudERlcHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXhwO1xufVxuXG52YXIgbWF4cCA9IHsgcGFyc2U6IHBhcnNlTWF4cFRhYmxlIH07XG5cbi8vIFRoZSBgT1MvMmAgdGFibGUgY29udGFpbnMgbWV0cmljcyByZXF1aXJlZCBpbiBPcGVuVHlwZSBmb250cy5cblxuLy8gUGFyc2UgdGhlIE9TLzIgYW5kIFdpbmRvd3MgbWV0cmljcyBgT1MvMmAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlT1MyVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgb3MyID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBvczIudmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIueEF2Z0NoYXJXaWR0aCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi51c1dlaWdodENsYXNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c1dpZHRoQ2xhc3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLmZzVHlwZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFhTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRZU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WE9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WU9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRYU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRZU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRYT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFlPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN0cmlrZW91dFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN0cmlrZW91dFBvc2l0aW9uID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNGYW1pbHlDbGFzcyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi5wYW5vc2UgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgb3MyLnBhbm9zZVtpXSA9IHAucGFyc2VCeXRlKCk7XG4gICAgfVxuXG4gICAgb3MyLnVsVW5pY29kZVJhbmdlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi51bFVuaWNvZGVSYW5nZTIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIudWxVbmljb2RlUmFuZ2UzID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlNCA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi5hY2hWZW5kSUQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICBwLnBhcnNlQnl0ZSgpLFxuICAgICAgICBwLnBhcnNlQnl0ZSgpLFxuICAgICAgICBwLnBhcnNlQnl0ZSgpLFxuICAgICAgICBwLnBhcnNlQnl0ZSgpXG4gICAgKTtcbiAgICBvczIuZnNTZWxlY3Rpb24gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzRmlyc3RDaGFySW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzTGFzdENoYXJJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIuc1R5cG9Bc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi5zVHlwb0Rlc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi5zVHlwb0xpbmVHYXAgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIudXNXaW5Bc2NlbnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzV2luRGVzY2VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAob3MyLnZlcnNpb24gPj0gMSkge1xuICAgICAgICBvczIudWxDb2RlUGFnZVJhbmdlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICBvczIudWxDb2RlUGFnZVJhbmdlMiA9IHAucGFyc2VVTG9uZygpO1xuICAgIH1cblxuICAgIGlmIChvczIudmVyc2lvbiA+PSAyKSB7XG4gICAgICAgIG9zMi5zeEhlaWdodCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBvczIuc0NhcEhlaWdodCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBvczIudXNEZWZhdWx0Q2hhciA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgb3MyLnVzQnJlYWtDaGFyID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBvczIudXNNYXhDb250ZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIH1cblxuICAgIHJldHVybiBvczI7XG59XG5cbnZhciBvczIgPSB7IHBhcnNlOiBwYXJzZU9TMlRhYmxlIH07XG5cbi8vIFRoZSBgcG9zdGAgdGFibGUgc3RvcmVzIGFkZGl0aW9uYWwgUG9zdFNjcmlwdCBpbmZvcm1hdGlvbiwgc3VjaCBhcyBnbHlwaCBuYW1lcy5cblxuLy8gUGFyc2UgdGhlIFBvc3RTY3JpcHQgYHBvc3RgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZVBvc3RUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwb3N0ID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBwb3N0LnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIHBvc3QuaXRhbGljQW5nbGUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBwb3N0LnVuZGVybGluZVBvc2l0aW9uID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcG9zdC51bmRlcmxpbmVUaGlja25lc3MgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwb3N0LmlzRml4ZWRQaXRjaCA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWluTWVtVHlwZTQyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5tYXhNZW1UeXBlNDIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1pbk1lbVR5cGUxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5tYXhNZW1UeXBlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubmFtZXMgPSBbXTtcbiAgICBzd2l0Y2ggKHBvc3QudmVyc2lvbikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcG9zdC5udW1iZXJPZkdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHBvc3QuZ2x5cGhOYW1lSW5kZXggPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyLjU6XG4gICAgICAgICAgICBwb3N0Lm51bWJlck9mR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgcG9zdC5vZmZzZXQgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpJDErKykge1xuICAgICAgICAgICAgICAgIHBvc3Qub2Zmc2V0W2kkMV0gPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBwb3N0O1xufVxuXG52YXIgcG9zdCA9IHsgcGFyc2U6IHBhcnNlUG9zdFRhYmxlIH07XG5cbi8vIERhdGEgdHlwZXMgdXNlZCBpbiB0aGUgT3BlblR5cGUgZm9udCBmaWxlLlxuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLmRlY29kZVxuICogQGNsYXNzXG4gKi9cbnZhciBkZWNvZGUgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gbnVtQnl0ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmRlY29kZS5VVEY4ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBudW1CeXRlcykge1xuICAgIHZhciBjb2RlUG9pbnRzID0gW107XG4gICAgdmFyIG51bUNoYXJzID0gbnVtQnl0ZXM7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1DaGFyczsgaisrLCBvZmZzZXQgKz0gMSkge1xuICAgICAgICBjb2RlUG9pbnRzW2pdID0gZGF0YS5nZXRVaW50OChvZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVQb2ludHMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gbnVtQnl0ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmRlY29kZS5VVEYxNiA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbnVtQnl0ZXMpIHtcbiAgICB2YXIgY29kZVBvaW50cyA9IFtdO1xuICAgIHZhciBudW1DaGFycyA9IG51bUJ5dGVzIC8gMjtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUNoYXJzOyBqKyssIG9mZnNldCArPSAyKSB7XG4gICAgICAgIGNvZGVQb2ludHNbal0gPSBkYXRhLmdldFVpbnQxNihvZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVQb2ludHMpO1xufTtcblxuLy8gRGF0YSBmb3IgY29udmVydGluZyBvbGQgZWlnaHQtYml0IE1hY2ludG9zaCBlbmNvZGluZ3MgdG8gVW5pY29kZS5cbi8vIFRoaXMgcmVwcmVzZW50YXRpb24gaXMgb3B0aW1pemVkIGZvciBkZWNvZGluZzsgZW5jb2RpbmcgaXMgc2xvd2VyXG4vLyBhbmQgbmVlZHMgbW9yZSBtZW1vcnkuIFRoZSBhc3N1bXB0aW9uIGlzIHRoYXQgYWxsIG9wZW50eXBlLmpzIHVzZXJzXG4vLyB3YW50IHRvIG9wZW4gZm9udHMsIGJ1dCBzYXZpbmcgYSBmb250IHdpbGwgYmUgY29tcGFyYXRpdmVseSByYXJlXG4vLyBzbyBpdCBjYW4gYmUgbW9yZSBleHBlbnNpdmUuIEtleWVkIGJ5IElBTkEgY2hhcmFjdGVyIHNldCBuYW1lLlxuLy9cbi8vIFB5dGhvbiBzY3JpcHQgZm9yIGdlbmVyYXRpbmcgdGhlc2Ugc3RyaW5nczpcbi8vXG4vLyAgICAgcyA9IHUnJy5qb2luKFtjaHIoYykuZGVjb2RlKCdtYWNfZ3JlZWsnKSBmb3IgYyBpbiByYW5nZSgxMjgsIDI1NildKVxuLy8gICAgIHByaW50KHMuZW5jb2RlKCd1dGYtOCcpKVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZWlnaHRCaXRNYWNFbmNvZGluZ3MgPSB7XG4gICAgJ3gtbWFjLWNyb2F0aWFuJzogIC8vIFB5dGhvbjogJ21hY19jcm9hdGlhbidcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuxaDihKLCtMKo4omgxb3DmOKInsKx4omk4oml4oiGwrXiiILiiJHiiI/FoeKIq8KqwrrOqcW+w7gnICtcbiAgICAnwr/CocKs4oiaxpLiiYjEhsKrxIzigKbCoMOAw4PDlcWSxZPEkOKAlOKAnOKAneKAmOKAmcO34peK76O/wqnigYTigqzigLnigLrDhsK74oCTwrfigJrigJ7igLDDgsSHw4HEjcOIw43DjsOPw4zDk8OUxJHDksOaw5vDmcSxy4bLnMKvz4DDi8uawrjDisOmy4cnLFxuICAgICd4LW1hYy1jeXJpbGxpYyc6ICAvLyBQeXRob246ICdtYWNfY3lyaWxsaWMnXG4gICAgJ9CQ0JHQktCT0JTQldCW0JfQmNCZ0JrQm9Cc0J3QntCf0KDQodCi0KPQpNCl0KbQp9Co0KnQqtCr0KzQrdCu0K/igKDCsNKQwqPCp+KAosK20IbCrsKp4oSi0ILRkuKJoNCD0ZPiiJ7CseKJpOKJpdGWwrXSkdCI0ITRlNCH0ZfQidGZ0IrRmicgK1xuICAgICfRmNCFwqziiJrGkuKJiOKIhsKrwrvigKbCoNCL0ZvQjNGc0ZXigJPigJTigJzigJ3igJjigJnDt+KAntCO0Z7Qj9Gf4oSW0IHRkdGP0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/RgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y4nLFxuICAgICd4LW1hYy1nYWVsaWMnOiAvLyBodHRwOi8vdW5pY29kZS5vcmcvUHVibGljL01BUFBJTkdTL1ZFTkRPUlMvQVBQTEUvR0FFTElDLlRYVFxuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4biCwrHiiaTiiaXhuIPEisSL4biK4biL4bie4bifxKDEoeG5gMOmw7gnICtcbiAgICAn4bmB4bmW4bmXybzGksW/4bmgwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmeG5oeG6m8O/xbjhuarigqzigLnigLrFtsW34bmrwrfhu7Lhu7PigYrDgsOKw4HDi8OIw43DjsOPw4zDk8OU4pmjw5LDmsObw5nEscOdw73FtMW14bqE4bqF4bqA4bqB4bqC4bqDJyxcbiAgICAneC1tYWMtZ3JlZWsnOiAgLy8gUHl0aG9uOiAnbWFjX2dyZWVrJ1xuICAgICfDhMK5wrLDicKzw5bDnM6Fw6DDosOkzoTCqMOnw6nDqMOqw6vCo+KEosOuw6/igKLCveKAsMO0w7bCpuKCrMO5w7vDvOKAoM6TzpTOmM6bzp7OoMOfwq7Cqc6jzqrCp+KJoMKwwrfOkcKx4omk4omlwqXOks6VzpbOl86ZzprOnM6mzqvOqM6pJyArXG4gICAgJ86szp3CrM6fzqHiiYjOpMKrwrvigKbCoM6lzqfOhs6IxZPigJPigJXigJzigJ3igJjigJnDt86JzorOjM6Ozq3Ors6vz4zOj8+NzrHOss+IzrTOtc+GzrPOt865zr7Ous67zrzOvc6/z4DPjs+Bz4PPhM64z4nPgs+Hz4XOts+Kz4vOkM6wXFx1MDBBRCcsXG4gICAgJ3gtbWFjLWljZWxhbmRpYyc6ICAvLyBQeXRob246ICdtYWNfaWNlbGFuZCdcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvMOdwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnDpsO4JyArXG4gICAgJ8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhOKCrMOQw7DDnsO+w73Ct+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4cnLFxuICAgICd4LW1hYy1pbnVpdCc6IC8vIGh0dHA6Ly91bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9BUFBMRS9JTlVJVC5UWFRcbiAgICAn4ZCD4ZCE4ZCF4ZCG4ZCK4ZCL4ZCx4ZCy4ZCz4ZC04ZC44ZC54ZGJ4ZGO4ZGP4ZGQ4ZGR4ZGV4ZGW4ZGm4ZGt4ZGu4ZGv4ZGw4ZGy4ZGz4ZKD4ZKL4ZKM4ZKN4ZKO4ZKQ4ZKRwrDhkqHhkqXhkqbigKLCtuGSp8KuwqnihKLhkqjhkqrhkqvhkrvhk4Lhk4Phk4Thk4Xhk4fhk4jhk5Dhk6/hk7Dhk7Hhk7Lhk7Thk7XhlIXhk5Xhk5bhk5cnICtcbiAgICAn4ZOY4ZOa4ZOb4ZOq4ZSo4ZSp4ZSq4ZSr4ZSt4oCmwqDhlK7hlL7hlZXhlZbhlZfigJPigJTigJzigJ3igJjigJnhlZjhlZnhlZrhlZ3hlYbhlYfhlYjhlYnhlYvhlYzhlZDhlb/hloDhloHhloLhloPhloThloXhlo/hlpDhlpHhlpLhlpPhlpThlpXhmbHhmbLhmbPhmbThmbXhmbbhlpbhlqDhlqHhlqLhlqPhlqThlqXhlqbhlbzFgcWCJyxcbiAgICAneC1tYWMtY2UnOiAgLy8gUHl0aG9uOiAnbWFjX2xhdGluMidcbiAgICAnw4TEgMSBw4nEhMOWw5zDocSFxIzDpMSNxIbEh8OpxbnFusSOw63Ej8SSxJPElsOzxJfDtMO2w7XDusSaxJvDvOKAoMKwxJjCo8Kn4oCiwrbDn8KuwqnihKLEmcKo4omgxKPErsSvxKriiaTiiaXEq8S24oiC4oiRxYLEu8S8xL3EvsS5xLrFhScgK1xuICAgICfFhsWDwqziiJrFhMWH4oiGwqvCu+KApsKgxYjFkMOVxZHFjOKAk+KAlOKAnOKAneKAmOKAmcO34peKxY3FlMWVxZjigLnigLrFmcWWxZfFoOKAmuKAnsWhxZrFm8OBxaTFpcONxb3FvsWqw5PDlMWrxa7DmsWvxbDFscWyxbPDncO9xLfFu8WBxbzEosuHJyxcbiAgICBtYWNpbnRvc2g6ICAvLyBQeXRob246ICdtYWNfcm9tYW4nXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrOqcOmw7gnICtcbiAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGE4oKs4oC54oC676yB76yC4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHJyxcbiAgICAneC1tYWMtcm9tYW5pYW4nOiAgLy8gUHl0aG9uOiAnbWFjX3JvbWFuaWFuJ1xuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDEgsiY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnEg8iZJyArXG4gICAgJ8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhOKCrOKAueKAusiayJvigKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4cnLFxuICAgICd4LW1hYy10dXJraXNoJzogIC8vIFB5dGhvbjogJ21hY190dXJraXNoJ1xuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnDpsO4JyArXG4gICAgJ8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuMSexJ/EsMSxxZ7Fn+KAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZ76Kgy4bLnMKvy5jLmcuawrjLncuby4cnXG59O1xuXG4vKipcbiAqIERlY29kZXMgYW4gb2xkLXN0eWxlIE1hY2ludG9zaCBzdHJpbmcuIFJldHVybnMgZWl0aGVyIGEgVW5pY29kZSBKYXZhU2NyaXB0XG4gKiBzdHJpbmcsIG9yICd1bmRlZmluZWQnIGlmIHRoZSBlbmNvZGluZyBpcyB1bnN1cHBvcnRlZC4gRm9yIGV4YW1wbGUsIHdlIGRvXG4gKiBub3Qgc3VwcG9ydCBDaGluZXNlLCBKYXBhbmVzZSBvciBLb3JlYW4gYmVjYXVzZSB0aGVzZSB3b3VsZCBuZWVkIGxhcmdlXG4gKiBtYXBwaW5nIHRhYmxlcy5cbiAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFWaWV3XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gZGF0YUxlbmd0aFxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5kZWNvZGUuTUFDU1RSSU5HID0gZnVuY3Rpb24oZGF0YVZpZXcsIG9mZnNldCwgZGF0YUxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgICB2YXIgdGFibGUgPSBlaWdodEJpdE1hY0VuY29kaW5nc1tlbmNvZGluZ107XG4gICAgaWYgKHRhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKTtcbiAgICAgICAgLy8gSW4gYWxsIGVpZ2h0LWJpdCBNYWMgZW5jb2RpbmdzLCB0aGUgY2hhcmFjdGVycyAweDAwLi4weDdGIGFyZVxuICAgICAgICAvLyBtYXBwZWQgdG8gVSswMDAwLi5VKzAwN0Y7IHdlIG9ubHkgbmVlZCB0byBsb29rIHVwIHRoZSBvdGhlcnMuXG4gICAgICAgIGlmIChjIDw9IDB4N0YpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRhYmxlW2MgJiAweDdGXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBUaGUgYEdQT1NgIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cblxuLy8gUGFyc2UgdGhlIG1ldGFkYXRhIGBtZXRhYCB0YWJsZS5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb250cy9UcnVlVHlwZS1SZWZlcmVuY2UtTWFudWFsL1JNMDYvQ2hhcDZtZXRhLmh0bWxcbmZ1bmN0aW9uIHBhcnNlTWV0YVRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxLCAnVW5zdXBwb3J0ZWQgTUVUQSB0YWJsZSB2ZXJzaW9uLicpO1xuICAgIHAucGFyc2VVTG9uZygpOyAvLyBmbGFncyAtIGN1cnJlbnRseSB1bnVzZWQgYW5kIHNldCB0byAwXG4gICAgcC5wYXJzZVVMb25nKCk7IC8vIHRhYmxlT2Zmc2V0XG4gICAgdmFyIG51bURhdGFNYXBzID0gcC5wYXJzZVVMb25nKCk7XG5cbiAgICB2YXIgdGFncyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRGF0YU1hcHM7IGkrKykge1xuICAgICAgICB2YXIgdGFnID0gcC5wYXJzZVRhZygpO1xuICAgICAgICB2YXIgZGF0YU9mZnNldCA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICB2YXIgZGF0YUxlbmd0aCA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICB2YXIgdGV4dCA9IGRlY29kZS5VVEY4KGRhdGEsIHN0YXJ0ICsgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCk7XG5cbiAgICAgICAgdGFnc1t0YWddID0gdGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3M7XG59XG5cbnZhciBtZXRhID0geyBwYXJzZTogcGFyc2VNZXRhVGFibGUgfTtcblxuLy8gb3BlbnR5cGUuanNcblxuLyoqXG4gKiBUaGUgb3BlbnR5cGUgbGlicmFyeS5cbiAqIEBuYW1lc3BhY2Ugb3BlbnR5cGVcbiAqL1xuXG4vLyBUYWJsZSBEaXJlY3RvcnkgRW50cmllcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAqIFBhcnNlcyBPcGVuVHlwZSB0YWJsZSBlbnRyaWVzLlxuICogQHBhcmFtICB7RGF0YVZpZXd9XG4gKiBAcGFyYW0gIHtOdW1iZXJ9XG4gKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VPcGVuVHlwZVRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpIHtcbiAgICB2YXIgdGFibGVFbnRyaWVzID0gW107XG4gICAgdmFyIHAgPSAxMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIHZhciB0YWcgPSBwYXJzZS5nZXRUYWcoZGF0YSwgcCk7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA0KTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA4KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyAxMik7XG4gICAgICAgIHRhYmxlRW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgICAgY2hlY2tzdW06IGNoZWNrc3VtLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHAgKz0gMTY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhYmxlRW50cmllcztcbn1cblxuLyoqXG4gKiBQYXJzZXMgV09GRiB0YWJsZSBlbnRyaWVzLlxuICogQHBhcmFtICB7RGF0YVZpZXd9XG4gKiBAcGFyYW0gIHtOdW1iZXJ9XG4gKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VXT0ZGVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcykge1xuICAgIHZhciB0YWJsZUVudHJpZXMgPSBbXTtcbiAgICB2YXIgcCA9IDQ0OyAvLyBvZmZzZXQgdG8gdGhlIGZpcnN0IHRhYmxlIGRpcmVjdG9yeSBlbnRyeS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIHZhciB0YWcgPSBwYXJzZS5nZXRUYWcoZGF0YSwgcCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgNCk7XG4gICAgICAgIHZhciBjb21wTGVuZ3RoID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDgpO1xuICAgICAgICB2YXIgb3JpZ0xlbmd0aCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyAxMik7XG4gICAgICAgIHZhciBjb21wcmVzc2lvbiA9ICh2b2lkIDApO1xuICAgICAgICBpZiAoY29tcExlbmd0aCA8IG9yaWdMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbXByZXNzaW9uID0gJ1dPRkYnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlRW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICBjb21wcmVzc2lvbjogY29tcHJlc3Npb24sXG4gICAgICAgICAgICBjb21wcmVzc2VkTGVuZ3RoOiBjb21wTGVuZ3RoLFxuICAgICAgICAgICAgbGVuZ3RoOiBvcmlnTGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgICAgcCArPSAyMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGVFbnRyaWVzO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFRhYmxlRGF0YVxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge0RhdGFWaWV3fSBkYXRhIC0gVGhlIERhdGFWaWV3XG4gKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0IC0gVGhlIGRhdGEgb2Zmc2V0LlxuICovXG5cbi8qKlxuICogQHBhcmFtICB7RGF0YVZpZXd9XG4gKiBAcGFyYW0gIHtPYmplY3R9XG4gKiBAcmV0dXJuIHtUYWJsZURhdGF9XG4gKi9cbmZ1bmN0aW9uIHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KSB7XG4gICAgaWYgKHRhYmxlRW50cnkuY29tcHJlc3Npb24gPT09ICdXT0ZGJykge1xuICAgICAgICB2YXIgaW5CdWZmZXIgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgIGRhdGEuYnVmZmVyLFxuICAgICAgICAgICAgdGFibGVFbnRyeS5vZmZzZXQgKyAyLFxuICAgICAgICAgICAgdGFibGVFbnRyeS5jb21wcmVzc2VkTGVuZ3RoIC0gMlxuICAgICAgICApO1xuICAgICAgICB2YXIgb3V0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodGFibGVFbnRyeS5sZW5ndGgpO1xuICAgICAgICBpbmZsYXRlU3luYyhpbkJ1ZmZlciwgb3V0QnVmZmVyKTtcbiAgICAgICAgaWYgKG91dEJ1ZmZlci5ieXRlTGVuZ3RoICE9PSB0YWJsZUVudHJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdEZWNvbXByZXNzaW9uIGVycm9yOiAnICtcbiAgICAgICAgICAgICAgICAgICAgdGFibGVFbnRyeS50YWcgK1xuICAgICAgICAgICAgICAgICAgICBcIiBkZWNvbXByZXNzZWQgbGVuZ3RoIGRvZXNuJ3QgbWF0Y2ggcmVjb3JkZWQgbGVuZ3RoXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhvdXRCdWZmZXIuYnVmZmVyLCAwKTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogdmlldywgb2Zmc2V0OiAwIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogZGF0YSwgb2Zmc2V0OiB0YWJsZUVudHJ5Lm9mZnNldCB9O1xuICAgIH1cbn1cblxuLy8gUHVibGljIEFQSSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFBhcnNlIHRoZSBPcGVuVHlwZSBmaWxlIGRhdGEgKGFzIGFuIEFycmF5QnVmZmVyKSBhbmQgcmV0dXJuIGEgRm9udCBvYmplY3QuXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGZvbnQgY291bGQgbm90IGJlIHBhcnNlZC5cbiAqIEBwYXJhbSAge0FycmF5QnVmZmVyfVxuICogQHBhcmFtICB7T2JqZWN0fSBvcHQgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5Gb250fVxuICovXG5mdW5jdGlvbiBwYXJzZUJ1ZmZlcihidWZmZXIsIG9wdCkge1xuICAgIG9wdCA9IG9wdCA9PT0gdW5kZWZpbmVkIHx8IG9wdCA9PT0gbnVsbCA/IHt9IDogb3B0O1xuXG4gICAgdmFyIGluZGV4VG9Mb2NGb3JtYXQ7XG5cbiAgICAvLyBTaW5jZSB0aGUgY29uc3RydWN0b3IgY2FuIGFsc28gYmUgY2FsbGVkIHRvIGNyZWF0ZSBuZXcgZm9udHMgZnJvbSBzY3JhdGNoLCB3ZSBpbmRpY2F0ZSB0aGlzXG4gICAgLy8gc2hvdWxkIGJlIGFuIGVtcHR5IGZvbnQgdGhhdCB3ZSdsbCBmaWxsIHdpdGggb3VyIG93biBkYXRhLlxuICAgIHZhciBmb250ID0gbmV3IEZvbnQoeyBlbXB0eTogdHJ1ZSB9KTtcblxuICAgIC8vIE9wZW5UeXBlIGZvbnRzIHVzZSBiaWcgZW5kaWFuIGJ5dGUgb3JkZXJpbmcuXG4gICAgLy8gV2UgY2FuJ3QgcmVseSBvbiB0eXBlZCBhcnJheSB2aWV3IHR5cGVzLCBiZWNhdXNlIHRoZXkgb3BlcmF0ZSB3aXRoIHRoZSBlbmRpYW5uZXNzIG9mIHRoZSBob3N0IGNvbXB1dGVyLlxuICAgIC8vIEluc3RlYWQgd2UgdXNlIERhdGFWaWV3cyB3aGVyZSB3ZSBjYW4gc3BlY2lmeSBlbmRpYW5uZXNzLlxuICAgIHZhciBkYXRhID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgMCk7XG4gICAgdmFyIG51bVRhYmxlcztcbiAgICB2YXIgdGFibGVFbnRyaWVzID0gW107XG4gICAgdmFyIHNpZ25hdHVyZSA9IHBhcnNlLmdldFRhZyhkYXRhLCAwKTtcbiAgICBpZiAoXG4gICAgICAgIHNpZ25hdHVyZSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAxLCAwLCAwKSB8fFxuICAgICAgICBzaWduYXR1cmUgPT09ICd0cnVlJyB8fFxuICAgICAgICBzaWduYXR1cmUgPT09ICd0eXAxJ1xuICAgICkge1xuICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ3RydWV0eXBlJztcbiAgICAgICAgbnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIDQpO1xuICAgICAgICB0YWJsZUVudHJpZXMgPSBwYXJzZU9wZW5UeXBlVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcyk7XG4gICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09ICdPVFRPJykge1xuICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ2NmZic7XG4gICAgICAgIG51bVRhYmxlcyA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCA0KTtcbiAgICAgICAgdGFibGVFbnRyaWVzID0gcGFyc2VPcGVuVHlwZVRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuICAgIH0gZWxzZSBpZiAoc2lnbmF0dXJlID09PSAnd09GRicpIHtcbiAgICAgICAgdmFyIGZsYXZvciA9IHBhcnNlLmdldFRhZyhkYXRhLCA0KTtcbiAgICAgICAgaWYgKGZsYXZvciA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAxLCAwLCAwKSkge1xuICAgICAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICd0cnVldHlwZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoZmxhdm9yID09PSAnT1RUTycpIHtcbiAgICAgICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAnY2ZmJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgT3BlblR5cGUgZmxhdm9yICcgKyBzaWduYXR1cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIDEyKTtcbiAgICAgICAgdGFibGVFbnRyaWVzID0gcGFyc2VXT0ZGVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBPcGVuVHlwZSBzaWduYXR1cmUgJyArIHNpZ25hdHVyZSk7XG4gICAgfVxuXG4gICAgdmFyIGNmZlRhYmxlRW50cnk7XG4gICAgdmFyIGZ2YXJUYWJsZUVudHJ5O1xuICAgIHZhciBnbHlmVGFibGVFbnRyeTtcbiAgICB2YXIgZ2RlZlRhYmxlRW50cnk7XG4gICAgdmFyIGdwb3NUYWJsZUVudHJ5O1xuICAgIHZhciBnc3ViVGFibGVFbnRyeTtcbiAgICB2YXIgaG10eFRhYmxlRW50cnk7XG4gICAgdmFyIGtlcm5UYWJsZUVudHJ5O1xuICAgIHZhciBsb2NhVGFibGVFbnRyeTtcbiAgICB2YXIgbWV0YVRhYmxlRW50cnk7XG4gICAgdmFyIHA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIHZhciB0YWJsZUVudHJ5ID0gdGFibGVFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgdGFibGUgPSAodm9pZCAwKTtcbiAgICAgICAgc3dpdGNoICh0YWJsZUVudHJ5LnRhZykge1xuICAgICAgICAgICAgY2FzZSAnY21hcCc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMuY21hcCA9IGNtYXAucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LmVuY29kaW5nID0gbmV3IENtYXBFbmNvZGluZyhmb250LnRhYmxlcy5jbWFwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2N2dCAnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMuY3Z0ID0gcC5wYXJzZVNob3J0TGlzdCh0YWJsZUVudHJ5Lmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnZhcic6XG4gICAgICAgICAgICAgICAgZnZhclRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnBnbSc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5mcGdtID0gcC5wYXJzZUJ5dGVMaXN0KHRhYmxlRW50cnkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmhlYWQgPSBoZWFkLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC51bml0c1BlckVtID0gZm9udC50YWJsZXMuaGVhZC51bml0c1BlckVtO1xuICAgICAgICAgICAgICAgIGluZGV4VG9Mb2NGb3JtYXQgPSBmb250LnRhYmxlcy5oZWFkLmluZGV4VG9Mb2NGb3JtYXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdoaGVhJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5oaGVhID0gaGhlYS5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQuYXNjZW5kZXIgPSBmb250LnRhYmxlcy5oaGVhLmFzY2VuZGVyO1xuICAgICAgICAgICAgICAgIGZvbnQuZGVzY2VuZGVyID0gZm9udC50YWJsZXMuaGhlYS5kZXNjZW5kZXI7XG4gICAgICAgICAgICAgICAgZm9udC5udW1iZXJPZkhNZXRyaWNzID0gZm9udC50YWJsZXMuaGhlYS5udW1iZXJPZkhNZXRyaWNzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG10eCc6XG4gICAgICAgICAgICAgICAgaG10eFRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbHRhZyc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgbHRhZ1RhYmxlID0gbHRhZy5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWF4cCc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMubWF4cCA9IG1heHAucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250Lm51bUdseXBocyA9IGZvbnQudGFibGVzLm1heHAubnVtR2x5cGhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnT1MvMic6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMub3MyID0gb3MyLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwb3N0JzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5wb3N0ID0gcG9zdC5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncHJlcCc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5wcmVwID0gcC5wYXJzZUJ5dGVMaXN0KHRhYmxlRW50cnkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2dseWYnOlxuICAgICAgICAgICAgICAgIGdseWZUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xvY2EnOlxuICAgICAgICAgICAgICAgIGxvY2FUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0NGRiAnOlxuICAgICAgICAgICAgICAgIGNmZlRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAna2Vybic6XG4gICAgICAgICAgICAgICAga2VyblRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnR0RFRic6XG4gICAgICAgICAgICAgICAgZ2RlZlRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnR1BPUyc6XG4gICAgICAgICAgICAgICAgZ3Bvc1RhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnR1NVQic6XG4gICAgICAgICAgICAgICAgZ3N1YlRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWV0YSc6XG4gICAgICAgICAgICAgICAgbWV0YVRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdseWZUYWJsZUVudHJ5ICYmIGxvY2FUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBzaG9ydFZlcnNpb24gPSBpbmRleFRvTG9jRm9ybWF0ID09PSAwO1xuICAgICAgICB2YXIgbG9jYVRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGxvY2FUYWJsZUVudHJ5KTtcbiAgICAgICAgdmFyIGxvY2FPZmZzZXRzID0gbG9jYS5wYXJzZShcbiAgICAgICAgICAgIGxvY2FUYWJsZS5kYXRhLFxuICAgICAgICAgICAgbG9jYVRhYmxlLm9mZnNldCxcbiAgICAgICAgICAgIGZvbnQubnVtR2x5cGhzLFxuICAgICAgICAgICAgc2hvcnRWZXJzaW9uXG4gICAgICAgICk7XG4gICAgICAgIHZhciBnbHlmVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ2x5ZlRhYmxlRW50cnkpO1xuICAgICAgICBmb250LmdseXBocyA9IGdseWYucGFyc2UoXG4gICAgICAgICAgICBnbHlmVGFibGUuZGF0YSxcbiAgICAgICAgICAgIGdseWZUYWJsZS5vZmZzZXQsXG4gICAgICAgICAgICBsb2NhT2Zmc2V0cyxcbiAgICAgICAgICAgIGZvbnQsXG4gICAgICAgICAgICBvcHRcbiAgICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNmZlRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIGNmZlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGNmZlRhYmxlRW50cnkpO1xuICAgICAgICBjZmYucGFyc2UoY2ZmVGFibGUuZGF0YSwgY2ZmVGFibGUub2Zmc2V0LCBmb250LCBvcHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvbnQgZG9lc24ndCBjb250YWluIFRydWVUeXBlIG9yIENGRiBvdXRsaW5lcy5cIik7XG4gICAgfVxuXG4gICAgdmFyIGhtdHhUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBobXR4VGFibGVFbnRyeSk7XG4gICAgaG10eC5wYXJzZShcbiAgICAgICAgZm9udCxcbiAgICAgICAgaG10eFRhYmxlLmRhdGEsXG4gICAgICAgIGhtdHhUYWJsZS5vZmZzZXQsXG4gICAgICAgIGZvbnQubnVtYmVyT2ZITWV0cmljcyxcbiAgICAgICAgZm9udC5udW1HbHlwaHMsXG4gICAgICAgIGZvbnQuZ2x5cGhzLFxuICAgICAgICBvcHRcbiAgICApO1xuICAgIGFkZEdseXBoTmFtZXMoZm9udCwgb3B0KTtcblxuICAgIGlmIChrZXJuVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIga2VyblRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGtlcm5UYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC5rZXJuaW5nUGFpcnMgPSBrZXJuLnBhcnNlKGtlcm5UYWJsZS5kYXRhLCBrZXJuVGFibGUub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250Lmtlcm5pbmdQYWlycyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChnZGVmVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgZ2RlZlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdkZWZUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC50YWJsZXMuZ2RlZiA9IGdkZWYucGFyc2UoZ2RlZlRhYmxlLmRhdGEsIGdkZWZUYWJsZS5vZmZzZXQpO1xuICAgIH1cblxuICAgIGlmIChncG9zVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgZ3Bvc1RhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdwb3NUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC50YWJsZXMuZ3BvcyA9IGdwb3MucGFyc2UoZ3Bvc1RhYmxlLmRhdGEsIGdwb3NUYWJsZS5vZmZzZXQpO1xuICAgICAgICBmb250LnBvc2l0aW9uLmluaXQoKTtcbiAgICB9XG5cbiAgICBpZiAoZ3N1YlRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIGdzdWJUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBnc3ViVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQudGFibGVzLmdzdWIgPSBnc3ViLnBhcnNlKGdzdWJUYWJsZS5kYXRhLCBnc3ViVGFibGUub2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAoZnZhclRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIGZ2YXJUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBmdmFyVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQudGFibGVzLmZ2YXIgPSBmdmFyLnBhcnNlKFxuICAgICAgICAgICAgZnZhclRhYmxlLmRhdGEsXG4gICAgICAgICAgICBmdmFyVGFibGUub2Zmc2V0LFxuICAgICAgICAgICAgZm9udC5uYW1lc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChtZXRhVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgbWV0YVRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIG1ldGFUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC50YWJsZXMubWV0YSA9IG1ldGEucGFyc2UobWV0YVRhYmxlLmRhdGEsIG1ldGFUYWJsZS5vZmZzZXQpO1xuICAgICAgICBmb250Lm1ldGFzID0gZm9udC50YWJsZXMubWV0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9udDtcbn1cblxuZnVuY3Rpb24gbG9hZCgpIHt9XG5mdW5jdGlvbiBsb2FkU3luYygpIHt9XG5cbnZhciBvcGVudHlwZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgIF9fcHJvdG9fXzogbnVsbCxcbiAgIEZvbnQ6IEZvbnQsXG4gICBHbHlwaDogR2x5cGgsXG4gICBQYXRoOiBQYXRoLFxuICAgX3BhcnNlOiBwYXJzZSxcbiAgIHBhcnNlOiBwYXJzZUJ1ZmZlcixcbiAgIGxvYWQ6IGxvYWQsXG4gICBsb2FkU3luYzogbG9hZFN5bmNcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBvcGVudHlwZTtcbmV4cG9ydCB7IEZvbnQsIEdseXBoLCBQYXRoLCBwYXJzZSBhcyBfcGFyc2UsIGxvYWQsIGxvYWRTeW5jLCBwYXJzZUJ1ZmZlciBhcyBwYXJzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlbnR5cGUubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInU4IiwiVWludDhBcnJheSIsInUxNiIsIlVpbnQxNkFycmF5IiwidTMyIiwiVWludDMyQXJyYXkiLCJmbGViIiwiZmRlYiIsImNsaW0iLCJmcmViIiwiZWIiLCJzdGFydCIsImIiLCJpIiwiciIsImoiLCJfYSIsImZsIiwicmV2ZmwiLCJfYiIsImZkIiwicmV2IiwieCIsImhNYXAiLCJjZCIsIm1iIiwicyIsImxlbmd0aCIsImwiLCJsZSIsImNvIiwicnZiIiwic3YiLCJyXzEiLCJ2IiwibSIsImZsdCIsImZkdCIsImZscm0iLCJmZHJtIiwibWF4IiwiYSIsImJpdHMiLCJkIiwicCIsIm8iLCJiaXRzMTYiLCJzaGZ0Iiwic2xjIiwiZSIsIm4iLCJCWVRFU19QRVJfRUxFTUVOVCIsInNldCIsInN1YmFycmF5IiwiZWMiLCJlcnIiLCJpbmQiLCJtc2ciLCJudCIsIkVycm9yIiwiY29kZSIsImNhcHR1cmVTdGFja1RyYWNlIiwiaW5mbHQiLCJkYXQiLCJidWYiLCJzdCIsInNsIiwiZiIsIm5vQnVmIiwibm9TdCIsImNidWYiLCJibCIsIm5idWYiLCJNYXRoIiwiZmluYWwiLCJwb3MiLCJidCIsImxtIiwiZG0iLCJsYnQiLCJkYnQiLCJ0YnRzIiwidHlwZSIsInQiLCJoTGl0IiwiaGNMZW4iLCJ0bCIsImxkdCIsImNsdCIsImNsYiIsImNsYm1zayIsImNsbSIsImMiLCJsdCIsImR0IiwibG1zIiwiZG1zIiwibHBvcyIsInN5bSIsImFkZCIsImRzeW0iLCJlbmQiLCJldCIsImluZmxhdGVTeW5jIiwiZGF0YSIsIm91dCIsInRkIiwiVGV4dERlY29kZXIiLCJ0ZHMiLCJkZWNvZGUiLCJzdHJlYW0iLCJQYXRoIiwiY29tbWFuZHMiLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJwcm90b3R5cGUiLCJtb3ZlVG8iLCJ5IiwicHVzaCIsImxpbmVUbyIsImN1cnZlVG8iLCJiZXppZXJDdXJ2ZVRvIiwieDEiLCJ5MSIsIngyIiwieTIiLCJxdWFkVG8iLCJxdWFkcmF0aWNDdXJ2ZVRvIiwiY2xvc2UiLCJjbG9zZVBhdGgiLCJleHRlbmQiLCJwYXRoT3JDb21tYW5kcyIsIkFycmF5IiwiYXBwbHkiLCJ0b1BhdGhEYXRhIiwiZGVjaW1hbFBsYWNlcyIsInVuZGVmaW5lZCIsImZsb2F0VG9TdHJpbmciLCJyb3VuZCIsInRvRml4ZWQiLCJwYWNrVmFsdWVzIiwiYXJndW1lbnRzJDEiLCJhcmd1bWVudHMiLCJjbWQiLCJjZmZTdGFuZGFyZFN0cmluZ3MiLCJjZmZTdGFuZGFyZEVuY29kaW5nIiwiY2ZmRXhwZXJ0RW5jb2RpbmciLCJEZWZhdWx0RW5jb2RpbmciLCJmb250IiwiY2hhclRvR2x5cGhJbmRleCIsImNvZGVQb2ludEF0IiwiZ2x5cGhzIiwiZ2x5cGgiLCJnZXQiLCJ1bmljb2RlcyIsIkNtYXBFbmNvZGluZyIsImNtYXAiLCJnbHlwaEluZGV4TWFwIiwiQ2ZmRW5jb2RpbmciLCJlbmNvZGluZyIsImNoYXJzZXQiLCJjaGFyTmFtZSIsImluZGV4T2YiLCJhZGRHbHlwaE5hbWVzQWxsIiwidGFibGVzIiwiY2hhckNvZGVzIiwiT2JqZWN0Iiwia2V5cyIsImdseXBoSW5kZXgiLCJhZGRVbmljb2RlIiwicGFyc2VJbnQiLCJhZGRHbHlwaE5hbWVzVG9Vbmljb2RlTWFwIiwiX0luZGV4VG9Vbmljb2RlTWFwIiwiYWRkR2x5cGhOYW1lcyIsIm9wdCIsImxvd01lbW9yeSIsImZhaWwiLCJtZXNzYWdlIiwiYXJndW1lbnQiLCJwcmVkaWNhdGUiLCJjaGVjayIsImFzc2VydCIsImdldFBhdGhEZWZpbml0aW9uIiwicGF0aCIsIl9wYXRoIiwiY29uZmlndXJhYmxlIiwiR2x5cGgiLCJvcHRpb25zIiwiYmluZENvbnN0cnVjdG9yVmFsdWVzIiwiaW5kZXgiLCJuYW1lIiwidW5pY29kZSIsInhNaW4iLCJ5TWluIiwieE1heCIsInlNYXgiLCJhZHZhbmNlV2lkdGgiLCJkZWZpbmVQcm9wZXJ0eSIsImdldFBhdGgiLCJmb250U2l6ZSIsImhQb2ludHMiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJoaW50aW5nIiwiZXhlYyIsImdldENvbW1hbmRzIiwic2NhbGUiLCJ1bml0c1BlckVtIiwiZ2V0Q29udG91cnMiLCJwb2ludHMiLCJjb250b3VycyIsImN1cnJlbnRDb250b3VyIiwicHQiLCJsYXN0UG9pbnRPZkNvbnRvdXIiLCJnZXRNZXRyaWNzIiwieENvb3JkcyIsInlDb29yZHMiLCJtZXRyaWNzIiwibWluIiwibGVmdFNpZGVCZWFyaW5nIiwiaXNGaW5pdGUiLCJyaWdodFNpZGVCZWFyaW5nIiwiZGVmaW5lRGVwZW5kZW50UHJvcGVydHkiLCJleHRlcm5hbE5hbWUiLCJpbnRlcm5hbE5hbWUiLCJuZXdWYWx1ZSIsImVudW1lcmFibGUiLCJHbHlwaFNldCIsImlzQXJyYXkiLCJfcHVzaCIsInVuaWNvZGVPYmoiLCJfaG10eFRhYmxlRGF0YSIsImxvYWRlciIsImdseXBoTG9hZGVyIiwidHRmR2x5cGhMb2FkZXIiLCJwYXJzZUdseXBoIiwicG9zaXRpb24iLCJidWlsZFBhdGgiLCJjZmZHbHlwaExvYWRlciIsInBhcnNlQ0ZGQ2hhcnN0cmluZyIsImNoYXJzdHJpbmciLCJnbHlwaHNldCIsInNlYXJjaFRhZyIsImFyciIsInRhZyIsImltaW4iLCJpbWF4IiwiaW1pZCIsInZhbCIsImJpblNlYXJjaCIsInZhbHVlIiwic2VhcmNoUmFuZ2UiLCJyYW5nZXMiLCJyYW5nZSIsIkxheW91dCIsInRhYmxlTmFtZSIsImdldFRhYmxlIiwiY3JlYXRlIiwibGF5b3V0IiwiY3JlYXRlRGVmYXVsdFRhYmxlIiwiZ2V0RGVmYXVsdFNjcmlwdE5hbWUiLCJoYXNMYXRuIiwic2NyaXB0cyIsImdldFNjcmlwdFRhYmxlIiwic2NyaXB0Iiwic2NyIiwiZGVmYXVsdExhbmdTeXMiLCJyZXNlcnZlZCIsInJlcUZlYXR1cmVJbmRleCIsImZlYXR1cmVJbmRleGVzIiwibGFuZ1N5c1JlY29yZHMiLCJzcGxpY2UiLCJnZXRMYW5nU3lzVGFibGUiLCJsYW5ndWFnZSIsInNjcmlwdFRhYmxlIiwibGFuZ1N5cyIsImxhbmdTeXNSZWNvcmQiLCJnZXRGZWF0dXJlVGFibGUiLCJmZWF0dXJlIiwibGFuZ1N5c1RhYmxlIiwiZmVhdHVyZVJlY29yZCIsImZlYXRJbmRleGVzIiwiYWxsRmVhdHVyZXMiLCJmZWF0dXJlcyIsInBhcmFtcyIsImxvb2t1cExpc3RJbmRleGVzIiwiZ2V0TG9va3VwVGFibGVzIiwibG9va3VwVHlwZSIsImZlYXR1cmVUYWJsZSIsImxvb2t1cFRhYmxlIiwiYWxsTG9va3VwcyIsImxvb2t1cHMiLCJsb29rdXBGbGFnIiwic3VidGFibGVzIiwibWFya0ZpbHRlcmluZ1NldCIsImdldEdseXBoQ2xhc3MiLCJjbGFzc0RlZlRhYmxlIiwiZm9ybWF0Iiwic3RhcnRHbHlwaCIsImNsYXNzZXMiLCJjbGFzc0lkIiwiZ2V0Q292ZXJhZ2VJbmRleCIsImNvdmVyYWdlVGFibGUiLCJleHBhbmRDb3ZlcmFnZSIsIlBvc2l0aW9uIiwiY2FsbCIsImluaXQiLCJkZWZhdWx0S2VybmluZ1RhYmxlcyIsImdldEtlcm5pbmdUYWJsZXMiLCJnZXRLZXJuaW5nVmFsdWUiLCJrZXJuaW5nTG9va3VwcyIsImxlZnRJbmRleCIsInJpZ2h0SW5kZXgiLCJzdWJ0YWJsZSIsImNvdkluZGV4IiwiY292ZXJhZ2UiLCJwb3NGb3JtYXQiLCJwYWlyU2V0IiwicGFpclNldHMiLCJrIiwicGFpciIsInNlY29uZEdseXBoIiwidmFsdWUxIiwieEFkdmFuY2UiLCJjbGFzczEiLCJjbGFzc0RlZjEiLCJjbGFzczIiLCJjbGFzc0RlZjIiLCJwYWlyJDEiLCJjbGFzc1JlY29yZHMiLCJncG9zIiwiU3Vic3RpdHV0aW9uIiwiYXJyYXlzRXF1YWwiLCJhcjEiLCJhcjIiLCJnZXRTdWJzdEZvcm1hdCIsImRlZmF1bHRTdWJ0YWJsZSIsInN1YnN0Rm9ybWF0IiwidmVyc2lvbiIsImdldFNpbmdsZSIsInN1YnN0aXR1dGlvbnMiLCJsb29rdXBUYWJsZXMiLCJpZHgiLCJkZWx0YSIsImRlbHRhR2x5cGhJZCIsInN1YiIsImJ5Iiwic3Vic3RpdHV0ZSIsImdldE11bHRpcGxlIiwicmVwbGFjZW1lbnRzIiwic2VxdWVuY2VzIiwiZ2V0QWx0ZXJuYXRlcyIsImFsdGVybmF0ZXMiLCJhbHRlcm5hdGVTZXRzIiwiZ2V0TGlnYXR1cmVzIiwibGlnYXR1cmVzIiwibGlnYXR1cmVTZXRzIiwibGlnU2V0IiwibGlnIiwiY29uY2F0IiwiY29tcG9uZW50cyIsImxpZ0dseXBoIiwiYWRkU2luZ2xlIiwic3Vic3RpdHV0aW9uIiwiY292ZXJhZ2VHbHlwaCIsImFkZE11bHRpcGxlIiwiYWRkQWx0ZXJuYXRlIiwiYWRkTGlnYXR1cmUiLCJsaWdhdHVyZSIsImxpZ0NvbXBvbmVudHMiLCJzbGljZSIsImxpZ2F0dXJlVGFibGUiLCJsaWdhdHVyZVNldCIsImdldEZlYXR1cmUiLCJ0ZXN0IiwiY2hlY2tBcmd1bWVudCIsImV4cHJlc3Npb24iLCJnZXRCeXRlIiwiZGF0YVZpZXciLCJvZmZzZXQiLCJnZXRVaW50OCIsImdldFVTaG9ydCIsImdldFVpbnQxNiIsImdldFNob3J0IiwiZ2V0SW50MTYiLCJnZXRVTG9uZyIsImdldFVpbnQzMiIsImdldEZpeGVkIiwiZGVjaW1hbCIsImZyYWN0aW9uIiwiZ2V0VGFnIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZ2V0SW50OCIsImdldE9mZnNldCIsIm9mZlNpemUiLCJnZXRCeXRlcyIsInN0YXJ0T2Zmc2V0IiwiZW5kT2Zmc2V0IiwiYnl0ZXMiLCJieXRlc1RvU3RyaW5nIiwidHlwZU9mZnNldHMiLCJieXRlIiwidVNob3J0Iiwic2hvcnQiLCJ1TG9uZyIsImZpeGVkIiwibG9uZ0RhdGVUaW1lIiwiUGFyc2VyIiwicmVsYXRpdmVPZmZzZXQiLCJwYXJzZUJ5dGUiLCJwYXJzZUNoYXIiLCJwYXJzZUNhcmQ4IiwicGFyc2VVU2hvcnQiLCJwYXJzZUNhcmQxNiIsInBhcnNlU0lEIiwicGFyc2VPZmZzZXQxNiIsInBhcnNlU2hvcnQiLCJwYXJzZUYyRG90MTQiLCJwYXJzZVVMb25nIiwicGFyc2VPZmZzZXQzMiIsInBhcnNlRml4ZWQiLCJwYXJzZVN0cmluZyIsInN0cmluZyIsInBhcnNlVGFnIiwicGFyc2VMb25nRGF0ZVRpbWUiLCJwYXJzZVZlcnNpb24iLCJtaW5vckJhc2UiLCJtYWpvciIsIm1pbm9yIiwic2tpcCIsImFtb3VudCIsInBhcnNlVUxvbmdMaXN0IiwiY291bnQiLCJvZmZzZXRzIiwicGFyc2VPZmZzZXQxNkxpc3QiLCJwYXJzZVVTaG9ydExpc3QiLCJwYXJzZVNob3J0TGlzdCIsImxpc3QiLCJwYXJzZUJ5dGVMaXN0IiwicGFyc2VMaXN0IiwiaXRlbUNhbGxiYWNrIiwicGFyc2VMaXN0MzIiLCJwYXJzZVJlY29yZExpc3QiLCJyZWNvcmREZXNjcmlwdGlvbiIsInJlY29yZHMiLCJmaWVsZHMiLCJyZWMiLCJmaWVsZE5hbWUiLCJmaWVsZFR5cGUiLCJwYXJzZVJlY29yZExpc3QzMiIsInBhcnNlU3RydWN0IiwiZGVzY3JpcHRpb24iLCJzdHJ1Y3QiLCJwYXJzZVZhbHVlUmVjb3JkIiwidmFsdWVGb3JtYXQiLCJ2YWx1ZVJlY29yZCIsInhQbGFjZW1lbnQiLCJ5UGxhY2VtZW50IiwieUFkdmFuY2UiLCJ4UGxhRGV2aWNlIiwieVBsYURldmljZSIsInhBZHZEZXZpY2UiLCJ5QWR2RGV2aWNlIiwicGFyc2VWYWx1ZVJlY29yZExpc3QiLCJ2YWx1ZUNvdW50IiwidmFsdWVzIiwicGFyc2VQb2ludGVyIiwic3RydWN0T2Zmc2V0IiwicGFyc2VQb2ludGVyMzIiLCJwYXJzZUxpc3RPZkxpc3RzIiwic3ViT2Zmc2V0cyIsInN1Ykxpc3QiLCJwYXJzZUNvdmVyYWdlIiwidG9TdHJpbmciLCJwYXJzZUNsYXNzRGVmIiwibGlzdDMyIiwicmVjb3JkTGlzdCIsInJlY29yZExpc3QzMiIsInBvaW50ZXIiLCJwb2ludGVyMzIiLCJvZmZzZXQxNiIsInVTaG9ydExpc3QiLCJvZmZzZXQzMiIsInVMb25nTGlzdCIsImNsYXNzRGVmIiwicGFyc2VTY3JpcHRMaXN0IiwicGFyc2VGZWF0dXJlTGlzdCIsImZlYXR1cmVQYXJhbXMiLCJwYXJzZUxvb2t1cExpc3QiLCJsb29rdXBUYWJsZVBhcnNlcnMiLCJ1c2VNYXJrRmlsdGVyaW5nU2V0IiwicGFyc2VGZWF0dXJlVmFyaWF0aW9uc0xpc3QiLCJtYWpvclZlcnNpb24iLCJtaW5vclZlcnNpb24iLCJmZWF0dXJlVmFyaWF0aW9ucyIsImNvbmRpdGlvblNldE9mZnNldCIsImZlYXR1cmVUYWJsZVN1YnN0aXR1dGlvbk9mZnNldCIsInBhcnNlIiwiZ2V0Q2FyZDgiLCJnZXRDYXJkMTYiLCJwYXJzZUdseXBoQ29vcmRpbmF0ZSIsImZsYWciLCJwcmV2aW91c1ZhbHVlIiwic2hvcnRWZWN0b3JCaXRNYXNrIiwic2FtZUJpdE1hc2siLCJudW1iZXJPZkNvbnRvdXJzIiwiX3hNaW4iLCJfeU1pbiIsIl94TWF4IiwiX3lNYXgiLCJmbGFncyIsImVuZFBvaW50SW5kaWNlcyIsImluc3RydWN0aW9uTGVuZ3RoIiwiaW5zdHJ1Y3Rpb25zIiwiaSQxIiwibnVtYmVyT2ZDb29yZGluYXRlcyIsImkkMiIsInJlcGVhdENvdW50IiwicG9pbnQiLCJpJDMiLCJvbkN1cnZlIiwicHgiLCJpJDQiLCJweSIsImkkNSIsImlzQ29tcG9zaXRlIiwibW9yZUNvbXBvbmVudHMiLCJjb21wb25lbnQiLCJzY2FsZTAxIiwic2NhbGUxMCIsImR4IiwiZHkiLCJtYXRjaGVkUG9pbnRzIiwiaSQ2IiwidHJhbnNmb3JtUG9pbnRzIiwidHJhbnNmb3JtIiwibmV3UG9pbnRzIiwibmV3UHQiLCJjb250b3VySW5kZXgiLCJjb250b3VyIiwicHJldiIsImN1cnIiLCJuZXh0IiwicHJldjIiLCJuZXh0MiIsImNvbXBvbmVudEdseXBoIiwidHJhbnNmb3JtZWRQb2ludHMiLCJmaXJzdFB0Iiwic2Vjb25kUHQiLCJwYXJzZUdseWZUYWJsZUFsbCIsImxvY2EiLCJuZXh0T2Zmc2V0IiwicGFyc2VHbHlmVGFibGVPbkxvd01lbW9yeSIsInBhcnNlR2x5ZlRhYmxlIiwiZ2x5ZiIsImluc3RydWN0aW9uVGFibGUiLCJleGVjR2x5cGgiLCJleGVjQ29tcG9uZW50IiwiSGludGluZyIsIl9mcGdtU3RhdGUiLCJfcHJlcFN0YXRlIiwiX2Vycm9yU3RhdGUiLCJyb3VuZE9mZiIsInJvdW5kVG9HcmlkIiwic2lnbiIsImFicyIsInJvdW5kVG9Eb3VibGVHcmlkIiwicm91bmRUb0hhbGZHcmlkIiwicm91bmRVcFRvR3JpZCIsImNlaWwiLCJyb3VuZERvd25Ub0dyaWQiLCJmbG9vciIsInJvdW5kU3VwZXIiLCJwZXJpb2QiLCJzclBlcmlvZCIsInBoYXNlIiwic3JQaGFzZSIsInRocmVzaG9sZCIsInNyVGhyZXNob2xkIiwidHJ1bmMiLCJ4VW5pdFZlY3RvciIsImF4aXMiLCJkaXN0YW5jZSIsInAxIiwicDIiLCJvMSIsIm8yIiwieG8iLCJpbnRlcnBvbGF0ZSIsInJwMSIsInJwMiIsInB2IiwiZG8xIiwiZG8yIiwiZG9hMSIsImRvYTIiLCJkbTEiLCJkbTIiLCJzZXRSZWxhdGl2ZSIsIm5vcm1hbFNsb3BlIiwiTnVtYmVyIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJycCIsIm9yZyIsInJweCIsInJweSIsInlvIiwicnBkeCIsInJwZHkiLCJzbG9wZSIsInRvdWNoIiwieFRvdWNoZWQiLCJ0b3VjaGVkIiwidW50b3VjaCIsInlVbml0VmVjdG9yIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJ5VG91Y2hlZCIsImZyZWV6ZSIsIlVuaXRWZWN0b3IiLCJwdm5zIiwiZnZzIiwiZ2V0VW5pdFZlY3RvciIsInNxcnQiLCJIUG9pbnQiLCJwcmV2UG9pbnRPbkNvbnRvdXIiLCJuZXh0UG9pbnRPbkNvbnRvdXIiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsIm5leHRUb3VjaGVkIiwicHJldlRvdWNoZWQiLCJIUFplcm8iLCJkZWZhdWx0U3RhdGUiLCJjdkN1dEluIiwiZGVsdGFCYXNlIiwiZGVsdGFTaGlmdCIsImxvb3AiLCJtaW5EaXMiLCJhdXRvRmxpcCIsIlN0YXRlIiwiZW52IiwicHJvZyIsInN0YWNrIiwienAwIiwienAxIiwienAyIiwicnAwIiwiZnYiLCJkcHYiLCJwcGVtIiwicHJlcFN0YXRlIiwiZnBnbVN0YXRlIiwiZnBnbSIsImZ1bmNzIiwiZXhwb3J0cyIsIkRFQlVHIiwiY29uc29sZSIsImxvZyIsInN0ZXAiLCJwcmVwIiwib0N2dCIsImN2dCIsImdab25lIiwic3RhdGUiLCJjZyIsImd6IiwiY2MiLCJwaSIsImdMZW4iLCJpbmhpYml0R3JpZEZpdCIsInowIiwiejEiLCJ6MiIsInBMZW4iLCJjcCIsInNwIiwibnAiLCJpbnMiLCJpcCIsImluaXRUWm9uZSIsInRab25lIiwiaGFuZGxlRWxzZSIsIm5lc3RpbmciLCJTVlRDQSIsIlNQVlRDQSIsIlNGVlRDQSIsIlNQVlRMIiwicDJpIiwicG9wIiwicDFpIiwiU0ZWVEwiLCJTUFZGUyIsIlNGVkZTIiwiR1BWIiwiR0ZWIiwiU0ZWVFBWIiwiSVNFQ1QiLCJwYTBpIiwicGExaSIsInBiMGkiLCJwYjFpIiwicGEwIiwicGExIiwicGIwIiwicGIxIiwieDMiLCJ5MyIsIng0IiwieTQiLCJkaXYiLCJmMSIsImYyIiwiU1JQMCIsIlNSUDEiLCJTUlAyIiwiU1pQMCIsIlNaUDEiLCJTWlAyIiwiU1pQUyIsIlNMT09QIiwiUlRHIiwiUlRIRyIsIlNNRCIsIkVMU0UiLCJKTVBSIiwiU0NWVENJIiwiRFVQIiwiUE9QIiwiQ0xFQVIiLCJTV0FQIiwiREVQVEgiLCJMT09QQ0FMTCIsImZuIiwiY2lwIiwiY3Byb2ciLCJDQUxMIiwiQ0lOREVYIiwiTUlOREVYIiwiRkRFRiIsImlwQmVnaW4iLCJNREFQIiwiSVVQIiwicHAiLCJTSFAiLCJycGkiLCJTSEMiLCJjaSIsIlNIWiIsInoiLCJTSFBJWCIsIklQIiwicnAxaSIsInJwMmkiLCJNU0lSUCIsIkFMSUdOUlAiLCJycDBpIiwiUlRERyIsIk1JQVAiLCJjdiIsIk5QVVNIQiIsIk5QVVNIVyIsInciLCJXUyIsInN0b3JlIiwiUlMiLCJXQ1ZUUCIsIlJDVlQiLCJjdnRlIiwiR0MiLCJNRCIsInBpMiIsInBpMSIsIk1QUEVNIiwiRkxJUE9OIiwiTFQiLCJlMiIsImUxIiwiTFRFUSIsIkdUIiwiR1RFUSIsIkVRIiwiTkVRIiwiT0REIiwiRVZFTiIsIklGIiwiRUlGIiwiQU5EIiwiT1IiLCJOT1QiLCJERUxUQVAxMjMiLCJiYXNlIiwiZHMiLCJhcmciLCJhcHBlbSIsIm1hZyIsIlNEQiIsIlNEUyIsInBvdyIsIkFERCIsIm4yIiwibjEiLCJTVUIiLCJESVYiLCJNVUwiLCJBQlMiLCJORUciLCJGTE9PUiIsIkNFSUxJTkciLCJST1VORCIsIldDVlRGIiwiREVMVEFDMTIzIiwiU1JPVU5EIiwiUzQ1Uk9VTkQiLCJST0ZGIiwiUlVURyIsIlJEVEciLCJTQ0FOQ1RSTCIsIlNEUFZUTCIsIkdFVElORk8iLCJzZWwiLCJST0xMIiwiTUFYIiwiTUlOIiwiU0NBTlRZUEUiLCJJTlNUQ1RSTCIsImlnbm9yZUN2dCIsIlBVU0hCIiwiUFVTSFciLCJNRFJQX01JUlAiLCJpbmRpcmVjdCIsInNldFJwMCIsImtlZXBEIiwicm8iLCJtZCIsIm9kIiwiYmluZCIsIlRva2VuIiwiY2hhciIsImFjdGl2ZVN0YXRlIiwiQ29udGV4dFJhbmdlIiwic3RhcnRJbmRleCIsImNvbnRleHROYW1lIiwiQ29udGV4dENoZWNrZXIiLCJjaGVja1N0YXJ0IiwiY2hlY2tFbmQiLCJvcGVuUmFuZ2UiLCJDb250ZXh0UGFyYW1zIiwiY29udGV4dCIsImN1cnJlbnRJbmRleCIsImN1cnJlbnQiLCJiYWNrdHJhY2siLCJsb29rYWhlYWQiLCJFdmVudCIsImV2ZW50SWQiLCJzdWJzY3JpYmVycyIsImluaXRpYWxpemVDb3JlRXZlbnRzIiwiZXZlbnRzIiwidGhpcyQxIiwiY29yZUV2ZW50cyIsImZvckVhY2giLCJldmVudCIsInN1YnNjcmliZSIsInJlcXVpcmVzQ29udGV4dFVwZGF0ZSIsInVwZGF0ZUNvbnRleHRzUmFuZ2VzIiwiVG9rZW5pemVyIiwidG9rZW5zIiwicmVnaXN0ZXJlZENvbnRleHRzIiwiY29udGV4dENoZWNrZXJzIiwicmVnaXN0ZXJlZE1vZGlmaWVycyIsInNldFN0YXRlIiwia2V5IiwiZ2V0U3RhdGUiLCJzdGF0ZUlkIiwiaW5ib3VuZEluZGV4IiwiY29tcG9zZVJVRCIsIlJVRHMiLCJzaWxlbnQiLCJtYXAiLCJSVUQiLCJoYXNGQUlMT2JqZWN0Iiwib2JqIiwiaGFzT3duUHJvcGVydHkiLCJldmVyeSIsIkZBSUwiLCJyZXBvcnQiLCJmaWx0ZXIiLCJkaXNwYXRjaCIsIm9wIiwicmVwbGFjZVJhbmdlIiwiaXNUb2tlblR5cGUiLCJ0b2tlbiIsImlzTmFOIiwicmVwbGFjZWQiLCJyZXBsYWNlVG9rZW4iLCJyZW1vdmVSYW5nZSIsInJlbW92ZVRva2VuIiwiaW5zZXJ0VG9rZW4iLCJ0b2tlblR5cGUiLCJyZWdpc3Rlck1vZGlmaWVyIiwibW9kaWZpZXJJZCIsImNvbmRpdGlvbiIsIm1vZGlmaWVyIiwibmV3VG9rZW4iLCJjb250ZXh0UGFyYW1zIiwiY29uZGl0aW9uUGFyYW1zIiwiY2FuQXBwbHlNb2RpZmllciIsIm1vZGlmaWVyUGFyYW1zIiwibmV3U3RhdGVWYWx1ZSIsImV2ZW50SGFuZGxlciIsInVuc3Vic2NyaWJlIiwic3Vic0lkIiwic2V0Q3VycmVudEluZGV4IiwicmFuZ2VUb1RleHQiLCJnZXRSYW5nZVRva2VucyIsImpvaW4iLCJnZXRUZXh0IiwiZ2V0Q29udGV4dCIsIm9uIiwiZXZlbnROYW1lIiwiYXJncyIsInN1YnNjcmliZXIiLCJyZWdpc3RlckNvbnRleHRDaGVja2VyIiwiY29udGV4dFN0YXJ0Q2hlY2siLCJjb250ZXh0RW5kQ2hlY2siLCJlbmRJbmRleCIsImdldENvbnRleHRSYW5nZXMiLCJyZXNldENvbnRleHRzUmFuZ2VzIiwiY2hhcnMiLCJydW5Db250ZXh0Q2hlY2siLCJzZXRFbmRPZmZzZXQiLCJyYW5nZUlkIiwiY29udGV4dENoZWNrZXIiLCJ0b2tlbml6ZSIsInRleHQiLCJmcm9tIiwiaXNBcmFiaWNDaGFyIiwiaXNJc29sYXRlZEFyYWJpY0NoYXIiLCJpc1Rhc2hrZWVsQXJhYmljQ2hhciIsImlzTGF0aW5DaGFyIiwiaXNXaGl0ZVNwYWNlIiwiRmVhdHVyZVF1ZXJ5IiwiU3Vic3RpdHV0aW9uQWN0aW9uIiwiYWN0aW9uIiwiaWQiLCJsb29rdXBDb3ZlcmFnZSIsInNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDEiLCJzdWJzdGl0dXRlSW5kZXgiLCJzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQyIiwibG9va3VwQ292ZXJhZ2VMaXN0IiwiY292ZXJhZ2VMaXN0IiwibG9va3VwTGlzdCIsImxvb2t1cEluZGV4IiwiY2hhaW5pbmdTdWJzdGl0dXRpb25Gb3JtYXQzIiwibG9va3Vwc0NvdW50IiwiaW5wdXRDb3ZlcmFnZSIsImxvb2thaGVhZENvdmVyYWdlIiwiYmFja3RyYWNrQ292ZXJhZ2UiLCJpbnB1dExvb2t1cHMiLCJsb29rYWhlYWRPZmZzZXQiLCJsb29rYWhlYWRDb250ZXh0Iiwic2hpZnQiLCJsb29rYWhlYWRQYXJhbXMiLCJsb29rYWhlYWRMb29rdXBzIiwiYmFja3RyYWNrQ29udGV4dCIsInJldmVyc2UiLCJiYWNrdHJhY2tQYXJhbXMiLCJiYWNrdHJhY2tMb29rdXBzIiwiY29udGV4dFJ1bGVzTWF0Y2giLCJsb29rdXBSZWNvcmRzIiwibG9va3VwUmVjb3JkIiwibG9va3VwTGlzdEluZGV4IiwiZ2V0TG9va3VwQnlJbmRleCIsInN1YnRhYmxlJDEiLCJsb29rdXAiLCJnZXRMb29rdXBNZXRob2QiLCJzdWJzdGl0dXRpb25UeXBlIiwiZ2V0U3Vic3RpdHV0aW9uVHlwZSIsImxpZ2F0dXJlU3Vic3RpdHV0aW9uRm9ybWF0MSIsImxpZ1NldEluZGV4IiwibG9va2FoZWFkSXRlbSIsImRlY29tcG9zaXRpb25TdWJzdGl0dXRpb25Gb3JtYXQxIiwiZ2V0RGVmYXVsdFNjcmlwdEZlYXR1cmVzSW5kZXhlcyIsImdzdWIiLCJnZXRTY3JpcHRGZWF0dXJlc0luZGV4ZXMiLCJzY3JpcHRUYWciLCJtYXBUYWdzVG9GZWF0dXJlcyIsInRhZ3MiLCJnZXRTY3JpcHRGZWF0dXJlcyIsImZlYXR1cmVzSW5kZXhlcyIsImxvb2t1cEZlYXR1cmUiLCJxdWVyeSIsIm5hbWVzIiwiZnVsbE5hbWUiLCJlbiIsImdldEZlYXR1cmVMb29rdXBzIiwiZ2V0TG9va3VwU3VidGFibGVzIiwic3Vic3RUeXBlIiwic3VwcG9ydHMiLCJzdXBwb3J0ZWRTY3JpcHQiLCJzdXBwb3J0ZWRGZWF0dXJlIiwic29tZSIsInNjcmlwdEZlYXR1cmVzIiwiYXJhYmljV29yZFN0YXJ0Q2hlY2siLCJwcmV2Q2hhciIsImFyYWJpY1dvcmRFbmRDaGVjayIsIm5leHRDaGFyIiwiYXJhYmljV29yZENoZWNrIiwic3RhcnRDaGVjayIsImVuZENoZWNrIiwiYXJhYmljU2VudGVuY2VTdGFydENoZWNrIiwiYXJhYmljU2VudGVuY2VFbmRDaGVjayIsIm5leHRJc1doaXRlc3BhY2UiLCJhcmFiaWNDaGFyQWhlYWQiLCJhcmFiaWNTZW50ZW5jZUNoZWNrIiwic2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MSQxIiwic2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MiQxIiwiY2hhaW5pbmdTdWJzdGl0dXRpb25Gb3JtYXQzJDEiLCJzdWJzdCIsImxpZ2F0dXJlU3Vic3RpdHV0aW9uRm9ybWF0MSQxIiwiY29tcHNDb3VudCIsIlNVQlNUSVRVVElPTlMiLCJhcHBseVN1YnN0aXR1dGlvbiIsIndpbGxDb25uZWN0UHJldiIsImNoYXJDb250ZXh0UGFyYW1zIiwiaXNvbGF0ZWQiLCJ0YXNoa2VlbCIsIndpbGxDb25uZWN0TmV4dCIsImFyYWJpY1ByZXNlbnRhdGlvbkZvcm1zIiwiZmVhdHVyZXNUYWdzIiwidG9rZW5pemVyIiwiQ09OTkVDVCIsImluZm8iLCJnZXRDb250ZXh0UGFyYW1zIiwiYXJhYmljUmVxdWlyZWRMaWdhdHVyZXMiLCJsYXRpbldvcmRTdGFydENoZWNrIiwibGF0aW5Xb3JkRW5kQ2hlY2siLCJsYXRpbldvcmRDaGVjayIsImdldENvbnRleHRQYXJhbXMkMSIsImxhdGluTGlnYXR1cmUiLCJCaWRpIiwiYmFzZURpciIsInNldFRleHQiLCJjb250ZXh0Q2hlY2tzIiwiY2hlY2tJZCIsInRva2VuaXplVGV4dCIsInJldmVyc2VBcmFiaWNTZW50ZW5jZXMiLCJyYW5nZVRva2VucyIsInJlZ2lzdGVyRmVhdHVyZXMiLCJzdXBwb3J0ZWRUYWdzIiwiYXBwbHlGZWF0dXJlcyIsImNoZWNrR2x5cGhJbmRleFN0YXR1cyIsImFwcGx5QXJhYmljUHJlc2VudGF0aW9uRm9ybXMiLCJhcHBseUFyYWJpY1JlcXVpcmVMaWdhdHVyZXMiLCJhcHBseUxhdGluTGlnYXR1cmVzIiwiY2hlY2tDb250ZXh0UmVhZHkiLCJjb250ZXh0SWQiLCJhcHBseUZlYXR1cmVzVG9Db250ZXh0cyIsInByb2Nlc3NUZXh0IiwiZ2V0QmlkaVRleHQiLCJnZXRUZXh0R2x5cGhzIiwiaW5kZXhlcyIsImRlbGV0ZWQiLCJGb250IiwiZW1wdHkiLCJmYW1pbHlOYW1lIiwic3R5bGVOYW1lIiwiYXNjZW5kZXIiLCJkZXNjZW5kZXIiLCJjcmVhdGVkVGltZXN0YW1wIiwiYXNzaWduIiwib3MyIiwidXNXZWlnaHRDbGFzcyIsIndlaWdodENsYXNzIiwidXNXZWlnaHRDbGFzc2VzIiwiTUVESVVNIiwidXNXaWR0aENsYXNzIiwid2lkdGhDbGFzcyIsInVzV2lkdGhDbGFzc2VzIiwiZnNTZWxlY3Rpb24iLCJmc1NlbGVjdGlvblZhbHVlcyIsIlJFR1VMQVIiLCJzdXBwb3J0ZWQiLCJfaGludGluZyIsIm91dGxpbmVzRm9ybWF0IiwiaGFzQ2hhciIsImNoYXJUb0dseXBoIiwidXBkYXRlRmVhdHVyZXMiLCJkZWZhdWx0UmVuZGVyT3B0aW9ucyIsInN0cmluZ1RvR2x5cGhzIiwiYmlkaSIsImNoYXJUb0dseXBoSW5kZXhNb2QiLCJub3RkZWYiLCJsZWZ0R2x5cGgiLCJyaWdodEdseXBoIiwiZ3Bvc0tlcm5pbmciLCJrZXJuaW5nUGFpcnMiLCJrZXJuaW5nIiwiZm9yRWFjaEdseXBoIiwiY2FsbGJhY2siLCJmb250U2NhbGUiLCJrZXJuaW5nVmFsdWUiLCJsZXR0ZXJTcGFjaW5nIiwidHJhY2tpbmciLCJmdWxsUGF0aCIsImdYIiwiZ1kiLCJnRm9udFNpemUiLCJnbHlwaFBhdGgiLCJnZXRQYXRocyIsImdseXBoUGF0aHMiLCJnZXRBZHZhbmNlV2lkdGgiLCJJVEFMSUMiLCJVTkRFUlNDT1JFIiwiTkVHQVRJVkUiLCJPVVRMSU5FRCIsIlNUUklLRU9VVCIsIkJPTEQiLCJVU0VSX1RZUE9fTUVUUklDUyIsIldXUyIsIk9CTElRVUUiLCJVTFRSQV9DT05ERU5TRUQiLCJFWFRSQV9DT05ERU5TRUQiLCJDT05ERU5TRUQiLCJTRU1JX0NPTkRFTlNFRCIsIlNFTUlfRVhQQU5ERUQiLCJFWFBBTkRFRCIsIkVYVFJBX0VYUEFOREVEIiwiVUxUUkFfRVhQQU5ERUQiLCJUSElOIiwiRVhUUkFfTElHSFQiLCJMSUdIVCIsIk5PUk1BTCIsIlNFTUlfQk9MRCIsIkVYVFJBX0JPTEQiLCJCTEFDSyIsInBhcnNlQ21hcFRhYmxlRm9ybWF0MTIiLCJncm91cENvdW50Iiwic3RhcnRDaGFyQ29kZSIsImVuZENoYXJDb2RlIiwic3RhcnRHbHlwaElkIiwicGFyc2VDbWFwVGFibGVGb3JtYXQ0Iiwic2VnQ291bnQiLCJlbmRDb3VudFBhcnNlciIsInN0YXJ0Q291bnRQYXJzZXIiLCJpZERlbHRhUGFyc2VyIiwiaWRSYW5nZU9mZnNldFBhcnNlciIsImdseXBoSW5kZXhPZmZzZXQiLCJlbmRDb3VudCIsInN0YXJ0Q291bnQiLCJpZERlbHRhIiwiaWRSYW5nZU9mZnNldCIsInBhcnNlQ21hcFRhYmxlIiwibnVtVGFibGVzIiwicGxhdGZvcm1JZCIsImVuY29kaW5nSWQiLCJjYWxjQ0ZGU3Vicm91dGluZUJpYXMiLCJzdWJycyIsImJpYXMiLCJwYXJzZUNGRkluZGV4IiwiY29udmVyc2lvbkZuIiwib2JqZWN0cyIsIm9iamVjdE9mZnNldCIsIm9mZnNldFNpemUiLCJwYXJzZUNGRkluZGV4TG93TWVtb3J5IiwiZ2V0Q2ZmSW5kZXhPYmplY3QiLCJwYXJzZUZsb2F0T3BlcmFuZCIsInBhcnNlciIsImVvZiIsInBhcnNlRmxvYXQiLCJwYXJzZU9wZXJhbmQiLCJiMCIsImIxIiwiYjIiLCJiMyIsImI0IiwiZW50cmllc1RvT2JqZWN0IiwiZW50cmllcyIsInBhcnNlQ0ZGRGljdCIsInNpemUiLCJvcGVyYW5kcyIsImdldENGRlN0cmluZyIsInN0cmluZ3MiLCJpbnRlcnByZXREaWN0IiwiZGljdCIsIm1ldGEiLCJuZXdEaWN0IiwicGFyc2VDRkZIZWFkZXIiLCJoZWFkZXIiLCJmb3JtYXRNYWpvciIsImZvcm1hdE1pbm9yIiwiVE9QX0RJQ1RfTUVUQSIsIlBSSVZBVEVfRElDVF9NRVRBIiwicGFyc2VDRkZUb3BEaWN0IiwiYnl0ZUxlbmd0aCIsInBhcnNlQ0ZGUHJpdmF0ZURpY3QiLCJnYXRoZXJDRkZUb3BEaWN0cyIsImNmZkluZGV4IiwidG9wRGljdEFycmF5IiwiaVRvcERpY3QiLCJ0b3BEaWN0RGF0YSIsIkRhdGFWaWV3IiwiYnVmZmVyIiwidG9wRGljdCIsIl9zdWJycyIsIl9zdWJyc0JpYXMiLCJfZGVmYXVsdFdpZHRoWCIsIl9ub21pbmFsV2lkdGhYIiwicHJpdmF0ZVNpemUiLCJwcml2YXRlIiwicHJpdmF0ZU9mZnNldCIsInByaXZhdGVEaWN0IiwiZGVmYXVsdFdpZHRoWCIsIm5vbWluYWxXaWR0aFgiLCJzdWJyT2Zmc2V0Iiwic3VickluZGV4IiwiX3ByaXZhdGVEaWN0IiwicGFyc2VDRkZDaGFyc2V0IiwibkdseXBocyIsInNpZCIsInBhcnNlQ0ZGRW5jb2RpbmciLCJlbmMiLCJuQ29kZXMiLCJuUmFuZ2VzIiwiZmlyc3QiLCJuTGVmdCIsImMxeCIsImMxeSIsImMyeCIsImMyeSIsIm5TdGVtcyIsImhhdmVXaWR0aCIsIm9wZW4iLCJzdWJyc0JpYXMiLCJpc0NJREZvbnQiLCJmZEluZGV4IiwiY2ZmIiwiX2ZkU2VsZWN0IiwiZmREaWN0IiwiX2ZkQXJyYXkiLCJ3aWR0aCIsIm5ld0NvbnRvdXIiLCJwYXJzZVN0ZW1zIiwiaGFzV2lkdGhBcmciLCJjb2RlSW5kZXgiLCJzdWJyQ29kZSIsImpweCIsImpweSIsImMzeCIsImMzeSIsImM0eCIsImM0eSIsImdzdWJyc0JpYXMiLCJnc3VicnMiLCJwYXJzZUNGRkZEU2VsZWN0IiwiZmRBcnJheUNvdW50IiwiZmRTZWxlY3QiLCJpR2lkIiwiaVJhbmdlIiwicGFyc2VDRkZUYWJsZSIsIm5hbWVJbmRleCIsInRvcERpY3RJbmRleCIsInN0cmluZ0luZGV4IiwiZ2xvYmFsU3VickluZGV4Iiwicm9zIiwiZmRBcnJheU9mZnNldCIsImZkQXJyYXkiLCJmZFNlbGVjdE9mZnNldCIsImZkQXJyYXlJbmRleCIsIm51bUdseXBocyIsInByaXZhdGVEaWN0T2Zmc2V0IiwiY2hhclN0cmluZ3NJbmRleCIsImNoYXJTdHJpbmdzIiwiY2ZmRW5jb2RpbmciLCJjaGFyU3RyaW5nIiwicGFyc2VGdmFyQXhpcyIsIm1pblZhbHVlIiwiZGVmYXVsdFZhbHVlIiwibWF4VmFsdWUiLCJwYXJzZUZ2YXJJbnN0YW5jZSIsImF4ZXMiLCJpbnN0IiwiY29vcmRpbmF0ZXMiLCJwYXJzZUZ2YXJUYWJsZSIsInRhYmxlVmVyc2lvbiIsIm9mZnNldFRvRGF0YSIsImF4aXNDb3VudCIsImF4aXNTaXplIiwiaW5zdGFuY2VDb3VudCIsImluc3RhbmNlU2l6ZSIsImluc3RhbmNlcyIsImluc3RhbmNlU3RhcnQiLCJmdmFyIiwiYXR0YWNoTGlzdCIsImF0dGFjaFBvaW50cyIsImNhcmV0VmFsdWUiLCJjb29yZGluYXRlIiwicG9pbnRpbmRleCIsImxpZ0NhcmV0TGlzdCIsImxpZ0dseXBocyIsIm1hcmtHbHlwaFNldHMiLCJwYXJzZUdERUZUYWJsZSIsImdkZWYiLCJtYXJrQXR0YWNoQ2xhc3NEZWYiLCJzdWJ0YWJsZVBhcnNlcnMiLCJwYXJzZUxvb2t1cDEiLCJwb3Nmb3JtYXQiLCJwYXJzZUxvb2t1cDIiLCJ2YWx1ZUZvcm1hdDEiLCJ2YWx1ZUZvcm1hdDIiLCJ2YWx1ZTIiLCJjbGFzczFDb3VudCIsImNsYXNzMkNvdW50IiwicGFyc2VMb29rdXAzIiwiZXJyb3IiLCJwYXJzZUxvb2t1cDQiLCJwYXJzZUxvb2t1cDUiLCJwYXJzZUxvb2t1cDYiLCJwYXJzZUxvb2t1cDciLCJwYXJzZUxvb2t1cDgiLCJwYXJzZUxvb2t1cDkiLCJwYXJzZUdwb3NUYWJsZSIsInZhcmlhdGlvbnMiLCJzdWJ0YWJsZVBhcnNlcnMkMSIsImxvb2t1cFJlY29yZERlc2MiLCJzZXF1ZW5jZUluZGV4IiwicnVsZVNldHMiLCJnbHlwaENvdW50Iiwic3Vic3RDb3VudCIsImlucHV0IiwiY2xhc3NTZXRzIiwiY292ZXJhZ2VzIiwiY2hhaW5SdWxlU2V0cyIsImJhY2t0cmFja0NsYXNzRGVmIiwiaW5wdXRDbGFzc0RlZiIsImxvb2thaGVhZENsYXNzRGVmIiwiY2hhaW5DbGFzc1NldCIsImV4dGVuc2lvbkxvb2t1cFR5cGUiLCJleHRlbnNpb25QYXJzZXIiLCJleHRlbnNpb24iLCJzdWJzdGl0dXRlcyIsInBhcnNlR3N1YlRhYmxlIiwicGFyc2VIZWFkVGFibGUiLCJoZWFkIiwiZm9udFJldmlzaW9uIiwiY2hlY2tTdW1BZGp1c3RtZW50IiwibWFnaWNOdW1iZXIiLCJjcmVhdGVkIiwibW9kaWZpZWQiLCJtYWNTdHlsZSIsImxvd2VzdFJlY1BQRU0iLCJmb250RGlyZWN0aW9uSGludCIsImluZGV4VG9Mb2NGb3JtYXQiLCJnbHlwaERhdGFGb3JtYXQiLCJwYXJzZUhoZWFUYWJsZSIsImhoZWEiLCJsaW5lR2FwIiwiYWR2YW5jZVdpZHRoTWF4IiwibWluTGVmdFNpZGVCZWFyaW5nIiwibWluUmlnaHRTaWRlQmVhcmluZyIsInhNYXhFeHRlbnQiLCJjYXJldFNsb3BlUmlzZSIsImNhcmV0U2xvcGVSdW4iLCJjYXJldE9mZnNldCIsIm1ldHJpY0RhdGFGb3JtYXQiLCJudW1iZXJPZkhNZXRyaWNzIiwicGFyc2VIbXR4VGFibGVBbGwiLCJudW1NZXRyaWNzIiwicGFyc2VIbXR4VGFibGVPbkxvd01lbW9yeSIsInBhcnNlSG10eFRhYmxlIiwiaG10eCIsInBhcnNlV2luZG93c0tlcm5UYWJsZSIsInBhaXJzIiwic3VidGFibGVWZXJzaW9uIiwiblBhaXJzIiwicGFyc2VNYWNLZXJuVGFibGUiLCJuVGFibGVzIiwid2FybiIsInBhcnNlS2VyblRhYmxlIiwia2VybiIsInBhcnNlTHRhZ1RhYmxlIiwibnVtVGFncyIsImx0YWciLCJwYXJzZUxvY2FUYWJsZSIsInNob3J0VmVyc2lvbiIsInBhcnNlRm4iLCJnbHlwaE9mZnNldHMiLCJnbHlwaE9mZnNldCIsInBhcnNlTWF4cFRhYmxlIiwibWF4cCIsIm1heFBvaW50cyIsIm1heENvbnRvdXJzIiwibWF4Q29tcG9zaXRlUG9pbnRzIiwibWF4Q29tcG9zaXRlQ29udG91cnMiLCJtYXhab25lcyIsIm1heFR3aWxpZ2h0UG9pbnRzIiwibWF4U3RvcmFnZSIsIm1heEZ1bmN0aW9uRGVmcyIsIm1heEluc3RydWN0aW9uRGVmcyIsIm1heFN0YWNrRWxlbWVudHMiLCJtYXhTaXplT2ZJbnN0cnVjdGlvbnMiLCJtYXhDb21wb25lbnRFbGVtZW50cyIsIm1heENvbXBvbmVudERlcHRoIiwicGFyc2VPUzJUYWJsZSIsInhBdmdDaGFyV2lkdGgiLCJmc1R5cGUiLCJ5U3Vic2NyaXB0WFNpemUiLCJ5U3Vic2NyaXB0WVNpemUiLCJ5U3Vic2NyaXB0WE9mZnNldCIsInlTdWJzY3JpcHRZT2Zmc2V0IiwieVN1cGVyc2NyaXB0WFNpemUiLCJ5U3VwZXJzY3JpcHRZU2l6ZSIsInlTdXBlcnNjcmlwdFhPZmZzZXQiLCJ5U3VwZXJzY3JpcHRZT2Zmc2V0IiwieVN0cmlrZW91dFNpemUiLCJ5U3RyaWtlb3V0UG9zaXRpb24iLCJzRmFtaWx5Q2xhc3MiLCJwYW5vc2UiLCJ1bFVuaWNvZGVSYW5nZTEiLCJ1bFVuaWNvZGVSYW5nZTIiLCJ1bFVuaWNvZGVSYW5nZTMiLCJ1bFVuaWNvZGVSYW5nZTQiLCJhY2hWZW5kSUQiLCJ1c0ZpcnN0Q2hhckluZGV4IiwidXNMYXN0Q2hhckluZGV4Iiwic1R5cG9Bc2NlbmRlciIsInNUeXBvRGVzY2VuZGVyIiwic1R5cG9MaW5lR2FwIiwidXNXaW5Bc2NlbnQiLCJ1c1dpbkRlc2NlbnQiLCJ1bENvZGVQYWdlUmFuZ2UxIiwidWxDb2RlUGFnZVJhbmdlMiIsInN4SGVpZ2h0Iiwic0NhcEhlaWdodCIsInVzRGVmYXVsdENoYXIiLCJ1c0JyZWFrQ2hhciIsInVzTWF4Q29udGVudCIsInBhcnNlUG9zdFRhYmxlIiwicG9zdCIsIml0YWxpY0FuZ2xlIiwidW5kZXJsaW5lUG9zaXRpb24iLCJ1bmRlcmxpbmVUaGlja25lc3MiLCJpc0ZpeGVkUGl0Y2giLCJtaW5NZW1UeXBlNDIiLCJtYXhNZW1UeXBlNDIiLCJtaW5NZW1UeXBlMSIsIm1heE1lbVR5cGUxIiwibnVtYmVyT2ZHbHlwaHMiLCJnbHlwaE5hbWVJbmRleCIsIlVURjgiLCJudW1CeXRlcyIsImNvZGVQb2ludHMiLCJudW1DaGFycyIsIlVURjE2IiwiZWlnaHRCaXRNYWNFbmNvZGluZ3MiLCJtYWNpbnRvc2giLCJNQUNTVFJJTkciLCJkYXRhTGVuZ3RoIiwidGFibGUiLCJyZXN1bHQiLCJwYXJzZU1ldGFUYWJsZSIsIm51bURhdGFNYXBzIiwiZGF0YU9mZnNldCIsInBhcnNlT3BlblR5cGVUYWJsZUVudHJpZXMiLCJ0YWJsZUVudHJpZXMiLCJjaGVja3N1bSIsImNvbXByZXNzaW9uIiwicGFyc2VXT0ZGVGFibGVFbnRyaWVzIiwiY29tcExlbmd0aCIsIm9yaWdMZW5ndGgiLCJjb21wcmVzc2VkTGVuZ3RoIiwidW5jb21wcmVzc1RhYmxlIiwidGFibGVFbnRyeSIsImluQnVmZmVyIiwib3V0QnVmZmVyIiwidmlldyIsInBhcnNlQnVmZmVyIiwic2lnbmF0dXJlIiwiZmxhdm9yIiwiY2ZmVGFibGVFbnRyeSIsImZ2YXJUYWJsZUVudHJ5IiwiZ2x5ZlRhYmxlRW50cnkiLCJnZGVmVGFibGVFbnRyeSIsImdwb3NUYWJsZUVudHJ5IiwiZ3N1YlRhYmxlRW50cnkiLCJobXR4VGFibGVFbnRyeSIsImtlcm5UYWJsZUVudHJ5IiwibG9jYVRhYmxlRW50cnkiLCJtZXRhVGFibGVFbnRyeSIsImx0YWdUYWJsZSIsImxvY2FUYWJsZSIsImxvY2FPZmZzZXRzIiwiZ2x5ZlRhYmxlIiwiY2ZmVGFibGUiLCJobXR4VGFibGUiLCJrZXJuVGFibGUiLCJnZGVmVGFibGUiLCJncG9zVGFibGUiLCJnc3ViVGFibGUiLCJmdmFyVGFibGUiLCJtZXRhVGFibGUiLCJtZXRhcyIsImxvYWQiLCJsb2FkU3luYyIsIm9wZW50eXBlIiwiX19wcm90b19fIiwiX3BhcnNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@shuding/opentype.js/dist/opentype.module.js\n");

/***/ })

};
;